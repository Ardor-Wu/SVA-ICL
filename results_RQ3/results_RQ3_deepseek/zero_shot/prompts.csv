"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int uv__rwlock_fallback_init(uv_rwlock_t* rwlock) { int err; err = uv_mutex_init(&rwlock->fallback_.read_mutex_); if (err) return err; err = uv_mutex_init(&rwlock->fallback_.write_mutex_); if (err) { uv_mutex_destroy(&rwlock->fallback_.read_mutex_); return err; } rwlock->fallback_.num_readers_ = 0; return 0; }
Description: The uv_rwlock_t fallback implementation for Windows XP and Server 2003 in libuv before 1.7.4 does not properly prevent threads from releasing the locks of other threads, which allows attackers to cause a denial of service (deadlock) or possibly have unspecified other impact by leveraging a race condition.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void Compute(OpKernelContext* ctx) override { const Tensor& in0 = ctx->input(0); const Tensor& in1 = ctx->input(1); ValidateInputTensors(ctx, in0, in1); MatMulBCast bcast(in0.shape().dim_sizes(), in1.shape().dim_sizes()); OP_REQUIRES( ctx, bcast.IsValid(), errors::InvalidArgument( ""In[0] and In[1] must have compatible batch dimensions: "", in0.shape().DebugString(), "" vs. "", in1.shape().DebugString())); TensorShape out_shape = bcast.output_batch_shape(); auto batch_size = bcast.output_batch_size(); auto d0 = in0.dim_size(in0.dims() - 2);      auto d1 = in0.dim_size(in0.dims() - 1); Tensor in0_reshaped; OP_REQUIRES( ctx, in0_reshaped.CopyFrom(in0, TensorShape({bcast.x_batch_size(), d0, d1})), errors::Internal(""Failed to reshape In[0] from "", in0.shape().DebugString())); auto d2 = in1.dim_size(in1.dims() - 2); auto d3 = in1.dim_size(in1.dims() - 1); Tensor in1_reshaped; OP_REQUIRES( ctx, in1_reshaped.CopyFrom(in1, TensorShape({bcast.y_batch_size(), d2, d3})), errors::Internal(""Failed to reshape In[1] from "", in1.shape().DebugString())); OP_REQUIRES(ctx, d1 == d2, errors::InvalidArgument( ""In[0] mismatch In[1] shape: "", d1, "" vs. "", d2, "": "", in0.shape().DebugString(), "" "", in1.shape().DebugString(), "" "", lower_, "" "", adjoint_)); out_shape.AddDim(d1); out_shape.AddDim(d3); Tensor* out = nullptr; OP_REQUIRES_OK(ctx, ctx->allocate_output(0, out_shape, &out)); if (out->NumElements() == 0) { return; } Tensor out_reshaped; OP_REQUIRES(ctx, out_reshaped.CopyFrom(*out, TensorShape({batch_size, d1, d3})), errors::Internal(""Failed to reshape output from "", out->shape().DebugString())); LaunchBatchBandedTriangularSolve<Scalar>::Launch( ctx, in0_reshaped, in1_reshaped, adjoint_, lower_, bcast, &out_reshaped); }
Description: TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a heap buffer overflow in Eigen implementation of `tf.raw_ops.BandedTriangularSolve`. The implementation(https://github.com/tensorflow/tensorflow/blob/eccb7ec454e6617738554a255d77f08e60ee0808/tensorflow/core/kernels/linalg/banded_triangular_solve_op.cc#L269-L278) calls `ValidateInputTensors` for input validation but fails to validate that the two tensors are not empty. Furthermore, since `OP_REQUIRES` macro only stops execution of current function after setting `ctx->status()` to a non-OK value, callers of helper functions that use `OP_REQUIRES` must check value of `ctx->status()` before continuing. This doesn't happen in this op's implementation(https://github.com/tensorflow/tensorflow/blob/eccb7ec454e6617738554a255d77f08e60ee0808/tensorflow/core/kernels/linalg/banded_triangular_solve_op.cc#L219), hence the validation that is present is also not effective. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static OPJ_BOOL opj_j2k_read_SPCod_SPCoc(  opj_j2k_t *p_j2k, OPJ_UINT32 compno, OPJ_BYTE * p_header_data, OPJ_UINT32 * p_header_size, opj_event_mgr_t * p_manager) { OPJ_UINT32 i, l_tmp; opj_cp_t *l_cp = NULL; opj_tcp_t *l_tcp = NULL; opj_tccp_t *l_tccp = NULL; OPJ_BYTE * l_current_ptr = NULL; assert(p_j2k != 00); assert(p_manager != 00); assert(p_header_data != 00); l_cp = &(p_j2k->m_cp); l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ? &l_cp->tcps[p_j2k->m_current_tile_number] : p_j2k->m_specific_param.m_decoder.m_default_tcp; assert(compno < p_j2k->m_private_image->numcomps); l_tccp = &l_tcp->tccps[compno]; l_current_ptr = p_header_data; if (*p_header_size < 5) { opj_event_msg(p_manager, EVT_ERROR, ""Error reading SPCod SPCoc element\n""); return OPJ_FALSE; } opj_read_bytes(l_current_ptr, &l_tccp->numresolutions ,1);               ++l_tccp->numresolutions;                                                                                if (l_tccp->numresolutions > OPJ_J2K_MAXRLVLS) { opj_event_msg(p_manager, EVT_ERROR, ""Invalid value for numresolutions : %d, max value is set in openjpeg.h at %d\n"", l_tccp->numresolutions, OPJ_J2K_MAXRLVLS); return OPJ_FALSE; } ++l_current_ptr; if (l_cp->m_specific_param.m_dec.m_reduce >= l_tccp->numresolutions) { opj_event_msg(p_manager, EVT_ERROR, ""Error decoding component %d.\nThe number of resolutions to remove is higher than the number "" ""of resolutions of this component\nModify the cp_reduce parameter.\n\n"", compno); p_j2k->m_specific_param.m_decoder.m_state |= 0x8000; return OPJ_FALSE; } opj_read_bytes(l_current_ptr,&l_tccp->cblkw ,1);                 ++l_current_ptr; l_tccp->cblkw += 2; opj_read_bytes(l_current_ptr,&l_tccp->cblkh ,1);                 ++l_current_ptr; l_tccp->cblkh += 2; if ((l_tccp->cblkw > 10) || (l_tccp->cblkh > 10) || ((l_tccp->cblkw + l_tccp->cblkh) > 12)) { opj_event_msg(p_manager, EVT_ERROR, ""Error reading SPCod SPCoc element, Invalid cblkw/cblkh combination\n""); return OPJ_FALSE; } opj_read_bytes(l_current_ptr,&l_tccp->cblksty ,1);               ++l_current_ptr; opj_read_bytes(l_current_ptr,&l_tccp->qmfbid ,1);                ++l_current_ptr; *p_header_size = *p_header_size - 5; if (l_tccp->csty & J2K_CCP_CSTY_PRT) { if (*p_header_size < l_tccp->numresolutions) { opj_event_msg(p_manager, EVT_ERROR, ""Error reading SPCod SPCoc element\n""); return OPJ_FALSE; } for     (i = 0; i < l_tccp->numresolutions; ++i) { opj_read_bytes(l_current_ptr,&l_tmp ,1);                 ++l_current_ptr; if ((i != 0) && (((l_tmp & 0xf) == 0) || ((l_tmp >> 4) == 0))) { opj_event_msg(p_manager, EVT_ERROR, ""Invalid precinct size\n""); return OPJ_FALSE; } l_tccp->prcw[i] = l_tmp & 0xf; l_tccp->prch[i] = l_tmp >> 4; } *p_header_size = *p_header_size - l_tccp->numresolutions; } else { for     (i = 0; i < l_tccp->numresolutions; ++i) { l_tccp->prcw[i] = 15; l_tccp->prch[i] = 15; } } #ifdef WIP_REMOVE_MSD if (p_j2k->cstr_info && compno == 0) { OPJ_UINT32 l_data_size = l_tccp->numresolutions * sizeof(OPJ_UINT32); p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].cblkh = l_tccp->cblkh; p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].cblkw = l_tccp->cblkw; p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].numresolutions = l_tccp->numresolutions; p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].cblksty = l_tccp->cblksty; p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].qmfbid = l_tccp->qmfbid; memcpy(p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].pdx,l_tccp->prcw, l_data_size); memcpy(p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].pdy,l_tccp->prch, l_data_size); } #endif return OPJ_TRUE; }
Description: Heap-based buffer overflow in the opj_j2k_read_SPCod_SPCoc function in j2k.c in OpenJPEG, as used in PDFium in Google Chrome before 51.0.2704.63, allows remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted PDF document.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static ssize_t available_instances_show(struct mdev_type *mtype, struct mdev_type_attribute *attr, char *buf) { const struct mbochs_type *type = &mbochs_types[mtype_get_type_group_id(mtype)]; int count = (max_mbytes - mbochs_used_mbytes) / type->mbytes; return sprintf(buf, ""%d\n"", count); }
Description: A flaw was found in the Linux kernel. A memory leak problem was found in mbochs_ioctl in samples/vfio-mdev/mbochs.c in Virtual Function I/O (VFIO) Mediated devices. This flaw could allow a local attacker to leak internal kernel information.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static float vips_eye_point( VipsPoint *point, int x, int y )  { VipsEye *eye = (VipsEye *) point; double c = eye->factor * VIPS_PI / (2 * (point->width - 1)); double h = ((point->height - 1) * (point->height - 1)); return( y * y * cos( c * x * x ) / h ); }
Description: Division-By-Zero vulnerability in Libvips 8.10.5 in the function vips_eye_point, eye.c#L83, and function vips_mask_point, mask.c#L85.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void forEachForBinding(ScriptState* scriptState, const ScriptValue& thisValue, const ScriptValue& callback, const ScriptValue& thisArg, ExceptionState& exceptionState) { IterationSource* source = this->startIteration(scriptState, exceptionState); v8::Isolate* isolate = scriptState->isolate(); v8::TryCatch tryCatch(isolate); v8::Local<v8::Object> creationContext(scriptState->context()->Global()); v8::Local<v8::Function> v8Callback(callback.v8Value().As<v8::Function>()); v8::Local<v8::Value> v8ThisArg(thisArg.v8Value()); v8::Local<v8::Value> args[3]; args[2] = thisValue.v8Value(); while (true) { KeyType key; ValueType value; if (!source->next(scriptState, key, value, exceptionState)) return; ASSERT(!exceptionState.hadException()); args[0] = toV8(value, creationContext, isolate); args[1] = toV8(key, creationContext, isolate); if (args[0].IsEmpty() || args[1].IsEmpty()) { if (tryCatch.HasCaught()) exceptionState.rethrowV8Exception(tryCatch.Exception()); return; } v8::Local<v8::Value> result; if (!V8ScriptRunner::callFunction(v8Callback, scriptState->executionContext(), v8ThisArg, 3, args, isolate).ToLocal(&result)) { exceptionState.rethrowV8Exception(tryCatch.Exception()); return; } } }
Description: The forEachForBinding function in WebKit/Source/bindings/core/v8/Iterable.h in the V8 bindings in Blink, as used in Google Chrome before 50.0.2661.102, uses an improper creation context, which allows remote attackers to bypass the Same Origin Policy via a crafted web site.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool CmtkLoader::load(const std::string &filename, const CFileProvider &fp) { binistream *f = fp.open(filename); if(!f) return false; struct { char id[18]; unsigned short crc,size; } header; struct mtkdata { char songname[34],composername[34],instname[0x80][34]; unsigned char insts[0x80][12],order[0x80],dummy,patterns[0x32][0x40][9]; } *data; unsigned char *cmp,*org; unsigned int i; unsigned long cmpsize,cmpptr=0,orgptr=0; unsigned short ctrlbits=0,ctrlmask=0,cmd,cnt,offs; f->readString(header.id, 18); header.crc = f->readInt(2); header.size = f->readInt(2); if(strncmp(header.id,""mpu401tr\x92kk\xeer@data"",18)) { fp.close(f); return false; } cmpsize = fp.filesize(f) - 22; cmp = new unsigned char[cmpsize]; org = new unsigned char[header.size]; for(i = 0; i < cmpsize; i++) cmp[i] = f->readInt(1); fp.close(f); while(cmpptr < cmpsize) {    ctrlmask >>= 1; if(!ctrlmask) { ctrlbits = cmp[cmpptr] + (cmp[cmpptr + 1] << 8); cmpptr += 2; ctrlmask = 0x8000; } if(!(ctrlbits & ctrlmask)) {      if(orgptr >= header.size) goto err; org[orgptr] = cmp[cmpptr]; orgptr++; cmpptr++; continue; } cmd = (cmp[cmpptr] >> 4) & 0x0f; cnt = cmp[cmpptr] & 0x0f; cmpptr++; switch(cmd) { case 0: if(orgptr + cnt > header.size) goto err; cnt += 3; memset(&org[orgptr],cmp[cmpptr],cnt); cmpptr++; orgptr += cnt; break; case 1: if(orgptr + cnt > header.size) goto err; cnt += (cmp[cmpptr] << 4) + 19; memset(&org[orgptr],cmp[++cmpptr],cnt); cmpptr++; orgptr += cnt; break; case 2: if(orgptr + cnt > header.size) goto err; offs = (cnt+3) + (cmp[cmpptr] << 4); cnt = cmp[++cmpptr] + 16; cmpptr++; memcpy(&org[orgptr],&org[orgptr - offs],cnt); orgptr += cnt; break; default: if(orgptr + cmd > header.size) goto err; offs = (cnt+3) + (cmp[cmpptr++] << 4); memcpy(&org[orgptr],&org[orgptr-offs],cmd); orgptr += cmd; break; } } delete [] cmp; data = (struct mtkdata *) org; memset(title,0,34); strncpy(title,data->songname+1,33); memset(composer,0,34); strncpy(composer,data->composername+1,33); memset(instname,0,0x80*34); for(i=0;i<0x80;i++) strncpy(instname[i],data->instname[i]+1,33); memcpy(instr,data->insts,0x80 * 12); memcpy(song,data->order,0x80); memcpy(patterns,data->patterns,header.size-6084); for (i=0;i<128;i++) {    instr[i][2] ^= (instr[i][2] & 0x40) << 1; instr[i][3] ^= (instr[i][3] & 0x40) << 1; instr[i][11] >>= 4;  } delete [] org; rewind(0); return true; err: delete [] cmp; delete [] org; return false; }
Description: AdPlug 2.3.1 has multiple heap-based buffer overflows in CmtkLoader::load() in mtk.cpp.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int ldp_tlv_print(netdissect_options *ndo, register const u_char *tptr, u_short msg_tlen) { struct ldp_tlv_header { uint8_t type[2]; uint8_t length[2]; }; const struct ldp_tlv_header *ldp_tlv_header; u_short tlv_type,tlv_len,tlv_tlen,af,ft_flags; u_char fec_type; u_int ui,vc_info_len, vc_info_tlv_type, vc_info_tlv_len,idx; char buf[100]; int i; ldp_tlv_header = (const struct ldp_tlv_header *)tptr; ND_TCHECK(*ldp_tlv_header); tlv_len=EXTRACT_16BITS(ldp_tlv_header->length); if (tlv_len + 4 > msg_tlen) { ND_PRINT((ndo, ""\n\t\t TLV contents go past end of message"")); return 0; } tlv_tlen=tlv_len; tlv_type=LDP_MASK_TLV_TYPE(EXTRACT_16BITS(ldp_tlv_header->type)); ND_PRINT((ndo, ""\n\t    %s TLV (0x%04x), length: %u, Flags: [%s and %s forward if unknown]"", tok2str(ldp_tlv_values, ""Unknown"", tlv_type), tlv_type, tlv_len, LDP_MASK_U_BIT(EXTRACT_16BITS(&ldp_tlv_header->type)) ? ""continue processing"" : ""ignore"", LDP_MASK_F_BIT(EXTRACT_16BITS(&ldp_tlv_header->type)) ? ""do"" : ""don't"")); tptr+=sizeof(struct ldp_tlv_header); switch(tlv_type) { case LDP_TLV_COMMON_HELLO: TLV_TCHECK(4); ND_PRINT((ndo, ""\n\t      Hold Time: %us, Flags: [%s Hello%s]"", EXTRACT_16BITS(tptr), (EXTRACT_16BITS(tptr+2)&0x8000) ? ""Targeted"" : ""Link"", (EXTRACT_16BITS(tptr+2)&0x4000) ? "", Request for targeted Hellos"" : """")); break; case LDP_TLV_IPV4_TRANSPORT_ADDR: TLV_TCHECK(4); ND_PRINT((ndo, ""\n\t      IPv4 Transport Address: %s"", ipaddr_string(ndo, tptr))); break; case LDP_TLV_IPV6_TRANSPORT_ADDR: TLV_TCHECK(16); ND_PRINT((ndo, ""\n\t      IPv6 Transport Address: %s"", ip6addr_string(ndo, tptr))); break; case LDP_TLV_CONFIG_SEQ_NUMBER: TLV_TCHECK(4); ND_PRINT((ndo, ""\n\t      Sequence Number: %u"", EXTRACT_32BITS(tptr))); break; case LDP_TLV_ADDRESS_LIST: TLV_TCHECK(LDP_TLV_ADDRESS_LIST_AFNUM_LEN); af = EXTRACT_16BITS(tptr); tptr+=LDP_TLV_ADDRESS_LIST_AFNUM_LEN; tlv_tlen -= LDP_TLV_ADDRESS_LIST_AFNUM_LEN; ND_PRINT((ndo, ""\n\t      Address Family: %s, addresses"", tok2str(af_values, ""Unknown (%u)"", af))); switch (af) { case AFNUM_INET: while(tlv_tlen >= sizeof(struct in_addr)) { ND_TCHECK2(*tptr, sizeof(struct in_addr)); ND_PRINT((ndo, "" %s"", ipaddr_string(ndo, tptr))); tlv_tlen-=sizeof(struct in_addr); tptr+=sizeof(struct in_addr); } break; case AFNUM_INET6: while(tlv_tlen >= sizeof(struct in6_addr)) { ND_TCHECK2(*tptr, sizeof(struct in6_addr)); ND_PRINT((ndo, "" %s"", ip6addr_string(ndo, tptr))); tlv_tlen-=sizeof(struct in6_addr); tptr+=sizeof(struct in6_addr); } break; default: break; } break; case LDP_TLV_COMMON_SESSION: TLV_TCHECK(8); ND_PRINT((ndo, ""\n\t      Version: %u, Keepalive: %us, Flags: [Downstream %s, Loop Detection %s]"", EXTRACT_16BITS(tptr), EXTRACT_16BITS(tptr+2), (EXTRACT_16BITS(tptr+6)&0x8000) ? ""On Demand"" : ""Unsolicited"", (EXTRACT_16BITS(tptr+6)&0x4000) ? ""Enabled"" : ""Disabled"" )); break; case LDP_TLV_FEC: TLV_TCHECK(1); fec_type = *tptr; ND_PRINT((ndo, ""\n\t      %s FEC (0x%02x)"", tok2str(ldp_fec_values, ""Unknown"", fec_type), fec_type)); tptr+=1; tlv_tlen-=1; switch(fec_type) { case LDP_FEC_WILDCARD: break; case LDP_FEC_PREFIX: TLV_TCHECK(2); af = EXTRACT_16BITS(tptr); tptr+=LDP_TLV_ADDRESS_LIST_AFNUM_LEN; tlv_tlen-=LDP_TLV_ADDRESS_LIST_AFNUM_LEN; if (af == AFNUM_INET) { i=decode_prefix4(ndo, tptr, tlv_tlen, buf, sizeof(buf)); if (i == -2) goto trunc; if (i == -3) ND_PRINT((ndo, "": IPv4 prefix (goes past end of TLV)"")); else if (i == -1) ND_PRINT((ndo, "": IPv4 prefix (invalid length)"")); else ND_PRINT((ndo, "": IPv4 prefix %s"", buf)); } else if (af == AFNUM_INET6) { i=decode_prefix6(ndo, tptr, tlv_tlen, buf, sizeof(buf)); if (i == -2) goto trunc; if (i == -3) ND_PRINT((ndo, "": IPv4 prefix (goes past end of TLV)"")); else if (i == -1) ND_PRINT((ndo, "": IPv6 prefix (invalid length)"")); else ND_PRINT((ndo, "": IPv6 prefix %s"", buf)); } else ND_PRINT((ndo, "": Address family %u prefix"", af)); break; case LDP_FEC_HOSTADDRESS: break; case LDP_FEC_MARTINI_VC: TLV_TCHECK(7); vc_info_len = *(tptr+2); if (vc_info_len == 0) { ND_PRINT((ndo, "": %s, %scontrol word, group-ID %u, VC-info-length: %u"", tok2str(mpls_pw_types_values, ""Unknown"", EXTRACT_16BITS(tptr)&0x7fff), EXTRACT_16BITS(tptr)&0x8000 ? """" : ""no "", EXTRACT_32BITS(tptr+3), vc_info_len)); break; } TLV_TCHECK(11); ND_PRINT((ndo, "": %s, %scontrol word, group-ID %u, VC-ID %u, VC-info-length: %u"", tok2str(mpls_pw_types_values, ""Unknown"", EXTRACT_16BITS(tptr)&0x7fff), EXTRACT_16BITS(tptr)&0x8000 ? """" : ""no "", EXTRACT_32BITS(tptr+3), EXTRACT_32BITS(tptr+7), vc_info_len)); if (vc_info_len < 4) { ND_PRINT((ndo, "" (invalid, < 4"")); return(tlv_len+4);  } vc_info_len -= 4;  tptr+=11; tlv_tlen-=11; TLV_TCHECK(vc_info_len); while (vc_info_len > 2) { vc_info_tlv_type = *tptr; vc_info_tlv_len = *(tptr+1); if (vc_info_tlv_len < 2) break; if (vc_info_len < vc_info_tlv_len) break; ND_PRINT((ndo, ""\n\t\tInterface Parameter: %s (0x%02x), len %u"", tok2str(ldp_fec_martini_ifparm_values,""Unknown"",vc_info_tlv_type), vc_info_tlv_type, vc_info_tlv_len)); switch(vc_info_tlv_type) { case LDP_FEC_MARTINI_IFPARM_MTU: ND_PRINT((ndo, "": %u"", EXTRACT_16BITS(tptr+2))); break; case LDP_FEC_MARTINI_IFPARM_DESC: ND_PRINT((ndo, "": "")); for (idx = 2; idx < vc_info_tlv_len; idx++) safeputchar(ndo, *(tptr + idx)); break; case LDP_FEC_MARTINI_IFPARM_VCCV: ND_PRINT((ndo, ""\n\t\t  Control Channels (0x%02x) = [%s]"", *(tptr+2), bittok2str(ldp_fec_martini_ifparm_vccv_cc_values, ""none"", *(tptr+2)))); ND_PRINT((ndo, ""\n\t\t  CV Types (0x%02x) = [%s]"", *(tptr+3), bittok2str(ldp_fec_martini_ifparm_vccv_cv_values, ""none"", *(tptr+3)))); break; default: print_unknown_data(ndo, tptr+2, ""\n\t\t  "", vc_info_tlv_len-2); break; } vc_info_len -= vc_info_tlv_len; tptr += vc_info_tlv_len; } break; } break; case LDP_TLV_GENERIC_LABEL: TLV_TCHECK(4); ND_PRINT((ndo, ""\n\t      Label: %u"", EXTRACT_32BITS(tptr) & 0xfffff)); break; case LDP_TLV_STATUS: TLV_TCHECK(8); ui = EXTRACT_32BITS(tptr); tptr+=4; ND_PRINT((ndo, ""\n\t      Status: 0x%02x, Flags: [%s and %s forward]"", ui&0x3fffffff, ui&0x80000000 ? ""Fatal error"" : ""Advisory Notification"", ui&0x40000000 ? ""do"" : ""don't"")); ui = EXTRACT_32BITS(tptr); tptr+=4; if (ui) ND_PRINT((ndo, "", causing Message ID: 0x%08x"", ui)); break; case LDP_TLV_FT_SESSION: TLV_TCHECK(8); ft_flags = EXTRACT_16BITS(tptr); ND_PRINT((ndo, ""\n\t      Flags: [%sReconnect, %sSave State, %sAll-Label Protection, %s Checkpoint, %sRe-Learn State]"", ft_flags&0x8000 ? """" : ""No "", ft_flags&0x8 ? """" : ""Don't "", ft_flags&0x4 ? """" : ""No "", ft_flags&0x2 ? ""Sequence Numbered Label"" : ""All Labels"", ft_flags&0x1 ? """" : ""Don't "")); tptr+=4; ui = EXTRACT_32BITS(tptr); if (ui) ND_PRINT((ndo, "", Reconnect Timeout: %ums"", ui)); tptr+=4; ui = EXTRACT_32BITS(tptr); if (ui) ND_PRINT((ndo, "", Recovery Time: %ums"", ui)); break; case LDP_TLV_MTU: TLV_TCHECK(2); ND_PRINT((ndo, ""\n\t      MTU: %u"", EXTRACT_16BITS(tptr))); break; case LDP_TLV_HOP_COUNT: case LDP_TLV_PATH_VECTOR: case LDP_TLV_ATM_LABEL: case LDP_TLV_FR_LABEL: case LDP_TLV_EXTD_STATUS: case LDP_TLV_RETURNED_PDU: case LDP_TLV_RETURNED_MSG: case LDP_TLV_ATM_SESSION_PARM: case LDP_TLV_FR_SESSION_PARM: case LDP_TLV_LABEL_REQUEST_MSG_ID: default: if (ndo->ndo_vflag <= 1) print_unknown_data(ndo, tptr, ""\n\t      "", tlv_tlen); break; } return(tlv_len+4);  trunc: ND_PRINT((ndo, ""\n\t\t packet exceeded snapshot"")); return 0; badtlv: ND_PRINT((ndo, ""\n\t\t TLV contents go past end of TLV"")); return(tlv_len+4);  }
Description: The LDP parser in tcpdump before 4.9.3 has a buffer over-read in print-ldp.c:ldp_tlv_print().
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static inline void handle_socket_receive_unknown( fastd_socket_t *sock, const fastd_peer_address_t *local_addr, const fastd_peer_address_t *remote_addr, fastd_buffer_t *buffer) { const uint8_t *packet_type = buffer->data; switch (*packet_type) { case PACKET_DATA: fastd_buffer_free(buffer); if (!backoff_unknown(remote_addr)) { pr_debug(""unexpectedly received payload data from unknown address %I"", remote_addr); conf.protocol->handshake_init(sock, local_addr, remote_addr, NULL); } break; case PACKET_HANDSHAKE: fastd_handshake_handle(sock, local_addr, remote_addr, NULL, buffer); } }
Description: receive.c in fastd before v21 allows denial of service (assertion failure) when receiving packets with an invalid type code.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int kfd_parse_subtype_iolink(struct crat_subtype_iolink *iolink, struct list_head *device_list) { struct kfd_iolink_properties *props = NULL, *props2; struct kfd_topology_device *dev, *to_dev; uint32_t id_from; uint32_t id_to; id_from = iolink->proximity_domain_from; id_to = iolink->proximity_domain_to; pr_debug(""Found IO link entry in CRAT table with id_from=%d, id_to %d\n"", id_from, id_to); list_for_each_entry(dev, device_list, list) { if (id_from == dev->proximity_domain) { props = kfd_alloc_struct(props); if (!props) return -ENOMEM; props->node_from = id_from; props->node_to = id_to; props->ver_maj = iolink->version_major; props->ver_min = iolink->version_minor; props->iolink_type = iolink->io_interface_type; if (props->iolink_type == CRAT_IOLINK_TYPE_PCIEXPRESS) props->weight = 20; else if (props->iolink_type == CRAT_IOLINK_TYPE_XGMI) props->weight = 15 * iolink->num_hops_xgmi; else props->weight = node_distance(id_from, id_to); props->min_latency = iolink->minimum_latency; props->max_latency = iolink->maximum_latency; props->min_bandwidth = iolink->minimum_bandwidth_mbs; props->max_bandwidth = iolink->maximum_bandwidth_mbs; props->rec_transfer_size = iolink->recommended_transfer_size; dev->io_link_count++; dev->node_props.io_links_count++; list_add_tail(&props->list, &dev->io_link_props); break; } } if (props && (iolink->flags & CRAT_IOLINK_FLAGS_BI_DIRECTIONAL)) { to_dev = kfd_topology_device_by_proximity_domain(id_to); if (!to_dev) return -ENODEV; props2 = kmemdup(props, sizeof(*props2), GFP_KERNEL); props2->node_from = id_to; props2->node_to = id_from; props2->kobj = NULL; to_dev->io_link_count++; to_dev->node_props.io_links_count++; list_add_tail(&props2->list, &to_dev->io_link_props); } return 0; }
Description: An issue was discovered in the Linux kernel through 5.16-rc6. kfd_parse_subtype_iolink in drivers/gpu/drm/amd/amdkfd/kfd_crat.c lacks check of the return value of kmemdup().
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: VTermState *vterm_obtain_state(VTerm *vt) { VTermState *state; if(vt->state) return vt->state; state = vterm_state_new(vt); vt->state = state; state->combine_chars_size = 16; state->combine_chars = vterm_allocator_malloc(state->vt, state->combine_chars_size * sizeof(state->combine_chars[0])); state->tabstops = vterm_allocator_malloc(state->vt, (state->cols + 7) / 8); state->lineinfo = vterm_allocator_malloc(state->vt, state->rows * sizeof(VTermLineInfo)); state->encoding_utf8.enc = vterm_lookup_encoding(ENC_UTF8, 'u'); if(*state->encoding_utf8.enc->init != NULL) (*state->encoding_utf8.enc->init)(state->encoding_utf8.enc, state->encoding_utf8.data); vterm_parser_set_callbacks(vt, &parser_callbacks, state); return state; }
Description: libvterm through 0+bzr726, as used in Vim and other products, mishandles certain out-of-memory conditions, leading to a denial of service (application crash), related to screen.c, state.c, and vterm.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void lsr_read_paint(GF_LASeRCodec *lsr, SVG_Paint *paint, const char *name) { u32 val; GF_LSR_READ_INT(lsr, val, 1, ""hasIndex""); if (val) { GF_LSR_READ_INT(lsr, val, lsr->colorIndexBits, name); lsr_get_color(lsr, val, &paint->color); paint->type = SVG_PAINT_COLOR; paint->color.type = 0; } else { GF_LSR_READ_INT(lsr, val, 2, ""enum""); switch (val) { case 0: GF_LSR_READ_INT(lsr, val, 2, ""choice""); switch (val) { case 0: paint->type = SVG_PAINT_INHERIT; break; case 1: paint->type = SVG_PAINT_COLOR; paint->color.type = SVG_COLOR_CURRENTCOLOR; break; default: paint->type = SVG_PAINT_NONE; break; } break; case 1: { XMLRI iri; memset(&iri, 0, sizeof(XMLRI)); iri.type = 0xFF; lsr_read_any_uri(lsr, &iri, name); gf_node_unregister_iri(lsr->sg, &iri); paint->type = SVG_PAINT_URI; if (iri.string) { paint->type = SVG_PAINT_URI; paint->iri.type = XMLRI_STRING; paint->iri.string = iri.string; } else if (iri.target) { paint->iri.type = XMLRI_ELEMENTID; paint->iri.target = iri.target; } } break; case 2: { char *sysPaint=NULL; lsr_read_byte_align_string(lsr, &sysPaint, ""systemsPaint""); if (sysPaint) { paint->type = SVG_PAINT_COLOR; paint->color.type = gf_svg_get_system_paint_server_type(sysPaint); gf_free(sysPaint); } } break; case 3: lsr_read_extension(lsr, name); break; } } }
Description: GPAC 1.1.0 was discovered to contain an invalid memory address dereference via the function lsr_read_id(). This vulnerability can lead to a Denial of Service (DoS).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: tChecksumCheckResult ParaNdis_CheckRxChecksum( PARANDIS_ADAPTER *pContext, ULONG virtioFlags, tCompletePhysicalAddress *pPacketPages, ULONG ulPacketLength, ULONG ulDataOffset) { tOffloadSettingsFlags f = pContext->Offload.flags; tChecksumCheckResult res, resIp; tTcpIpPacketParsingResult ppr; ULONG flagsToCalculate = 0; res.value = 0; resIp.value = 0; if (f.fRxIPChecksum) flagsToCalculate |= pcrIpChecksum;  if (!(virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID)) { if (virtioFlags & VIRTIO_NET_HDR_F_NEEDS_CSUM) { flagsToCalculate |= pcrFixXxpChecksum | pcrTcpChecksum | pcrUdpChecksum; } else { if (f.fRxTCPChecksum) flagsToCalculate |= pcrTcpV4Checksum; if (f.fRxUDPChecksum) flagsToCalculate |= pcrUdpV4Checksum; if (f.fRxTCPv6Checksum) flagsToCalculate |= pcrTcpV6Checksum; if (f.fRxUDPv6Checksum) flagsToCalculate |= pcrUdpV6Checksum; } } ppr = ParaNdis_CheckSumVerify(pPacketPages, ulPacketLength - ETH_HEADER_SIZE, ulDataOffset + ETH_HEADER_SIZE, flagsToCalculate, __FUNCTION__); if (virtioFlags & VIRTIO_NET_HDR_F_DATA_VALID) { pContext->extraStatistics.framesRxCSHwOK++; ppr.xxpCheckSum = ppresCSOK; } if (ppr.ipStatus == ppresIPV4 && !ppr.IsFragment) { if (f.fRxIPChecksum) { res.flags.IpOK =  ppr.ipCheckSum == ppresCSOK; res.flags.IpFailed = ppr.ipCheckSum == ppresCSBad; } if(ppr.xxpStatus == ppresXxpKnown) { if(ppr.TcpUdp == ppresIsTCP)  { if (f.fRxTCPChecksum) { res.flags.TcpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS; res.flags.TcpFailed = !res.flags.TcpOK; } } else  { if (f.fRxUDPChecksum) { res.flags.UdpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS; res.flags.UdpFailed = !res.flags.UdpOK; } } } } else if (ppr.ipStatus == ppresIPV6) { if(ppr.xxpStatus == ppresXxpKnown) { if(ppr.TcpUdp == ppresIsTCP)  { if (f.fRxTCPv6Checksum) { res.flags.TcpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS; res.flags.TcpFailed = !res.flags.TcpOK; } } else  { if (f.fRxUDPv6Checksum) { res.flags.UdpOK = ppr.xxpCheckSum == ppresCSOK || ppr.fixedXxpCS; res.flags.UdpFailed = !res.flags.UdpOK; } } } } return res; }
Description: The NetKVM Windows Virtio driver allows remote attackers to cause a denial of service (guest crash) via a crafted length value in an IP packet, as demonstrated by a value that does not account for the size of the IP options.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static s32 gf_vvc_read_vps_bs_internal(GF_BitStream *bs, VVCState *vvc, Bool stop_at_vps_ext) { u32 i, j; s32 vps_id; VVC_VPS *vps; Bool vps_default_ptl_dpb_hrd_max_tid_flag=0; vps_id = gf_bs_read_int_log(bs, 4, ""vps_id""); if ((vps_id<0) || (vps_id >= 16)) return -1; if (!vps_id) { GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] VPS ID 0 is forbidden\n"")); return -1; } vps = &vvc->vps[vps_id]; if (!vps->state) { vps->id = vps_id; vps->state = 1; } vps->max_layers = 1 + gf_bs_read_int_log(bs, 6, ""max_layers""); if (vps->max_layers > MAX_LHVC_LAYERS) { GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] sorry, %d layers in VPS but only %d supported\n"", vps->max_layers, MAX_LHVC_LAYERS)); return -1; } vps->max_sub_layers = gf_bs_read_int_log(bs, 3, ""max_sub_layers_minus1"") + 1; if ((vps->max_layers>1) && (vps->max_sub_layers>1)) vps_default_ptl_dpb_hrd_max_tid_flag = gf_bs_read_int_log(bs, 1, ""vps_default_ptl_dpb_hrd_max_tid_flag""); if (vps->max_layers>1) vps->all_layers_independent = gf_bs_read_int_log(bs, 1, ""all_layers_independent""); for (i=0; i<vps->max_layers; i++) { u32 layer_id = gf_bs_read_int_log_idx(bs, 6, ""layer_id"", i); if (layer_id>vps->max_layer_id) vps->max_layer_id = layer_id; if (i && !vps->all_layers_independent) { Bool layer_indep = gf_bs_read_int_log_idx(bs, 1, ""layer_independent"", i); if (!layer_indep) { Bool vps_max_tid_ref_present_flag = gf_bs_read_int_log_idx(bs, 1, ""vps_max_tid_ref_present_flag"", i); for (j=0; j<i; j++) { Bool vps_direct_ref_layer_flag = gf_bs_read_int_log_idx2(bs, 1, ""vps_direct_ref_layer_flag"", i, j); if (vps_max_tid_ref_present_flag && vps_direct_ref_layer_flag) { gf_bs_read_int_log_idx2(bs, 3, ""vps_max_tid_il_ref_pics_plus1"", i, j); } } } } } vps->num_ptl = 1; if (vps->max_layers > 1) { if (vps->all_layers_independent) { vps->each_layer_is_ols = gf_bs_read_int_log(bs, 1, ""each_layer_is_ols""); } if (!vps->each_layer_is_ols) { u32 vps_ols_mode_idc = 2; if (!vps->all_layers_independent) { vps_ols_mode_idc = gf_bs_read_int_log(bs, 2, ""vps_ols_mode_idc""); } if (vps_ols_mode_idc==2) { u8 vps_num_output_layer_sets = 2 + gf_bs_read_int_log(bs, 8, ""vps_num_output_layer_sets_minus2""); for (i=0; i<vps_num_output_layer_sets; i++) { for (j=0; j<vps->max_layers; j++) { gf_bs_read_int_log_idx2(bs, 1, ""vps_ols_output_layer_flag"", i, j); } } } } vps->num_ptl = 1 + gf_bs_read_int_log(bs, 8, ""num_ptl_minus1""); } vps->ptl[0].pt_present = 1; for (i=0; i<vps->num_ptl; i++) { if (i) vps->ptl[i].pt_present = gf_bs_read_int_log_idx(bs, 1, ""pt_present"", i); if (!vps_default_ptl_dpb_hrd_max_tid_flag) vps->ptl[i].ptl_max_tid = gf_bs_read_int_log_idx(bs, 3, ""ptl_max_tid"", i); else vps->ptl[i].ptl_max_tid = vps->max_sub_layers - 1; } gf_bs_align(bs); for (i=0; i<vps->num_ptl; i++) { vvc_profile_tier_level(bs, &vps->ptl[i], i); } return vps_id; }
Description: GPAC MP4box 2.1-DEV-rev593-g007bf61a0 is vulnerable to Buffer Overflow in gf_hevc_read_sps_bs_internal function of media_tools/av_parsers.c:8261
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void __io_free_req(struct io_kiocb *req) { if (req->file && !(req->flags & REQ_F_FIXED_FILE)) fput(req->file); percpu_ref_put(&req->ctx->refs); kmem_cache_free(req_cachep, req); }
Description: Integer Overflow or Wraparound vulnerability in io_uring of Linux Kernel allows local attacker to cause memory corruption and escalate privileges to root. This issue affects: Linux Kernel versions prior to 5.4.189; version 5.4.24 and later versions.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int length() const { return m_str ? m_str->size() : 0; }
Description: xbuf_format_converter, used as part of exif_read_data, was appending a terminating null character to the generated string, but was not using its standard append char function. As a result, if the buffer was full, it would result in an out-of-bounds write. This issue affects HHVM versions prior to 4.56.3, all versions between 4.57.0 and 4.80.1, all versions between 4.81.0 and 4.93.1, and versions 4.94.0, 4.95.0, 4.96.0, 4.97.0, 4.98.0.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static x86newTokenType getToken(const char *str, size_t *begin, size_t *end) { while (begin && isspace ((ut8)str[*begin])) { ++(*begin); } if (!str[*begin]) {                *end = *begin; return TT_EOF; } else if (isalpha ((ut8)str[*begin])) {   *end = *begin; while (end && isalnum ((ut8)str[*end])) { ++(*end); } return TT_WORD; } else if (isdigit ((ut8)str[*begin])) {   *end = *begin; while (end && isalnum ((ut8)str[*end])) {     ++(*end); } return TT_NUMBER; } else {                             *end = *begin + 1; return TT_SPECIAL; } }
Description: getToken in libr/asm/p/asm_x86_nz.c in radare2 before 3.1.0 allows attackers to cause a denial of service (stack-based buffer over-read) via crafted x86 assembly data, as demonstrated by rasm2.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: enum bgp_attr_parse_ret bgp_attr_parse(struct peer *peer, struct attr *attr, bgp_size_t size, struct bgp_nlri *mp_update, struct bgp_nlri *mp_withdraw) { enum bgp_attr_parse_ret ret; uint8_t flag = 0; uint8_t type = 0; bgp_size_t length; uint8_t *startp, *endp; uint8_t *attr_endp; uint8_t seen[BGP_ATTR_BITMAP_SIZE]; struct aspath *as4_path = NULL; as_t as4_aggregator = 0; struct in_addr as4_aggregator_addr = {.s_addr = 0}; struct transit *transit; memset(seen, 0, BGP_ATTR_BITMAP_SIZE); endp = BGP_INPUT_PNT(peer) + size; while (BGP_INPUT_PNT(peer) < endp) { startp = BGP_INPUT_PNT(peer); if ((endp - startp) < BGP_ATTR_MIN_LEN) { flog_warn( EC_BGP_ATTRIBUTE_TOO_SMALL, ""%s: error BGP attribute length %lu is smaller than min len"", peer->host, (unsigned long)(endp - stream_pnt(BGP_INPUT(peer)))); if (peer->sort != BGP_PEER_EBGP) { bgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR); ret = BGP_ATTR_PARSE_ERROR; } else { ret = BGP_ATTR_PARSE_WITHDRAW; } goto done; } flag = 0xF0 & stream_getc(BGP_INPUT(peer)); type = stream_getc(BGP_INPUT(peer)); if (CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN) && ((endp - startp) < (BGP_ATTR_MIN_LEN + 1))) { flog_warn( EC_BGP_EXT_ATTRIBUTE_TOO_SMALL, ""%s: Extended length set, but just %lu bytes of attr header"", peer->host, (unsigned long)(endp - stream_pnt(BGP_INPUT(peer)))); if (peer->sort != BGP_PEER_EBGP) { bgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR); ret = BGP_ATTR_PARSE_ERROR; } else { ret = BGP_ATTR_PARSE_WITHDRAW; } goto done; } if (CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN)) length = stream_getw(BGP_INPUT(peer)); else length = stream_getc(BGP_INPUT(peer)); attr_endp = BGP_INPUT_PNT(peer) + length; if (attr_endp > endp) { flog_warn( EC_BGP_ATTRIBUTE_TOO_LARGE, ""%s: BGP type %d length %d is too large, attribute total length is %d.  attr_endp is %p.  endp is %p"", peer->host, type, length, size, attr_endp, endp); if (peer->sort != BGP_PEER_EBGP) { unsigned char ndata[peer->max_packet_size]; memset(ndata, 0x00, sizeof(ndata)); size_t lfl = CHECK_FLAG(flag, BGP_ATTR_FLAG_EXTLEN) ? 2 : 1; stream_rewind_getp(BGP_INPUT(peer), (1 + lfl)); stream_get(&ndata[0], BGP_INPUT(peer), 1); stream_get(&ndata[1], BGP_INPUT(peer), lfl); size_t atl = attr_endp - startp; size_t ndl = MIN(atl, STREAM_READABLE(BGP_INPUT(peer))); stream_get(&ndata[lfl + 1], BGP_INPUT(peer), ndl); bgp_notify_send_with_data(peer->connection, BGP_NOTIFY_UPDATE_ERR, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, ndata, ndl + lfl + 1); ret = BGP_ATTR_PARSE_ERROR; goto done; } else { flog_warn( EC_BGP_ATTRIBUTE_PARSE_WITHDRAW, ""%s: Attribute %s, parse error - treating as withdrawal"", peer->host, lookup_msg(attr_str, type, NULL)); ret = BGP_ATTR_PARSE_WITHDRAW; stream_forward_getp(BGP_INPUT(peer), endp - BGP_INPUT_PNT(peer)); goto done; } } if (CHECK_BITMAP(seen, type)) { if (peer->sort != BGP_PEER_EBGP || type == BGP_ATTR_MP_REACH_NLRI || type == BGP_ATTR_MP_UNREACH_NLRI) { flog_warn( EC_BGP_ATTRIBUTE_REPEATED, ""%s: error BGP attribute type %d appears twice in a message"", peer->host, type); bgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR, BGP_NOTIFY_UPDATE_MAL_ATTR); ret = BGP_ATTR_PARSE_ERROR; goto done; } else { flog_warn( EC_BGP_ATTRIBUTE_REPEATED, ""%s: error BGP attribute type %d appears twice in a message - discard attribute"", peer->host, type); stream_set_getp(BGP_INPUT(peer), (startp - STREAM_DATA(BGP_INPUT(peer))) + (attr_endp - startp)); continue; } } SET_BITMAP(seen, type); struct bgp_attr_parser_args attr_args = { .peer = peer, .length = length, .attr = attr, .type = type, .flags = flag, .startp = startp, .total = attr_endp - startp, }; if (bgp_attr_flag_invalid(&attr_args)) { ret = bgp_attr_malformed( &attr_args, BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR, attr_args.total); if (ret == BGP_ATTR_PARSE_PROCEED) continue; stream_forward_getp(BGP_INPUT(peer), endp - BGP_INPUT_PNT(peer)); goto done; } switch (type) { case BGP_ATTR_ORIGIN: ret = bgp_attr_origin(&attr_args); break; case BGP_ATTR_AS_PATH: ret = bgp_attr_aspath(&attr_args); break; case BGP_ATTR_AS4_PATH: ret = bgp_attr_as4_path(&attr_args, &as4_path); break; case BGP_ATTR_NEXT_HOP: ret = bgp_attr_nexthop(&attr_args); break; case BGP_ATTR_MULTI_EXIT_DISC: ret = bgp_attr_med(&attr_args); break; case BGP_ATTR_LOCAL_PREF: ret = bgp_attr_local_pref(&attr_args); break; case BGP_ATTR_ATOMIC_AGGREGATE: ret = bgp_attr_atomic(&attr_args); break; case BGP_ATTR_AGGREGATOR: ret = bgp_attr_aggregator(&attr_args); break; case BGP_ATTR_AS4_AGGREGATOR: ret = bgp_attr_as4_aggregator(&attr_args, &as4_aggregator, &as4_aggregator_addr); break; case BGP_ATTR_COMMUNITIES: ret = bgp_attr_community(&attr_args); break; case BGP_ATTR_LARGE_COMMUNITIES: ret = bgp_attr_large_community(&attr_args); break; case BGP_ATTR_ORIGINATOR_ID: ret = bgp_attr_originator_id(&attr_args); break; case BGP_ATTR_CLUSTER_LIST: ret = bgp_attr_cluster_list(&attr_args); break; case BGP_ATTR_MP_REACH_NLRI: ret = bgp_mp_reach_parse(&attr_args, mp_update); break; case BGP_ATTR_MP_UNREACH_NLRI: ret = bgp_mp_unreach_parse(&attr_args, mp_withdraw); break; case BGP_ATTR_EXT_COMMUNITIES: ret = bgp_attr_ext_communities(&attr_args); break; #ifdef ENABLE_BGP_VNC_ATTR case BGP_ATTR_VNC: #endif case BGP_ATTR_ENCAP: ret = bgp_attr_encap(&attr_args); break; case BGP_ATTR_PREFIX_SID: ret = bgp_attr_prefix_sid(&attr_args); break; case BGP_ATTR_PMSI_TUNNEL: ret = bgp_attr_pmsi_tunnel(&attr_args); break; case BGP_ATTR_IPV6_EXT_COMMUNITIES: ret = bgp_attr_ipv6_ext_communities(&attr_args); break; case BGP_ATTR_OTC: ret = bgp_attr_otc(&attr_args); break; case BGP_ATTR_AIGP: ret = bgp_attr_aigp(&attr_args); break; default: ret = bgp_attr_unknown(&attr_args); break; } if (ret == BGP_ATTR_PARSE_ERROR_NOTIFYPLS) { bgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR, BGP_NOTIFY_UPDATE_MAL_ATTR); ret = BGP_ATTR_PARSE_ERROR; goto done; } if (ret == BGP_ATTR_PARSE_EOR) { goto done; } if (ret == BGP_ATTR_PARSE_ERROR) { flog_warn(EC_BGP_ATTRIBUTE_PARSE_ERROR, ""%s: Attribute %s, parse error"", peer->host, lookup_msg(attr_str, type, NULL)); goto done; } if (ret == BGP_ATTR_PARSE_WITHDRAW) { flog_warn( EC_BGP_ATTRIBUTE_PARSE_WITHDRAW, ""%s: Attribute %s, parse error - treating as withdrawal"", peer->host, lookup_msg(attr_str, type, NULL)); stream_forward_getp(BGP_INPUT(peer), endp - BGP_INPUT_PNT(peer)); goto done; } if (BGP_INPUT_PNT(peer) != attr_endp) { flog_warn(EC_BGP_ATTRIBUTE_FETCH_ERROR, ""%s: BGP attribute %s, fetch error"", peer->host, lookup_msg(attr_str, type, NULL)); bgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR); ret = BGP_ATTR_PARSE_ERROR; goto done; } } if (!attr->mp_nexthop_len || mp_update->safi != SAFI_LABELED_UNICAST) attr->label_index = BGP_INVALID_LABEL_INDEX; if (BGP_INPUT_PNT(peer) != endp) { flog_warn(EC_BGP_ATTRIBUTES_MISMATCH, ""%s: BGP attribute %s, length mismatch"", peer->host, lookup_msg(attr_str, type, NULL)); bgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR); ret = BGP_ATTR_PARSE_ERROR; goto done; } if (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP)) && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI))) { if (bgp_attr_nexthop_valid(peer, attr) < 0) { ret = BGP_ATTR_PARSE_ERROR; goto done; } } ret = bgp_attr_check(peer, attr); if (ret < 0) goto done; if (CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH)) && bgp_attr_munge_as4_attrs(peer, attr, as4_path, as4_aggregator, &as4_aggregator_addr)) { bgp_notify_send(peer->connection, BGP_NOTIFY_UPDATE_ERR, BGP_NOTIFY_UPDATE_MAL_ATTR); ret = BGP_ATTR_PARSE_ERROR; goto done; } if (attr->flag & (ATTR_FLAG_BIT(BGP_ATTR_AS_PATH))) { ret = bgp_attr_aspath_check(peer, attr); if (ret != BGP_ATTR_PARSE_PROCEED) goto done; } ret = BGP_ATTR_PARSE_PROCEED; done: aspath_unintern(&as4_path); transit = bgp_attr_get_transit(attr); if (ret != BGP_ATTR_PARSE_ERROR) { if (transit) bgp_attr_set_transit(attr, transit_intern(transit)); if (attr->encap_subtlvs) attr->encap_subtlvs = encap_intern(attr->encap_subtlvs, ENCAP_SUBTLV_TYPE); #ifdef ENABLE_BGP_VNC struct bgp_attr_encap_subtlv *vnc_subtlvs = bgp_attr_get_vnc_subtlvs(attr); if (vnc_subtlvs) bgp_attr_set_vnc_subtlvs( attr, encap_intern(vnc_subtlvs, VNC_SUBTLV_TYPE)); #endif } else { if (transit) { transit_free(transit); bgp_attr_set_transit(attr, NULL); } bgp_attr_flush_encap(attr); }; transit = bgp_attr_get_transit(attr); if (transit) assert(transit->refcnt > 0); if (attr->encap_subtlvs) assert(attr->encap_subtlvs->refcnt > 0); #ifdef ENABLE_BGP_VNC struct bgp_attr_encap_subtlv *vnc_subtlvs = bgp_attr_get_vnc_subtlvs(attr); if (vnc_subtlvs) assert(vnc_subtlvs->refcnt > 0); #endif return ret; }
Description: An issue was discovered in FRRouting FRR through 9.0.1. It mishandles malformed MP_REACH_NLRI data, leading to a crash.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int write_node(FILE   *out, tree_t *t, int    col) { inti; uchar*ptr, *entity, *src, *realsrc, newsrc[1024]; if (out == NULL) return (0); switch (t->markup) { case MARKUP_NONE : if (t->data == NULL) break; if (t->preformatted) { for (ptr = t->data; *ptr; ptr ++) fputs((char *)iso8859(*ptr), out); if (t->data[strlen((char *)t->data) - 1] == '\n') col = 0; else col += strlen((char *)t->data); } else { if ((col + (int)strlen((char *)t->data)) > 72 && col > 0) { putc('\n', out); col = 0; } for (ptr = t->data; *ptr; ptr ++) fputs((char *)iso8859(*ptr), out); col += strlen((char *)t->data); if (col > 72) { putc('\n', out); col = 0; } } break; case MARKUP_COMMENT : case MARKUP_UNKNOWN : fputs(""\n<!--"", out); for (ptr = t->data; *ptr; ptr ++) fputs((char *)iso8859(*ptr), out); fputs(""-->\n"", out); col = 0; break; case MARKUP_AREA : case MARKUP_BODY : case MARKUP_DOCTYPE : case MARKUP_ERROR : case MARKUP_FILE : case MARKUP_HEAD : case MARKUP_HTML : case MARKUP_MAP : case MARKUP_META : case MARKUP_TITLE : break; case MARKUP_BR : case MARKUP_CENTER : case MARKUP_DD : case MARKUP_DL : case MARKUP_DT : case MARKUP_H1 : case MARKUP_H2 : case MARKUP_H3 : case MARKUP_H4 : case MARKUP_H5 : case MARKUP_H6 : case MARKUP_H7 : case MARKUP_H8 : case MARKUP_H9 : case MARKUP_H10 : case MARKUP_H11 : case MARKUP_H12 : case MARKUP_H13 : case MARKUP_H14 : case MARKUP_H15 : case MARKUP_HR : case MARKUP_LI : case MARKUP_OL : case MARKUP_P : case MARKUP_PRE : case MARKUP_TABLE : case MARKUP_TR : case MARKUP_UL : if (col > 0) { putc('\n', out); col = 0; } default : if (t->markup == MARKUP_IMG && OutputFiles && (src = htmlGetVariable(t, (uchar *)""SRC"")) != NULL && (realsrc = htmlGetVariable(t, (uchar *)""REALSRC"")) != NULL) { if (file_method((char *)src) == NULL && src[0] != '/' && src[0] != '\\' && (!isalpha(src[0]) || src[1] != ':')) { image_copy((char *)src, (char *)realsrc, OutputPath); strlcpy((char *)newsrc, file_basename((char *)src), sizeof(newsrc)); htmlSetVariable(t, (uchar *)""SRC"", newsrc); } } if (t->markup != MARKUP_EMBED) { col += fprintf(out, ""<%s"", _htmlMarkups[t->markup]); for (i = 0; i < t->nvars; i ++) { if (strcasecmp((char *)t->vars[i].name, ""BREAK"") == 0 && t->markup == MARKUP_HR) continue; if (strcasecmp((char *)t->vars[i].name, ""REALSRC"") == 0 && t->markup == MARKUP_IMG) continue; if (strncasecmp((char *)t->vars[i].name, ""_HD_"", 4) == 0) continue; if (col > 72 && !t->preformatted) { putc('\n', out); col = 0; } if (col > 0) { putc(' ', out); col ++; } if (t->vars[i].value == NULL) col += fprintf(out, ""%s"", t->vars[i].name); else { col += fprintf(out, ""%s=\"""", t->vars[i].name); for (ptr = t->vars[i].value; *ptr; ptr ++) { entity = iso8859(*ptr); fputs((char *)entity, out); col += strlen((char *)entity); } putc('\""', out); col ++; } } putc('>', out); col ++; if (col > 72 && !t->preformatted) { putc('\n', out); col = 0; } } break; } return (col); }
Description: HTMLDoc v1.9.15 was discovered to contain a heap overflow via (write_header) /htmldoc/htmldoc/html.cxx:273.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) { auto* params = reinterpret_cast<TfLiteEmbeddingLookupSparseParams*>(node->builtin_data); TfLiteTensor* output; TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, 0, &output)); const TfLiteTensor* ids; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 0, &ids)); const TfLiteTensor* indices; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 1, &indices)); const TfLiteTensor* dense_shape; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 2, &dense_shape)); const TfLiteTensor* weights; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 3, &weights)); const TfLiteTensor* value; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, 4, &value)); const int lookup_rank = SizeOfDimension(indices, 1); const int embedding_rank = NumDimensions(value); const int num_lookups = SizeOfDimension(ids, 0); const int num_rows = SizeOfDimension(value, 0); const int output_rank = (lookup_rank - 1) + (embedding_rank - 1); TF_LITE_ENSURE_EQ(context, SizeOfDimension(dense_shape, 0), lookup_rank); TfLiteIntArray* output_shape = TfLiteIntArrayCreate(output_rank); TF_LITE_ENSURE(context, output_shape != nullptr); int k = 0; size_t embedding_size = 1; size_t lookup_size = 1; for (int i = 0; i < lookup_rank - 1; i++, k++) { const size_t dim = dense_shape->data.i32[i]; TF_LITE_ENSURE_MSG( context, MultiplyAndCheckOverflow(lookup_size, dim, &lookup_size) == kTfLiteOk, ""Lookup size overflowed.""); output_shape->data[k] = dim; } for (int i = 1; i < embedding_rank; i++, k++) { const size_t dim = SizeOfDimension(value, i); TF_LITE_ENSURE_MSG(context, MultiplyAndCheckOverflow(embedding_size, dim, &embedding_size) == kTfLiteOk, ""Embedding size overflowed.""); output_shape->data[k] = dim; } TF_LITE_ENSURE_STATUS(context->ResizeTensor(context, output, output_shape)); const size_t output_size = lookup_size * embedding_size; TfLiteTensorRealloc(output_size * sizeof(float), output); float* output_ptr = GetTensorData<float>(output); const float* weights_ptr = GetTensorData<float>(weights); const float* value_ptr = GetTensorData<float>(value); TF_LITE_ENSURE(context, output_ptr != nullptr); std::fill_n(output_ptr, output_size, 0.0f); int current_output_offset = 0; float current_total_weight = 0.0; float current_squares_weight = 0.0; int num_elements = 0; for (int i = 0; i < num_lookups; i++) { int idx = ids->data.i32[i]; if (idx >= num_rows || idx < 0) { context->ReportError(context, ""Embedding Lookup Sparse: index out of bounds. "" ""Got %d, and bounds are [0, %d]"", idx, num_rows - 1); return kTfLiteError; } const int example_indices_offset = i * lookup_rank; int output_bucket = 0; int stride = 1; for (int k = (lookup_rank - 1) - 1; k >= 0; k--) { output_bucket += indices->data.i32[example_indices_offset + k] * stride; stride *= dense_shape->data.i32[k]; } const int output_offset = output_bucket * embedding_size; if (output_offset != current_output_offset) { FinalizeAggregation(params->combiner, num_elements, current_total_weight, current_squares_weight, embedding_size, &output_ptr[current_output_offset]); num_elements = 0; current_total_weight = 0.0; current_squares_weight = 0.0; current_output_offset = output_offset; } ++num_elements; const int example_embedding_offset = idx * embedding_size; const float w = weights_ptr[i]; current_squares_weight += w * w; current_total_weight += w; for (int k = 0; k < embedding_size; k++) { output_ptr[current_output_offset + k] += value_ptr[example_embedding_offset + k] * w; } } FinalizeAggregation(params->combiner, num_elements, current_total_weight, current_squares_weight, embedding_size, &GetTensorData<float>(output)[current_output_offset]); return kTfLiteOk; }
Description: Tensorflow is an Open Source Machine Learning Framework. An attacker can craft a TFLite model that would cause an integer overflow in embedding lookup operations. Both `embedding_size` and `lookup_size` are products of values provided by the user. Hence, a malicious user could trigger overflows in the multiplication. In certain scenarios, this can then result in heap OOB read/write. Users are advised to upgrade to a patched version.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int on_part_data_end(multipart_parser *parser) { multipart_parser_data_t *data = NULL; ogs_assert(parser); data = multipart_parser_get_data(parser); ogs_assert(data); data->num_of_part++; return 0; }
Description: A null pointer dereference in src/amf/namf-handler.c in Open5GS 2.3.6 and earlier allows remote attackers to Denial of Service via a crafted sbi request to amf.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: J9Method *    resolveSpecialSplitMethodRef(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA splitTableIndex, UDATA resolveFlags) { U_16 cpIndex = *(U_16 *)(J9ROMCLASS_SPECIALSPLITMETHODREFINDEXES(ramCP->ramClass->romClass) + splitTableIndex); J9Method *method = ramCP->ramClass->specialSplitMethodTable[splitTableIndex]; if (method == (J9Method*)vmStruct->javaVM->initialMethods.initialSpecialMethod) { method = resolveSpecialMethodRefInto(vmStruct, ramCP, cpIndex, resolveFlags, NULL); if (NULL != method) { ramCP->ramClass->specialSplitMethodTable[splitTableIndex] = method; } } return method; }
Description: In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void do_query_info_on_write (GVfsBackend *backend, GVfsJobQueryInfoWrite *query_info_job, GVfsBackendHandle handle, GFileInfo *info, GFileAttributeMatcher *matcher) { GVfsJob *job = G_VFS_JOB (query_info_job); GFileOutputStream *stream = handle; GError *error = NULL; GFileInfo *real_info; real_info = g_file_output_stream_query_info (stream, query_info_job->attributes, job->cancellable, &error); if (error != NULL) goto out; fix_file_info (real_info); g_file_info_copy_into (real_info, info); g_object_unref (real_info); out: complete_job (job, error); }
Description: An issue was discovered in GNOME gvfs 1.29.4 through 1.41.2. daemon/gvfsbackendadmin.c mishandles file ownership because setfsuid is not used.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int ib_prctl_set(struct task_struct *task, unsigned long ctrl) { switch (ctrl) { case PR_SPEC_ENABLE: if (spectre_v2_user == SPECTRE_V2_USER_NONE) return 0; if (spectre_v2_user == SPECTRE_V2_USER_STRICT || spectre_v2_user == SPECTRE_V2_USER_STRICT_PREFERRED) return -EPERM; task_clear_spec_ib_disable(task); task_update_spec_tif(task); break; case PR_SPEC_DISABLE: case PR_SPEC_FORCE_DISABLE: if (spectre_v2_user == SPECTRE_V2_USER_NONE) return -EPERM; if (spectre_v2_user == SPECTRE_V2_USER_STRICT || spectre_v2_user == SPECTRE_V2_USER_STRICT_PREFERRED) return 0; task_set_spec_ib_disable(task); if (ctrl == PR_SPEC_FORCE_DISABLE) task_set_spec_ib_force_disable(task); task_update_spec_tif(task); break; default: return -ERANGE; } return 0; }
Description: A flaw was found in the Linux kernel before 5.8-rc1 in the implementation of the Enhanced IBPB (Indirect Branch Prediction Barrier). The IBPB mitigation will be disabled when STIBP is not available or when the Enhanced Indirect Branch Restricted Speculation (IBRS) is available. This flaw allows a local attacker to perform a Spectre V2 style attack when this configuration is active. The highest threat from this vulnerability is to confidentiality.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: sp<VBRISeeker> VBRISeeker::CreateFromSource( const sp<DataSource> &source, off64_t post_id3_pos) { off64_t pos = post_id3_pos; uint8_t header[4]; ssize_t n = source->readAt(pos, header, sizeof(header)); if (n < (ssize_t)sizeof(header)) { return NULL; } uint32_t tmp = U32_AT(&header[0]); size_t frameSize; int sampleRate; if (!GetMPEGAudioFrameSize(tmp, &frameSize, &sampleRate)) { return NULL; } pos += sizeof(header) + 32; uint8_t vbriHeader[26]; n = source->readAt(pos, vbriHeader, sizeof(vbriHeader)); if (n < (ssize_t)sizeof(vbriHeader)) { return NULL; } if (memcmp(vbriHeader, ""VBRI"", 4)) { return NULL; } size_t numFrames = U32_AT(&vbriHeader[14]); int64_t durationUs = numFrames * 1000000ll * (sampleRate >= 32000 ? 1152 : 576) / sampleRate; ALOGV(""duration = %.2f secs"", durationUs / 1E6); size_t numEntries = U16_AT(&vbriHeader[18]); size_t entrySize = U16_AT(&vbriHeader[22]); size_t scale = U16_AT(&vbriHeader[20]); ALOGV(""%zu entries, scale=%zu, size_per_entry=%zu"", numEntries, scale, entrySize); size_t totalEntrySize = numEntries * entrySize; uint8_t *buffer = new uint8_t[totalEntrySize]; n = source->readAt(pos + sizeof(vbriHeader), buffer, totalEntrySize); if (n < (ssize_t)totalEntrySize) { delete[] buffer; buffer = NULL; return NULL; } sp<VBRISeeker> seeker = new VBRISeeker; seeker->mBasePos = post_id3_pos + frameSize; if (durationUs) { seeker->mDurationUs = durationUs; } off64_t offset = post_id3_pos; for (size_t i = 0; i < numEntries; ++i) { uint32_t numBytes; switch (entrySize) { case 1: numBytes = buffer[i]; break; case 2: numBytes = U16_AT(buffer + 2 * i); break; case 3: numBytes = U24_AT(buffer + 3 * i); break; default: { CHECK_EQ(entrySize, 4u); numBytes = U32_AT(buffer + 4 * i); break; } } numBytes *= scale; seeker->mSegments.push(numBytes); ALOGV(""entry #%zu: %u offset %#016llx"", i, numBytes, (long long)offset); offset += numBytes; } delete[] buffer; buffer = NULL; ALOGI(""Found VBRI header.""); return seeker; }
Description: A denial of service vulnerability in VBRISeeker.cpp in libstagefright in Mediaserver could enable a remote attacker to use a specially crafted file to cause a device hang or reboot. This issue is rated as High due to the possibility of remote denial of service. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1. Android ID: A-32577290.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: LiteralString(const std::string &s, bool ignore_case) : lit_(s), ignore_case_(ignore_case), is_word_(false) {}
Description: An issue was discovered in cpp-peglib through v0.1.12. A NULL pointer dereference exists in the peg::AstOptimizer::optimize() located in peglib.h. It allows an attacker to cause Denial of Service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int ntlm_decode_oem_str(struct wire_field_hdr *str_hdr, struct ntlm_buffer *buffer, size_t payload_offs, char **_str) { uint16_t str_len; uint32_t str_offs; char *str = NULL; str_len = le16toh(str_hdr->len); if (str_len == 0) goto done; str_offs = le32toh(str_hdr->offset); if ((str_offs < payload_offs) || (str_offs > buffer->length) || (str_offs + str_len > buffer->length)) { return ERR_DECODE; } str = strndup((const char *)&buffer->data[str_offs], str_len); if (!str) return ENOMEM; done: *_str = str; return 0; }
Description: GSS-NTLMSSP is a mechglue plugin for the GSSAPI library that implements NTLM authentication. Prior to version 1.2.0, multiple out-of-bounds reads when decoding NTLM fields can trigger a denial of service. A 32-bit integer overflow condition can lead to incorrect checks of consistency of length of internal buffers. Although most applications will error out before accepting a singe input buffer of 4GB in length this could theoretically happen. This vulnerability can be triggered via the main `gss_accept_sec_context` entry point if the application allows tokens greater than 4GB in length. This can lead to a large, up to 65KB, out-of-bounds read which could cause a denial-of-service if it reads from unmapped memory. Version 1.2.0 contains a patch for the out-of-bounds reads.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int io_register_personality(struct io_ring_ctx *ctx) { const struct cred *creds; u32 id; int ret; creds = get_current_cred(); ret = xa_alloc_cyclic(&ctx->personalities, &id, (void *)creds, XA_LIMIT(0, USHRT_MAX), &ctx->pers_next, GFP_KERNEL); if (!ret) return id; put_cred(creds); return ret; }
Description: A flaw was found in the Linux kernel’s io_uring implementation. This flaw allows an attacker with a local account to corrupt system memory, crash the system or escalate privileges.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void nbd_client_attach_aio_context(BlockDriverState *bs, AioContext *new_context) { aio_set_fd_handler(new_context, nbd_get_client_session(bs)->sioc->fd, false, nbd_reply_ready, NULL, NULL, bs); }
Description: An assertion-failure flaw was found in Qemu before 2.10.1, in the Network Block Device (NBD) server's initial connection negotiation, where the I/O coroutine was undefined. This could crash the qemu-nbd server if a client sent unexpected data during connection negotiation. A remote user or process could use this flaw to crash the qemu-nbd server resulting in denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: GF_Err chnl_box_write(GF_Box *s, GF_BitStream *bs) { GF_Err e; GF_ChannelLayoutBox *ptr = (GF_ChannelLayoutBox *) s; e = gf_isom_full_box_write(s, bs); if (e) return e; gf_bs_write_u8(bs, ptr->layout.stream_structure); if (ptr->layout.stream_structure & 1) { gf_bs_write_u8(bs, ptr->layout.definedLayout); if (ptr->layout.definedLayout==0) { u32 i; for (i=0; i<ptr->layout.channels_count; i++) { gf_bs_write_u8(bs, ptr->layout.layouts[i].position); if (ptr->layout.layouts[i].position==126) { gf_bs_write_int(bs, ptr->layout.layouts[i].azimuth, 16); gf_bs_write_int(bs, ptr->layout.layouts[i].elevation, 8); } } } else { gf_bs_write_u64(bs, ptr->layout.omittedChannelsMap); } } if (ptr->layout.stream_structure & 2) { gf_bs_write_u8(bs, ptr->layout.object_count); } return GF_OK; }
Description: Out-of-bounds Read in GitHub repository gpac/gpac prior to v2.2.2-DEV.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static uerr_t ftp_loop_internal (struct url *u, struct fileinfo *f, ccon *con, char **local_file, bool force_full_retrieve) { int count, orig_lp; wgint restval, len = 0, qtyread = 0; char *tms, *locf; const char *tmrate = NULL; uerr_t err; struct_stat st; bool warc_enabled = (opt.warc_filename != NULL); FILE *warc_tmp = NULL; ip_address *warc_ip = NULL; wgint last_expected_bytes = 0; if ((f == NULL) && (con->target)) { locf = con->target; } else { xfree (con->target); con->target = url_file_name (u, NULL); if (!opt.output_document) locf = con->target; else locf = opt.output_document; } if (opt.noclobber && !opt.output_document && file_exists_p (con->target) && !((con->cmd & DO_LIST) && !(con->cmd & DO_RETR))) { logprintf (LOG_VERBOSE, _(""File %s already there; not retrieving.\n""), quote (con->target)); return RETROK; } remove_link (con->target); count = 0; if (con->st & ON_YOUR_OWN) con->st = ON_YOUR_OWN; orig_lp = con->cmd & LEAVE_PENDING ? 1 : 0; do { ++count; sleep_between_retrievals (count); if (con->st & ON_YOUR_OWN) { con->cmd = 0; con->cmd |= (DO_RETR | LEAVE_PENDING); if (con->csock != -1) con->cmd &= ~ (DO_LOGIN | DO_CWD); else con->cmd |= (DO_LOGIN | DO_CWD); } else  { if (con->csock != -1) con->cmd &= ~DO_LOGIN; else con->cmd |= DO_LOGIN; if (con->st & DONE_CWD) con->cmd &= ~DO_CWD; else con->cmd |= DO_CWD; } if (warc_enabled && (con->cmd & DO_RETR) && warc_tmp == NULL) { warc_tmp = warc_tempfile (); if (warc_tmp == NULL) return WARC_TMP_FOPENERR; if (!con->proxy && con->csock != -1) { warc_ip = (ip_address *) alloca (sizeof (ip_address)); socket_ip_address (con->csock, warc_ip, ENDPOINT_PEER); } } if (con->cmd & DO_LIST) restval = 0; else if (force_full_retrieve) restval = 0; else if (opt.start_pos >= 0) restval = opt.start_pos; else if (opt.always_rest && stat (locf, &st) == 0 && S_ISREG (st.st_mode)) restval = st.st_size; else if (count > 1) restval = qtyread;           else restval = 0; tms = datetime_str (time (NULL)); if (opt.verbose) { char *hurl = url_string (u, URL_AUTH_HIDE_PASSWD); char tmp[256]; strcpy (tmp, ""        ""); if (count > 1) sprintf (tmp, _(""(try:%2d)""), count); logprintf (LOG_VERBOSE, ""--%s--  %s\n  %s => %s\n"", tms, hurl, tmp, quote (locf)); #ifdef WINDOWS ws_changetitle (hurl); #endif xfree (hurl); } if (f && f->type != FT_SYMLINK) len = f->size; else len = 0; err = getftp (u, len, &qtyread, restval, con, count, &last_expected_bytes, warc_tmp); if (con->csock == -1) con->st &= ~DONE_CWD; else con->st |= DONE_CWD; switch (err) { case HOSTERR: case CONIMPOSSIBLE: case FWRITEERR: case FOPENERR: case FTPNSFOD: case FTPLOGINC: case FTPNOPASV: case FTPNOAUTH: case FTPNOPBSZ: case FTPNOPROT: case UNLINKERR: case WARC_TMP_FWRITEERR: case CONSSLERR: case CONTNOTSUPPORTED: #ifdef HAVE_SSL if (err == FTPNOAUTH) logputs (LOG_NOTQUIET, ""Server does not support AUTH TLS.\n""); if (opt.ftps_implicit) logputs (LOG_NOTQUIET, ""Server does not like implicit FTPS connections.\n""); #endif if (warc_tmp != NULL) fclose (warc_tmp); return err; case CONSOCKERR: case CONERROR: case FTPSRVERR: case FTPRERR: case WRITEFAILED: case FTPUNKNOWNTYPE: case FTPSYSERR: case FTPPORTERR: case FTPLOGREFUSED: case FTPINVPASV: case FOPEN_EXCL_ERR: printwhat (count, opt.ntry); if (err == FOPEN_EXCL_ERR) { xfree (con->target); con->target = url_file_name (u, NULL); locf = con->target; } continue; case FTPRETRINT: if (!f || qtyread != f->size) { printwhat (count, opt.ntry); continue; } break; case RETRFINISHED: break; default: abort (); } tms = datetime_str (time (NULL)); if (!opt.spider) tmrate = retr_rate (qtyread - restval, con->dltime); downloaded_file (FILE_DOWNLOADED_NORMALLY, locf); if (con->st & ON_YOUR_OWN) { fd_close (con->csock); con->csock = -1; } if (!opt.spider) { bool write_to_stdout = (opt.output_document && HYPHENP (opt.output_document)); logprintf (LOG_VERBOSE, write_to_stdout ? _(""%s (%s) - written to stdout %s[%s]\n\n"") : _(""%s (%s) - %s saved [%s]\n\n""), tms, tmrate, write_to_stdout ? """" : quote (locf), number_to_static_string (qtyread)); } if (!opt.verbose && !opt.quiet) { char *hurl = url_string (u, URL_AUTH_HIDE_PASSWD); logprintf (LOG_NONVERBOSE, ""%s URL: %s [%s] -> \""%s\"" [%d]\n"", tms, hurl, number_to_static_string (qtyread), locf, count); xfree (hurl); } if (warc_enabled && (con->cmd & DO_RETR)) { bool warc_res; warc_res = warc_write_resource_record (NULL, u->url, NULL, NULL, warc_ip, NULL, warc_tmp, -1); if (! warc_res) return WARC_ERR; warc_tmp = NULL; } if (con->cmd & DO_LIST) { if (!opt.remove_listing) { total_downloaded_bytes += qtyread; numurls++; } } else if (!opt.spider) { total_downloaded_bytes += qtyread; numurls++; if (opt.delete_after && !input_file_url (opt.input_filename)) { DEBUGP ((""\ Removing file due to --delete-after in ftp_loop_internal():\n"")); logprintf (LOG_VERBOSE, _(""Removing %s.\n""), locf); if (unlink (locf)) logprintf (LOG_NOTQUIET, ""unlink: %s\n"", strerror (errno)); } } if (orig_lp) con->cmd |= LEAVE_PENDING; else con->cmd &= ~LEAVE_PENDING; if (local_file) *local_file = xstrdup (locf); if (warc_tmp != NULL) fclose (warc_tmp); return RETROK; } while (!opt.ntry || (count < opt.ntry)); if (con->csock != -1 && (con->st & ON_YOUR_OWN)) { fd_close (con->csock); con->csock = -1; } if (warc_tmp != NULL) fclose (warc_tmp); return TRYLIMEXC; }
Description: GNU wget before 1.18 allows remote servers to write to arbitrary files by redirecting a request from HTTP to a crafted FTP resource.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int xemaclite_of_probe(struct platform_device *ofdev) { struct resource *res; struct net_device *ndev = NULL; struct net_local *lp = NULL; struct device *dev = &ofdev->dev; int rc = 0; dev_info(dev, ""Device Tree Probing\n""); ndev = alloc_etherdev(sizeof(struct net_local)); if (!ndev) return -ENOMEM; dev_set_drvdata(dev, ndev); SET_NETDEV_DEV(ndev, &ofdev->dev); lp = netdev_priv(ndev); lp->ndev = ndev; res = platform_get_resource(ofdev, IORESOURCE_IRQ, 0); if (!res) { dev_err(dev, ""no IRQ found\n""); rc = -ENXIO; goto error; } ndev->irq = res->start; res = platform_get_resource(ofdev, IORESOURCE_MEM, 0); lp->base_addr = devm_ioremap_resource(&ofdev->dev, res); if (IS_ERR(lp->base_addr)) { rc = PTR_ERR(lp->base_addr); goto error; } ndev->mem_start = res->start; ndev->mem_end = res->end; spin_lock_init(&lp->reset_lock); lp->next_tx_buf_to_use = 0x0; lp->next_rx_buf_to_use = 0x0; lp->tx_ping_pong = get_bool(ofdev, ""xlnx,tx-ping-pong""); lp->rx_ping_pong = get_bool(ofdev, ""xlnx,rx-ping-pong""); rc = of_get_mac_address(ofdev->dev.of_node, ndev->dev_addr); if (rc) { dev_warn(dev, ""No MAC address found, using random\n""); eth_hw_addr_random(ndev); } xemaclite_writel(0, lp->base_addr + XEL_TSR_OFFSET); xemaclite_writel(0, lp->base_addr + XEL_BUFFER_OFFSET + XEL_TSR_OFFSET); xemaclite_update_address(lp, ndev->dev_addr); lp->phy_node = of_parse_phandle(ofdev->dev.of_node, ""phy-handle"", 0); xemaclite_mdio_setup(lp, &ofdev->dev); dev_info(dev, ""MAC address is now %pM\n"", ndev->dev_addr); ndev->netdev_ops = &xemaclite_netdev_ops; ndev->ethtool_ops = &xemaclite_ethtool_ops; ndev->flags &= ~IFF_MULTICAST; ndev->watchdog_timeo = TX_TIMEOUT; rc = register_netdev(ndev); if (rc) { dev_err(dev, ""Cannot register network device, aborting\n""); goto error; } dev_info(dev, ""Xilinx EmacLite at 0x%08lX mapped to 0x%08lX, irq=%d\n"", (unsigned long __force)ndev->mem_start, (unsigned long __force)lp->base_addr, ndev->irq); return 0; error: free_netdev(ndev); return rc; }
Description: drivers/net/ethernet/xilinx/xilinx_emaclite.c in the Linux kernel before 5.13.3 makes it easier for attackers to defeat an ASLR protection mechanism because it prints a kernel pointer (i.e., the real IOMEM pointer).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int parse_codes(struct archive_read *a) { int i, j, val, n, r; unsigned char bitlengths[MAX_SYMBOLS], zerocount, ppmd_flags; unsigned int maxorder; struct huffman_code precode; struct rar *rar = (struct rar *)(a->format->data); struct rar_br *br = &(rar->br); free_codes(a); rar_br_consume_unalined_bits(br); if (!rar_br_read_ahead(a, br, 1)) goto truncated_data; if ((rar->is_ppmd_block = rar_br_bits(br, 1)) != 0) { rar_br_consume(br, 1); if (!rar_br_read_ahead(a, br, 7)) goto truncated_data; ppmd_flags = rar_br_bits(br, 7); rar_br_consume(br, 7); if (ppmd_flags & 0x20) { if (!rar_br_read_ahead(a, br, 8)) goto truncated_data; rar->dictionary_size = (rar_br_bits(br, 8) + 1) << 20; rar_br_consume(br, 8); } if (ppmd_flags & 0x40) { if (!rar_br_read_ahead(a, br, 8)) goto truncated_data; rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(br, 8); rar_br_consume(br, 8); } else rar->ppmd_escape = 2; if (ppmd_flags & 0x20) { maxorder = (ppmd_flags & 0x1F) + 1; if(maxorder > 16) maxorder = 16 + (maxorder - 16) * 3; if (maxorder == 1) { archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT, ""Truncated RAR file data""); return (ARCHIVE_FATAL); } __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context, &g_szalloc); rar->bytein.a = a; rar->bytein.Read = &ppmd_read; __archive_ppmd7_functions.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec); rar->range_dec.Stream = &rar->bytein; __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context); if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context, rar->dictionary_size, &g_szalloc)) { archive_set_error(&a->archive, ENOMEM, ""Out of memory""); return (ARCHIVE_FATAL); } if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec)) { archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT, ""Unable to initialize PPMd range decoder""); return (ARCHIVE_FATAL); } __archive_ppmd7_functions.Ppmd7_Init(&rar->ppmd7_context, maxorder); rar->ppmd_valid = 1; } else { if (!rar->ppmd_valid) { archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT, ""Invalid PPMd sequence""); return (ARCHIVE_FATAL); } if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec)) { archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT, ""Unable to initialize PPMd range decoder""); return (ARCHIVE_FATAL); } } } else { rar_br_consume(br, 1); if (!rar_br_read_ahead(a, br, 1)) goto truncated_data; if (!rar_br_bits(br, 1)) memset(rar->lengthtable, 0, sizeof(rar->lengthtable)); rar_br_consume(br, 1); memset(&bitlengths, 0, sizeof(bitlengths)); for (i = 0; i < MAX_SYMBOLS;) { if (!rar_br_read_ahead(a, br, 4)) goto truncated_data; bitlengths[i++] = rar_br_bits(br, 4); rar_br_consume(br, 4); if (bitlengths[i-1] == 0xF) { if (!rar_br_read_ahead(a, br, 4)) goto truncated_data; zerocount = rar_br_bits(br, 4); rar_br_consume(br, 4); if (zerocount) { i--; for (j = 0; j < zerocount + 2 && i < MAX_SYMBOLS; j++) bitlengths[i++] = 0; } } } memset(&precode, 0, sizeof(precode)); r = create_code(a, &precode, bitlengths, MAX_SYMBOLS, MAX_SYMBOL_LENGTH); if (r != ARCHIVE_OK) { free(precode.tree); free(precode.table); return (r); } for (i = 0; i < HUFFMAN_TABLE_SIZE;) { if ((val = read_next_symbol(a, &precode)) < 0) { free(precode.tree); free(precode.table); return (ARCHIVE_FATAL); } if (val < 16) { rar->lengthtable[i] = (rar->lengthtable[i] + val) & 0xF; i++; } else if (val < 18) { if (i == 0) { free(precode.tree); free(precode.table); archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT, ""Internal error extracting RAR file.""); return (ARCHIVE_FATAL); } if(val == 16) { if (!rar_br_read_ahead(a, br, 3)) { free(precode.tree); free(precode.table); goto truncated_data; } n = rar_br_bits(br, 3) + 3; rar_br_consume(br, 3); } else { if (!rar_br_read_ahead(a, br, 7)) { free(precode.tree); free(precode.table); goto truncated_data; } n = rar_br_bits(br, 7) + 11; rar_br_consume(br, 7); } for (j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++) { rar->lengthtable[i] = rar->lengthtable[i-1]; i++; } } else { if(val == 18) { if (!rar_br_read_ahead(a, br, 3)) { free(precode.tree); free(precode.table); goto truncated_data; } n = rar_br_bits(br, 3) + 3; rar_br_consume(br, 3); } else { if (!rar_br_read_ahead(a, br, 7)) { free(precode.tree); free(precode.table); goto truncated_data; } n = rar_br_bits(br, 7) + 11; rar_br_consume(br, 7); } for(j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++) rar->lengthtable[i++] = 0; } } free(precode.tree); free(precode.table); r = create_code(a, &rar->maincode, &rar->lengthtable[0], MAINCODE_SIZE, MAX_SYMBOL_LENGTH); if (r != ARCHIVE_OK) return (r); r = create_code(a, &rar->offsetcode, &rar->lengthtable[MAINCODE_SIZE], OFFSETCODE_SIZE, MAX_SYMBOL_LENGTH); if (r != ARCHIVE_OK) return (r); r = create_code(a, &rar->lowoffsetcode, &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE], LOWOFFSETCODE_SIZE, MAX_SYMBOL_LENGTH); if (r != ARCHIVE_OK) return (r); r = create_code(a, &rar->lengthcode, &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE + LOWOFFSETCODE_SIZE], LENGTHCODE_SIZE, MAX_SYMBOL_LENGTH); if (r != ARCHIVE_OK) return (r); } if (!rar->dictionary_size || !rar->lzss.window) { void *new_window; unsigned int new_size; if (rar->unp_size >= DICTIONARY_MAX_SIZE) new_size = DICTIONARY_MAX_SIZE; else new_size = rar_fls((unsigned int)rar->unp_size) << 1; new_window = realloc(rar->lzss.window, new_size); if (new_window == NULL) { archive_set_error(&a->archive, ENOMEM, ""Unable to allocate memory for uncompressed data.""); return (ARCHIVE_FATAL); } rar->lzss.window = (unsigned char *)new_window; rar->dictionary_size = new_size; memset(rar->lzss.window, 0, rar->dictionary_size); rar->lzss.mask = rar->dictionary_size - 1; } rar->start_new_table = 0; return (ARCHIVE_OK); truncated_data: archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT, ""Truncated RAR file data""); rar->valid = 0; return (ARCHIVE_FATAL); }
Description: Heap-based buffer overflow in the parse_codes function in archive_read_support_format_rar.c in libarchive before 3.2.1 allows remote attackers to execute arbitrary code via a RAR file with a zero-sized dictionary.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void pt_restore_timer(struct vcpu *v) { struct list_head *head = &v->arch.hvm.tm_list; struct periodic_time *pt; spin_lock(&v->arch.hvm.tm_lock); list_for_each_entry ( pt, head, list ) { if ( pt->pending_intr_nr == 0 ) { pt_process_missed_ticks(pt); set_timer(&pt->timer, pt->scheduled); } } pt_thaw_time(v); spin_unlock(&v->arch.hvm.tm_lock); }
Description: An issue was discovered in Xen through 4.14.x. There is a race condition when migrating timers between x86 HVM vCPUs. When migrating timers of x86 HVM guests between its vCPUs, the locking model used allows for a second vCPU of the same guest (also operating on the timers) to release a lock that it didn't acquire. The most likely effect of the issue is a hang or crash of the hypervisor, i.e., a Denial of Service (DoS). All versions of Xen are affected. Only x86 systems are vulnerable. Arm systems are not vulnerable. Only x86 HVM guests can leverage the vulnerability. x86 PV and PVH cannot leverage the vulnerability. Only guests with more than one vCPU can exploit the vulnerability.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static proto_item * proto_tree_add_node(proto_tree *tree, field_info *fi) { proto_node *pnode, *tnode, *sibling; field_info *tfi; tnode = tree; tfi = PNODE_FINFO(tnode); if (tfi != NULL && (tfi->tree_type < 0 || tfi->tree_type >= num_tree_types)) { REPORT_DISSECTOR_BUG(wmem_strdup_printf(wmem_packet_scope(), ""\""%s\"" - \""%s\"" tfi->tree_type: %u invalid (%s:%u)"", fi->hfinfo->name, fi->hfinfo->abbrev, tfi->tree_type, __FILE__, __LINE__)); } pnode = wmem_new(PNODE_POOL(tree), proto_node); PROTO_NODE_INIT(pnode); pnode->parent = tnode; PNODE_FINFO(pnode) = fi; pnode->tree_data = PTREE_DATA(tree); if (tnode->last_child != NULL) { sibling = tnode->last_child; DISSECTOR_ASSERT(sibling->next == NULL); sibling->next = pnode; } else tnode->first_child = pnode; tnode->last_child = pnode; tree_data_add_maybe_interesting_field(pnode->tree_data, fi); return (proto_item *)pnode; }
Description: epan/proto.c in Wireshark 1.12.x before 1.12.11 and 2.0.x before 2.0.3 does not limit the protocol-tree depth, which allows remote attackers to cause a denial of service (stack memory consumption and application crash) via a crafted packet.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void HeaderMapImpl::remove(const LowerCaseString& key) { EntryCb cb = ConstSingleton<StaticLookupTable>::get().find(key.get()); if (cb) { StaticLookupResponse ref_lookup_response = cb(*this); removeInline(ref_lookup_response.entry_); } else { for (auto i = headers_.begin(); i != headers_.end();) { if (i->key() == key.get().c_str()) { i = headers_.erase(i); } else { ++i; } } } }
Description: Upon receiving each incoming request header data, Envoy will iterate over existing request headers to verify that the total size of the headers stays below a maximum limit. The implementation in versions 1.10.0 through 1.11.1 for HTTP/1.x traffic and all versions of Envoy for HTTP/2 traffic had O(n^2) performance characteristics. A remote attacker may craft a request that stays below the maximum request header size but consists of many thousands of small headers to consume CPU and result in a denial-of-service attack.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static gnrc_pktsnip_t *_iphc_encode(gnrc_pktsnip_t *pkt, const gnrc_netif_hdr_t *netif_hdr, gnrc_netif_t *iface) { assert(pkt != NULL); uint8_t *iphc_hdr; gnrc_pktsnip_t *dispatch, *ptr = pkt->next; size_t dispatch_size = 0; uint16_t inline_pos = 0; uint8_t nh; dispatch = NULL;     while ((ptr != NULL) && _compressible(ptr)) { gnrc_pktsnip_t *tmp = gnrc_pktbuf_start_write(ptr); if (tmp == NULL) { DEBUG(""6lo iphc: unable to write protect compressible header\n""); return NULL; } ptr = tmp; if (dispatch == NULL) { pkt->next = ptr;     } else { dispatch->next = ptr; } if (ptr->type == GNRC_NETTYPE_UNDEF) { dispatch_size += sizeof(udp_hdr_t); break;   } else { dispatch_size += ptr->size; } dispatch = ptr;  ptr = ptr->next; } assert(dispatch_size > 0); dispatch = gnrc_pktbuf_add(NULL, NULL, dispatch_size + 1, GNRC_NETTYPE_SIXLOWPAN); if (dispatch == NULL) { DEBUG(""6lo iphc: error allocating dispatch space\n""); return NULL; } iphc_hdr = dispatch->data; inline_pos = _iphc_ipv6_encode(pkt, netif_hdr, iface, iphc_hdr); if (inline_pos == 0) { DEBUG(""6lo iphc: error encoding IPv6 header\n""); gnrc_pktbuf_release(dispatch); return NULL; } nh = ((ipv6_hdr_t *)pkt->next->data)->nh; #ifdef MODULE_GNRC_SIXLOWPAN_IPHC_NHC while (_compressible_nh(nh)) { ssize_t local_pos = 0; if (pkt->next->next == NULL) { DEBUG(""6lo iphc: packet next header missing data""); gnrc_pktbuf_release(dispatch); return NULL; } switch (nh) { case PROTNUM_UDP: local_pos = _nhc_udp_encode_snip(pkt, &iphc_hdr[inline_pos]); nh = PROTNUM_RESERVED; break; case PROTNUM_IPV6: {     local_pos = _nhc_ipv6_encode_snip(pkt, netif_hdr, iface, &iphc_hdr[inline_pos], &nh); break; } case PROTNUM_IPV6_EXT_HOPOPT: case PROTNUM_IPV6_EXT_RH: case PROTNUM_IPV6_EXT_FRAG: case PROTNUM_IPV6_EXT_DST: case PROTNUM_IPV6_EXT_MOB: local_pos = _nhc_ipv6_ext_encode_snip(pkt, &iphc_hdr[inline_pos], &nh); if (local_pos == 0) { nh = PROTNUM_RESERVED; } break; default: nh = PROTNUM_RESERVED; break; } if (local_pos < 0) { DEBUG(""6lo iphc: error on compressing next header\n""); gnrc_pktbuf_release(dispatch); return NULL; } inline_pos += local_pos; } #endif gnrc_pktbuf_realloc_data(dispatch, (size_t)inline_pos); pkt = gnrc_pktbuf_remove_snip(pkt, pkt->next); dispatch->next = pkt->next; pkt->next = dispatch; return pkt; }
Description: RIOT-OS, an operating system that supports Internet of Things devices, contains a network stack with the ability to process 6LoWPAN frames. Prior to version 2022.10, an attacker can send a crafted frame to the device resulting in a type confusion between IPv6 extension headers and a UDP header. This occurs while encoding a 6LoWPAN IPHC header. The type confusion manifests in an out of bounds write in the packet buffer. The overflow can be used to corrupt other packets and the allocator metadata. Corrupting a pointer will easily lead to denial of service. While carefully manipulating the allocator metadata gives an attacker the possibility to write data to arbitrary locations and thus execute arbitrary code. Version 2022.10 fixes this issue. As a workaround, apply the patches manually.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static ImapResult imap_mbox_connect(ImapMboxHandle* handle) { ImapResponse resp; GError *error = NULL; handle->op_cancelled = FALSE; handle->has_capabilities = FALSE; handle->can_fetch_body = TRUE; handle->idle_state = IDLE_INACTIVE; if(handle->sio) { g_object_unref(handle->sio); handle->sio = NULL; } handle->sio = net_client_siobuf_new(handle->host, handle->tls_mode == NET_CLIENT_CRYPT_ENCRYPTED ? 993 : 143); g_signal_connect(handle->sio, ""auth"", handle->auth_cb, handle->auth_arg); g_signal_connect(handle->sio, ""cert-check"", handle->cert_cb, handle->sio); if (!net_client_connect(NET_CLIENT(handle->sio), &error)) { imap_mbox_handle_set_msg(handle, _(""Connecting %s failed: %s""), handle->host, error_safe(error)); g_clear_error(&error); return IMAP_CONNECT_FAILED; } #if 0 if(handle->timeout>0) { sio_set_timeout(handle->sio, handle->timeout); sio_set_timeoutcb(handle->sio, imap_timeout_cb, handle); } #endif if (handle->tls_mode == NET_CLIENT_CRYPT_ENCRYPTED) { if (!net_client_start_tls(NET_CLIENT(handle->sio), &error)) { imap_mbox_handle_set_msg(handle, _(""TLS negotiation failed: %s""), error_safe(error)); g_clear_error(&error); return IMAP_UNSECURE; } } handle->state = IMHS_CONNECTED; if ( (resp=imap_cmd_step(handle, 0)) != IMR_UNTAGGED) { g_message(""imap_mbox_connect:unexpected initial response(%d): %s"", resp, handle->last_msg); imap_handle_disconnect(handle); return IMAP_PROTOCOL_ERROR; } handle->can_fetch_body =  (strncmp(handle->last_msg, ""Microsoft Exchange"", 18) != 0); if((handle->tls_mode == NET_CLIENT_CRYPT_ENCRYPTED) || (handle->tls_mode == NET_CLIENT_CRYPT_NONE)) { resp = IMAP_SUCCESS;  } else if(imap_mbox_handle_can_do(handle, IMCAP_STARTTLS)) { if( imap_handle_starttls(handle, &error) != IMR_OK) { imap_mbox_handle_set_msg(handle, _(""TLS negotiation failed: %s""), error_safe(error)); resp = IMAP_UNSECURE;  } else { resp = IMAP_SUCCESS;  } } else { imap_mbox_handle_set_msg(handle, _(""TLS required but not available"")); resp = IMR_NO;  } return resp; }
Description: In GNOME Balsa before 2.6.0, a malicious server operator or man in the middle can trigger a NULL pointer dereference and client crash by sending a PREAUTH response to imap_mbox_connect in libbalsa/imap/imap-handle.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static Image *ReadTXTImage(const ImageInfo *image_info,ExceptionInfo *exception) { char colorspace[MagickPathExtent], text[MagickPathExtent]; Image *image; long x_offset, y_offset; PixelInfo pixel; MagickBooleanType status; QuantumAny range; register ssize_t i, x; register Quantum *q; ssize_t count, type, y; unsigned long depth, height, max_value, width; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); image=AcquireImage(image_info,exception); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } (void) ResetMagickMemory(text,0,sizeof(text)); (void) ReadBlobString(image,text); if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) != 0) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); do { width=0; height=0; max_value=0; *colorspace='\0'; count=(ssize_t) sscanf(text+32,""%lu,%lu,%lu,%s"",&width,&height,&max_value, colorspace); if ((count != 4) || (width == 0) || (height == 0) || (max_value == 0)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); image->columns=width; image->rows=height; for (depth=1; (GetQuantumRange(depth)+1) < max_value; depth++) ; image->depth=depth; status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) return(DestroyImageList(image)); LocaleLower(colorspace); i=(ssize_t) strlen(colorspace)-1; image->alpha_trait=UndefinedPixelTrait; if ((i > 0) && (colorspace[i] == 'a')) { colorspace[i]='\0'; image->alpha_trait=BlendPixelTrait; } type=ParseCommandOption(MagickColorspaceOptions,MagickFalse,colorspace); if (type < 0) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); (void) SetImageBackgroundColor(image,exception); (void) SetImageColorspace(image,(ColorspaceType) type,exception); GetPixelInfo(image,&pixel); range=GetQuantumRange(image->depth); for (y=0; y < (ssize_t) image->rows; y++) { double alpha, black, blue, green, red; red=0.0; green=0.0; blue=0.0; black=0.0; alpha=0.0; for (x=0; x < (ssize_t) image->columns; x++) { if (ReadBlobString(image,text) == (char *) NULL) break; switch (image->colorspace) { case GRAYColorspace: { if (image->alpha_trait != UndefinedPixelTrait) { count=(ssize_t) sscanf(text,""%ld,%ld: (%lf%*[%,]%lf%*[%,]"", &x_offset,&y_offset,&red,&alpha); green=red; blue=red; break; } count=(ssize_t) sscanf(text,""%ld,%ld: (%lf%*[%,]"",&x_offset, &y_offset,&red); green=red; blue=red; break;        } case CMYKColorspace: { if (image->alpha_trait != UndefinedPixelTrait) { count=(ssize_t) sscanf(text, ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"", &x_offset,&y_offset,&red,&green,&blue,&black,&alpha); break; } count=(ssize_t) sscanf(text, ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&x_offset, &y_offset,&red,&green,&blue,&black); break; } default: { if (image->alpha_trait != UndefinedPixelTrait) { count=(ssize_t) sscanf(text, ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]%lf%*[%,]"", &x_offset,&y_offset,&red,&green,&blue,&alpha); break; } count=(ssize_t) sscanf(text, ""%ld,%ld: (%lf%*[%,]%lf%*[%,]%lf%*[%,]"",&x_offset, &y_offset,&red,&green,&blue); break;        } } if (strchr(text,'%') != (char *) NULL) { red*=0.01*range; green*=0.01*range; blue*=0.01*range; black*=0.01*range; alpha*=0.01*range; } if (image->colorspace == LabColorspace) { green+=(range+1)/2.0; blue+=(range+1)/2.0; } pixel.red=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (red+0.5), range); pixel.green=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (green+0.5), range); pixel.blue=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (blue+0.5), range); pixel.black=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (black+0.5), range); pixel.alpha=(MagickRealType) ScaleAnyToQuantum((QuantumAny) (alpha+0.5), range); q=GetAuthenticPixels(image,(ssize_t) x_offset,(ssize_t) y_offset,1,1, exception); if (q == (Quantum *) NULL) continue; SetPixelViaPixelInfo(image,&pixel,q); if (SyncAuthenticPixels(image,exception) == MagickFalse) break; } } if (EOFBlob(image) != MagickFalse) { ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"", image->filename); break; } (void) ReadBlobString(image,text); if (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0) { AcquireNextImage(image_info,image,exception); if (GetNextImageInList(image) == (Image *) NULL) { image=DestroyImageList(image); return((Image *) NULL); } image=SyncNextImageInList(image); status=SetImageProgress(image,LoadImagesTag,TellBlob(image), GetBlobSize(image)); if (status == MagickFalse) break; } } while (LocaleNCompare((char *) text,MagickID,strlen(MagickID)) == 0); (void) CloseBlob(image); return(GetFirstImageInList(image)); }
Description: In the function ReadTXTImage() in coders/txt.c in ImageMagick 7.0.6-10, an integer overflow might occur for the addition operation ""GetQuantumRange(depth)+1"" when ""depth"" is large, producing a smaller value than expected. As a result, an infinite loop would occur for a crafted TXT file that claims a very large ""max_value"" value.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void parser_reparse_as_common_identifier (parser_context_t *context_p,  parser_line_counter_t start_line,  parser_line_counter_t start_column)  { context_p->source_p = context_p->token.lit_location.char_p; context_p->line = start_line; context_p->column = start_column; lexer_next_token (context_p); if (context_p->token.type != LEXER_LITERAL || context_p->token.lit_location.type != LEXER_IDENT_LITERAL) { parser_raise_error (context_p, PARSER_ERR_IDENTIFIER_EXPECTED); } lexer_construct_literal_object (context_p, &context_p->token.lit_location, LEXER_IDENT_LITERAL); }
Description: There is an Assertion 'context_p->token.type == LEXER_RIGHT_BRACE || context_p->token.type == LEXER_ASSIGN || context_p->token.type == LEXER_COMMA' failed at js-parser-expr.c:3230 in parser_parse_object_initializer in JerryScript 2.2.0.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int Request::parse_request(const char *read_buffer, int read_size) { _total_req_size += read_size; if (_total_req_size > MAX_REQ_SIZE) { LOG_INFO(""TOO BIG REQUEST WE WILL REFUSE IT! MAX_REQ_SIZE:%d"", MAX_REQ_SIZE); return -1; } LOG_DEBUG(""read from client: size:%d, content:%s"", read_size, read_buffer); ssize_t nparsed = http_parser_execute(&_parser, &_settings, read_buffer, read_size); if (nparsed != read_size) { std::string err_msg = ""unkonw""; if (_parser.http_errno) { err_msg = http_errno_description(HTTP_PARSER_ERRNO(&_parser)); } LOG_ERROR(""parse request error, nparsed:%jd, input size:%d! msg:%s"",  nparsed, read_size, err_msg.c_str()); return -1; } if (_parse_err) { return _parse_err; } if (_parse_part != PARSE_REQ_OVER) { return NEED_MORE_STATUS; } return 0; }
Description: ehttp 1.0.6 before 17405b9 has an epoll_socket.cpp read_func use-after-free. An attacker can make many connections over a short time to trigger this.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: struct sd_markdown * sd_markdown_new( unsigned int extensions, size_t max_nesting, size_t max_table_cols, const struct sd_callbacks *callbacks, void *opaque) { struct sd_markdown *md = NULL; assert(max_nesting > 0 && max_table_cols > 0 && callbacks); md = malloc(sizeof(struct sd_markdown)); if (!md) return NULL; memcpy(&md->cb, callbacks, sizeof(struct sd_callbacks)); stack_init(&md->work_bufs[BUFFER_BLOCK], 4); stack_init(&md->work_bufs[BUFFER_SPAN], 8); memset(md->active_char, 0x0, 256); if (md->cb.emphasis || md->cb.double_emphasis || md->cb.triple_emphasis) { md->active_char['*'] = MD_CHAR_EMPHASIS; md->active_char['_'] = MD_CHAR_EMPHASIS; md->active_char['>'] = MD_CHAR_EMPHASIS; if (extensions & MKDEXT_STRIKETHROUGH) md->active_char['~'] = MD_CHAR_EMPHASIS; } if (md->cb.codespan) md->active_char['`'] = MD_CHAR_CODESPAN; if (md->cb.linebreak) md->active_char['\n'] = MD_CHAR_LINEBREAK; if (md->cb.image || md->cb.link) md->active_char['['] = MD_CHAR_LINK; md->active_char['<'] = MD_CHAR_LANGLE; md->active_char['\\'] = MD_CHAR_ESCAPE; md->active_char['&'] = MD_CHAR_ENTITITY; if (extensions & MKDEXT_AUTOLINK) { if (!(extensions & MKDEXT_NO_EMAIL_AUTOLINK)) md->active_char['@'] = MD_CHAR_AUTOLINK_EMAIL; md->active_char[':'] = MD_CHAR_AUTOLINK_URL; md->active_char['w'] = MD_CHAR_AUTOLINK_WWW; md->active_char['/'] = MD_CHAR_AUTOLINK_SUBREDDIT_OR_USERNAME; } if (extensions & MKDEXT_SUPERSCRIPT) md->active_char['^'] = MD_CHAR_SUPERSCRIPT; md->ext_flags = extensions; md->opaque = opaque; md->max_nesting = max_nesting; md->max_table_cols = max_table_cols; md->in_link_body = 0; return md; }
Description: Snudown is a reddit-specific fork of the Sundown Markdown parser used by GitHub, with Python integration added. In affected versions snudown was found to be vulnerable to denial of service attacks to its reference table implementation. References written in markdown ` [reference_name]: https://www.example.com` are inserted into a hash table which was found to have a weak hash function, meaning that an attacker can reliably generate a large number of collisions for it. This makes the hash table vulnerable to a hash-collision DoS attack, a type of algorithmic complexity attack. Further the hash table allowed for duplicate entries resulting in long retrieval times. Proofs of concept and further discussion of the hash collision issue are discussed on the snudown GHSA(https://github.com/reddit/snudown/security/advisories/GHSA-6gvv-9q92-w5f6). Users are advised to update to version 1.7.0.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void spl_ptr_heap_insert(spl_ptr_heap *heap, spl_ptr_heap_element elem, void *cmp_userdata TSRMLS_DC) {  int i; if (heap->count+1 > heap->max_size) { heap->elements  = (void **) safe_erealloc(heap->elements, sizeof(spl_ptr_heap_element), (heap->max_size), (sizeof(spl_ptr_heap_element) * (heap->max_size))); heap->max_size *= 2; } heap->ctor(elem TSRMLS_CC); for(i = heap->count++; i > 0 && heap->cmp(heap->elements[(i-1)/2], elem, cmp_userdata TSRMLS_CC) < 0; i = (i-1)/2) { heap->elements[i] = heap->elements[(i-1)/2]; } if (EG(exception)) { heap->flags |= SPL_HEAP_CORRUPTED; } heap->elements[i] = elem; }
Description: Use-after-free vulnerability in the spl_ptr_heap_insert function in ext/spl/spl_heap.c in PHP before 5.5.27 and 5.6.x before 5.6.11 allows remote attackers to execute arbitrary code by triggering a failed SplMinHeap::compare operation.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int var_files_tmp_contents_generate(modsec_rec *msr, msre_var *var, msre_rule *rule, apr_table_t *vartab, apr_pool_t *mptmp) { multipart_part **parts = NULL; int i, count = 0; if (msr->mpd == NULL) return 0; parts = (multipart_part **)msr->mpd->parts->elts; for (i = 0; i < msr->mpd->parts->nelts; i++) { if ((parts[i]->type == MULTIPART_FILE) && (parts[i]->tmp_file_name != NULL)) { int match = 0; if (var->param == NULL) { match = 1; } else { if (var->param_data != NULL) { char *my_error_msg = NULL; if (!(msc_regexec((msc_regex_t *)var->param_data, parts[i]->name, strlen(parts[i]->name), &my_error_msg) == PCRE_ERROR_NOMATCH))  { match = 1; } } else { if (strcasecmp(parts[i]->name, var->param) == 0) { match = 1; } } } if (match) { char buf[1024]; FILE *file; size_t nread; char *full_content = NULL; size_t total_lenght = 0; msre_var *rvar = NULL; file = fopen(parts[i]->tmp_file_name, ""r""); if (file == NULL) { continue; } while ((nread = fread(buf, 1, 1023, file)) > 0) {    total_lenght += nread; buf[nread] = '\0'; if (full_content == NULL) { full_content = apr_psprintf(mptmp, ""%s"", buf); } else { full_content = apr_psprintf(mptmp, ""%s%s"", full_content, buf); } } fclose(file); rvar = apr_pmemdup(mptmp, var, sizeof(msre_var)); rvar->value = full_content; rvar->value_len = total_lenght; rvar->name = apr_psprintf(mptmp, ""FILES_TMP_CONTENT:%s"", log_escape_nq(mptmp, parts[i]->name)); apr_table_addn(vartab, rvar->name, (void *)rvar); count++; } } } return count; }
Description: Incorrect handling of '\0' bytes in file uploads in ModSecurity before 2.9.7 may allow for Web Application Firewall bypasses and buffer over-reads on the Web Application Firewall when executing rules that read the FILES_TMP_CONTENT collection.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int v9fs_device_realize_common(V9fsState *s, Error **errp) { V9fsVirtioState *v = container_of(s, V9fsVirtioState, state); int i, len; struct stat stat; FsDriverEntry *fse; V9fsPath path; int rc = 1; QLIST_INIT(&s->free_list); QLIST_INIT(&s->active_list); for (i = 0; i < (MAX_REQ - 1); i++) { QLIST_INSERT_HEAD(&s->free_list, &v->pdus[i], next); v->pdus[i].s = s; v->pdus[i].idx = i; } v9fs_path_init(&path); fse = get_fsdev_fsentry(s->fsconf.fsdev_id); if (!fse) { error_setg(errp, ""9pfs device couldn't find fsdev with the "" ""id = %s"", s->fsconf.fsdev_id ? s->fsconf.fsdev_id : ""NULL""); goto out; } if (!s->fsconf.tag) { error_setg(errp, ""fsdev with id %s needs mount_tag arguments"", s->fsconf.fsdev_id); goto out; } s->ctx.export_flags = fse->export_flags; s->ctx.fs_root = g_strdup(fse->path); s->ctx.exops.get_st_gen = NULL; len = strlen(s->fsconf.tag); if (len > MAX_TAG_LEN - 1) { error_setg(errp, ""mount tag '%s' (%d bytes) is longer than "" ""maximum (%d bytes)"", s->fsconf.tag, len, MAX_TAG_LEN - 1); goto out; } s->tag = g_strdup(s->fsconf.tag); s->ctx.uid = -1; s->ops = fse->ops; s->fid_list = NULL; qemu_co_rwlock_init(&s->rename_lock); if (s->ops->init(&s->ctx) < 0) { error_setg(errp, ""9pfs Failed to initialize fs-driver with id:%s"" "" and export path:%s"", s->fsconf.fsdev_id, s->ctx.fs_root); goto out; } if (s->ops->name_to_path(&s->ctx, NULL, ""/"", &path) < 0) { error_setg(errp, ""error in converting name to path %s"", strerror(errno)); goto out; } if (s->ops->lstat(&s->ctx, &path, &stat)) { error_setg(errp, ""share path %s does not exist"", fse->path); goto out; } else if (!S_ISDIR(stat.st_mode)) { error_setg(errp, ""share path %s is not a directory"", fse->path); goto out; } v9fs_path_free(&path); rc = 0; out: if (rc) { g_free(s->tag); g_free(s->ctx.fs_root); v9fs_path_free(&path); } return rc; }
Description: Memory leak in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local privileged guest OS users to cause a denial of service (host memory consumption and possibly QEMU process crash) by leveraging a missing cleanup operation in FileOperations.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int64_t BZ2File::readImpl(char * buf, int64_t length) { if (length == 0) { return 0; } assertx(m_bzFile); int len = BZ2_bzread(m_bzFile, buf, length); if (len <= 0) { setEof(true); if (len < 0) { return -1; } } return len; }
Description: The implementations of streams for bz2 and php://output improperly implemented their readImpl functions, returning -1 consistently. This behavior caused some stream functions, such as stream_get_line, to trigger an out-of-bounds read when operating on such malformed streams. The implementations were updated to return valid values consistently. This affects all supported versions of HHVM (3.30 and 3.27.4 and below).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: GPLOT * gplotRead(const char  *filename) { char     buf[L_BUF_SIZE]; char    *rootname, *title, *xlabel, *ylabel, *ignores; l_int32  outformat, ret, version, ignore; FILE    *fp; GPLOT   *gplot; PROCNAME(""gplotRead""); if (!filename) return (GPLOT *)ERROR_PTR(""filename not defined"", procName, NULL); if ((fp = fopenReadStream(filename)) == NULL) return (GPLOT *)ERROR_PTR(""stream not opened"", procName, NULL); ret = fscanf(fp, ""Gplot Version %d\n"", &version); if (ret != 1) { fclose(fp); return (GPLOT *)ERROR_PTR(""not a gplot file"", procName, NULL); } if (version != GPLOT_VERSION_NUMBER) { fclose(fp); return (GPLOT *)ERROR_PTR(""invalid gplot version"", procName, NULL); } ignore = fscanf(fp, ""Rootname: %s\n"", buf); rootname = stringNew(buf); ignore = fscanf(fp, ""Output format: %d\n"", &outformat); ignores = fgets(buf, L_BUF_SIZE, fp);    title = stringNew(buf + 7); title[strlen(title) - 1] = '\0'; ignores = fgets(buf, L_BUF_SIZE, fp);    xlabel = stringNew(buf + 14); xlabel[strlen(xlabel) - 1] = '\0'; ignores = fgets(buf, L_BUF_SIZE, fp);    ylabel = stringNew(buf + 14); ylabel[strlen(ylabel) - 1] = '\0'; gplot = gplotCreate(rootname, outformat, title, xlabel, ylabel); LEPT_FREE(rootname); LEPT_FREE(title); LEPT_FREE(xlabel); LEPT_FREE(ylabel); if (!gplot) { fclose(fp); return (GPLOT *)ERROR_PTR(""gplot not made"", procName, NULL); } sarrayDestroy(&gplot->cmddata); sarrayDestroy(&gplot->datanames); sarrayDestroy(&gplot->plotdata); sarrayDestroy(&gplot->plottitles); numaDestroy(&gplot->plotstyles); ignore = fscanf(fp, ""Commandfile name: %s\n"", buf); stringReplace(&gplot->cmdname, buf); ignore = fscanf(fp, ""\nCommandfile data:""); gplot->cmddata = sarrayReadStream(fp); ignore = fscanf(fp, ""\nDatafile names:""); gplot->datanames = sarrayReadStream(fp); ignore = fscanf(fp, ""\nPlot data:""); gplot->plotdata = sarrayReadStream(fp); ignore = fscanf(fp, ""\nPlot titles:""); gplot->plottitles = sarrayReadStream(fp); ignore = fscanf(fp, ""\nPlot styles:""); gplot->plotstyles = numaReadStream(fp); ignore = fscanf(fp, ""Number of plots: %d\n"", &gplot->nplots); ignore = fscanf(fp, ""Output file name: %s\n"", buf); stringReplace(&gplot->outname, buf); ignore = fscanf(fp, ""Axis scaling: %d\n"", &gplot->scaling); fclose(fp); return gplot; }
Description: Leptonica before 1.75.3 does not limit the number of characters in a %s format argument to fscanf or sscanf, which allows remote attackers to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact via a long string, as demonstrated by the gplotRead and ptaReadStream functions.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void conversation_set_addr2(conversation_t *conv, const address *addr) { char* addr_str; DISSECTOR_ASSERT_HINT(!(conv->options & CONVERSATION_TEMPLATE), ""Use the conversation_create_from_template function when the CONVERSATION_TEMPLATE bit is set in the options mask""); addr_str = address_to_str(NULL, addr); DPRINT((""called for addr=%s"", addr_str)); wmem_free(NULL, addr_str); if (!(conv->options & NO_ADDR2)) return; DINDENT(); if (conv->options & NO_PORT2) { conversation_remove_from_hashtable(conversation_hashtable_no_addr2_or_port2, conv); } else { conversation_remove_from_hashtable(conversation_hashtable_no_port2, conv); } conv->options &= ~NO_ADDR2; wmem_map_t *hashtable; if (conv->options & NO_PORT2) { conv->key_ptr[ENDP_NO_PORT2_IDX] = conv->key_ptr[ENDP_NO_ADDR2_PORT2_IDX]; hashtable = conversation_hashtable_no_port2; } else { conv->key_ptr[ENDP_EXACT_IDX] = conv->key_ptr[ENDP_NO_ADDR2_IDX]; conv->key_ptr[PORT2_IDX] = conv->key_ptr[PORT2_NO_ADDR2_IDX]; hashtable = conversation_hashtable_exact_addr_port; } conv->key_ptr[ADDR2_IDX].type = CE_ADDRESS; copy_address_wmem(wmem_file_scope(), &conv->key_ptr[ADDR2_IDX].addr_val, addr); conversation_insert_into_hashtable(hashtable, conv); DENDENT(); }
Description: Dissection engine bug in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void appendCommand(client *c) { size_t totlen; robj *o, *append; o = lookupKeyWrite(c->db,c->argv[1]); if (o == NULL) { c->argv[2] = tryObjectEncoding(c->argv[2]); dbAdd(c->db,c->argv[1],c->argv[2]); incrRefCount(c->argv[2]); totlen = stringObjectLen(c->argv[2]); } else { if (checkType(c,o,OBJ_STRING)) return; append = c->argv[2]; totlen = stringObjectLen(o)+sdslen(append->ptr); if (checkStringLength(c,totlen) != C_OK) return; o = dbUnshareStringValue(c->db,c->argv[1],o); o->ptr = sdscatlen(o->ptr,append->ptr,sdslen(append->ptr)); totlen = sdslen(o->ptr); } signalModifiedKey(c,c->db,c->argv[1]); notifyKeyspaceEvent(NOTIFY_STRING,""append"",c->argv[1],c->db->id); server.dirty++; addReplyLongLong(c,totlen); }
Description: Redis is an in-memory database that persists on disk. Authenticated users issuing specially crafted `SETRANGE` and `SORT(_RO)` commands can trigger an integer overflow, resulting with Redis attempting to allocate impossible amounts of memory and abort with an out-of-memory (OOM) panic. The problem is fixed in Redis versions 7.0.8, 6.2.9 and 6.0.17. Users are advised to upgrade. There are no known workarounds for this vulnerability.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int append_key_value(smart_str* loc_name, HashTable* hash_arr, char* key_name) { zval**ele_value= NULL; if(zend_hash_find(hash_arr , key_name , strlen(key_name) + 1 ,(void **)&ele_value ) == SUCCESS ) { if(Z_TYPE_PP(ele_value)!= IS_STRING ){ return FAILURE; } if(strcmp(key_name, LOC_LANG_TAG) != 0 &&  strcmp(key_name, LOC_GRANDFATHERED_LANG_TAG)!=0 ) { smart_str_appendl(loc_name, SEPARATOR , sizeof(SEPARATOR)-1); } smart_str_appendl(loc_name, Z_STRVAL_PP(ele_value) , Z_STRLEN_PP(ele_value)); return SUCCESS; } return LOC_NOT_FOUND; }
Description: The get_icu_value_internal function in ext/intl/locale/locale_methods.c in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7 does not ensure the presence of a '\0' character, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted locale_get_primary_language call.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: unsigned int GetU32LE (int nPos, bool *pbSuccess) { if ( nPos < 0 || nPos + 3 >= m_nLen ) { *pbSuccess = false; return 0; } unsigned int nRes = m_sFile[nPos + 3]; nRes = (nRes << 8) + m_sFile[nPos + 2]; nRes = (nRes << 8) + m_sFile[nPos + 1]; nRes = (nRes << 8) + m_sFile[nPos + 0]; return nRes; }
Description: Onlyoffice Document Server v6.0.0 and below and Core 6.1.0.26 and below were discovered to contain a heap overflow via the component DesktopEditor/fontengine/fontconverter/FontFileBase.h.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static Image *ReadWEBPImage(const ImageInfo *image_info, ExceptionInfo *exception) { Image *image; int webp_status; MagickBooleanType status; register unsigned char *p; size_t length; ssize_t count, y; unsigned char header[12], *stream; WebPDecoderConfig configure; WebPDecBuffer *magick_restrict webp_image = &configure.output; WebPBitstreamFeatures *magick_restrict features = &configure.input; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickSignature); image=AcquireImage(image_info); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } if (WebPInitDecoderConfig(&configure) == 0) ThrowReaderException(ResourceLimitError,""UnableToDecodeImageFile""); webp_image->colorspace=MODE_RGBA; count=ReadBlob(image,12,header); if (count != 12) ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile""); status=IsWEBP(header,count); if (status == MagickFalse) ThrowReaderException(CorruptImageError,""CorruptImage""); length=(size_t) (ReadWebPLSBWord(header+4)+8); if (length < 12) ThrowReaderException(CorruptImageError,""CorruptImage""); stream=(unsigned char *) AcquireQuantumMemory(length,sizeof(*stream)); if (stream == (unsigned char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); (void) memcpy(stream,header,12); count=ReadBlob(image,length-12,stream+12); if (count != (ssize_t) (length-12)) ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile""); webp_status=WebPGetFeatures(stream,length,features); if (webp_status == VP8_STATUS_OK) { image->columns=(size_t) features->width; image->rows=(size_t) features->height; image->depth=8; image->matte=features->has_alpha != 0 ? MagickTrue : MagickFalse; if (IsWEBPImageLossless(stream,length) != MagickFalse) image->quality=100; if (image_info->ping != MagickFalse) { stream=(unsigned char*) RelinquishMagickMemory(stream); (void) CloseBlob(image); return(GetFirstImageInList(image)); } status=SetImageExtent(image,image->columns,image->rows); if (status == MagickFalse) { InheritException(exception,&image->exception); return(DestroyImageList(image)); } webp_status=WebPDecode(stream,length,&configure); } if (webp_status != VP8_STATUS_OK) { stream=(unsigned char*) RelinquishMagickMemory(stream); switch (webp_status) { case VP8_STATUS_OUT_OF_MEMORY: { ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); break; } case VP8_STATUS_INVALID_PARAM: { ThrowReaderException(CorruptImageError,""invalid parameter""); break; } case VP8_STATUS_BITSTREAM_ERROR: { ThrowReaderException(CorruptImageError,""CorruptImage""); break; } case VP8_STATUS_UNSUPPORTED_FEATURE: { ThrowReaderException(CoderError,""DataEncodingSchemeIsNotSupported""); break; } case VP8_STATUS_SUSPENDED: { ThrowReaderException(CorruptImageError,""decoder suspended""); break; } case VP8_STATUS_USER_ABORT: { ThrowReaderException(CorruptImageError,""user abort""); break; } case VP8_STATUS_NOT_ENOUGH_DATA: { ThrowReaderException(CorruptImageError,""InsufficientImageDataInFile""); break; } default: ThrowReaderException(CorruptImageError,""CorruptImage""); } } p=(unsigned char *) webp_image->u.RGBA.rgba; for (y=0; y < (ssize_t) image->rows; y++) { register PixelPacket *q; register ssize_t x; q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (PixelPacket *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { SetPixelRed(q,ScaleCharToQuantum(*p++)); SetPixelGreen(q,ScaleCharToQuantum(*p++)); SetPixelBlue(q,ScaleCharToQuantum(*p++)); SetPixelAlpha(q,ScaleCharToQuantum(*p++)); q++; } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } WebPFreeDecBuffer(webp_image); stream=(unsigned char*) RelinquishMagickMemory(stream); return(image); }
Description: An issue was discovered in ImageMagick 6.9.7. A specially crafted webp file could lead to a file-descriptor leak in libmagickcore (thus, a DoS).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int main(int argc, char** argv) { GOOGLE_PROTOBUF_VERIFY_VERSION; srand(1); cxxopts::Options options(""htm"", ""Headless terminal multiplexer""); options.allow_unrecognised_options(); options.add_options()             (""help"", ""Print help"")        (""x,kill-other-sessions"", ""kill all old sessions belonging to the user"")        ; auto result = options.parse(argc, argv); if (result.count(""help"")) { CLOG(INFO, ""stdout"") << options.help({}) << endl; exit(0); } setvbuf(stdin, NULL, _IONBF, 0);     setvbuf(stdout, NULL, _IONBF, 0);   termios terminal_local; tcgetattr(0, &terminal_local); memcpy(&terminal_backup, &terminal_local, sizeof(struct termios)); cfmakeraw(&terminal_local); tcsetattr(0, TCSANOW, &terminal_local); struct sigaction action; memset(&action, 0, sizeof(struct sigaction)); action.sa_handler = term; sigaction(SIGTERM, &action, NULL); el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv); defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, ""false""); el::Loggers::setVerboseLevel(3); string maxlogsize = ""20971520""; LogHandler::setupLogFile(&defaultConf, GetTempDirectory() + ""htm.log"", maxlogsize); LogHandler::stderrToFile(GetTempDirectory() + ""htm""); el::Loggers::reconfigureLogger(""default"", defaultConf); et::HandleTerminate(); ::signal(SIGINT, et::InterruptSignalHandler); uid_t myuid = getuid(); if (result.count(""x"")) { LOG(INFO) << ""Killing previous htmd""; string command = string(""pkill -x -U "") + to_string(myuid) + string("" htmd""); system(command.c_str()); } string command = string(""pgrep -x -U "") + to_string(myuid) + string("" htmd""); string pgrepOutput = SystemToStr(command.c_str()); if (pgrepOutput.length() == 0) { int result = DaemonCreator::create(false, """"); if (result == DaemonCreator::CHILD) { exit(system(""htmd"")); } } std::this_thread::sleep_for(std::chrono::microseconds( 10 * 1000));    shared_ptr<SocketHandler> socketHandler(new PipeSocketHandler()); SocketEndpoint pipeEndpoint; pipeEndpoint.set_name(HtmServer::getPipeName()); HtmClient htmClient(socketHandler, pipeEndpoint); htmClient.run(); char buf[] = { 0x1b, 0x5b, '$', '$', '$', 'q', }; RawSocketUtils::writeAll(STDOUT_FILENO, buf, sizeof(buf)); fflush(stdout); tcsetattr(0, TCSANOW, &terminal_backup); return 0; }
Description: In Eternal Terminal 6.2.1, etserver and etclient have predictable logfile names in /tmp.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int vmnc_handle_packet (GstVMncDec * dec, const guint8 * data, int len, gboolean decode) { int type; int offset = 0; if (len < 4) { GST_LOG_OBJECT (dec, ""Packet too short""); return ERROR_INSUFFICIENT_DATA; } type = data[0]; switch (type) { case 0: { int numrect = RFB_GET_UINT16 (data + 2); int i; int read; offset = 4; for (i = 0; i < numrect; i++) { struct RfbRectangle r; rectangle_handler handler; if (len < offset + 12) { GST_LOG_OBJECT (dec, ""Packet too short for rectangle header: %d < %d"", len, offset + 12); return ERROR_INSUFFICIENT_DATA; } GST_LOG_OBJECT (dec, ""Reading rectangle %d"", i); r.x = RFB_GET_UINT16 (data + offset); r.y = RFB_GET_UINT16 (data + offset + 2); r.width = RFB_GET_UINT16 (data + offset + 4); r.height = RFB_GET_UINT16 (data + offset + 6); r.type = RFB_GET_UINT32 (data + offset + 8); if (r.type != TYPE_WMVi) { if (!dec->have_format) { GST_WARNING_OBJECT (dec, ""Received packet without WMVi: %d"", r.type); return ERROR_INVALID; } if (r.x + r.width > dec->format.width || r.y + r.height > dec->format.height) { GST_WARNING_OBJECT (dec, ""Rectangle out of range, type %d"", r.type); return ERROR_INVALID; } } switch (r.type) { case TYPE_WMVd: handler = vmnc_handle_wmvd_rectangle; break; case TYPE_WMVe: handler = vmnc_handle_wmve_rectangle; break; case TYPE_WMVf: handler = vmnc_handle_wmvf_rectangle; break; case TYPE_WMVg: handler = vmnc_handle_wmvg_rectangle; break; case TYPE_WMVh: handler = vmnc_handle_wmvh_rectangle; break; case TYPE_WMVi: handler = vmnc_handle_wmvi_rectangle; break; case TYPE_WMVj: handler = vmnc_handle_wmvj_rectangle; break; case TYPE_RAW: handler = vmnc_handle_raw_rectangle; break; case TYPE_COPY: handler = vmnc_handle_copy_rectangle; break; case TYPE_HEXTILE: handler = vmnc_handle_hextile_rectangle; break; default: GST_WARNING_OBJECT (dec, ""Unknown rectangle type""); return ERROR_INVALID; } read = handler (dec, &r, data + offset + 12, len - offset - 12, decode); if (read < 0) { GST_DEBUG_OBJECT (dec, ""Error calling rectangle handler\n""); return read; } offset += 12 + read; } break; } default: GST_WARNING_OBJECT (dec, ""Packet type unknown: %d"", type); return ERROR_INVALID; } return offset; }
Description: Integer overflow in the vmnc decoder in the gstreamer allows remote attackers to cause a denial of service (crash) via large width and height values, which triggers a buffer overflow.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void dump_irqs(unsigned char key) { int i, irq, pirq; struct irq_desc *desc; irq_guest_action_t *action; struct evtchn *evtchn; struct domain *d; const struct pirq *info; unsigned long flags; char *ssid; printk(""IRQ information:\n""); for ( irq = 0; irq < nr_irqs; irq++ ) { if ( !(irq & 0x1f) ) process_pending_softirqs(); desc = irq_to_desc(irq); if ( !irq_desc_initialized(desc) || desc->handler == &no_irq_type ) continue; ssid = in_irq() ? NULL : xsm_show_irq_sid(irq); spin_lock_irqsave(&desc->lock, flags); cpumask_scnprintf(keyhandler_scratch, sizeof(keyhandler_scratch), desc->affinity); printk(""   IRQ:%4d affinity:%s vec:%02x type=%-15s"" "" status=%08x "", irq, keyhandler_scratch, desc->arch.vector, desc->handler->typename, desc->status); if ( ssid ) printk(""Z=%-25s "", ssid); if ( desc->status & IRQ_GUEST ) { action = (irq_guest_action_t *)desc->action; printk(""in-flight=%d domain-list="", action->in_flight); for ( i = 0; i < action->nr_guests; i++ ) { d = action->guest[i]; pirq = domain_irq_to_pirq(d, irq); info = pirq_info(d, pirq); evtchn = evtchn_from_port(d, info->evtchn); printk(""%u:%3d(%c%c%c)"", d->domain_id, pirq, (evtchn_port_is_pending(d, evtchn) ? 'P' : '-'), (evtchn_port_is_masked(d, evtchn) ? 'M' : '-'), (info->masked ? 'M' : '-')); if ( i != action->nr_guests ) printk("",""); } printk(""\n""); } else if ( desc->action ) printk(""%ps()\n"", desc->action->handler); else printk(""mapped, unbound\n""); spin_unlock_irqrestore(&desc->lock, flags); xfree(ssid); } process_pending_softirqs(); printk(""Direct vector information:\n""); for ( i = FIRST_DYNAMIC_VECTOR; i < NR_VECTORS; ++i ) if ( direct_apic_vector[i] ) printk(""   %#02x -> %ps()\n"", i, direct_apic_vector[i]); dump_ioapic_irq_info(); }
Description: Xen through 4.8.x does not validate the port numbers of polled event channel ports, which allows guest OS users to cause a denial of service (NULL pointer dereference and host OS crash) or possibly obtain sensitive information, aka XSA-221.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int wl_map_insert_at(struct wl_map *map, uint32_t flags, uint32_t i, void *data) { union map_entry *start; uint32_t count; struct wl_array *entries; if (i < WL_SERVER_ID_START) { entries = &map->client_entries; } else { entries = &map->server_entries; i -= WL_SERVER_ID_START; } count = entries->size / sizeof *start; if (count < i) { errno = EINVAL; return -1; } if (count == i) { if (!wl_array_add(entries, sizeof *start)) return -1; } start = entries->data; start[i].data = data; start[i].next |= (flags & 0x1) << 1; return 0; }
Description: An internal reference count is held on the buffer pool, incremented every time a new buffer is created from the pool. The reference count is maintained as an int; on LP64 systems this can cause the reference count to overflow if the client creates a large number of wl_shm buffer objects, or if it can coerce the server to create a large number of external references to the buffer storage. With the reference count overflowing, a use-after-free can be constructed on the wl_shm_pool tracking structure, where values may be incremented or decremented; it may also be possible to construct a limited oracle to leak 4 bytes of server-side memory to the attacking client at a time.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static bool set_reg_profile(RAnal *anal) { const char *p = ""=PCpc\n"" ""=SPr14\n"" ""=BPsrp\n"" ""=A0r0\n"" ""=A1r1\n"" ""=A2r2\n"" ""=A3r3\n"" ""gprsp.32560\n"" ""gpracr.32600\n"" ""gprpc.32640\n"" ""gprsrp.32680\n"" ""gprr0.3200\n"" ""gprr1.3240\n"" ""gprr2.3280\n"" ""gprr3.32120\n"" ""gprr4.32160\n"" ""gprr5.32200\n"" ""gprr6.32240\n"" ""gprr7.32280\n"" ""gprr8.32320\n"" ""gprr9.32360\n"" ""gprr10.32400\n"" ""gprr11.32440\n"" ""gprr12.32480\n"" ""gprr13.32520\n"" ""gprr14.32560\n"" ""gprr15.32600\n"" ; return r_reg_set_profile_string (anal->reg, p); }
Description: Out-of-bounds read in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability allows attackers to read sensitive information from outside the allocated buffer boundary.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: std::string queueloader::get_filename(const std::string& str) { std::string fn = ctrl->get_dlpath(); if (fn[fn.length()-1] != NEWSBEUTER_PATH_SEP[0]) fn.append(NEWSBEUTER_PATH_SEP); char buf[1024]; snprintf(buf, sizeof(buf), ""%s"", str.c_str()); char * base = basename(buf); if (!base || strlen(base) == 0) { char lbuf[128]; time_t t = time(NULL); strftime(lbuf, sizeof(lbuf), ""%Y-%b-%d-%H%M%S.unknown"", localtime(&t)); fn.append(lbuf); } else { fn.append(base); } return fn; }
Description: Improper Neutralization of Special Elements used in an OS Command in the podcast playback function of Podbeuter in Newsbeuter 0.3 through 2.9 allows remote attackers to perform user-assisted code execution by crafting an RSS item with a media enclosure (i.e., a podcast file) that includes shell metacharacters in its filename, related to pb_controller.cpp and queueloader.cpp, a different vulnerability than CVE-2017-12904.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int decompress_i(AVCodecContext *avctx, uint32_t *dst, int linesize) { SCPRContext *s = avctx->priv_data; GetByteContext *gb = &s->gb; int cx = 0, cx1 = 0, k = 0, clr = 0; int run, r, g, b, off, y = 0, x = 0, z, ret; unsigned backstep = linesize - avctx->width; const int cxshift = s->cxshift; unsigned lx, ly, ptype; reinit_tables(s); bytestream2_skip(gb, 2); init_rangecoder(&s->rc, gb); while (k < avctx->width + 1) { ret = decode_unit(s, &s->pixel_model[0][cx + cx1], 400, &r); if (ret < 0) return ret; cx1 = (cx << 6) & 0xFC0; cx = r >> cxshift; ret = decode_unit(s, &s->pixel_model[1][cx + cx1], 400, &g); if (ret < 0) return ret; cx1 = (cx << 6) & 0xFC0; cx = g >> cxshift; ret = decode_unit(s, &s->pixel_model[2][cx + cx1], 400, &b); if (ret < 0) return ret; cx1 = (cx << 6) & 0xFC0; cx = b >> cxshift; ret = decode_value(s, s->run_model[0], 256, 400, &run); if (ret < 0) return ret; clr = (b << 16) + (g << 8) + r; k += run; while (run-- > 0) { dst[y * linesize + x] = clr; lx = x; ly = y; x++; if (x >= avctx->width) { x = 0; y++; } } } off = -linesize - 1; ptype = 0; while (x < avctx->width && y < avctx->height) { ret = decode_value(s, s->op_model[ptype], 6, 1000, &ptype); if (ret < 0) return ret; if (ptype == 0) { ret = decode_unit(s, &s->pixel_model[0][cx + cx1], 400, &r); if (ret < 0) return ret; cx1 = (cx << 6) & 0xFC0; cx = r >> cxshift; ret = decode_unit(s, &s->pixel_model[1][cx + cx1], 400, &g); if (ret < 0) return ret; cx1 = (cx << 6) & 0xFC0; cx = g >> cxshift; ret = decode_unit(s, &s->pixel_model[2][cx + cx1], 400, &b); if (ret < 0) return ret; clr = (b << 16) + (g << 8) + r; } if (ptype > 5) return AVERROR_INVALIDDATA; ret = decode_value(s, s->run_model[ptype], 256, 400, &run); if (ret < 0) return ret; switch (ptype) { case 0: while (run-- > 0) { if (y >= avctx->height) return AVERROR_INVALIDDATA; dst[y * linesize + x] = clr; lx = x; ly = y; x++; if (x >= avctx->width) { x = 0; y++; } } break; case 1: while (run-- > 0) { if (y >= avctx->height) return AVERROR_INVALIDDATA; dst[y * linesize + x] = dst[ly * linesize + lx]; lx = x; ly = y; x++; if (x >= avctx->width) { x = 0; y++; } } clr = dst[ly * linesize + lx]; break; case 2: while (run-- > 0) { if (y < 1 || y >= avctx->height) return AVERROR_INVALIDDATA; clr = dst[y * linesize + x + off + 1]; dst[y * linesize + x] = clr; lx = x; ly = y; x++; if (x >= avctx->width) { x = 0; y++; } } break; case 4: while (run-- > 0) { uint8_t *odst = (uint8_t *)dst; if (y < 1 || y >= avctx->height || (y == 1 && x == 0)) return AVERROR_INVALIDDATA; if (x == 0) { z = backstep; } else { z = 0; } r = odst[(ly * linesize + lx) * 4] + odst[((y * linesize + x) + off - z) * 4 + 4] - odst[((y * linesize + x) + off - z) * 4]; g = odst[(ly * linesize + lx) * 4 + 1] + odst[((y * linesize + x) + off - z) * 4 + 5] - odst[((y * linesize + x) + off - z) * 4 + 1]; b = odst[(ly * linesize + lx) * 4 + 2] + odst[((y * linesize + x) + off - z) * 4 + 6] - odst[((y * linesize + x) + off - z) * 4 + 2]; clr = ((b & 0xFF) << 16) + ((g & 0xFF) << 8) + (r & 0xFF); dst[y * linesize + x] = clr; lx = x; ly = y; x++; if (x >= avctx->width) { x = 0; y++; } } break; case 5: while (run-- > 0) { if (y < 1 || y >= avctx->height || (y == 1 && x == 0)) return AVERROR_INVALIDDATA; if (x == 0) { z = backstep; } else { z = 0; } clr = dst[y * linesize + x + off - z]; dst[y * linesize + x] = clr; lx = x; ly = y; x++; if (x >= avctx->width) { x = 0; y++; } } break; } if (avctx->bits_per_coded_sample == 16) { cx1 = (clr & 0x3F00) >> 2; cx = (clr & 0xFFFFFF) >> 16; } else { cx1 = (clr & 0xFC00) >> 4; cx = (clr & 0xFFFFFF) >> 18; } } return 0; }
Description: libavcodec/scpr.c in FFmpeg 3.3 before 3.3.1 does not properly validate height and width data, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void PasswordGenerationAgent::FindPossibleGenerationForm() { if (!enabled_) return; if (!ShouldAnalyzeDocument()) return; if (generation_form_data_) return; blink::WebVector<blink::WebFormElement> forms; render_frame()->GetWebFrame()->document().forms(forms); for (size_t i = 0; i < forms.size(); ++i) { if (forms[i].isNull()) continue; std::unique_ptr<PasswordForm> password_form( CreatePasswordFormFromWebForm(forms[i], nullptr, nullptr)); if (!password_form.get()) { VLOG(2) << ""Skipping form as it would not be saved""; continue; } GURL realm(password_form->signon_realm); if (realm == GaiaUrls::GetInstance()->gaia_login_form_realm()) continue; std::vector<blink::WebInputElement> passwords; if (GetAccountCreationPasswordFields( form_util::ExtractAutofillableElementsInForm(forms[i]), &passwords)) { AccountCreationFormData ac_form_data( make_linked_ptr(password_form.release()), passwords); possible_account_creation_forms_.push_back(ac_form_data); } } if (!possible_account_creation_forms_.empty()) { VLOG(2) << possible_account_creation_forms_.size() << "" possible account creation forms deteceted""; DetermineGenerationElement(); } }
Description: The Autofill implementation in Google Chrome before 51.0.2704.63 mishandles the interaction between field updates and JavaScript code that triggers a frame deletion, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted web site, a different vulnerability than CVE-2016-1701.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: DevToolsWindow* DevToolsWindow::Create( Profile* profile, const GURL& frontend_url, content::WebContents* inspected_web_contents, bool shared_worker_frontend, const std::string& remote_frontend, bool can_dock, const std::string& settings) { if (profile->GetPrefs()->GetBoolean(prefs::kDevToolsDisabled) || base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kKioskMode)) return nullptr; if (inspected_web_contents) { Browser* browser = NULL; int tab; if (!FindInspectedBrowserAndTabIndex(inspected_web_contents, &browser, &tab) || browser->is_type_popup()) { can_dock = false; } } GURL url(GetDevToolsURL(profile, frontend_url, shared_worker_frontend, remote_frontend, can_dock, settings)); std::unique_ptr<WebContents> main_web_contents( WebContents::Create(WebContents::CreateParams(profile))); main_web_contents->GetController().LoadURL( DecorateFrontendURL(url), content::Referrer(), ui::PAGE_TRANSITION_AUTO_TOPLEVEL, std::string()); DevToolsUIBindings* bindings = DevToolsUIBindings::ForWebContents(main_web_contents.get()); if (!bindings) return nullptr; return new DevToolsWindow(profile, main_web_contents.release(), bindings, inspected_web_contents, can_dock); }
Description: Cross-site scripting (XSS) vulnerability in the Developer Tools (aka DevTools) subsystem in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux allows remote attackers to inject arbitrary web script or HTML via the settings parameter in a chrome-devtools-frontend.appspot.com URL's query string.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void SerializedScriptValueWriter::writeImageBitmap(uint32_t width, uint32_t height, const uint8_t* pixelData, uint32_t pixelDataLength) { append(ImageBitmapTag); doWriteImageData(width, height, pixelData, pixelDataLength); }
Description: Blink, as used in Google Chrome before 52.0.2743.116, does not ensure that a taint property is preserved after a structure-clone operation on an ImageBitmap object derived from a cross-origin image, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static Image *ReadLABELImage(const ImageInfo *image_info, ExceptionInfo *exception) { char geometry[MagickPathExtent], *property; const char *label; DrawInfo *draw_info; Image *image; MagickBooleanType status; TypeMetric metrics; size_t height, width; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); image=AcquireImage(image_info,exception); (void) ResetImagePage(image,""0x0+0+0""); property=InterpretImageProperties((ImageInfo *) image_info,image, image_info->filename,exception); (void) SetImageProperty(image,""label"",property,exception); property=DestroyString(property); label=GetImageProperty(image,""label"",exception); draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL); draw_info->text=ConstantString(label); metrics.width=0; metrics.ascent=0.0; status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception); if ((image->columns == 0) && (image->rows == 0)) { image->columns=(size_t) (metrics.width+draw_info->stroke_width+0.5); image->rows=(size_t) floor(metrics.height+draw_info->stroke_width+0.5); } else if (((image->columns == 0) || (image->rows == 0)) || (fabs(image_info->pointsize) < MagickEpsilon)) { double high, low; for ( ; ; draw_info->pointsize*=2.0) { (void) FormatLocaleString(geometry,MagickPathExtent,""%+g%+g"", -metrics.bounds.x1,metrics.ascent); if (draw_info->gravity == UndefinedGravity) (void) CloneString(&draw_info->geometry,geometry); status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception); width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5); height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5); if ((image->columns != 0) && (image->rows != 0)) { if ((width >= image->columns) && (height >= image->rows)) break; } else if (((image->columns != 0) && (width >= image->columns)) || ((image->rows != 0) && (height >= image->rows))) break; } high=draw_info->pointsize; for (low=1.0; (high-low) > 0.5; ) { draw_info->pointsize=(low+high)/2.0; (void) FormatLocaleString(geometry,MagickPathExtent,""%+g%+g"", -metrics.bounds.x1,metrics.ascent); if (draw_info->gravity == UndefinedGravity) (void) CloneString(&draw_info->geometry,geometry); status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception); width=(size_t) floor(metrics.width+draw_info->stroke_width+0.5); height=(size_t) floor(metrics.height+draw_info->stroke_width+0.5); if ((image->columns != 0) && (image->rows != 0)) { if ((width < image->columns) && (height < image->rows)) low=draw_info->pointsize+0.5; else high=draw_info->pointsize-0.5; } else if (((image->columns != 0) && (width < image->columns)) || ((image->rows != 0) && (height < image->rows))) low=draw_info->pointsize+0.5; else high=draw_info->pointsize-0.5; } draw_info->pointsize=(low+high)/2.0-0.5; } status=GetMultilineTypeMetrics(image,draw_info,&metrics,exception); if (status == MagickFalse) { draw_info=DestroyDrawInfo(draw_info); image=DestroyImageList(image); return((Image *) NULL); } if (image->columns == 0) image->columns=(size_t) (metrics.width+draw_info->stroke_width+0.5); if (image->columns == 0) image->columns=(size_t) (draw_info->pointsize+draw_info->stroke_width+0.5); if (image->rows == 0) image->rows=(size_t) (metrics.ascent-metrics.descent+ draw_info->stroke_width+0.5); if (image->rows == 0) image->rows=(size_t) (draw_info->pointsize+draw_info->stroke_width+0.5); status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) { draw_info=DestroyDrawInfo(draw_info); return(DestroyImageList(image)); } if (SetImageBackgroundColor(image,exception) == MagickFalse) { draw_info=DestroyDrawInfo(draw_info); image=DestroyImageList(image); return((Image *) NULL); } (void) FormatLocaleString(geometry,MagickPathExtent,""%+g%+g"", draw_info->direction == RightToLeftDirection ? image->columns- metrics.bounds.x2 : 0.0,draw_info->gravity == UndefinedGravity ? metrics.ascent : 0.0); draw_info->geometry=AcquireString(geometry); status=AnnotateImage(image,draw_info,exception); if (image_info->pointsize == 0.0) { char pointsize[MagickPathExtent]; (void) FormatLocaleString(pointsize,MagickPathExtent,""%.20g"", draw_info->pointsize); (void) SetImageProperty(image,""label:pointsize"",pointsize,exception); } draw_info=DestroyDrawInfo(draw_info); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } return(GetFirstImageInList(image)); }
Description: Buffer overflow in the ReadVIFFImage function in coders/viff.c in ImageMagick before 6.9.4-5 allows remote attackers to cause a denial of service (application crash) via a crafted file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: struct vm_area_struct * find_extend_vma(struct mm_struct *mm, unsigned long addr) { struct vm_area_struct *vma, *prev; addr &= PAGE_MASK; vma = find_vma_prev(mm, addr, &prev); if (vma && (vma->vm_start <= addr)) return vma; if (!prev || expand_stack(prev, addr)) return NULL; if (prev->vm_flags & VM_LOCKED) populate_vma_page_range(prev, addr, prev->vm_end, NULL); return prev; }
Description: The coredump implementation in the Linux kernel before 5.0.10 does not use locking or other mechanisms to prevent vma layout or vma flags changes while it runs, which allows local users to obtain sensitive information, cause a denial of service, or possibly have unspecified other impact by triggering a race condition with mmget_not_zero or get_task_mm calls. This is related to fs/userfaultfd.c, mm/mmap.c, fs/proc/task_mmu.c, and drivers/infiniband/core/uverbs_main.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: char_u  * vim_strchr(char_u *string, int c) { char_u*p; intb; p = string; if (enc_utf8 && c >= 0x80) { while (*p != NUL) { int l = utfc_ptr2len(p); if (utf_ptr2char(p) == c && l > 1) return p; p += l; } return NULL; } if (enc_dbcs != 0 && c > 255) { intn2 = c & 0xff; c = ((unsigned)c >> 8) & 0xff; while ((b = *p) != NUL) { if (b == c && p[1] == n2) return p; p += (*mb_ptr2len)(p); } return NULL; } if (has_mbyte) { while ((b = *p) != NUL) { if (b == c) return p; p += (*mb_ptr2len)(p); } return NULL; } while ((b = *p) != NUL) { if (b == c) return p; ++p; } return NULL; }
Description: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1144.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int assign_cfs_rq_runtime(struct cfs_rq *cfs_rq) { struct task_group *tg = cfs_rq->tg; struct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(tg); u64 amount = 0, min_amount, expires; int expires_seq; min_amount = sched_cfs_bandwidth_slice() - cfs_rq->runtime_remaining; raw_spin_lock(&cfs_b->lock); if (cfs_b->quota == RUNTIME_INF) amount = min_amount; else { start_cfs_bandwidth(cfs_b); if (cfs_b->runtime > 0) { amount = min(cfs_b->runtime, min_amount); cfs_b->runtime -= amount; cfs_b->idle = 0; } } expires_seq = cfs_b->expires_seq; expires = cfs_b->runtime_expires; raw_spin_unlock(&cfs_b->lock); cfs_rq->runtime_remaining += amount; if (cfs_rq->expires_seq != expires_seq) { cfs_rq->expires_seq = expires_seq; cfs_rq->runtime_expires = expires; } return cfs_rq->runtime_remaining > 0; }
Description: kernel/sched/fair.c in the Linux kernel before 5.3.9, when cpu.cfs_quota_us is used (e.g., with Kubernetes), allows attackers to cause a denial of service against non-cpu-bound applications by generating a workload that triggers unwanted slice expiration, aka CID-de53fd7aedb1. (In other words, although this slice expiration would typically be seen with benign workloads, it is possible that an attacker could calculate how many stray requests are required to force an entire Kubernetes cluster into a low-performance state caused by slice expiration, and ensure that a DDoS attack sent that number of stray requests. An attack does not affect the stability of the kernel; it only causes mismanagement of application execution.)
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: DRWAV_API drwav_uint32 drwav_bytes_to_u32(const drwav_uint8* data) { return (data[0] << 0) | (data[1] << 8) | (data[2] << 16) | (data[3] << 24); }
Description: Miniaudio 0.10.35 has an integer-based buffer overflow caused by an out-of-bounds left shift in drwav_bytes_to_u32 in miniaudio.h
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool AES_GCM_EncryptContext::Encrypt( const void *pPlaintextData, size_t cbPlaintextData, const void *pIV, void *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag, const void *pAdditionalAuthenticationData, size_t cbAuthenticationData ) { unsigned long long pcbEncryptedDataAndTag_longlong = *pcbEncryptedDataAndTag; crypto_aead_aes256gcm_encrypt_afternm( static_cast<unsigned char*>( pEncryptedDataAndTag ), &pcbEncryptedDataAndTag_longlong, static_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData, static_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData, nullptr, static_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx ) ); *pcbEncryptedDataAndTag = pcbEncryptedDataAndTag_longlong; return true; }
Description: Valve's Game Networking Sockets prior to version v1.2.0 improperly handles long encrypted messages in function AES_GCM_DecryptContext::Decrypt() when compiled using libsodium, leading to a Stack-Based Buffer Overflow and resulting in a memory corruption and possibly even a remote code execution.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: PIX * pixBlockconvGrayUnnormalized(PIX     *pixs, l_int32  wc, l_int32  hc) { l_int32    i, j, w, h, d, wpla, wpld, jmax; l_uint32  *linemina, *linemaxa, *lined, *dataa, *datad; PIX       *pixsb, *pixacc, *pixd; PROCNAME(""pixBlockconvGrayUnnormalized""); if (!pixs) return (PIX *)ERROR_PTR(""pixs not defined"", procName, NULL); pixGetDimensions(pixs, &w, &h, &d); if (d != 8) return (PIX *)ERROR_PTR(""pixs not 8 bpp"", procName, NULL); if (wc < 0) wc = 0; if (hc < 0) hc = 0; if (w < 2 * wc + 1 || h < 2 * hc + 1) { wc = L_MIN(wc, (w - 1) / 2); hc = L_MIN(hc, (h - 1) / 2); L_WARNING(""kernel too large; reducing!\n"", procName); L_INFO(""wc = %d, hc = %d\n"", procName, wc, hc); } if (wc == 0 && hc == 0)    return pixCopy(NULL, pixs); if ((pixsb = pixAddMirroredBorder(pixs, wc + 1, wc, hc + 1, hc)) == NULL) return (PIX *)ERROR_PTR(""pixsb not made"", procName, NULL); pixacc = pixBlockconvAccum(pixsb); pixDestroy(&pixsb); if (!pixacc) return (PIX *)ERROR_PTR(""pixacc not made"", procName, NULL); if ((pixd = pixCreate(w, h, 32)) == NULL) { pixDestroy(&pixacc); return (PIX *)ERROR_PTR(""pixd not made"", procName, NULL); } wpla = pixGetWpl(pixacc); wpld = pixGetWpl(pixd); datad = pixGetData(pixd); dataa = pixGetData(pixacc); for (i = 0; i < h; i++) { lined = datad + i * wpld; linemina = dataa + i * wpla; linemaxa = dataa + (i + 2 * hc + 1) * wpla; for (j = 0; j < w; j++) { jmax = j + 2 * wc + 1; lined[j] = linemaxa[jmax] - linemaxa[j] - linemina[jmax] + linemina[j]; } } pixDestroy(&pixacc); return pixd; }
Description: An issue in the Leptonica linked library (v1.79.0) allows attackers to cause an arithmetic exception leading to a Denial of Service (DoS) via a crafted JPEG file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int hvm_load_segment_selector( enum x86_segment seg, uint16_t sel) { struct segment_register desctab, cs, segr; struct desc_struct *pdesc, desc; u8 dpl, rpl, cpl; bool_t writable; int fault_type = TRAP_invalid_tss; struct cpu_user_regs *regs = guest_cpu_user_regs(); struct vcpu *v = current; if ( regs->eflags & X86_EFLAGS_VM ) { segr.sel = sel; segr.base = (uint32_t)sel << 4; segr.limit = 0xffffu; segr.attr.bytes = 0xf3; hvm_set_segment_register(v, seg, &segr); return 0; } if ( (sel & 0xfffc) == 0 ) { if ( (seg == x86_seg_cs) || (seg == x86_seg_ss) ) goto fail; memset(&segr, 0, sizeof(segr)); segr.sel = sel; hvm_set_segment_register(v, seg, &segr); return 0; } if ( (seg == x86_seg_ldtr) && (sel & 4) ) goto fail; hvm_get_segment_register(v, x86_seg_cs, &cs); hvm_get_segment_register( v, (sel & 4) ? x86_seg_ldtr : x86_seg_gdtr, &desctab); if ( ((sel & 0xfff8) + 7) > desctab.limit ) goto fail; pdesc = hvm_map_entry(desctab.base + (sel & 0xfff8), &writable); if ( pdesc == NULL ) goto hvm_map_fail; do { desc = *pdesc; if ( (desc.b & (1u<<12)) == ((seg == x86_seg_ldtr) << 12) ) goto unmap_and_fail; dpl = (desc.b >> 13) & 3; rpl = sel & 3; cpl = cs.sel & 3; switch ( seg ) { case x86_seg_cs: if ( !(desc.b & _SEGMENT_CODE) ) goto unmap_and_fail; if ( !(desc.b & _SEGMENT_EC) && (dpl != rpl) ) goto unmap_and_fail; break; case x86_seg_ss: if ( (desc.b & (_SEGMENT_CODE|_SEGMENT_WR)) != _SEGMENT_WR ) goto unmap_and_fail; if ( (dpl != cpl) || (dpl != rpl) ) goto unmap_and_fail; break; case x86_seg_ldtr: if ( (desc.b & _SEGMENT_TYPE) != (2u<<8) ) goto unmap_and_fail; goto skip_accessed_flag; default: if ( (desc.b & (_SEGMENT_CODE|_SEGMENT_WR)) == _SEGMENT_CODE ) goto unmap_and_fail; if ( ((desc.b & (_SEGMENT_EC|_SEGMENT_CODE)) != (_SEGMENT_EC|_SEGMENT_CODE)) && ((dpl < cpl) || (dpl < rpl)) ) goto unmap_and_fail; break; } if ( !(desc.b & _SEGMENT_P) ) { fault_type = (seg != x86_seg_ss) ? TRAP_no_segment : TRAP_stack_error; goto unmap_and_fail; } } while ( !(desc.b & 0x100) &&  writable &&  (cmpxchg(&pdesc->b, desc.b, desc.b | 0x100) != desc.b) ); desc.b |= 0x100; skip_accessed_flag: hvm_unmap_entry(pdesc); segr.base = (((desc.b <<  0) & 0xff000000u) | ((desc.b << 16) & 0x00ff0000u) | ((desc.a >> 16) & 0x0000ffffu)); segr.attr.bytes = (((desc.b >>  8) & 0x00ffu) | ((desc.b >> 12) & 0x0f00u)); segr.limit = (desc.b & 0x000f0000u) | (desc.a & 0x0000ffffu); if ( segr.attr.fields.g ) segr.limit = (segr.limit << 12) | 0xfffu; segr.sel = sel; hvm_set_segment_register(v, seg, &segr); return 0; unmap_and_fail: hvm_unmap_entry(pdesc); fail: hvm_inject_hw_exception(fault_type, sel & 0xfffc); hvm_map_fail: return 1; }
Description: The x86 emulator in Xen does not properly treat x86 NULL segments as unusable when accessing memory, which might allow local HVM guest users to gain privileges via vectors involving ""unexpected"" base/limit values.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int smsusb_init_device(struct usb_interface *intf, int board_id) { struct smsdevice_params_t params; struct smsusb_device_t *dev; void *mdev; int i, rc; dev = kzalloc(sizeof(struct smsusb_device_t), GFP_KERNEL); if (!dev) return -ENOMEM; memset(&params, 0, sizeof(params)); usb_set_intfdata(intf, dev); dev->udev = interface_to_usbdev(intf); dev->state = SMSUSB_DISCONNECTED; params.device_type = sms_get_board(board_id)->type; switch (params.device_type) { case SMS_STELLAR: dev->buffer_size = USB1_BUFFER_SIZE; params.setmode_handler = smsusb1_setmode; params.detectmode_handler = smsusb1_detectmode; break; case SMS_UNKNOWN_TYPE: pr_err(""Unspecified sms device type!\n""); default: dev->buffer_size = USB2_BUFFER_SIZE; dev->response_alignment = le16_to_cpu(dev->udev->ep_in[1]->desc.wMaxPacketSize) - sizeof(struct sms_msg_hdr); params.flags |= SMS_DEVICE_FAMILY2; break; } for (i = 0; i < intf->cur_altsetting->desc.bNumEndpoints; i++) { if (intf->cur_altsetting->endpoint[i].desc. bEndpointAddress & USB_DIR_IN) dev->in_ep = intf->cur_altsetting->endpoint[i].desc.bEndpointAddress; else dev->out_ep = intf->cur_altsetting->endpoint[i].desc.bEndpointAddress; } pr_debug(""in_ep = %02x, out_ep = %02x\n"", dev->in_ep, dev->out_ep); params.device = &dev->udev->dev; params.usb_device = dev->udev; params.buffer_size = dev->buffer_size; params.num_buffers = MAX_BUFFERS; params.sendrequest_handler = smsusb_sendrequest; params.context = dev; usb_make_path(dev->udev, params.devpath, sizeof(params.devpath)); mdev = siano_media_device_register(dev, board_id); rc = smscore_register_device(&params, &dev->coredev, 0, mdev); if (rc < 0) { pr_err(""smscore_register_device(...) failed, rc %d\n"", rc); smsusb_term_device(intf); #ifdef CONFIG_MEDIA_CONTROLLER_DVB media_device_unregister(mdev); #endif kfree(mdev); return rc; } smscore_set_board_id(dev->coredev, board_id); dev->coredev->is_usb_device = true; for (i = 0; i < MAX_URBS; i++) { dev->surbs[i].dev = dev; usb_init_urb(&dev->surbs[i].urb); } pr_debug(""smsusb_start_streaming(...).\n""); rc = smsusb_start_streaming(dev); if (rc < 0) { pr_err(""smsusb_start_streaming(...) failed\n""); smsusb_term_device(intf); return rc; } dev->state = SMSUSB_ACTIVE; rc = smscore_start_device(dev->coredev); if (rc < 0) { pr_err(""smscore_start_device(...) failed\n""); smsusb_term_device(intf); return rc; } pr_debug(""device 0x%p created\n"", dev); return rc; }
Description: An issue was discovered in the Linux kernel before 5.1.8. There is a NULL pointer dereference caused by a malicious USB device in the drivers/media/usb/siano/smsusb.c driver.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Status ComputeConv2DDimension(const Conv2DParameters& params, const Tensor& input, const Tensor& filter, Conv2DDimensions* dimensions) { TF_REQUIRES(input.dims() == 4, errors::InvalidArgument(""input must be 4-dimensional"", input.shape().DebugString())); TF_REQUIRES(filter.dims() == 4, errors::InvalidArgument(""filter must be 4-dimensional: "", filter.shape().DebugString())); for (int i = 0; i < 3; i++) { TF_REQUIRES( FastBoundsCheck(filter.dim_size(i), std::numeric_limits<int>::max()), errors::InvalidArgument(""filter too large"")); } const int64 in_depth_raw = GetTensorDim(input, params.data_format, 'C'); const int64 patch_depth_raw = filter.dim_size(2); TF_REQUIRES(FastBoundsCheck(in_depth_raw, std::numeric_limits<int>::max()), errors::InvalidArgument(""Input depth too large"")); TF_REQUIRES(FastBoundsCheck(patch_depth_raw, std::numeric_limits<int>::max()), errors::InvalidArgument(""Patch depth too large"")); const int in_depth = static_cast<int>(in_depth_raw); const int patch_depth = static_cast<int>(patch_depth_raw); TF_REQUIRES(in_depth % patch_depth == 0, errors::InvalidArgument( ""input depth must be evenly divisible by filter depth: "", in_depth, "" vs "", patch_depth)); const int out_depth = static_cast<int>(filter.dim_size(3)); const int64 input_rows_raw = GetTensorDim(input, params.data_format, 'H'); TF_REQUIRES(FastBoundsCheck(input_rows_raw, std::numeric_limits<int>::max()), errors::InvalidArgument(""Input rows too large"")); const int input_rows = static_cast<int>(input_rows_raw); const int filter_rows = static_cast<int>(filter.dim_size(0)); const int64 input_cols_raw = GetTensorDim(input, params.data_format, 'W'); TF_REQUIRES(FastBoundsCheck(input_cols_raw, std::numeric_limits<int>::max()), errors::InvalidArgument(""Input cols too large"")); const int input_cols = static_cast<int>(input_cols_raw); const int filter_cols = static_cast<int>(filter.dim_size(1)); const int64 batch_raw = GetTensorDim(input, params.data_format, 'N'); TF_REQUIRES(FastBoundsCheck(batch_raw, std::numeric_limits<int>::max()), errors::InvalidArgument(""batch is too large"")); const int batch = static_cast<int>(batch_raw); const int stride_rows = GetTensorDim(params.strides, params.data_format, 'H'); const int stride_cols = GetTensorDim(params.strides, params.data_format, 'W'); const int dilation_rows = GetTensorDim(params.dilations, params.data_format, 'H'); const int dilation_cols = GetTensorDim(params.dilations, params.data_format, 'W'); int64 pad_rows_before, pad_rows_after, pad_cols_before, pad_cols_after; if (params.padding == Padding::EXPLICIT) { GetExplicitPaddingForDim(params.explicit_paddings, params.data_format, 'H', &pad_rows_before, &pad_rows_after); GetExplicitPaddingForDim(params.explicit_paddings, params.data_format, 'W', &pad_cols_before, &pad_cols_after); } int64 out_rows = 0, out_cols = 0; TF_RETURN_IF_ERROR(GetWindowedOutputSizeVerboseV2( input_rows, filter_rows, dilation_rows, stride_rows, params.padding, &out_rows, &pad_rows_before, &pad_rows_after)); TF_RETURN_IF_ERROR(GetWindowedOutputSizeVerboseV2( input_cols, filter_cols, dilation_cols, stride_cols, params.padding, &out_cols, &pad_cols_before, &pad_cols_after)); dimensions->batch = batch; dimensions->input_rows = input_rows; dimensions->input_cols = input_cols; dimensions->in_depth = in_depth; dimensions->filter_rows = filter_rows; dimensions->filter_cols = filter_cols; dimensions->patch_depth = patch_depth; dimensions->out_depth = out_depth; dimensions->stride_rows = stride_rows; dimensions->stride_cols = stride_cols; dimensions->dilation_rows = dilation_rows; dimensions->dilation_cols = dilation_cols; dimensions->out_rows = out_rows; dimensions->out_cols = out_cols; dimensions->pad_rows_before = pad_rows_before; dimensions->pad_rows_after = pad_rows_after; dimensions->pad_cols_before = pad_cols_before; dimensions->pad_cols_after = pad_cols_after; return Status::OK(); }
Description: TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.Conv2D`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/988087bd83f144af14087fe4fecee2d250d93737/tensorflow/core/kernels/conv_ops.cc#L261-L263) does a division by a quantity that is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int Downmix_Command(effect_handle_t self, uint32_t cmdCode, uint32_t cmdSize, void *pCmdData, uint32_t *replySize, void *pReplyData) { downmix_module_t *pDwmModule = (downmix_module_t *) self; downmix_object_t *pDownmixer; if (pDwmModule == NULL || pDwmModule->context.state == DOWNMIX_STATE_UNINITIALIZED) { return -EINVAL; } pDownmixer = (downmix_object_t*) &pDwmModule->context; ALOGV(""Downmix_Command command %"" PRIu32 "" cmdSize %"" PRIu32, cmdCode, cmdSize); switch (cmdCode) { case EFFECT_CMD_INIT: if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) { return -EINVAL; } *(int *) pReplyData = Downmix_Init(pDwmModule); break; case EFFECT_CMD_SET_CONFIG: if (pCmdData == NULL || cmdSize != sizeof(effect_config_t) || pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) { return -EINVAL; } *(int *) pReplyData = Downmix_Configure(pDwmModule, (effect_config_t *)pCmdData, false); break; case EFFECT_CMD_RESET: Downmix_Reset(pDownmixer, false); break; case EFFECT_CMD_GET_PARAM: ALOGV(""Downmix_Command EFFECT_CMD_GET_PARAM pCmdData %p, *replySize %"" PRIu32 "", pReplyData: %p"", pCmdData, *replySize, pReplyData); if (pCmdData == NULL || cmdSize < (int)(sizeof(effect_param_t) + sizeof(int32_t)) || pReplyData == NULL || replySize == NULL || *replySize < (int) sizeof(effect_param_t) + 2 * sizeof(int32_t)) { return -EINVAL; } effect_param_t *rep = (effect_param_t *) pReplyData; memcpy(pReplyData, pCmdData, sizeof(effect_param_t) + sizeof(int32_t)); ALOGV(""Downmix_Command EFFECT_CMD_GET_PARAM param %"" PRId32 "", replySize %"" PRIu32, *(int32_t *)rep->data, rep->vsize); rep->status = Downmix_getParameter(pDownmixer, *(int32_t *)rep->data, &rep->vsize, rep->data + sizeof(int32_t)); *replySize = sizeof(effect_param_t) + sizeof(int32_t) + rep->vsize; break; case EFFECT_CMD_SET_PARAM: ALOGV(""Downmix_Command EFFECT_CMD_SET_PARAM cmdSize %d pCmdData %p, *replySize %"" PRIu32 "", pReplyData %p"", cmdSize, pCmdData, *replySize, pReplyData); if (pCmdData == NULL || (cmdSize < (int)(sizeof(effect_param_t) + sizeof(int32_t))) || pReplyData == NULL || replySize == NULL || *replySize != (int)sizeof(int32_t)) { return -EINVAL; } effect_param_t *cmd = (effect_param_t *) pCmdData; *(int *)pReplyData = Downmix_setParameter(pDownmixer, *(int32_t *)cmd->data, cmd->vsize, cmd->data + sizeof(int32_t)); break; case EFFECT_CMD_SET_PARAM_DEFERRED: ALOGW(""Downmix_Command command EFFECT_CMD_SET_PARAM_DEFERRED not supported, FIXME""); break; case EFFECT_CMD_SET_PARAM_COMMIT: ALOGW(""Downmix_Command command EFFECT_CMD_SET_PARAM_COMMIT not supported, FIXME""); break; case EFFECT_CMD_ENABLE: if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) { return -EINVAL; } if (pDownmixer->state != DOWNMIX_STATE_INITIALIZED) { return -ENOSYS; } pDownmixer->state = DOWNMIX_STATE_ACTIVE; ALOGV(""EFFECT_CMD_ENABLE() OK""); *(int *)pReplyData = 0; break; case EFFECT_CMD_DISABLE: if (pReplyData == NULL || replySize == NULL || *replySize != sizeof(int)) { return -EINVAL; } if (pDownmixer->state != DOWNMIX_STATE_ACTIVE) { return -ENOSYS; } pDownmixer->state = DOWNMIX_STATE_INITIALIZED; ALOGV(""EFFECT_CMD_DISABLE() OK""); *(int *)pReplyData = 0; break; case EFFECT_CMD_SET_DEVICE: if (pCmdData == NULL || cmdSize != (int)sizeof(uint32_t)) { return -EINVAL; } ALOGV(""Downmix_Command EFFECT_CMD_SET_DEVICE: 0x%08"" PRIx32, *(uint32_t *)pCmdData); break; case EFFECT_CMD_SET_VOLUME: { if (pCmdData == NULL || cmdSize != (int)sizeof(uint32_t) * 2) { return -EINVAL; } ALOGW(""Downmix_Command command EFFECT_CMD_SET_VOLUME not supported, FIXME""); float left = (float)(*(uint32_t *)pCmdData) / (1 << 24); float right = (float)(*((uint32_t *)pCmdData + 1)) / (1 << 24); ALOGV(""Downmix_Command EFFECT_CMD_SET_VOLUME: left %f, right %f "", left, right); break; } case EFFECT_CMD_SET_AUDIO_MODE: if (pCmdData == NULL || cmdSize != (int)sizeof(uint32_t)) { return -EINVAL; } ALOGV(""Downmix_Command EFFECT_CMD_SET_AUDIO_MODE: %"" PRIu32, *(uint32_t *)pCmdData); break; case EFFECT_CMD_SET_CONFIG_REVERSE: case EFFECT_CMD_SET_INPUT_DEVICE: break; default: ALOGW(""Downmix_Command invalid command %"" PRIu32, cmdCode); return -EINVAL; } return 0; }
Description: An information disclosure vulnerability in the Android media framework (libeffects). Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2, 8.0. Android ID: A-63526567.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static s32 brcmf_wowl_nd_results(struct brcmf_if *ifp, const struct brcmf_event_msg *e, void *data) { struct brcmf_cfg80211_info *cfg = ifp->drvr->config; struct wiphy *wiphy = cfg_to_wiphy(cfg); struct brcmf_pno_scanresults_le *pfn_result; struct brcmf_pno_net_info_le *netinfo; brcmf_dbg(SCAN, ""Enter\n""); if (e->datalen < (sizeof(*pfn_result) + sizeof(*netinfo))) { brcmf_dbg(SCAN, ""Event data to small. Ignore\n""); return 0; } pfn_result = (struct brcmf_pno_scanresults_le *)data; if (e->event_code == BRCMF_E_PFN_NET_LOST) { brcmf_dbg(SCAN, ""PFN NET LOST event. Ignore\n""); return 0; } if (le32_to_cpu(pfn_result->count) < 1) { bphy_err(wiphy, ""Invalid result count, expected 1 (%d)\n"", le32_to_cpu(pfn_result->count)); return -EINVAL; } netinfo = brcmf_get_netinfo_array(pfn_result); memcpy(cfg->wowl.nd->ssid.ssid, netinfo->SSID, netinfo->SSID_len); cfg->wowl.nd->ssid.ssid_len = netinfo->SSID_len; cfg->wowl.nd->n_channels = 1; cfg->wowl.nd->channels[0] = ieee80211_channel_to_frequency(netinfo->channel, netinfo->channel <= CH_MAX_2G_CHANNEL ? NL80211_BAND_2GHZ : NL80211_BAND_5GHZ); cfg->wowl.nd_info->n_matches = 1; cfg->wowl.nd_info->matches[0] = cfg->wowl.nd; cfg->wowl.nd_data_completed = true; wake_up(&cfg->wowl.nd_data_wait); return 0; }
Description: The Broadcom brcmfmac WiFi driver prior to commit 1b5e2423164b3670e8bc9174e4762d297990deff is vulnerable to a heap buffer overflow. If the Wake-up on Wireless LAN functionality is configured, a malicious event frame can be constructed to trigger an heap buffer overflow in the brcmf_wowl_nd_results function. This vulnerability can be exploited with compromised chipsets to compromise the host, or when used in combination with CVE-2019-9503, can be used remotely. In the worst case scenario, by sending specially-crafted WiFi packets, a remote, unauthenticated attacker may be able to execute arbitrary code on a vulnerable system. More typically, this vulnerability will result in denial-of-service conditions.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void spell_load_lang(char_u *lang) { char_ufname_enc[85]; intr; spelload_Tsl; intround; STRCPY(sl.sl_lang, lang); sl.sl_slang = NULL; sl.sl_nobreak = FALSE; for (round = 1; round <= 2; ++round) { vim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5, #ifdef VMS ""spell/%s_%s.spl"", #else ""spell/%s.%s.spl"", #endif lang, spell_enc()); r = do_in_runtimepath(fname_enc, 0, spell_load_cb, &sl); if (r == FAIL && *sl.sl_lang != NUL) { vim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5, #ifdef VMS ""spell/%s_ascii.spl"", #else ""spell/%s.ascii.spl"", #endif lang); r = do_in_runtimepath(fname_enc, 0, spell_load_cb, &sl); if (r == FAIL && *sl.sl_lang != NUL && round == 1 && apply_autocmds(EVENT_SPELLFILEMISSING, lang, curbuf->b_fname, FALSE, curbuf)) continue; break; } break; } if (r == FAIL) { smsg( #ifdef VMS _(""Warning: Cannot find word list \""%s_%s.spl\"" or \""%s_ascii.spl\""""), #else _(""Warning: Cannot find word list \""%s.%s.spl\"" or \""%s.ascii.spl\""""), #endif lang, spell_enc(), lang); } else if (sl.sl_slang != NULL) { STRCPY(fname_enc + STRLEN(fname_enc) - 3, ""add.spl""); do_in_runtimepath(fname_enc, DIP_ALL, spell_load_cb, &sl); } }
Description: Use After Free in GitHub repository vim/vim prior to 9.0.0614.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void PropertiesWidget::loadTorrentInfos(BitTorrent::TorrentHandle *const torrent) { clear(); m_torrent = torrent; downloaded_pieces->setTorrent(m_torrent); pieces_availability->setTorrent(m_torrent); if (!m_torrent) return; updateSavePath(m_torrent); hash_lbl->setText(m_torrent->hash()); PropListModel->model()->clear(); if (m_torrent->hasMetadata()) { lbl_creationDate->setText(m_torrent->creationDate().toString(Qt::DefaultLocaleShortDate)); label_total_size_val->setText(Utils::Misc::friendlyUnit(m_torrent->totalSize())); comment_text->setText(Utils::Misc::parseHtmlLinks(m_torrent->comment())); loadUrlSeeds(); label_created_by_val->setText(m_torrent->creator()); PropListModel->model()->setupModelData(m_torrent->info()); filesList->setExpanded(PropListModel->index(0, 0), true); PropListModel->model()->updateFilesPriorities(m_torrent->filePriorities()); } loadDynamicData(); }
Description: WebUI in qBittorrent before 3.3.11 did not escape many values, which could potentially lead to XSS.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sadb_msg *hdr, void * const *ext_hdrs) { struct pfkey_sock *pfk = pfkey_sk(sk); struct sk_buff *supp_skb; if (hdr->sadb_msg_satype > SADB_SATYPE_MAX) return -EINVAL; if (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) { if (pfk->registered&(1<<hdr->sadb_msg_satype)) return -EEXIST; pfk->registered |= (1<<hdr->sadb_msg_satype); } xfrm_probe_algs(); supp_skb = compose_sadb_supported(hdr, GFP_KERNEL | __GFP_ZERO); if (!supp_skb) { if (hdr->sadb_msg_satype != SADB_SATYPE_UNSPEC) pfk->registered &= ~(1<<hdr->sadb_msg_satype); return -ENOBUFS; } pfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk, sock_net(sk)); return 0; }
Description: A race condition was found in the Linux kernel's IP framework for transforming packets (XFRM subsystem) when multiple calls to xfrm_probe_algs occurred simultaneously. This flaw could allow a local attacker to potentially trigger an out-of-bounds write or leak kernel heap memory by performing an out-of-bounds read and copying it into a socket.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static inline LineContribType *_gdContributionsCalc(unsigned int line_size, unsigned int src_size, double scale_d,  const interpolation_method pFilter) { double width_d; double scale_f_d = 1.0; const double filter_width_d = DEFAULT_BOX_RADIUS; int windows_size; unsigned int u; LineContribType *res; if (scale_d < 1.0) { width_d = filter_width_d / scale_d; scale_f_d = scale_d; }  else { width_d= filter_width_d; } windows_size = 2 * (int)ceil(width_d) + 1; res = _gdContributionsAlloc(line_size, windows_size); for (u = 0; u < line_size; u++) { const double dCenter = (double)u / scale_d; register int iLeft = MAX(0, (int)floor (dCenter - width_d)); int iRight = MIN((int)ceil(dCenter + width_d), (int)src_size - 1); double dTotalWeight = 0.0; int iSrc; res->ContribRow[u].Left = iLeft; res->ContribRow[u].Right = iRight; if (iRight - iLeft + 1 > windows_size)  { if (iLeft < ((int)src_size - 1 / 2))  { iLeft++; } else { iRight--; } } for (iSrc = iLeft; iSrc <= iRight; iSrc++) { dTotalWeight += (res->ContribRow[u].Weights[iSrc-iLeft] =  scale_f_d * (*pFilter)(scale_f_d * (dCenter - (double)iSrc))); } if (dTotalWeight < 0.0) { _gdContributionsFree(res); return NULL; } if (dTotalWeight > 0.0) { for (iSrc = iLeft; iSrc <= iRight; iSrc++) { res->ContribRow[u].Weights[iSrc-iLeft] /= dTotalWeight; } } } return res; }
Description: gd_interpolation.c in the GD Graphics Library (aka libgd) before 2.1.1, as used in PHP before 5.5.36, 5.6.x before 5.6.22, and 7.x before 7.0.7, allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted image that is mishandled by the imagescale function.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void prep_write_cb(struct bt_att_chan *chan, uint8_t opcode, const void *pdu, uint16_t length, void *user_data) { struct bt_gatt_server *server = user_data; uint16_t handle = 0; uint16_t offset; struct gatt_db_attribute *attr; struct prep_write_complete_data *pwcd; uint8_t ecode, status; if (length < 4) { ecode = BT_ATT_ERROR_INVALID_PDU; goto error; } if (queue_length(server->prep_queue) >= server->max_prep_queue_len) { ecode = BT_ATT_ERROR_PREPARE_QUEUE_FULL; goto error; } handle = get_le16(pdu); offset = get_le16(pdu + 2); attr = gatt_db_get_attribute(server->db, handle); if (!attr) { ecode = BT_ATT_ERROR_INVALID_HANDLE; goto error; } util_debug(server->debug_callback, server->debug_data, ""Prep Write Req - handle: 0x%04x"", handle); ecode = check_permissions(server, attr, BT_ATT_PERM_WRITE_MASK); if (ecode) goto error; pwcd = new0(struct prep_write_complete_data, 1); pwcd->chan = chan; pwcd->pdu = malloc(length); memcpy(pwcd->pdu, pdu, length); pwcd->length = length; pwcd->server = server; status = gatt_db_attribute_write(attr, offset, NULL, 0, BT_ATT_OP_PREP_WRITE_REQ, server->att, prep_write_complete_cb, pwcd); if (status) return; ecode = BT_ATT_ERROR_UNLIKELY; error: bt_att_chan_send_error_rsp(chan, opcode, handle, ecode); }
Description: A heap overflow vulnerability was found in bluez in versions prior to 5.63. An attacker with local network access could pass specially crafted files causing an application to halt or crash, leading to a denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int mxf_parse_structural_metadata(MXFContext *mxf) { MXFPackage *material_package = NULL; int i, j, k, ret; av_log(mxf->fc, AV_LOG_TRACE, ""metadata sets count %d\n"", mxf->metadata_sets_count); for (i = 0; i < mxf->packages_count; i++) { material_package = mxf_resolve_strong_ref(mxf, &mxf->packages_refs[i], MaterialPackage); if (material_package) break; } if (!material_package) { av_log(mxf->fc, AV_LOG_ERROR, ""no material package found\n""); return AVERROR_INVALIDDATA; } mxf_add_umid_metadata(&mxf->fc->metadata, ""material_package_umid"", material_package); if (material_package->name && material_package->name[0]) av_dict_set(&mxf->fc->metadata, ""material_package_name"", material_package->name, 0); mxf_parse_package_comments(mxf, &mxf->fc->metadata, material_package); for (i = 0; i < material_package->tracks_count; i++) { MXFPackage *source_package = NULL; MXFTrack *material_track = NULL; MXFTrack *source_track = NULL; MXFTrack *temp_track = NULL; MXFDescriptor *descriptor = NULL; MXFStructuralComponent *component = NULL; MXFTimecodeComponent *mxf_tc = NULL; UID *essence_container_ul = NULL; const MXFCodecUL *codec_ul = NULL; const MXFCodecUL *container_ul = NULL; const MXFCodecUL *pix_fmt_ul = NULL; AVStream *st; AVTimecode tc; int flags; if (!(material_track = mxf_resolve_strong_ref(mxf, &material_package->tracks_refs[i], Track))) { av_log(mxf->fc, AV_LOG_ERROR, ""could not resolve material track strong ref\n""); continue; } if ((component = mxf_resolve_strong_ref(mxf, &material_track->sequence_ref, TimecodeComponent))) { mxf_tc = (MXFTimecodeComponent*)component; flags = mxf_tc->drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0; if (av_timecode_init(&tc, mxf_tc->rate, flags, mxf_tc->start_frame, mxf->fc) == 0) { mxf_add_timecode_metadata(&mxf->fc->metadata, ""timecode"", &tc); } } if (!(material_track->sequence = mxf_resolve_strong_ref(mxf, &material_track->sequence_ref, Sequence))) { av_log(mxf->fc, AV_LOG_ERROR, ""could not resolve material track sequence strong ref\n""); continue; } for (j = 0; j < material_track->sequence->structural_components_count; j++) { component = mxf_resolve_strong_ref(mxf, &material_track->sequence->structural_components_refs[j], TimecodeComponent); if (!component) continue; mxf_tc = (MXFTimecodeComponent*)component; flags = mxf_tc->drop_frame == 1 ? AV_TIMECODE_FLAG_DROPFRAME : 0; if (av_timecode_init(&tc, mxf_tc->rate, flags, mxf_tc->start_frame, mxf->fc) == 0) { mxf_add_timecode_metadata(&mxf->fc->metadata, ""timecode"", &tc); break; } } if(material_track->sequence->structural_components_count > 1) av_log(mxf->fc, AV_LOG_WARNING, ""material track %d: has %d components\n"", material_track->track_id, material_track->sequence->structural_components_count); for (j = 0; j < material_track->sequence->structural_components_count; j++) { component = mxf_resolve_sourceclip(mxf, &material_track->sequence->structural_components_refs[j]); if (!component) continue; source_package = mxf_resolve_source_package(mxf, component->source_package_ul, component->source_package_uid); if (!source_package) { av_log(mxf->fc, AV_LOG_TRACE, ""material track %d: no corresponding source package found\n"", material_track->track_id); continue; } for (k = 0; k < source_package->tracks_count; k++) { if (!(temp_track = mxf_resolve_strong_ref(mxf, &source_package->tracks_refs[k], Track))) { av_log(mxf->fc, AV_LOG_ERROR, ""could not resolve source track strong ref\n""); ret = AVERROR_INVALIDDATA; goto fail_and_free; } if (temp_track->track_id == component->source_track_id) { source_track = temp_track; break; } } if (!source_track) { av_log(mxf->fc, AV_LOG_ERROR, ""material track %d: no corresponding source track found\n"", material_track->track_id); break; } for (k = 0; k < mxf->essence_container_data_count; k++) { MXFEssenceContainerData *essence_data; if (!(essence_data = mxf_resolve_strong_ref(mxf, &mxf->essence_container_data_refs[k], EssenceContainerData))) { av_log(mxf, AV_LOG_TRACE, ""could not resolve essence container data strong ref\n""); continue; } if (!memcmp(component->source_package_ul, essence_data->package_ul, sizeof(UID)) && !memcmp(component->source_package_uid, essence_data->package_uid, sizeof(UID))) { source_track->body_sid = essence_data->body_sid; source_track->index_sid = essence_data->index_sid; break; } } if(source_track && component) break; } if (!source_track || !component || !source_package) { if((ret = mxf_add_metadata_stream(mxf, material_track))) goto fail_and_free; continue; } if (!(source_track->sequence = mxf_resolve_strong_ref(mxf, &source_track->sequence_ref, Sequence))) { av_log(mxf->fc, AV_LOG_ERROR, ""could not resolve source track sequence strong ref\n""); ret = AVERROR_INVALIDDATA; goto fail_and_free; } if (memcmp(material_track->sequence->data_definition_ul, source_track->sequence->data_definition_ul, 16)) { av_log(mxf->fc, AV_LOG_ERROR, ""material track %d: DataDefinition mismatch\n"", material_track->track_id); continue; } st = avformat_new_stream(mxf->fc, NULL); if (!st) { av_log(mxf->fc, AV_LOG_ERROR, ""could not allocate stream\n""); ret = AVERROR(ENOMEM); goto fail_and_free; } st->id = material_track->track_id; st->priv_data = source_track; source_package->descriptor = mxf_resolve_strong_ref(mxf, &source_package->descriptor_ref, AnyType); descriptor = mxf_resolve_multidescriptor(mxf, source_package->descriptor, source_track->track_id); if (descriptor && descriptor->duration != AV_NOPTS_VALUE) source_track->original_duration = st->duration = FFMIN(descriptor->duration, component->duration); else source_track->original_duration = st->duration = component->duration; if (st->duration == -1) st->duration = AV_NOPTS_VALUE; st->start_time = component->start_position; if (material_track->edit_rate.num <= 0 || material_track->edit_rate.den <= 0) { av_log(mxf->fc, AV_LOG_WARNING, ""Invalid edit rate (%d/%d) found on stream #%d, "" ""defaulting to 25/1\n"", material_track->edit_rate.num, material_track->edit_rate.den, st->index); material_track->edit_rate = (AVRational){25, 1}; } avpriv_set_pts_info(st, 64, material_track->edit_rate.den, material_track->edit_rate.num); source_track->edit_rate = material_track->edit_rate; PRINT_KEY(mxf->fc, ""data definition   ul"", source_track->sequence->data_definition_ul); codec_ul = mxf_get_codec_ul(ff_mxf_data_definition_uls, &source_track->sequence->data_definition_ul); st->codecpar->codec_type = codec_ul->id; if (!descriptor) { av_log(mxf->fc, AV_LOG_INFO, ""source track %d: stream %d, no descriptor found\n"", source_track->track_id, st->index); continue; } PRINT_KEY(mxf->fc, ""essence codec     ul"", descriptor->essence_codec_ul); PRINT_KEY(mxf->fc, ""essence container ul"", descriptor->essence_container_ul); essence_container_ul = &descriptor->essence_container_ul; source_track->wrapping = (mxf->op == OPAtom) ? ClipWrapped : mxf_get_wrapping_kind(essence_container_ul); if (source_track->wrapping == UnknownWrapped) av_log(mxf->fc, AV_LOG_INFO, ""wrapping of stream %d is unknown\n"", st->index); if (IS_KLV_KEY(essence_container_ul, mxf_encrypted_essence_container)) { av_log(mxf->fc, AV_LOG_INFO, ""broken encrypted mxf file\n""); for (k = 0; k < mxf->metadata_sets_count; k++) { MXFMetadataSet *metadata = mxf->metadata_sets[k]; if (metadata->type == CryptoContext) { essence_container_ul = &((MXFCryptoContext *)metadata)->source_container_ul; break; } } } codec_ul = mxf_get_codec_ul(ff_mxf_codec_uls, &descriptor->essence_codec_ul); st->codecpar->codec_id = (enum AVCodecID)codec_ul->id; if (st->codecpar->codec_id == AV_CODEC_ID_NONE) { codec_ul = mxf_get_codec_ul(ff_mxf_codec_uls, &descriptor->codec_ul); st->codecpar->codec_id = (enum AVCodecID)codec_ul->id; } av_log(mxf->fc, AV_LOG_VERBOSE, ""%s: Universal Label: "", avcodec_get_name(st->codecpar->codec_id)); for (k = 0; k < 16; k++) { av_log(mxf->fc, AV_LOG_VERBOSE, ""%.2x"", descriptor->essence_codec_ul[k]); if (!(k+1 & 19) || k == 5) av_log(mxf->fc, AV_LOG_VERBOSE, "".""); } av_log(mxf->fc, AV_LOG_VERBOSE, ""\n""); mxf_add_umid_metadata(&st->metadata, ""file_package_umid"", source_package); if (source_package->name && source_package->name[0]) av_dict_set(&st->metadata, ""file_package_name"", source_package->name, 0); if (material_track->name && material_track->name[0]) av_dict_set(&st->metadata, ""track_name"", material_track->name, 0); mxf_parse_physical_source_package(mxf, source_track, st); if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) { source_track->intra_only = mxf_is_intra_only(descriptor); container_ul = mxf_get_codec_ul(mxf_picture_essence_container_uls, essence_container_ul); if (st->codecpar->codec_id == AV_CODEC_ID_NONE) st->codecpar->codec_id = container_ul->id; st->codecpar->width = descriptor->width; st->codecpar->height = descriptor->height;  switch (descriptor->frame_layout) { case FullFrame: st->codecpar->field_order = AV_FIELD_PROGRESSIVE; break; case OneField: av_log(mxf->fc, AV_LOG_INFO, ""OneField frame layout isn't currently supported\n""); break;  case MixedFields: break; case SegmentedFrame: st->codecpar->field_order = AV_FIELD_PROGRESSIVE; case SeparateFields: av_log(mxf->fc, AV_LOG_DEBUG, ""video_line_map: (%d, %d), field_dominance: %d\n"", descriptor->video_line_map[0], descriptor->video_line_map[1], descriptor->field_dominance); if ((descriptor->video_line_map[0] > 0) && (descriptor->video_line_map[1] > 0)) { if ((descriptor->video_line_map[0] + descriptor->video_line_map[1]) % 2) { switch (descriptor->field_dominance) { case MXF_FIELD_DOMINANCE_DEFAULT: case MXF_FIELD_DOMINANCE_FF: st->codecpar->field_order = AV_FIELD_TT; break; case MXF_FIELD_DOMINANCE_FL: st->codecpar->field_order = AV_FIELD_TB; break; default: avpriv_request_sample(mxf->fc, ""Field dominance %d support"", descriptor->field_dominance); } } else { switch (descriptor->field_dominance) { case MXF_FIELD_DOMINANCE_DEFAULT: case MXF_FIELD_DOMINANCE_FF: st->codecpar->field_order = AV_FIELD_BB; break; case MXF_FIELD_DOMINANCE_FL: st->codecpar->field_order = AV_FIELD_BT; break; default: avpriv_request_sample(mxf->fc, ""Field dominance %d support"", descriptor->field_dominance); } } } st->codecpar->height *= 2; break; default: av_log(mxf->fc, AV_LOG_INFO, ""Unknown frame layout type: %d\n"", descriptor->frame_layout); } if (st->codecpar->codec_id == AV_CODEC_ID_RAWVIDEO) { st->codecpar->format = descriptor->pix_fmt; if (st->codecpar->format == AV_PIX_FMT_NONE) { pix_fmt_ul = mxf_get_codec_ul(ff_mxf_pixel_format_uls, &descriptor->essence_codec_ul); st->codecpar->format = (enum AVPixelFormat)pix_fmt_ul->id; if (st->codecpar->format== AV_PIX_FMT_NONE) { st->codecpar->codec_tag = mxf_get_codec_ul(ff_mxf_codec_tag_uls, &descriptor->essence_codec_ul)->id; if (!st->codecpar->codec_tag) { if (descriptor->horiz_subsampling == 2 && descriptor->vert_subsampling == 1 && descriptor->component_depth == 8) { st->codecpar->format = AV_PIX_FMT_UYVY422; } } } } } st->need_parsing = AVSTREAM_PARSE_HEADERS; if (material_track->sequence->origin) { av_dict_set_int(&st->metadata, ""material_track_origin"", material_track->sequence->origin, 0); } if (source_track->sequence->origin) { av_dict_set_int(&st->metadata, ""source_track_origin"", source_track->sequence->origin, 0); } if (descriptor->aspect_ratio.num && descriptor->aspect_ratio.den) st->display_aspect_ratio = descriptor->aspect_ratio; } else if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) { container_ul = mxf_get_codec_ul(mxf_sound_essence_container_uls, essence_container_ul); if (st->codecpar->codec_id == AV_CODEC_ID_NONE || (st->codecpar->codec_id == AV_CODEC_ID_PCM_ALAW && (enum AVCodecID)container_ul->id != AV_CODEC_ID_NONE)) st->codecpar->codec_id = (enum AVCodecID)container_ul->id; st->codecpar->channels = descriptor->channels; st->codecpar->bits_per_coded_sample = descriptor->bits_per_sample; if (descriptor->sample_rate.den > 0) { st->codecpar->sample_rate = descriptor->sample_rate.num / descriptor->sample_rate.den; avpriv_set_pts_info(st, 64, descriptor->sample_rate.den, descriptor->sample_rate.num); } else { av_log(mxf->fc, AV_LOG_WARNING, ""invalid sample rate (%d/%d) "" ""found for stream #%d, time base forced to 1/48000\n"", descriptor->sample_rate.num, descriptor->sample_rate.den, st->index); avpriv_set_pts_info(st, 64, 1, 48000); } if (st->duration != AV_NOPTS_VALUE) st->duration = av_rescale_q(st->duration, av_inv_q(material_track->edit_rate), st->time_base); if (st->codecpar->codec_id == AV_CODEC_ID_PCM_S16LE) { if (descriptor->bits_per_sample > 16 && descriptor->bits_per_sample <= 24) st->codecpar->codec_id = AV_CODEC_ID_PCM_S24LE; else if (descriptor->bits_per_sample == 32) st->codecpar->codec_id = AV_CODEC_ID_PCM_S32LE; } else if (st->codecpar->codec_id == AV_CODEC_ID_PCM_S16BE) { if (descriptor->bits_per_sample > 16 && descriptor->bits_per_sample <= 24) st->codecpar->codec_id = AV_CODEC_ID_PCM_S24BE; else if (descriptor->bits_per_sample == 32) st->codecpar->codec_id = AV_CODEC_ID_PCM_S32BE; } else if (st->codecpar->codec_id == AV_CODEC_ID_MP2) { st->need_parsing = AVSTREAM_PARSE_FULL; } } else if (st->codecpar->codec_type == AVMEDIA_TYPE_DATA) { enum AVMediaType type; container_ul = mxf_get_codec_ul(mxf_data_essence_container_uls, essence_container_ul); if (st->codecpar->codec_id == AV_CODEC_ID_NONE) st->codecpar->codec_id = container_ul->id; type = avcodec_get_type(st->codecpar->codec_id); if (type == AVMEDIA_TYPE_SUBTITLE) st->codecpar->codec_type = type; if (container_ul->desc) av_dict_set(&st->metadata, ""data_type"", container_ul->desc, 0); } if (descriptor->extradata) { if (!ff_alloc_extradata(st->codecpar, descriptor->extradata_size)) { memcpy(st->codecpar->extradata, descriptor->extradata, descriptor->extradata_size); } } else if (st->codecpar->codec_id == AV_CODEC_ID_H264) { int coded_width = mxf_get_codec_ul(mxf_intra_only_picture_coded_width, &descriptor->essence_codec_ul)->id; if (coded_width) st->codecpar->width = coded_width; ret = ff_generate_avci_extradata(st); if (ret < 0) return ret; } if (st->codecpar->codec_type != AVMEDIA_TYPE_DATA && source_track->wrapping != FrameWrapped) { st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS; } } ret = 0; fail_and_free: return ret; }
Description: FFmpeg before commit bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75 contains an out of array access vulnerability in MXF format demuxer that can result in DoS. This attack appear to be exploitable via specially crafted MXF file which has to be provided as input. This vulnerability appears to have been fixed in bab0716c7f4793ec42e05a5aa7e80d82a0dd4e75 and later.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: std::string getauthor() { if(*author) return std::string(author,1,*author); else return std::string(); }
Description: AdPlug 2.3.1 has multiple heap-based buffer overflows in Ca2mLoader::load() in a2m.cpp.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static GF_Err BD_DecFieldReplace(GF_BifsDecoder * codec, GF_BitStream *bs) { GF_Err e; u32 NodeID, ind, field_ind, NumBits; GF_Node *node; GF_ChildNodeItem *prev_child; GF_FieldInfo field; NodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits); node = gf_sg_find_node(codec->current_graph, NodeID); if (!node) return GF_NON_COMPLIANT_BITSTREAM; NumBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_IN)-1); ind = gf_bs_read_int(bs, NumBits); e = gf_bifs_get_field_index(node, ind, GF_SG_FIELD_CODING_IN, &field_ind); if (e) return e; e = gf_node_get_field(node, field_ind, &field); if (e) return e; prev_child = NULL; if (field.fieldType == GF_SG_VRML_MFNODE) { prev_child = * ((GF_ChildNodeItem **) field.far_ptr); * ((GF_ChildNodeItem **) field.far_ptr) = NULL; } else if (!gf_sg_vrml_is_sf_field(field.fieldType)) { gf_sg_vrml_mf_reset(field.far_ptr, field.fieldType); } codec->is_com_dec = GF_TRUE; e = gf_bifs_dec_field(codec, bs, node, &field, GF_FALSE); codec->is_com_dec = GF_FALSE; if (field.fieldType == GF_SG_VRML_MFNODE) { gf_node_unregister_children(node, prev_child); } if (!e) gf_bifs_check_field_change(node, &field); return e; }
Description: GPAC v1.1.0 was discovered to contain an invalid memory address dereference via the function gf_sg_vrml_mf_reset(). This vulnerability allows attackers to cause a Denial of Service (DoS).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void RenderFrameObserverNatives::OnDocumentElementCreated( const v8::FunctionCallbackInfo<v8::Value>& args) { CHECK(args.Length() == 2); CHECK(args[0]->IsInt32()); CHECK(args[1]->IsFunction()); int frame_id = args[0]->Int32Value(); content::RenderFrame* frame = content::RenderFrame::FromRoutingID(frame_id); if (!frame) { LOG(WARNING) << ""No render frame found to register LoadWatcher.""; return; } new LoadWatcher(context(), frame, args[1].As<v8::Function>()); args.GetReturnValue().Set(true); }
Description: extensions/renderer/render_frame_observer_natives.cc in Google Chrome before 49.0.2623.75 does not properly consider object lifetimes and re-entrancy issues during OnDocumentElementCreated handling, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via unknown vectors.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: DataBuf PngChunk::readRawProfile(const DataBuf& text,bool iTXt) { DataBuf                 info; register long           i; register unsigned char *dp; const char             *sp; unsigned int            nibbles; long                    length; unsigned char           unhex[103]={0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,1, 2,3,4,5,6,7,8,9,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,10,11,12, 13,14,15}; if (text.size_ == 0) { return DataBuf(); } if ( iTXt ) { info.alloc(text.size_); ::memcpy(info.pData_,text.pData_,text.size_); return  info; } sp = (char*)text.pData_+1; while (*sp != '\n') sp++; while (*sp == '\0' || *sp == ' ' || *sp == '\n') sp++; length = (long) atol(sp); while (*sp != ' ' && *sp != '\n') sp++; if (length == 0) { #ifdef DEBUG std::cerr << ""Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: invalid profile length\n""; #endif } info.alloc(length); if (info.size_ != length) { #ifdef DEBUG std::cerr << ""Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: cannot allocate memory\n""; #endif return DataBuf(); } dp      = (unsigned char*)info.pData_; nibbles = length * 2; for (i = 0; i < (long) nibbles; i++) { while (*sp < '0' || (*sp > '9' && *sp < 'a') || *sp > 'f') { if (*sp == '\0') { #ifdef DEBUG std::cerr << ""Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: ran out of data\n""; #endif return DataBuf(); } sp++; } if (i%2 == 0) *dp = (unsigned char) (16*unhex[(int) *sp++]); else (*dp++) += unhex[(int) *sp++]; } return info; }
Description: In Exiv2 0.26 and previous versions, PngChunk::readRawProfile in pngchunk_int.cpp may cause a denial of service (application crash due to a heap-based buffer over-read) via a crafted PNG file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int image_load_gif(image_t *img, FILE    *fp, int     gray, int     load_data) { ucharbuf[1024]; gif_cmap_tcmap; intncolors, transparent; fread(buf, 13, 1, fp); img->width  = (buf[7] << 8) | buf[6]; img->height = (buf[9] << 8) | buf[8]; ncolors     = 2 << (buf[10] & 0x07); if (img->width <= 0 || img->width > 32767 || img->height <= 0 || img->height > 32767) return (-1); if (Encryption) img->use ++; if (buf[10] & GIF_COLORMAP) if (gif_read_cmap(fp, ncolors, cmap, &gray)) return (-1); transparent = -1; while (1) { switch (getc(fp)) { case ';' : return (-1); case '!' : buf[0] = (uchar)getc(fp); if (buf[0] == 0xf9) { gif_get_block(fp, buf); if (buf[0] & 1) transparent = buf[3]; } while (gif_get_block(fp, buf) != 0); break; case ',' : fread(buf, 9, 1, fp); if (buf[8] & GIF_COLORMAP) { ncolors = 2 << (buf[8] & 0x07); if (gif_read_cmap(fp, ncolors, cmap, &gray)) return (-1); } img->width  = (buf[5] << 8) | buf[4]; img->height = (buf[7] << 8) | buf[6]; img->depth  = gray ? 1 : 3; if (img->width <= 0 || img->width > 32767 || img->height <= 0 || img->height > 32767) return (-1); if (transparent >= 0) { if (BodyColor[0]) { float rgb[3];  get_color((uchar *)BodyColor, rgb); cmap[transparent][0] = (uchar)(rgb[0] * 255.0f + 0.5f); cmap[transparent][1] = (uchar)(rgb[1] * 255.0f + 0.5f); cmap[transparent][2] = (uchar)(rgb[2] * 255.0f + 0.5f); } else { cmap[transparent][0] = 255; cmap[transparent][1] = 255; cmap[transparent][2] = 255; } image_need_mask(img); } if (!load_data) return (0); img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth)); if (img->pixels == NULL) return (-1); return (gif_read_image(fp, img, cmap, buf[8] & GIF_INTERLACE, transparent)); } } }
Description: There is a vulnerability in htmldoc 1.9.16. In image_load_jpeg function image.cxx when it calls malloc,'img->width' and 'img->height' they are large enough to cause an integer overflow. So, the malloc function may return a heap blosmaller than the expected size, and it will cause a buffer overflow/Address boundary error in the jpeg_read_scanlines function.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static gboolean compare_by_coherent_set_key(gconstpointer a, gconstpointer b) { const coherent_set_key * guid_a = (const coherent_set_key *)a; const coherent_set_key * guid_b = (const coherent_set_key *)b; return memcmp(guid_a, guid_b, sizeof(coherent_set_key)) == 0; }
Description: Memory leak in RTPS protocol dissector in Wireshark 3.4.0 and 3.2.0 to 3.2.8 allows denial of service via packet injection or crafted capture file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void ok_png_decode2(ok_png_decoder *decoder) { ok_png *png = decoder->png; uint8_t png_header[8]; if (!ok_read(decoder, png_header, sizeof(png_header))) { return; } uint8_t png_signature[8] = {137, 80, 78, 71, 13, 10, 26, 10}; if (memcmp(png_header, png_signature, 8) != 0) { ok_png_error(decoder->png, OK_PNG_ERROR_INVALID, ""Invalid signature (not a PNG file)""); return; } bool info_only = (decoder->decode_flags & OK_PNG_INFO_ONLY) != 0; bool hdr_found = false; bool end_found = false; while (!end_found) { uint8_t chunk_header[8]; uint8_t chunk_footer[4]; if (!ok_read(decoder, chunk_header, sizeof(chunk_header))) { return; } const uint32_t chunk_length = readBE32(chunk_header); const uint32_t chunk_type = readBE32(chunk_header + 4); bool success = false; if (!hdr_found && chunk_type != OK_PNG_CHUNK_CGBI && chunk_type != OK_PNG_CHUNK_IHDR) { ok_png_error(png, OK_PNG_ERROR_INVALID, ""IHDR chunk must appear first""); return; } if (chunk_type == OK_PNG_CHUNK_IHDR) { hdr_found = true; success = ok_png_read_header(decoder, chunk_length); if (success && info_only) { if (png->has_alpha) { return; } } } else if (chunk_type == OK_PNG_CHUNK_CGBI) { success = ok_seek(decoder, (long)chunk_length); decoder->is_ios_format = true; } else if (chunk_type == OK_PNG_CHUNK_PLTE && !info_only) { success = ok_png_read_palette(decoder, chunk_length); } else if (chunk_type == OK_PNG_CHUNK_TRNS) { if (info_only) { png->has_alpha = true; return; } else { success = ok_png_read_transparency(decoder, chunk_length); } } else if (chunk_type == OK_PNG_CHUNK_IDAT) { if (info_only) { return; } success = ok_png_read_data(decoder, chunk_length); } else if (chunk_type == OK_PNG_CHUNK_IEND) { success = ok_seek(decoder, (long)chunk_length); end_found = true; } else { success = ok_seek(decoder, (long)chunk_length); } if (!success) { return; } if (!ok_read(decoder, chunk_footer, sizeof(chunk_footer))) { return; } } if (!decoder->decoding_completed) { ok_png_error(png, OK_PNG_ERROR_INVALID, ""Missing imaga data""); } }
Description: David Brackeen ok-file-formats 203defd is vulnerable to Buffer Overflow. When the function of the ok-file-formats project is used, a heap-buffer-overflow occurred in function ok_png_transform_scanline() in ""/ok_png.c:712"".
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static Image *ExtractPostscript(Image *image,const ImageInfo *image_info, MagickOffsetType PS_Offset,ssize_t PS_Size,ExceptionInfo *exception) { char postscript_file[MaxTextExtent]; const MagicInfo *magic_info; FILE *ps_file; ImageInfo *clone_info; Image *image2; unsigned char magick[2*MaxTextExtent]; if ((clone_info=CloneImageInfo(image_info)) == NULL) return(image); clone_info->blob=(void *) NULL; clone_info->length=0; (void) AcquireUniqueFilename(postscript_file); ps_file=fopen_utf8(postscript_file,""wb""); if (ps_file == (FILE *) NULL) goto FINISH; (void) SeekBlob(image,PS_Offset,SEEK_SET); (void) ReadBlob(image, 2*MaxTextExtent, magick); (void) SeekBlob(image,PS_Offset,SEEK_SET); while(PS_Size-- > 0) { (void) fputc(ReadBlobByte(image),ps_file); } (void) fclose(ps_file); magic_info=GetMagicInfo(magick,2*MaxTextExtent,exception); if(magic_info == (const MagicInfo *) NULL) goto FINISH_UNL; if(exception->severity != UndefinedException) goto FINISH_UNL; if(magic_info->name == (char *) NULL) goto FINISH_UNL; (void) strncpy(clone_info->magick,magic_info->name,MaxTextExtent-1); FormatLocaleString(clone_info->filename,MaxTextExtent,""%s"",postscript_file); image2=ReadImage(clone_info,exception); if (!image2) goto FINISH_UNL; (void) CopyMagickString(image2->filename,image->filename,MaxTextExtent); (void) CopyMagickString(image2->magick_filename,image->magick_filename,MaxTextExtent); (void) CopyMagickString(image2->magick,image->magick,MaxTextExtent); image2->depth=image->depth; DestroyBlob(image2); image2->blob=ReferenceBlob(image->blob); if ((image->rows == 0) || (image->columns == 0)) DeleteImageFromList(&image); AppendImageToList(&image,image2); FINISH_UNL: (void) RelinquishUniqueFileResource(postscript_file); FINISH: DestroyImageInfo(clone_info); return(image); }
Description: In ImageMagick 7.0.7-12 Q16, a large loop vulnerability was found in the function ExtractPostscript in coders/wpg.c, which allows attackers to cause a denial of service (CPU exhaustion) via a crafted wpg image file that triggers a ReadWPGImage call.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int uas_switch_interface(struct usb_device *udev, struct usb_interface *intf) { int alt; alt = uas_find_uas_alt_setting(intf); if (alt < 0) return alt; return usb_set_interface(udev, intf->altsetting[0].desc.bInterfaceNumber, alt); }
Description: The uas driver in the Linux kernel before 4.13.6 allows local users to cause a denial of service (out-of-bounds read and system crash) or possibly have unspecified other impact via a crafted USB device, related to drivers/usb/storage/uas-detect.h and drivers/usb/storage/uas.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static Image *ReadMAGICKImage(const ImageInfo *image_info, ExceptionInfo *exception) { const void *blob; Image *image; ImageInfo *blob_info; register ssize_t i; size_t extent; blob_info=CloneImageInfo(image_info); if (LocaleCompare(image_info->magick,""MAGICK"") != 0) (void) CopyMagickString(blob_info->filename,image_info->magick, MaxTextExtent); image=(Image *) NULL; blob=(const void *) NULL; extent=0; for (i=0; MagickImageList[i].blob != (const void *) NULL; i++) if (LocaleCompare(blob_info->filename,MagickImageList[i].name) == 0) { (void) CopyMagickString(blob_info->magick,MagickImageList[i].magick, MaxTextExtent); blob=MagickImageList[i].blob; extent=MagickImageList[i].extent; break; } if (blob == (const void *) NULL) ThrowReaderException(OptionError,""UnrecognizedImageFormat""); image=BlobToImage(blob_info,blob,extent,exception); blob_info=DestroyImageInfo(blob_info); if (image == (Image *) NULL) return(image); return(GetFirstImageInList(image)); }
Description: The ReadMAGICKImage function in coders/magick.c in ImageMagick 7.0.6-4 allows remote attackers to cause a denial of service (memory leak) via a crafted file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)  { if (prev_options != NULL) { *prev_options = MBREX(regex_default_options); } if (prev_syntax != NULL) { *prev_syntax = MBREX(regex_default_syntax); } MBREX(regex_default_options) = options; MBREX(regex_default_syntax) = syntax; }
Description: Double free vulnerability in the _php_mb_regex_ereg_replace_exec function in php_mbregex.c in the mbstring extension in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8 allows remote attackers to execute arbitrary code or cause a denial of service (application crash) by leveraging a callback exception.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void gf_media_update_bitrate_ex(GF_ISOFile *file, u32 track, Bool use_esd) { #ifndef GPAC_DISABLE_ISOM_WRITE u32 i, count, timescale, db_size, cdur, csize; u64 time_wnd, max_rate, avg_rate, bitrate; Double br; GF_ISOSample sample; db_size = 0; max_rate = avg_rate = time_wnd = bitrate = 0; csize = 0; cdur = 0; if (gf_isom_get_media_type(file, track)==GF_ISOM_MEDIA_AUDIO) { csize = gf_isom_get_constant_sample_size(file, track); cdur = gf_isom_get_constant_sample_duration(file, track); if (cdur > 1) cdur = 0; } memset(&sample, 0, sizeof(GF_ISOSample)); timescale = gf_isom_get_media_timescale(file, track); count = gf_isom_get_sample_count(file, track); if (csize && cdur) { db_size = 0; avg_rate = 8 * csize * timescale / cdur; bitrate = avg_rate; } else { u32 rate = 0; for (i=0; i<count; i++) { u32 di; GF_ISOSample *samp = gf_isom_get_sample_info_ex(file, track, i+1, &di, NULL, &sample); if (!samp) break; if (samp->dataLength > db_size) db_size = samp->dataLength; avg_rate += samp->dataLength; rate += samp->dataLength; if (samp->DTS > time_wnd + timescale) { if (rate > max_rate) max_rate = rate; time_wnd = samp->DTS; rate = 0; } } } br = (Double) (s64) gf_isom_get_media_duration(file, track); br /= timescale; if (br) { GF_ESD *esd = NULL; if (!csize || !cdur) { bitrate = (u32) ((Double) (s64)avg_rate / br); bitrate *= 8; max_rate *= 8; } if (!max_rate) max_rate = bitrate; if (use_esd) esd = gf_isom_get_esd(file, track, 1); if (esd && esd->decoderConfig) { esd->decoderConfig->avgBitrate = (u32) bitrate; esd->decoderConfig->maxBitrate = (u32) max_rate; esd->decoderConfig->bufferSizeDB = db_size; gf_isom_change_mpeg4_description(file, track, 1, esd); } else { gf_isom_update_bitrate(file, track, 1, (u32) bitrate, (u32) max_rate, db_size); } if (esd) gf_odf_desc_del((GF_Descriptor *)esd); } #endif }
Description: GPAC MP4Box 2.1-DEV-rev644-g5c4df2a67 is has an integer overflow in isomedia/isom_write.c
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void Node::RunForwardTypeInference() { VLOG(4) << ""Forward type inference: "" << props_->node_def.DebugString(); if (props_->fwd_type_fn == nullptr) { return; } std::vector<Node*> input_nodes(props_->input_types.size(), nullptr); std::vector<int> input_idx(props_->input_types.size(), 0); for (const auto& edge : in_edges_) { if (edge->IsControlEdge()) { continue; } DCHECK(edge->dst_input() < input_nodes.size()) << DebugString(); int i = edge->dst_input(); input_nodes.at(i) = edge->src(); input_idx.at(i) = edge->src_output(); } for (const auto* node : input_nodes) { if (node == nullptr) { ClearTypeInfo(); return; } } static FullTypeDef* no_type = new FullTypeDef(); std::vector<std::reference_wrapper<const FullTypeDef>> input_types; for (int i = 0; i < input_nodes.size(); i++) { const auto* node = input_nodes[i]; if (node->def().has_experimental_type()) { const auto& node_t = node->def().experimental_type(); if (node_t.type_id() != TFT_UNSET) { int ix = input_idx[i]; DCHECK(ix < node_t.args_size()) << ""input "" << i << "" should have an output "" << ix << "" but instead only has "" << node_t.args_size() << "" outputs: "" << node_t.DebugString(); input_types.emplace_back(node_t.args(ix)); } else { input_types.emplace_back(*no_type); } } else { ClearTypeInfo(); return; } } const auto infer_type = props_->fwd_type_fn(input_types); const FullTypeDef infer_typedef = infer_type.ValueOrDie(); if (infer_typedef.type_id() != TFT_UNSET) { MaybeCopyOnWrite(); *(props_->node_def.mutable_experimental_type()) = infer_typedef; } }
Description: Tensorflow is an Open Source Machine Learning Framework. TensorFlow's type inference can cause a heap out of bounds read as the bounds checking is done in a `DCHECK` (which is a no-op during production). An attacker can control the `input_idx` variable such that `ix` would be larger than the number of values in `node_t.args`. The fix will be included in TensorFlow 2.8.0. This is the only affected version.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void mt76_add_fragment(struct mt76_dev *dev, struct mt76_queue *q, void *data, int len, bool more) { struct page *page = virt_to_head_page(data); int offset = data - page_address(page); struct sk_buff *skb = q->rx_head; offset += q->buf_offset; skb_add_rx_frag(skb, skb_shinfo(skb)->nr_frags, page, offset, len, q->buf_size); if (more) return; q->rx_head = NULL; dev->drv->rx_skb(dev, q - dev->q_rx, skb); }
Description: An array overflow was discovered in mt76_add_fragment in drivers/net/wireless/mediatek/mt76/dma.c in the Linux kernel before 5.5.10, aka CID-b102f0c522cf. An oversized packet with too many rx fragments can corrupt memory of adjacent pages.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int main(int argc, char **argv) { int         i, n_valid, do_write, do_scrub; char       *c, *dname, *name; DIR        *dir; FILE       *fp; pdf_t      *pdf; pdf_flag_t  flags; if (argc < 2) usage(); do_write = do_scrub = flags = 0; name = NULL; for (i=1; i<argc; i++) { if (strncmp(argv[i], ""-w"", 2) == 0) do_write = 1; else if (strncmp(argv[i], ""-i"", 2) == 0) flags |= PDF_FLAG_DISP_CREATOR; else if (strncmp(argv[i], ""-q"", 2) == 0) flags |= PDF_FLAG_QUIET; else if (strncmp(argv[i], ""-s"", 2) == 0) do_scrub = 1; else if (argv[i][0] != '-') name = argv[i]; else if (argv[i][0] == '-') usage(); } if (!name) usage(); if (!(fp = fopen(name, ""r""))) { ERR(""Could not open file '%s'\n"", argv[1]); return -1; } else if (!pdf_is_pdf(fp)) { ERR(""'%s' specified is not a valid PDF\n"", name); fclose(fp); return -1; } if (!(pdf = init_pdf(fp, name))) { fclose(fp); return -1; } for (i=0, n_valid=0; i<pdf->n_xrefs; i++) if (pdf->xrefs[i].version) ++n_valid; if (n_valid < 2) { if (!(flags & (PDF_FLAG_QUIET | PDF_FLAG_DISP_CREATOR))) printf(""%s: There is only one version of this PDF\n"", pdf->name); if (do_write) { fclose(fp); pdf_delete(pdf); return 0; } } dname = NULL; if (do_write) { if ((c = strrchr(name, '/'))) name = c + 1; if ((c = strrchr(name, '.'))) *c = '\0'; dname = malloc(strlen(name) + 16); sprintf(dname, ""%s-versions"", name); if (!(dir = opendir(dname))) mkdir(dname, S_IRWXU); else { ERR(""This directory already exists, PDF version extraction will "" ""not occur.\n""); fclose(fp); closedir(dir); free(dname); pdf_delete(pdf); return -1; } for (i=0; i<pdf->n_xrefs; i++) if (pdf->xrefs[i].version) write_version(fp, name, dname, &pdf->xrefs[i]); } pdf_summarize(fp, pdf, dname, flags); if (do_scrub) scrub_document(fp, pdf); if (flags & PDF_FLAG_DISP_CREATOR) display_creator(fp, pdf); fclose(fp); free(dname); pdf_delete(pdf); return 0; }
Description: An issue was discovered in PDFResurrect before 0.18. pdf_load_pages_kids in pdf.c doesn't validate a certain size value, which leads to a malloc failure and out-of-bounds write.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int rsa_verify_hash_ex(const unsigned char *sig,      unsigned long siglen, const unsigned char *hash,     unsigned long hashlen, int            padding, int            hash_idx, unsigned long saltlen, int           *stat,     rsa_key      *key) { unsigned long modulus_bitlen, modulus_bytelen, x; int           err; unsigned char *tmpbuf; LTC_ARGCHK(hash  != NULL); LTC_ARGCHK(sig   != NULL); LTC_ARGCHK(stat  != NULL); LTC_ARGCHK(key   != NULL); *stat = 0; if ((padding != LTC_PKCS_1_V1_5) && (padding != LTC_PKCS_1_PSS)) { return CRYPT_PK_INVALID_PADDING; } if (padding == LTC_PKCS_1_PSS) { if ((err = hash_is_valid(hash_idx)) != CRYPT_OK) { return err; } } modulus_bitlen = mp_count_bits( (key->N)); modulus_bytelen = mp_unsigned_bin_size( (key->N)); if (modulus_bytelen != siglen) { return CRYPT_INVALID_PACKET; } tmpbuf = XMALLOC(siglen); if (tmpbuf == NULL) { return CRYPT_MEM; } x = siglen; if ((err = ltc_mp.rsa_me(sig, siglen, tmpbuf, &x, PK_PUBLIC, key)) != CRYPT_OK) { XFREE(tmpbuf); return err; } if (x != siglen) { XFREE(tmpbuf); return CRYPT_INVALID_PACKET; } if (padding == LTC_PKCS_1_PSS) { if(modulus_bitlen%8 == 1){ err = pkcs_1_pss_decode(hash, hashlen, tmpbuf+1, x-1, saltlen, hash_idx, modulus_bitlen, stat); } else{ err = pkcs_1_pss_decode(hash, hashlen, tmpbuf, x, saltlen, hash_idx, modulus_bitlen, stat); } } else { unsigned char *out; unsigned long outlen, loid[16]; int           decoded; ltc_asn1_list digestinfo[2], siginfo[2]; if (hash_descriptor[hash_idx].OIDlen == 0) { err = CRYPT_INVALID_ARG; goto bail_2; } outlen = ((modulus_bitlen >> 3) + (modulus_bitlen & 7 ? 1 : 0)) - 3; out    = XMALLOC(outlen); if (out == NULL) { err = CRYPT_MEM; goto bail_2; } if ((err = pkcs_1_v1_5_decode(tmpbuf, x, LTC_PKCS_1_EMSA, modulus_bitlen, out, &outlen, &decoded)) != CRYPT_OK) { XFREE(out); goto bail_2; } LTC_SET_ASN1(digestinfo, 0, LTC_ASN1_OBJECT_IDENTIFIER, loid, sizeof(loid)/sizeof(loid[0])); LTC_SET_ASN1(digestinfo, 1, LTC_ASN1_NULL,              NULL,                          0); LTC_SET_ASN1(siginfo,    0, LTC_ASN1_SEQUENCE,          digestinfo,                    2); LTC_SET_ASN1(siginfo,    1, LTC_ASN1_OCTET_STRING,      tmpbuf,                        siglen); if ((err = der_decode_sequence(out, outlen, siginfo, 2)) != CRYPT_OK) { XFREE(out); goto bail_2; } if ((digestinfo[0].size == hash_descriptor[hash_idx].OIDlen) && (XMEMCMP(digestinfo[0].data, hash_descriptor[hash_idx].OID, sizeof(unsigned long) * hash_descriptor[hash_idx].OIDlen) == 0) && (siginfo[1].size == hashlen) && (XMEMCMP(siginfo[1].data, hash, hashlen) == 0)) { *stat = 1; } #ifdef LTC_CLEAN_STACK zeromem(out, outlen); #endif XFREE(out); } bail_2: #ifdef LTC_CLEAN_STACK zeromem(tmpbuf, siglen); #endif XFREE(tmpbuf); return err; }
Description: The rsa_verify_hash_ex function in rsa_verify_hash.c in LibTomCrypt, as used in OP-TEE before 2.2.0, does not validate that the message length is equal to the ASN.1 encoded data length, which makes it easier for remote attackers to forge RSA signatures or public certificates by leveraging a Bleichenbacher signature forgery attack.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static ssize_t sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos) { int mxsize, cmd_size, k; int input_size, blocking; unsigned char opcode; Sg_device *sdp; Sg_fd *sfp; Sg_request *srp; struct sg_header old_hdr; sg_io_hdr_t *hp; unsigned char cmnd[SG_MAX_CDB_SIZE]; if ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp))) return -ENXIO; SCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp, ""sg_write: count=%d\n"", (int) count)); if (atomic_read(&sdp->detaching)) return -ENODEV; if (!((filp->f_flags & O_NONBLOCK) || scsi_block_when_processing_errors(sdp->device))) return -ENXIO; if (!access_ok(VERIFY_READ, buf, count)) return -EFAULT; if (count < SZ_SG_HEADER) return -EIO; if (__copy_from_user(&old_hdr, buf, SZ_SG_HEADER)) return -EFAULT; blocking = !(filp->f_flags & O_NONBLOCK); if (old_hdr.reply_len < 0) return sg_new_write(sfp, filp, buf, count, blocking, 0, 0, NULL); if (count < (SZ_SG_HEADER + 6)) return -EIO; if (!(srp = sg_add_request(sfp))) { SCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sdp, ""sg_write: queue full\n"")); return -EDOM; } buf += SZ_SG_HEADER; __get_user(opcode, buf); if (sfp->next_cmd_len > 0) { cmd_size = sfp->next_cmd_len; sfp->next_cmd_len = 0; } else { cmd_size = COMMAND_SIZE(opcode); if ((opcode >= 0xc0) && old_hdr.twelve_byte) cmd_size = 12; } SCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sdp, ""sg_write:   scsi opcode=0x%02x, cmd_size=%d\n"", (int) opcode, cmd_size)); input_size = count - cmd_size; mxsize = (input_size > old_hdr.reply_len) ? input_size : old_hdr.reply_len; mxsize -= SZ_SG_HEADER; input_size -= SZ_SG_HEADER; if (input_size < 0) { sg_remove_request(sfp, srp); return -EIO; } hp = &srp->header; hp->interface_id = '\0'; hp->cmd_len = (unsigned char) cmd_size; hp->iovec_count = 0; hp->mx_sb_len = 0; if (input_size > 0) hp->dxfer_direction = (old_hdr.reply_len > SZ_SG_HEADER) ? SG_DXFER_TO_FROM_DEV : SG_DXFER_TO_DEV; else hp->dxfer_direction = (mxsize > 0) ? SG_DXFER_FROM_DEV : SG_DXFER_NONE; hp->dxfer_len = mxsize; if ((hp->dxfer_direction == SG_DXFER_TO_DEV) || (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV)) hp->dxferp = (char __user *)buf + cmd_size; else hp->dxferp = NULL; hp->sbp = NULL; hp->timeout = old_hdr.reply_len; hp->flags = input_size; hp->pack_id = old_hdr.pack_id; hp->usr_ptr = NULL; if (__copy_from_user(cmnd, buf, cmd_size)) return -EFAULT; if (hp->dxfer_direction == SG_DXFER_TO_FROM_DEV) { static char cmd[TASK_COMM_LEN]; if (strcmp(current->comm, cmd)) { printk_ratelimited(KERN_WARNING ""sg_write: data in/out %d/%d bytes "" ""for SCSI command 0x%x-- guessing "" ""data in;\n   program %s not setting "" ""count and/or reply_len properly\n"", old_hdr.reply_len - (int)SZ_SG_HEADER, input_size, (unsigned int) cmnd[0], current->comm); strcpy(cmd, current->comm); } } k = sg_common_write(sfp, srp, cmnd, sfp->timeout, blocking); return (k < 0) ? k : count; }
Description: The sg implementation in the Linux kernel through 4.9 does not properly restrict write operations in situations where the KERNEL_DS option is set, which allows local users to read or write to arbitrary kernel memory locations or cause a denial of service (use-after-free) by leveraging access to a /dev/sg device, related to block/bsg.c and drivers/scsi/sg.c.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-9576.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static gboolean polkit_backend_interactive_authority_authentication_agent_response (PolkitBackendAuthority   *authority, PolkitSubject            *caller, uid_t                     uid, const gchar              *cookie, PolkitIdentity           *identity, GError                  **error) { PolkitBackendInteractiveAuthority *interactive_authority; PolkitBackendInteractiveAuthorityPrivate *priv; PolkitIdentity *user_of_caller; gchar *identity_str; AuthenticationSession *session; GList *l; gboolean ret; interactive_authority = POLKIT_BACKEND_INTERACTIVE_AUTHORITY (authority); priv = POLKIT_BACKEND_INTERACTIVE_AUTHORITY_GET_PRIVATE (interactive_authority); ret = FALSE; user_of_caller = NULL; identity_str = polkit_identity_to_string (identity); g_debug (""In authentication_agent_response for cookie '%s' and identity %s"", cookie, identity_str); user_of_caller = polkit_backend_session_monitor_get_user_for_subject (priv->session_monitor, caller, error); if (user_of_caller == NULL) goto out; if (!identity_is_root_user (user_of_caller)) { g_set_error (error, POLKIT_ERROR, POLKIT_ERROR_FAILED, ""Only uid 0 may invoke this method. This incident has been logged.""); goto out; } session = get_authentication_session_for_uid_and_cookie (interactive_authority, uid, cookie); if (session == NULL) { g_set_error (error, POLKIT_ERROR, POLKIT_ERROR_FAILED, ""No session for cookie""); goto out; } for (l = session->identities; l != NULL; l = l->next) { PolkitIdentity *i = POLKIT_IDENTITY (l->data); if (polkit_identity_equal (i, identity)) break; } if (l == NULL) { g_set_error (error, POLKIT_ERROR, POLKIT_ERROR_FAILED, ""The authenticated identity is wrong""); goto out; } session->is_authenticated = TRUE; session->authenticated_identity = g_object_ref (identity); ret = TRUE; out: g_free (identity_str); if (user_of_caller != NULL) g_object_unref (user_of_caller); return ret; }
Description: A flaw was found in polkit before version 0.116. The implementation of the polkit_backend_interactive_authority_check_authorization function in polkitd allows to test for authentication and trigger authentication of unrelated processes owned by other users. This may result in a local DoS and information disclosure.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static inline int compat_copy_match_to_user(struct ipt_entry_match *m, void __user **dstptr, compat_uint_t *size) { if (m->u.kernel.match->compat) return m->u.kernel.match->compat(m, dstptr, size, COMPAT_TO_USER); else return xt_compat_match(m, dstptr, size, COMPAT_TO_USER); }
Description: A heap out-of-bounds write affecting Linux since v2.6.19-rc1 was discovered in net/netfilter/x_tables.c. This allows an attacker to gain privileges or cause a DoS (via heap memory corruption) through user name space
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void gru_check_context_placement(struct gru_thread_state *gts) { struct gru_state *gru; gru = gts->ts_gru; if (!gru || gts->ts_tgid_owner != current->tgid) return; if (!gru_check_chiplet_assignment(gru, gts)) { STAT(check_context_unload); gru_unload_context(gts, 1); } else if (gru_retarget_intr(gts)) { STAT(check_context_retarget_intr); } }
Description: A use-after-free flaw was found in the Linux kernel’s SGI GRU driver in the way the first gru_file_unlocked_ioctl function is called by the user, where a fail pass occurs in the gru_check_chiplet_assignment function. This flaw allows a local user to crash or potentially escalate their privileges on the system.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int sd_isoc_init(struct gspca_dev *gspca_dev) { struct usb_host_interface *alt; int max_packet_size; switch (gspca_dev->pixfmt.width) { case 160: max_packet_size = 450; break; case 176: max_packet_size = 600; break; default: max_packet_size = 1022; break; } alt = &gspca_dev->dev->actconfig->intf_cache[0]->altsetting[1]; alt->endpoint[0].desc.wMaxPacketSize = cpu_to_le16(max_packet_size); return 0; }
Description: In the Linux kernel before 5.6.1, drivers/media/usb/gspca/xirlink_cit.c (aka the Xirlink camera USB driver) mishandles invalid descriptors, aka CID-a246b4d54770.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void h2o_http2_conn_unregister_stream(h2o_http2_conn_t *conn, h2o_http2_stream_t *stream) { h2o_http2_conn_preserve_stream_scheduler(conn, stream); khiter_t iter = kh_get(h2o_http2_stream_t, conn->streams, stream->stream_id); assert(iter != kh_end(conn->streams)); kh_del(h2o_http2_stream_t, conn->streams, iter); if (stream->req_body.state != H2O_HTTP2_REQ_BODY_NONE && stream->req_body.state < H2O_HTTP2_REQ_BODY_CLOSE_DELIVERED) { stream->req.proceed_req = NULL; set_req_body_state(conn, stream, H2O_HTTP2_REQ_BODY_CLOSE_DELIVERED); } if (stream->blocked_by_server) h2o_http2_stream_set_blocked_by_server(conn, stream, 0); switch (stream->state) { case H2O_HTTP2_STREAM_STATE_RECV_BODY: if (h2o_linklist_is_linked(&stream->_link)) h2o_linklist_unlink(&stream->_link); case H2O_HTTP2_STREAM_STATE_IDLE: case H2O_HTTP2_STREAM_STATE_RECV_HEADERS: assert(!h2o_linklist_is_linked(&stream->_link)); break; case H2O_HTTP2_STREAM_STATE_REQ_PENDING: assert(h2o_linklist_is_linked(&stream->_link)); h2o_linklist_unlink(&stream->_link); break; case H2O_HTTP2_STREAM_STATE_SEND_HEADERS: case H2O_HTTP2_STREAM_STATE_SEND_BODY: case H2O_HTTP2_STREAM_STATE_SEND_BODY_IS_FINAL: case H2O_HTTP2_STREAM_STATE_END_STREAM: if (h2o_linklist_is_linked(&stream->_link)) h2o_linklist_unlink(&stream->_link); break; } if (stream->state != H2O_HTTP2_STREAM_STATE_END_STREAM) h2o_http2_stream_set_state(conn, stream, H2O_HTTP2_STREAM_STATE_END_STREAM); if (conn->state < H2O_HTTP2_CONN_STATE_IS_CLOSING) { run_pending_requests(conn); update_idle_timeout(conn); } }
Description: The HTTP/2 protocol allows a denial of service (server resource consumption) because request cancellation can reset many streams quickly, as exploited in the wild in August through October 2023.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int v9fs_refresh_inode_dotl(struct p9_fid *fid, struct inode *inode) { loff_t i_size; struct p9_stat_dotl *st; struct v9fs_session_info *v9ses; v9ses = v9fs_inode2v9ses(inode); st = p9_client_getattr_dotl(fid, P9_STATS_ALL); if (IS_ERR(st)) return PTR_ERR(st); if ((inode->i_mode & S_IFMT) != (st->st_mode & S_IFMT)) goto out; spin_lock(&inode->i_lock); i_size = inode->i_size; v9fs_stat2inode_dotl(st, inode); if (v9ses->cache == CACHE_LOOSE || v9ses->cache == CACHE_FSCACHE) inode->i_size = i_size; spin_unlock(&inode->i_lock); out: kfree(st); return 0; }
Description: An issue was discovered in the Linux kernel before 5.0.4. The 9p filesystem did not protect i_size_write() properly, which causes an i_size_read() infinite loop and denial of service on SMP systems.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static struct cbq_class * cbq_classify(struct sk_buff *skb, struct Qdisc *sch, int *qerr) { struct cbq_sched_data *q = qdisc_priv(sch); struct cbq_class *head = &q->link; struct cbq_class **defmap; struct cbq_class *cl = NULL; u32 prio = skb->priority; struct tcf_proto *fl; struct tcf_result res; if (TC_H_MAJ(prio ^ sch->handle) == 0 && (cl = cbq_class_lookup(q, prio)) != NULL) return cl; *qerr = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS; for (;;) { int result = 0; defmap = head->defaults; fl = rcu_dereference_bh(head->filter_list); result = tcf_classify(skb, NULL, fl, &res, true); if (!fl || result < 0) goto fallback; cl = (void *)res.class; if (!cl) { if (TC_H_MAJ(res.classid)) cl = cbq_class_lookup(q, res.classid); else if ((cl = defmap[res.classid & TC_PRIO_MAX]) == NULL) cl = defmap[TC_PRIO_BESTEFFORT]; if (cl == NULL) goto fallback; } if (cl->level >= head->level) goto fallback; #ifdef CONFIG_NET_CLS_ACT switch (result) { case TC_ACT_QUEUED: case TC_ACT_STOLEN: case TC_ACT_TRAP: *qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN; fallthrough; case TC_ACT_SHOT: return NULL; case TC_ACT_RECLASSIFY: return cbq_reclassify(skb, cl); } #endif if (cl->level == 0) return cl; head = cl; } fallback: cl = head; if (TC_H_MAJ(prio) == 0 && !(cl = head->defaults[prio & TC_PRIO_MAX]) && !(cl = head->defaults[TC_PRIO_BESTEFFORT])) return head; return cl; }
Description: cbq_classify in net/sched/sch_cbq.c in the Linux kernel through 6.1.4 allows attackers to cause a denial of service (slab-out-of-bounds read) because of type confusion (non-negative numbers can sometimes indicate a TC_ACT_SHOT condition rather than valid classification results).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static MagickRealType ApplyEvaluateOperator(RandomInfo *random_info, const Quantum pixel,const MagickEvaluateOperator op, const MagickRealType value) { MagickRealType result; result=0.0; switch (op) { case UndefinedEvaluateOperator: break; case AbsEvaluateOperator: { result=(MagickRealType) fabs((double) (pixel+value)); break; } case AddEvaluateOperator: { result=(MagickRealType) (pixel+value); break; } case AddModulusEvaluateOperator: { result=pixel+value; result-=(QuantumRange+1.0)*floor((double) result/(QuantumRange+1.0)); break; } case AndEvaluateOperator: { result=(MagickRealType) ((size_t) pixel & (size_t) (value+0.5)); break; } case CosineEvaluateOperator: { result=(MagickRealType) (QuantumRange*(0.5*cos((double) (2.0*MagickPI* QuantumScale*pixel*value))+0.5)); break; } case DivideEvaluateOperator: { result=pixel/(value == 0.0 ? 1.0 : value); break; } case ExponentialEvaluateOperator: { result=(MagickRealType) (QuantumRange*exp((double) (value*QuantumScale* pixel))); break; } case GaussianNoiseEvaluateOperator: { result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel, GaussianNoise,value); break; } case ImpulseNoiseEvaluateOperator: { result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel, ImpulseNoise,value); break; } case LaplacianNoiseEvaluateOperator: { result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel, LaplacianNoise,value); break; } case LeftShiftEvaluateOperator: { result=(MagickRealType) ((size_t) pixel << (size_t) (value+0.5)); break; } case LogEvaluateOperator: { if ((QuantumScale*pixel) >= MagickEpsilon) result=(MagickRealType) (QuantumRange*log((double) (QuantumScale*value* pixel+1.0))/log((double) (value+1.0))); break; } case MaxEvaluateOperator: { result=(MagickRealType) EvaluateMax((double) pixel,value); break; } case MeanEvaluateOperator: { result=(MagickRealType) (pixel+value); break; } case MedianEvaluateOperator: { result=(MagickRealType) (pixel+value); break; } case MinEvaluateOperator: { result=(MagickRealType) MagickMin((double) pixel,value); break; } case MultiplicativeNoiseEvaluateOperator: { result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel, MultiplicativeGaussianNoise,value); break; } case MultiplyEvaluateOperator: { result=(MagickRealType) (value*pixel); break; } case OrEvaluateOperator: { result=(MagickRealType) ((size_t) pixel | (size_t) (value+0.5)); break; } case PoissonNoiseEvaluateOperator: { result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel, PoissonNoise,value); break; } case PowEvaluateOperator: { result=(MagickRealType) (QuantumRange*pow((double) (QuantumScale*pixel), (double) value)); break; } case RightShiftEvaluateOperator: { result=(MagickRealType) ((size_t) pixel >> (size_t) (value+0.5)); break; } case RootMeanSquareEvaluateOperator: { result=(MagickRealType) (pixel*pixel+value); break; } case SetEvaluateOperator: { result=value; break; } case SineEvaluateOperator: { result=(MagickRealType) (QuantumRange*(0.5*sin((double) (2.0*MagickPI* QuantumScale*pixel*value))+0.5)); break; } case SubtractEvaluateOperator: { result=(MagickRealType) (pixel-value); break; } case SumEvaluateOperator: { result=(MagickRealType) (pixel+value); break; } case ThresholdEvaluateOperator: { result=(MagickRealType) (((MagickRealType) pixel <= value) ? 0 : QuantumRange); break; } case ThresholdBlackEvaluateOperator: { result=(MagickRealType) (((MagickRealType) pixel <= value) ? 0 : pixel); break; } case ThresholdWhiteEvaluateOperator: { result=(MagickRealType) (((MagickRealType) pixel > value) ? QuantumRange : pixel); break; } case UniformNoiseEvaluateOperator: { result=(MagickRealType) GenerateDifferentialNoise(random_info,pixel, UniformNoise,value); break; } case XorEvaluateOperator: { result=(MagickRealType) ((size_t) pixel ^ (size_t) (value+0.5)); break; } } return(result); }
Description: In /MagickCore/statistic.c, there are several areas in ApplyEvaluateOperator() where a size_t cast should have been a ssize_t cast, which causes out-of-range values under some circumstances when a crafted input file is processed by ImageMagick. Red Hat Product Security marked this as Low severity because although it could potentially lead to an impact to application availability, no specific impact was shown in this case. This flaw affects ImageMagick versions prior to 6.9.10-69.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int java_switch_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) { ut8 op_byte = data[0]; ut64 offset = addr - java_get_method_start (); ut8 pos = (offset+1)%4 ? 1 + 4 - (offset+1)%4 : 1; if (op_byte == 0xaa) { if (pos + 8 > len) { return op->size; } int min_val = (ut32)(UINT (data, pos + 4)), max_val = (ut32)(UINT (data, pos + 8)); ut32 default_loc = (ut32) (UINT (data, pos)), cur_case = 0; op->switch_op = r_anal_switch_op_new (addr, min_val, default_loc); RAnalCaseOp *caseop = NULL; pos += 12; if (max_val > min_val && ((max_val - min_val)<(UT16_MAX/4))) { for (cur_case = 0; cur_case <= max_val - min_val; pos += 4, cur_case++) { if (pos + 4 >= len) { break; } int offset = (int)(ut32)(R_BIN_JAVA_UINT (data, pos)); caseop = r_anal_switch_op_add_case (op->switch_op, addr + pos, cur_case + min_val, addr + offset); if (caseop) { caseop->bb_ref_to = addr+offset; caseop->bb_ref_from = addr; } } } else { eprintf (""Invalid switch boundaries at 0x%""PFMT64x""\n"", addr); } } op->size = pos; return op->size; }
Description: There is a heap out of bounds read in radare2 2.6.0 in java_switch_op() in libr/anal/p/anal_java.c via a crafted Java binary file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: enum nss_status _nss_dns_gethostbyname4_r (const char *name, struct gaih_addrtuple **pat, char *buffer, size_t buflen, int *errnop, int *herrnop, int32_t *ttlp) { if (__res_maybe_init (&_res, 0) == -1) return NSS_STATUS_UNAVAIL; if (strchr (name, '.') == NULL) { char *tmp = alloca (NS_MAXDNAME); const char *cp = res_hostalias (&_res, name, tmp, NS_MAXDNAME); if (cp != NULL) name = cp; } union { querybuf *buf; u_char *ptr; } host_buffer; querybuf *orig_host_buffer; host_buffer.buf = orig_host_buffer = (querybuf *) alloca (2048); u_char *ans2p = NULL; int nans2p = 0; int resplen2 = 0; int ans2p_malloced = 0; int olderr = errno; enum nss_status status; int n = __libc_res_nsearch (&_res, name, C_IN, T_UNSPEC, host_buffer.buf->buf, 2048, &host_buffer.ptr, &ans2p, &nans2p, &resplen2, &ans2p_malloced); if (n >= 0) { status = gaih_getanswer (host_buffer.buf, n, (const querybuf *) ans2p, resplen2, name, pat, buffer, buflen, errnop, herrnop, ttlp); } else { switch (errno) { case ESRCH: status = NSS_STATUS_TRYAGAIN; h_errno = TRY_AGAIN; break; case EMFILE: case ENFILE: h_errno = NETDB_INTERNAL; case ECONNREFUSED: case ETIMEDOUT: status = NSS_STATUS_UNAVAIL; break; default: status = NSS_STATUS_NOTFOUND; break; } *herrnop = h_errno; if (h_errno == TRY_AGAIN) *errnop = EAGAIN; else __set_errno (olderr); } if (ans2p_malloced) free (ans2p); if (host_buffer.buf != orig_host_buffer) free (host_buffer.buf); return status; }
Description: res_query in libresolv in glibc before 2.25 allows remote attackers to cause a denial of service (NULL pointer dereference and process crash).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int jp2_cmap_getdata(jp2_box_t *box, jas_stream_t *in) { jp2_cmap_t *cmap = &box->data.cmap; jp2_cmapent_t *ent; unsigned int i; cmap->numchans = (box->datalen) / 4; if (!(cmap->ents = jas_alloc2(cmap->numchans, sizeof(jp2_cmapent_t)))) { return -1; } for (i = 0; i < cmap->numchans; ++i) { ent = &cmap->ents[i]; if (jp2_getuint16(in, &ent->cmptno) || jp2_getuint8(in, &ent->map) || jp2_getuint8(in, &ent->pcol)) { return -1; } } return 0; }
Description: The jp2_cdef_destroy function in jp2_cod.c in JasPer before 2.0.13 allows remote attackers to cause a denial of service (NULL pointer dereference) via a crafted image.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int rdma_listen(struct rdma_cm_id *id, int backlog) { struct rdma_id_private *id_priv = container_of(id, struct rdma_id_private, id); int ret; if (!cma_comp_exch(id_priv, RDMA_CM_ADDR_BOUND, RDMA_CM_LISTEN)) { id->route.addr.src_addr.ss_family = AF_INET; ret = rdma_bind_addr(id, cma_src_addr(id_priv)); if (ret) return ret; if (WARN_ON(!cma_comp_exch(id_priv, RDMA_CM_ADDR_BOUND, RDMA_CM_LISTEN))) return -EINVAL; } if (id_priv->reuseaddr) { mutex_lock(&lock); ret = cma_check_port(id_priv->bind_list, id_priv, 0); if (!ret) id_priv->reuseaddr = 0; mutex_unlock(&lock); if (ret) goto err; } id_priv->backlog = backlog; if (id_priv->cma_dev) { if (rdma_cap_ib_cm(id->device, 1)) { ret = cma_ib_listen(id_priv); if (ret) goto err; } else if (rdma_cap_iw_cm(id->device, 1)) { ret = cma_iw_listen(id_priv, backlog); if (ret) goto err; } else { ret = -ENOSYS; goto err; } } else { ret = cma_listen_on_all(id_priv); if (ret) goto err; } return 0; err: id_priv->backlog = 0; cma_comp_exch(id_priv, RDMA_CM_LISTEN, RDMA_CM_ADDR_BOUND); return ret; }
Description: A flaw in the Linux kernel's implementation of RDMA communications manager listener code allowed an attacker with local access to setup a socket to listen on a high port allowing for a list element to be used after free. Given the ability to execute code, a local attacker could leverage this use-after-free to crash the system or possibly escalate privileges on the system.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int dissect_xra_tlv_burst_info(tvbuff_t * tvb, proto_tree * tree, void* data _U_, guint16 tlv_length) { proto_item *it; proto_tree *xra_tlv_burst_info_tree; it = proto_tree_add_item (tree, hf_xra_tlv_burst_info, tvb, 0, tlv_length, ENC_NA); xra_tlv_burst_info_tree = proto_item_add_subtree (it, ett_xra_tlv_burst_info); guint32 tlv_index =0; while (tlv_index < tlv_length) { guint8 type = tvb_get_guint8 (tvb, tlv_index); ++tlv_index; guint8 length = tvb_get_guint8 (tvb, tlv_index); ++tlv_index; switch (type) { case XRA_BURST_INFO_BURST_ID_REFERENCE: proto_tree_add_item (xra_tlv_burst_info_tree, hf_xra_tlv_burst_info_burst_id_reference, tvb, tlv_index, length, ENC_BIG_ENDIAN); break; case XRA_US_CHANNEL_ID: proto_tree_add_item (xra_tlv_burst_info_tree, hf_xra_tlv_us_channel_id, tvb, tlv_index, length, ENC_BIG_ENDIAN); break; case XRA_SID: proto_tree_add_item (xra_tlv_burst_info_tree, hf_xra_tlv_sid, tvb, tlv_index, length, ENC_BIG_ENDIAN); break; case XRA_IUC: proto_tree_add_item (xra_tlv_burst_info_tree, hf_xra_tlv_iuc, tvb, tlv_index, length, ENC_BIG_ENDIAN); break; default: proto_tree_add_item (xra_tlv_burst_info_tree, hf_xra_unknown, tvb, tlv_index, length, ENC_NA); break; } tlv_index+=length; } return tvb_captured_length(tvb); }
Description: XRA dissector infinite loop in Wireshark 4.0.0 to 4.0.5 and 3.6.0 to 3.6.13 allows denial of service via packet injection or crafted capture file
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool handleBackslash(signed char& out) { char ch = *p++; switch (ch) { case 0: return false; case '""': out = ch; return true; case '\\': out = ch; return true; case '/': out = ch; return true; case 'b': out = '\b'; return true; case 'f': out = '\f'; return true; case 'n': out = '\n'; return true; case 'r': out = '\r'; return true; case 't': out = '\t'; return true; case 'u': { if (UNLIKELY(is_tsimplejson)) { auto const ch1 = *p++; auto const ch2 = *p++; auto const dch3 = dehexchar(*p++); auto const dch4 = dehexchar(*p++); if (UNLIKELY(ch1 != '0' || ch2 != '0' || dch3 < 0 || dch4 < 0)) { return false; } out = (dch3 << 4) | dch4; return true; } else { uint16_t u16cp = 0; for (int i = 0; i < 4; i++) { auto const hexv = dehexchar(*p++); if (hexv < 0) return false;             u16cp <<= 4; u16cp |= hexv; } if (u16cp > 0x7f) { return false; } else { out = u16cp; return true; } } } default: return false; } }
Description: Insufficient boundary checks when decoding JSON in handleBackslash reads out of bounds memory, potentially leading to DOS. This issue affects HHVM 4.45.0, 4.44.0, 4.43.0, 4.42.0, 4.41.0, 4.40.0, 4.39.0, versions between 4.33.0 and 4.38.0 (inclusive), versions between 4.9.0 and 4.32.0 (inclusive), and versions prior to 4.8.7.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int krb5_authenticate(struct ksmbd_work *work) { struct smb2_sess_setup_req *req = work->request_buf; struct smb2_sess_setup_rsp *rsp = work->response_buf; struct ksmbd_conn *conn = work->conn; struct ksmbd_session *sess = work->sess; char *in_blob, *out_blob; struct channel *chann = NULL; u64 prev_sess_id; int in_len, out_len; int retval; in_blob = (char *)&req->hdr.ProtocolId + le16_to_cpu(req->SecurityBufferOffset); in_len = le16_to_cpu(req->SecurityBufferLength); out_blob = (char *)&rsp->hdr.ProtocolId + le16_to_cpu(rsp->SecurityBufferOffset); out_len = work->response_sz - offsetof(struct smb2_hdr, smb2_buf_length) - le16_to_cpu(rsp->SecurityBufferOffset); prev_sess_id = le64_to_cpu(req->PreviousSessionId); if (prev_sess_id && prev_sess_id != sess->id) destroy_previous_session(sess->user, prev_sess_id); if (sess->state == SMB2_SESSION_VALID) ksmbd_free_user(sess->user); retval = ksmbd_krb5_authenticate(sess, in_blob, in_len, out_blob, &out_len); if (retval) { ksmbd_debug(SMB, ""krb5 authentication failed\n""); return -EINVAL; } rsp->SecurityBufferLength = cpu_to_le16(out_len); inc_rfc1001_len(rsp, out_len - 1); if ((conn->sign || server_conf.enforced_signing) || (req->SecurityMode & SMB2_NEGOTIATE_SIGNING_REQUIRED)) sess->sign = true; if ((conn->vals->capabilities & SMB2_GLOBAL_CAP_ENCRYPTION) && conn->ops->generate_encryptionkey) { retval = conn->ops->generate_encryptionkey(sess); if (retval) { ksmbd_debug(SMB, ""SMB3 encryption key generation failed\n""); return -EINVAL; } sess->enc = true; rsp->SessionFlags = SMB2_SESSION_FLAG_ENCRYPT_DATA_LE; sess->sign = false; } if (conn->dialect >= SMB30_PROT_ID) { chann = lookup_chann_list(sess, conn); if (!chann) { chann = kmalloc(sizeof(struct channel), GFP_KERNEL); if (!chann) return -ENOMEM; chann->conn = conn; INIT_LIST_HEAD(&chann->chann_list); list_add(&chann->chann_list, &sess->ksmbd_chann_list); } } if (conn->ops->generate_signingkey) { retval = conn->ops->generate_signingkey(sess, conn); if (retval) { ksmbd_debug(SMB, ""SMB3 signing key generation failed\n""); return -EINVAL; } } if (conn->dialect > SMB20_PROT_ID) { if (!ksmbd_conn_lookup_dialect(conn)) { pr_err(""fail to verify the dialect\n""); return -ENOENT; } } return 0; }
Description: The ksmbd server through 3.4.2, as used in the Linux kernel through 5.15.8, sometimes communicates in cleartext even though encryption has been enabled. This occurs because it sets the SMB2_GLOBAL_CAP_ENCRYPTION flag when using the SMB 3.1.1 protocol, which is a violation of the SMB protocol specification. When Windows 10 detects this protocol violation, it disables encryption.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static guint8 elem_dtmf_chars(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, guint32 offset, guint len, ansi_a_shared_data_t *data_p) { guint32     curr_offset; guint8      packed_len; const char *str; curr_offset = offset; proto_tree_add_item(tree, hf_ansi_a_bdtmf_chars_num_chars, tvb, curr_offset, 1, ENC_BIG_ENDIAN); curr_offset++; if (curr_offset - offset >= len)  return (curr_offset - offset); packed_len = len - (curr_offset - offset); str = tvb_bcd_dig_to_wmem_packet_str(tvb, curr_offset, packed_len, &Dgt_dtmf, FALSE); proto_tree_add_string(tree, hf_ansi_a_bdtmf_chars_digits, tvb, curr_offset, packed_len, str); proto_item_append_text(data_p->elem_item, "" - (%s)"", str); curr_offset += packed_len; EXTRANEOUS_DATA_CHECK(len, curr_offset - offset); return(curr_offset - offset); }
Description: The Mobile Identity parser in (1) epan/dissectors/packet-ansi_a.c in the ANSI A dissector and (2) epan/dissectors/packet-gsm_a_common.c in the GSM A dissector in Wireshark 1.12.x before 1.12.9 and 2.0.x before 2.0.1 improperly uses the tvb_bcd_dig_to_wmem_packet_str function, which allows remote attackers to cause a denial of service (buffer overflow and application crash) via a crafted packet.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void emcute_run(uint16_t port, const char *id) { assert(strlen(id) >= MQTTSN_CLI_ID_MINLEN && strlen(id) <= MQTTSN_CLI_ID_MAXLEN); sock_udp_ep_t local = SOCK_IPV6_EP_ANY; sock_udp_ep_t remote; local.port = port; cli_id = id; timer.callback = time_evt; timer.arg = NULL; mutex_init(&txlock); if (sock_udp_create(&sock, &local, NULL, 0) < 0) { LOG_ERROR(""[emcute] unable to open UDP socket on port %i\n"", (int)port); return; } uint32_t start = xtimer_now_usec(); uint32_t t_out = (EMCUTE_KEEPALIVE * US_PER_SEC); while (1) { ssize_t len = sock_udp_recv(&sock, rbuf, sizeof(rbuf), t_out, &remote); if ((len < 0) && (len != -ETIMEDOUT)) { LOG_ERROR(""[emcute] error while receiving UDP packet\n""); return; } if (len >= 2) { uint16_t pkt_len; if ((len == 2) && (rbuf[0] == 0x01)) { continue; } size_t pos = get_len(rbuf, &pkt_len); if (((size_t)pkt_len > (size_t)len) || (pos >= (size_t)len)) { continue; } uint8_t type = rbuf[pos]; switch (type) { case CONNACK:       on_ack(type, 0, 2, 0);              break; case WILLTOPICREQ:  on_ack(type, 0, 0, 0);              break; case WILLMSGREQ:    on_ack(type, 0, 0, 0);              break; case REGACK:        on_ack(type, 4, 6, 2);              break; case PUBLISH:       on_publish((size_t)pkt_len, pos);   break; case PUBACK:        on_ack(type, 4, 6, 0);              break; case SUBACK:        on_ack(type, 5, 7, 3);              break; case UNSUBACK:      on_ack(type, 2, 0, 0);              break; case PINGREQ:       on_pingreq(&remote);                break; case PINGRESP:      on_pingresp();                      break; case DISCONNECT:    on_disconnect();                    break; case WILLTOPICRESP: on_ack(type, 0, 0, 0);              break; case WILLMSGRESP:   on_ack(type, 0, 0, 0);              break; default: LOG_DEBUG(""[emcute] received unexpected type [%s]\n"", emcute_type_str(type)); } } uint32_t now = xtimer_now_usec(); if ((now - start) >= (EMCUTE_KEEPALIVE * US_PER_SEC)) { send_ping(); start = now; t_out = (EMCUTE_KEEPALIVE * US_PER_SEC); } else { t_out = (EMCUTE_KEEPALIVE * US_PER_SEC) - (now - start); } } }
Description: In RIOT 2019.07, the MQTT-SN implementation (asymcute) mishandles errors occurring during a read operation on a UDP socket. The receive loop ends. This allows an attacker (via a large packet) to prevent a RIOT MQTT-SN client from working until the device is restarted.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: PolkitIdentity * polkit_unix_group_new (gint gid) { return POLKIT_IDENTITY (g_object_new (POLKIT_TYPE_UNIX_GROUP, ""gid"", gid, NULL)); }
Description: A flaw was found in PolicyKit (aka polkit) 0.115 that allows a user with a uid greater than INT_MAX to successfully execute any systemctl command.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void* _TIFFmalloc(tmsize_t s) { return (malloc((size_t) s)); }
Description: The _TIFFmalloc function in tif_unix.c in LibTIFF 4.0.3 does not reject a zero size, which allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted TIFF image that is mishandled by the TIFFWriteScanline function in tif_write.c, as demonstrated by tiffdither.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: BOOL planar_decompress(BITMAP_PLANAR_CONTEXT* planar, const BYTE* pSrcData, UINT32 SrcSize, UINT32 nSrcWidth, UINT32 nSrcHeight, BYTE* pDstData, UINT32 DstFormat, UINT32 nDstStep, UINT32 nXDst, UINT32 nYDst, UINT32 nDstWidth, UINT32 nDstHeight, BOOL vFlip) { BOOL cs; BOOL rle; UINT32 cll; BOOL alpha; BOOL useAlpha = FALSE; INT32 status; const BYTE* srcp; UINT32 subSize; UINT32 subWidth; UINT32 subHeight; UINT32 planeSize; INT32 rleSizes[4] = { 0, 0, 0, 0 }; UINT32 rawSizes[4]; UINT32 rawWidths[4]; UINT32 rawHeights[4]; BYTE FormatHeader; const BYTE* planes[4] = { 0 }; const UINT32 w = MIN(nSrcWidth, nDstWidth); const UINT32 h = MIN(nSrcHeight, nDstHeight); const primitives_t* prims = primitives_get(); WINPR_ASSERT(planar); WINPR_ASSERT(prims); if (nDstStep <= 0) nDstStep = nDstWidth * FreeRDPGetBytesPerPixel(DstFormat); srcp = pSrcData; if (!pSrcData) { WLog_ERR(TAG, ""Invalid argument pSrcData=NULL""); return FALSE; } if (!pDstData) { WLog_ERR(TAG, ""Invalid argument pDstData=NULL""); return FALSE; } FormatHeader = *srcp++; cll = (FormatHeader & PLANAR_FORMAT_HEADER_CLL_MASK); cs = (FormatHeader & PLANAR_FORMAT_HEADER_CS) ? TRUE : FALSE; rle = (FormatHeader & PLANAR_FORMAT_HEADER_RLE) ? TRUE : FALSE; alpha = (FormatHeader & PLANAR_FORMAT_HEADER_NA) ? FALSE : TRUE; DstFormat = planar_invert_format(planar, alpha, DstFormat); if (alpha) useAlpha = FreeRDPColorHasAlpha(DstFormat); if (!cll && cs) { WLog_ERR(TAG, ""Chroma subsampling requires YCoCg and does not work with RGB data""); return FALSE;  } subWidth = (nSrcWidth / 2) + (nSrcWidth % 2); subHeight = (nSrcHeight / 2) + (nSrcHeight % 2); planeSize = nSrcWidth * nSrcHeight; subSize = subWidth * subHeight; if (!cs) { rawSizes[0] = planeSize;  rawWidths[0] = nSrcWidth; rawHeights[0] = nSrcHeight; rawSizes[1] = planeSize;  rawWidths[1] = nSrcWidth; rawHeights[1] = nSrcHeight; rawSizes[2] = planeSize;  rawWidths[2] = nSrcWidth; rawHeights[2] = nSrcHeight; rawSizes[3] = planeSize;  rawWidths[3] = nSrcWidth; rawHeights[3] = nSrcHeight; } else  { rawSizes[0] = planeSize;  rawWidths[0] = nSrcWidth; rawHeights[0] = nSrcHeight; rawSizes[1] = subSize;  rawWidths[1] = subWidth; rawHeights[1] = subHeight; rawSizes[2] = subSize;  rawWidths[2] = subWidth; rawHeights[2] = subHeight; rawSizes[3] = planeSize;  rawWidths[3] = nSrcWidth; rawHeights[3] = nSrcHeight; } if (!rle)  { UINT32 base = planeSize * 3; if (cs) base = planeSize + planeSize / 2; if (alpha) { if ((SrcSize - (srcp - pSrcData)) < (planeSize + base)) { WLog_ERR(TAG, ""Alpha plane size mismatch %"" PRIu32 "" < %"" PRIu32, SrcSize - (srcp - pSrcData), (planeSize + base)); return FALSE; } planes[3] = srcp;                     planes[0] = planes[3] + rawSizes[3];  planes[1] = planes[0] + rawSizes[0];  planes[2] = planes[1] + rawSizes[1];  if ((planes[2] + rawSizes[2]) > &pSrcData[SrcSize]) { WLog_ERR(TAG, ""plane size mismatch %p + %"" PRIu32 "" > %p"", planes[2], rawSizes[2], &pSrcData[SrcSize]); return FALSE; } } else { if ((SrcSize - (srcp - pSrcData)) < base) { WLog_ERR(TAG, ""plane size mismatch %"" PRIu32 "" < %"" PRIu32, SrcSize - (srcp - pSrcData), base); return FALSE; } planes[0] = srcp;                     planes[1] = planes[0] + rawSizes[0];  planes[2] = planes[1] + rawSizes[1];  if ((planes[2] + rawSizes[2]) > &pSrcData[SrcSize]) { WLog_ERR(TAG, ""plane size mismatch %p + %"" PRIu32 "" > %p"", planes[2], rawSizes[2], &pSrcData[SrcSize]); return FALSE; } } } else  { if (alpha) { planes[3] = srcp; rleSizes[3] = planar_skip_plane_rle(planes[3], SrcSize - (planes[3] - pSrcData), rawWidths[3], rawHeights[3]);  if (rleSizes[3] < 0) return FALSE; planes[0] = planes[3] + rleSizes[3]; } else planes[0] = srcp; rleSizes[0] = planar_skip_plane_rle(planes[0], SrcSize - (planes[0] - pSrcData), rawWidths[0], rawHeights[0]);  if (rleSizes[0] < 0) return FALSE; planes[1] = planes[0] + rleSizes[0]; rleSizes[1] = planar_skip_plane_rle(planes[1], SrcSize - (planes[1] - pSrcData), rawWidths[1], rawHeights[1]);  if (rleSizes[1] < 1) return FALSE; planes[2] = planes[1] + rleSizes[1]; rleSizes[2] = planar_skip_plane_rle(planes[2], SrcSize - (planes[2] - pSrcData), rawWidths[2], rawHeights[2]);  if (rleSizes[2] < 1) return FALSE; } if (!cll)  { UINT32 TempFormat; BYTE* pTempData = pDstData; UINT32 nTempStep = nDstStep; UINT32 nTotalHeight = nYDst + nDstHeight; if (useAlpha) TempFormat = PIXEL_FORMAT_BGRA32; else TempFormat = PIXEL_FORMAT_BGRX32; TempFormat = planar_invert_format(planar, alpha, TempFormat); if ((TempFormat != DstFormat) || (nSrcWidth != nDstWidth) || (nSrcHeight != nDstHeight)) { pTempData = planar->pTempData; nTempStep = planar->nTempStep; nTotalHeight = planar->maxHeight; } if (!rle)  { if (!planar_decompress_planes_raw(planes, pTempData, TempFormat, nTempStep, nXDst, nYDst, nSrcWidth, nSrcHeight, vFlip, nTotalHeight)) return FALSE; if (alpha) srcp += rawSizes[0] + rawSizes[1] + rawSizes[2] + rawSizes[3]; else  srcp += rawSizes[0] + rawSizes[1] + rawSizes[2]; if ((SrcSize - (srcp - pSrcData)) == 1) srcp++;  } else  { status = planar_decompress_plane_rle(planes[0], rleSizes[0], pTempData, nTempStep, nXDst, nYDst, nSrcWidth, nSrcHeight, 2, vFlip);  if (status < 0) return FALSE; status = planar_decompress_plane_rle(planes[1], rleSizes[1], pTempData, nTempStep, nXDst, nYDst, nSrcWidth, nSrcHeight, 1, vFlip);  if (status < 0) return FALSE; status = planar_decompress_plane_rle(planes[2], rleSizes[2], pTempData, nTempStep, nXDst, nYDst, nSrcWidth, nSrcHeight, 0, vFlip);  if (status < 0) return FALSE; srcp += rleSizes[0] + rleSizes[1] + rleSizes[2]; if (useAlpha) { status = planar_decompress_plane_rle(planes[3], rleSizes[3], pTempData, nTempStep, nXDst, nYDst, nSrcWidth, nSrcHeight, 3, vFlip);  } else status = planar_set_plane(0xFF, pTempData, nTempStep, nXDst, nYDst, nSrcWidth, nSrcHeight, 3, vFlip); if (status < 0) return FALSE; if (alpha) srcp += rleSizes[3]; } if (pTempData != pDstData) { if (!freerdp_image_copy(pDstData, DstFormat, nDstStep, nXDst, nYDst, w, h, pTempData, TempFormat, nTempStep, nXDst, nYDst, NULL, FREERDP_FLIP_NONE)) { WLog_ERR(TAG, ""planar image copy failed""); return FALSE; } } } else  { UINT32 TempFormat; BYTE* pTempData = planar->pTempData; UINT32 nTempStep = planar->nTempStep; UINT32 nTotalHeight = planar->maxHeight; BYTE* dst = &pDstData[nXDst * FreeRDPGetBytesPerPixel(DstFormat) + nYDst * nDstStep]; if (useAlpha) TempFormat = PIXEL_FORMAT_BGRA32; else TempFormat = PIXEL_FORMAT_BGRX32; if (!pTempData) { return FALSE; } if (rle)  { BYTE* rleBuffer[4] = { 0 }; rleBuffer[3] = planar->rlePlanesBuffer;   rleBuffer[0] = rleBuffer[3] + planeSize;  rleBuffer[1] = rleBuffer[0] + planeSize;  rleBuffer[2] = rleBuffer[1] + planeSize;  if (useAlpha) { status = planar_decompress_plane_rle_only(planes[3], rleSizes[3], rleBuffer[3], rawWidths[3], rawHeights[3]);  if (status < 0) return FALSE; } if (alpha) srcp += rleSizes[3]; status = planar_decompress_plane_rle_only(planes[0], rleSizes[0], rleBuffer[0], rawWidths[0], rawHeights[0]);  if (status < 0) return FALSE; status = planar_decompress_plane_rle_only(planes[1], rleSizes[1], rleBuffer[1], rawWidths[1], rawHeights[1]);  if (status < 0) return FALSE; status = planar_decompress_plane_rle_only(planes[2], rleSizes[2], rleBuffer[2], rawWidths[2], rawHeights[2]);  if (status < 0) return FALSE; planes[0] = rleBuffer[0]; planes[1] = rleBuffer[1]; planes[2] = rleBuffer[2]; planes[3] = rleBuffer[3]; } { if (cs) {  if (!planar_subsample_expand(planes[1], rawSizes[1], nSrcWidth, nSrcHeight, rawWidths[1], rawHeights[1], planar->deltaPlanes[0])) return FALSE; planes[1] = planar->deltaPlanes[0]; rawSizes[1] = planeSize;  rawWidths[1] = nSrcWidth; rawHeights[1] = nSrcHeight; if (!planar_subsample_expand(planes[2], rawSizes[2], nSrcWidth, nSrcHeight, rawWidths[2], rawHeights[2], planar->deltaPlanes[1])) return FALSE; planes[2] = planar->deltaPlanes[1]; rawSizes[2] = planeSize;  rawWidths[2] = nSrcWidth; rawHeights[2] = nSrcHeight; } if (!planar_decompress_planes_raw(planes, pTempData, TempFormat, nTempStep, nXDst, nYDst, nSrcWidth, nSrcHeight, vFlip, nTotalHeight)) return FALSE; if (alpha) srcp += rawSizes[0] + rawSizes[1] + rawSizes[2] + rawSizes[3]; else  srcp += rawSizes[0] + rawSizes[1] + rawSizes[2]; if ((SrcSize - (srcp - pSrcData)) == 1) srcp++;  } WINPR_ASSERT(prims->YCoCgToRGB_8u_AC4R); int rc = prims->YCoCgToRGB_8u_AC4R(pTempData, nTempStep, dst, DstFormat, nDstStep, w, h, cll, useAlpha); if (rc != PRIMITIVES_SUCCESS) { WLog_ERR(TAG, ""YCoCgToRGB_8u_AC4R failed with %d"", rc); return FALSE; } } WINPR_UNUSED(srcp); return TRUE; }
Description: FreeRDP is a free implementation of the Remote Desktop Protocol (RDP), released under the Apache license. Versions of FreeRDP on the 3.x release branch before beta3 are subject to a Use-After-Free in processing `RDPGFX_CMDID_RESETGRAPHICS` packets. If `context->maxPlaneSize` is 0, `context->planesBuffer` will be freed. However, without updating `context->planesBuffer`, this leads to a Use-After-Free exploit vector. In most environments this should only result in a crash. This issue has been addressed in version 3.0.0-beta3 and users of the beta 3.x releases are advised to upgrade. There are no known workarounds for this vulnerability.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: GF_EXPORT GF_3GPConfig *gf_isom_3gp_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 StreamDescriptionIndex) { GF_3GPConfig *config, *res; GF_TrackBox *trak; GF_SampleEntryBox *entry; trak = gf_isom_get_track_from_file(the_file, trackNumber); if (!trak || !StreamDescriptionIndex) return NULL; config = NULL; entry = (GF_SampleEntryBox *)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, StreamDescriptionIndex-1); if (!entry) return NULL; switch (entry->type) { case GF_ISOM_SUBTYPE_3GP_AMR: case GF_ISOM_SUBTYPE_3GP_AMR_WB: case GF_ISOM_SUBTYPE_3GP_EVRC: case GF_ISOM_SUBTYPE_3GP_QCELP: case GF_ISOM_SUBTYPE_3GP_SMV: if (! ((GF_MPEGAudioSampleEntryBox*)entry)->cfg_3gpp) return NULL; config = & ((GF_MPEGAudioSampleEntryBox*)entry)->cfg_3gpp->cfg; break; case GF_ISOM_SUBTYPE_3GP_H263: if (! ((GF_MPEGVisualSampleEntryBox*)entry)->cfg_3gpp) return NULL; config = & ((GF_MPEGVisualSampleEntryBox*)entry)->cfg_3gpp->cfg; break; default: return NULL; } if (!config) return NULL; res = (GF_3GPConfig*)gf_malloc(sizeof(GF_3GPConfig)); if (res) memcpy(res, config, sizeof(GF_3GPConfig)); return res; }
Description: A heap-based buffer overflow vulnerability exists in GPAC v1.0.1 in the gf_isom_dovi_config_get function in MP4Box, which causes a denial of service or execute arbitrary code via a crafted file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void ExtensionViewGuest::DidNavigateMainFrame( const content::LoadCommittedDetails& details, const content::FrameNavigateParams& params) { if (attached() && (params.url.GetOrigin() != url_.GetOrigin())) { bad_message::ReceivedBadMessage(web_contents()->GetRenderProcessHost(), bad_message::EVG_BAD_ORIGIN); } }
Description: The Extensions subsystem in Google Chrome before 50.0.2661.75 incorrectly relies on GetOrigin method calls for origin comparisons, which allows remote attackers to bypass the Same Origin Policy and obtain sensitive information via a crafted extension.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void SExpressionWasmBuilder::parseFunction(Element& s, bool preParseImport) { size_t i = 1; Name name, exportName; i = parseFunctionNames(s, name, exportName); if (!preParseImport) { if (!name.is()) { name = Name::fromInt(functionCounter); } functionCounter++; } else { if (!name.is()) { name = functionNames[functionCounter - 1]; } } if (exportName.is()) { auto ex = make_unique<Export>(); ex->name = exportName; ex->value = name; ex->kind = ExternalKind::Function; if (wasm.getExportOrNull(ex->name)) throw ParseException(""duplicate export"", s.line, s.col); wasm.addExport(ex.release()); } Expression* body = nullptr; localIndex = 0; otherIndex = 0; brokeToAutoBlock = false; std::vector<NameType> typeParams;   std::vector<NameType> params; std::vector<NameType> vars; Type result = none; Name type; Block* autoBlock = nullptr;   Name importModule, importBase; auto makeFunction = [&]() { currFunction = std::unique_ptr<Function>(Builder(wasm).makeFunction( name, std::move(params), result, std::move(vars) )); }; auto ensureAutoBlock = [&]() { if (!autoBlock) { autoBlock = allocator.alloc<Block>(); autoBlock->list.push_back(body); body = autoBlock; } }; for (;i < s.size(); i++) { Element& curr = *s[i]; IString id = curr[0]->str(); if (id == PARAM || id == LOCAL) { size_t j = 1; while (j < curr.size()) { IString name; Type type = none; if (!curr[j]->dollared()) {           type = stringToType(curr[j]->str(), true); } if (type != none) { name = Name::fromInt(localIndex); } else { name = curr[j]->str(); type = stringToType(curr[j+1]->str()); j++; } j++; if (id == PARAM) { params.emplace_back(name, type); } else { vars.emplace_back(name, type); } localIndex++; currLocalTypes[name] = type; } } else if (id == RESULT) { if (curr.size() > 2) throw ParseException(""invalid result arity"", curr.line, curr.col); result = stringToType(curr[1]->str()); } else if (id == TYPE) { Name name = getFunctionTypeName(*curr[1]); type = name; if (!wasm.getFunctionTypeOrNull(name)) throw ParseException(""unknown function type""); FunctionType* type = wasm.getFunctionType(name); result = type->result; for (size_t j = 0; j < type->params.size(); j++) { IString name = Name::fromInt(j); Type currType = type->params[j]; typeParams.emplace_back(name, currType); currLocalTypes[name] = currType; } } else if (id == IMPORT) { importModule = curr[1]->str(); importBase = curr[2]->str(); } else { if (typeParams.size() > 0 && params.size() == 0) { params = typeParams; } if (!currFunction) makeFunction(); Expression* ex = parseExpression(curr); if (!body) { body = ex; } else { ensureAutoBlock(); autoBlock->list.push_back(ex); } } } if (type.isNull()) { auto functionType = make_unique<FunctionType>(sigToFunctionType(getSigFromStructs(result, params))); for (auto& existing : wasm.functionTypes) { if (existing->structuralComparison(*functionType)) { type = existing->name; break; } } if (!type.is()) throw ParseException(""no function type [internal error?]"", s.line, s.col); } if (importModule.is()) { if (!preParseImport) throw ParseException(""!preParseImport in func""); auto im = make_unique<Function>(); im->name = name; im->module = importModule; im->base = importBase; im->type = type; FunctionTypeUtils::fillFunction(im.get(), wasm.getFunctionType(type)); functionTypes[name] = im->result; if (wasm.getFunctionOrNull(im->name)) throw ParseException(""duplicate import"", s.line, s.col); wasm.addFunction(im.release()); if (currFunction) throw ParseException(""import module inside function dec""); currLocalTypes.clear(); nameMapper.clear(); return; } if (preParseImport) throw ParseException(""preParseImport in func""); if (brokeToAutoBlock) { ensureAutoBlock(); autoBlock->name = FAKE_RETURN; } if (autoBlock) { autoBlock->finalize(result); } if (!currFunction) { makeFunction(); body = allocator.alloc<Nop>(); } if (currFunction->result != result) throw ParseException(""bad func declaration"", s.line, s.col); currFunction->body = body; currFunction->type = type; if (s.startLoc) { currFunction->prologLocation.insert(getDebugLocation(*s.startLoc)); } if (s.endLoc) { currFunction->epilogLocation.insert(getDebugLocation(*s.endLoc)); } if (wasm.getFunctionOrNull(currFunction->name)) throw ParseException(""duplicate function"", s.line, s.col); wasm.addFunction(currFunction.release()); currLocalTypes.clear(); nameMapper.clear(); }
Description: A NULL pointer dereference was discovered in wasm::WasmBinaryBuilder::processFunctions() in wasm/wasm-binary.cpp (when calling wasm::WasmBinaryBuilder::getFunctionIndexName) in Binaryen 1.38.22. A crafted input can cause segmentation faults, leading to denial-of-service, as demonstrated by wasm-opt.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void PdfXRefStreamParserObject::getIndices(vector<int64_t>& indices, int64_t size) { auto indexObj = this->GetDictionary().GetKey(""Index""); if (indexObj == nullptr) { indices.push_back(static_cast<int64_t>(0)); indices.push_back(size); } else { const PdfArray* arr; if (!indexObj->TryGetArray(arr)) PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, ""Invalid XRef Stream /Index""); for (auto index : *arr) indices.push_back(index.GetNumber()); } if (indices.size() % 2 != 0) PODOFO_RAISE_ERROR_INFO(PdfErrorCode::NoXRef, ""Invalid XRef Stream /Index""); }
Description: A vulnerability, which was classified as critical, was found in PoDoFo 0.10.0. Affected is the function readXRefStreamEntry of the file PdfXRefStreamParserObject.cpp. The manipulation leads to heap-based buffer overflow. An attack has to be approached locally. The exploit has been disclosed to the public and may be used. The patch is identified as 535a786f124b739e3c857529cecc29e4eeb79778. It is recommended to apply a patch to fix this issue. VDB-227226 is the identifier assigned to this vulnerability.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int ossl_punycode_decode(const char *pEncoded, const size_t enc_len, unsigned int *pDecoded, unsigned int *pout_length) { unsigned int n = initial_n; unsigned int i = 0; unsigned int bias = initial_bias; size_t processed_in = 0, written_out = 0; unsigned int max_out = *pout_length; unsigned int basic_count = 0; unsigned int loop; for (loop = 0; loop < enc_len; loop++) { if (pEncoded[loop] == delimiter) basic_count = loop; } if (basic_count > 0) { if (basic_count > max_out) return 0; for (loop = 0; loop < basic_count; loop++) { if (is_basic(pEncoded[loop]) == 0) return 0; pDecoded[loop] = pEncoded[loop]; written_out++; } processed_in = basic_count + 1; } for (loop = processed_in; loop < enc_len;) { unsigned int oldi = i; unsigned int w = 1; unsigned int k, t; int digit; for (k = base;; k += base) { if (loop >= enc_len) return 0; digit = digit_decoded(pEncoded[loop]); loop++; if (digit < 0) return 0; if ((unsigned int)digit > (maxint - i) / w) return 0; i = i + digit * w; t = (k <= bias) ? tmin : (k >= bias + tmax) ? tmax : k - bias; if ((unsigned int)digit < t) break; if (w > maxint / (base - t)) return 0; w = w * (base - t); } bias = adapt(i - oldi, written_out + 1, (oldi == 0)); if (i / (written_out + 1) > maxint - n) return 0; n = n + i / (written_out + 1); i %= (written_out + 1); if (written_out > max_out) return 0; memmove(pDecoded + i + 1, pDecoded + i, (written_out - i) * sizeof *pDecoded); pDecoded[i] = n; i++; written_out++; } *pout_length = written_out; return 1; }
Description: A buffer overrun can be triggered in X.509 certificate verification, specifically in name constraint checking. Note that this occurs after certificate chain signature verification and requires either a CA to have signed the malicious certificate or for the application to continue certificate verification despite failure to construct a path to a trusted issuer. An attacker can craft a malicious email address to overflow four attacker-controlled bytes on the stack. This buffer overflow could result in a crash (causing a denial of service) or potentially remote code execution. Many platforms implement stack overflow protections which would mitigate against the risk of remote code execution. The risk may be further mitigated based on stack layout for any given platform/compiler. Pre-announcements of CVE-2022-3602 described this issue as CRITICAL. Further analysis based on some of the mitigating factors described above have led this to be downgraded to HIGH. Users are still encouraged to upgrade to a new version as soon as possible. In a TLS client, this can be triggered by connecting to a malicious server. In a TLS server, this can be triggered if the server requests client authentication and a malicious client connects. Fixed in OpenSSL 3.0.7 (Affected 3.0.0,3.0.1,3.0.2,3.0.3,3.0.4,3.0.5,3.0.6).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void CSndUList::realloc_() { CSNode** temp = NULL; try { temp = new CSNode * [m_iArrayLength * 2]; } catch (...) { return; } memcpy(temp, m_pHeap, sizeof(CSNode*) * m_iArrayLength); m_iArrayLength *= 2; delete[] m_pHeap; m_pHeap = temp; }
Description: Secure Reliable Transport (SRT) through 1.3.4 has a CSndUList array overflow if there are many SRT connections.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: XModifierKeymap * XGetDeviceModifierMapping( register Display*dpy, XDevice*dev) { unsigned long nbytes; XModifierKeymap *res; xGetDeviceModifierMappingReq *req; xGetDeviceModifierMappingReply rep; XExtDisplayInfo *info = XInput_find_display(dpy); LockDisplay(dpy); if (_XiCheckExtInit(dpy, XInput_Initial_Release, info) == -1) return NULL; GetReq(GetDeviceModifierMapping, req); req->reqType = info->codes->major_opcode; req->ReqType = X_GetDeviceModifierMapping; req->deviceid = dev->device_id; if (!_XReply(dpy, (xReply *) & rep, 0, xFalse)) { UnlockDisplay(dpy); SyncHandle(); return (XModifierKeymap *) NULL; } nbytes = (unsigned long)rep.length << 2; res = (XModifierKeymap *) Xmalloc(sizeof(XModifierKeymap)); if (res) { res->modifiermap = (KeyCode *) Xmalloc(nbytes); if (res->modifiermap) _XReadPad(dpy, (char *)res->modifiermap, nbytes); else _XEatDataWords(dpy, rep.length); res->max_keypermod = rep.numKeyPerModifier; } UnlockDisplay(dpy); SyncHandle(); return (res); }
Description: Multiple integer overflows in X.org libXi before 1.7.7 allow remote X servers to cause a denial of service (out-of-bounds memory access or infinite loop) via vectors involving length fields.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static enum ofperr decode_bundle(bool load, const struct nx_action_bundle *nab, const struct vl_mff_map *vl_mff_map, uint64_t *tlv_bitmap, struct ofpbuf *ofpacts) { static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5); struct ofpact_bundle *bundle; uint32_t slave_type; size_t slaves_size, i; enum ofperr error; bundle = ofpact_put_BUNDLE(ofpacts); bundle->n_slaves = ntohs(nab->n_slaves); bundle->basis = ntohs(nab->basis); bundle->fields = ntohs(nab->fields); bundle->algorithm = ntohs(nab->algorithm); slave_type = ntohl(nab->slave_type); slaves_size = ntohs(nab->len) - sizeof *nab; error = OFPERR_OFPBAC_BAD_ARGUMENT; if (!flow_hash_fields_valid(bundle->fields)) { VLOG_WARN_RL(&rl, ""unsupported fields %d"", (int) bundle->fields); } else if (bundle->n_slaves > BUNDLE_MAX_SLAVES) { VLOG_WARN_RL(&rl, ""too many slaves""); } else if (bundle->algorithm != NX_BD_ALG_HRW && bundle->algorithm != NX_BD_ALG_ACTIVE_BACKUP) { VLOG_WARN_RL(&rl, ""unsupported algorithm %d"", (int) bundle->algorithm); } else if (slave_type != mf_nxm_header(MFF_IN_PORT)) { VLOG_WARN_RL(&rl, ""unsupported slave type %""PRIu16, slave_type); } else { error = 0; } if (!is_all_zeros(nab->zero, sizeof nab->zero)) { VLOG_WARN_RL(&rl, ""reserved field is nonzero""); error = OFPERR_OFPBAC_BAD_ARGUMENT; } if (load) { bundle->dst.ofs = nxm_decode_ofs(nab->ofs_nbits); bundle->dst.n_bits = nxm_decode_n_bits(nab->ofs_nbits); error = mf_vl_mff_mf_from_nxm_header(ntohl(nab->dst), vl_mff_map, &bundle->dst.field, tlv_bitmap); if (error) { return error; } if (bundle->dst.n_bits < 16) { VLOG_WARN_RL(&rl, ""bundle_load action requires at least 16 bit "" ""destination.""); error = OFPERR_OFPBAC_BAD_ARGUMENT; } } else { if (nab->ofs_nbits || nab->dst) { VLOG_WARN_RL(&rl, ""bundle action has nonzero reserved fields""); error = OFPERR_OFPBAC_BAD_ARGUMENT; } } if (slaves_size < bundle->n_slaves * sizeof(ovs_be16)) { VLOG_WARN_RL(&rl, ""Nicira action %s only has %""PRIuSIZE"" bytes "" ""allocated for slaves.  %""PRIuSIZE"" bytes are required "" ""for %""PRIu16"" slaves."", load ? ""bundle_load"" : ""bundle"", slaves_size, bundle->n_slaves * sizeof(ovs_be16), bundle->n_slaves); error = OFPERR_OFPBAC_BAD_LEN; } for (i = 0; i < bundle->n_slaves; i++) { ofp_port_t ofp_port = u16_to_ofp(ntohs(((ovs_be16 *)(nab + 1))[i])); ofpbuf_put(ofpacts, &ofp_port, sizeof ofp_port); bundle = ofpacts->header; } ofpact_finish_BUNDLE(ofpacts, &bundle); if (!error) { error = bundle_check(bundle, OFPP_MAX, NULL); } return error; }
Description: An issue was discovered in Open vSwitch (OvS) 2.7.x through 2.7.6. The decode_bundle function inside lib/ofp-actions.c is affected by a buffer over-read issue during BUNDLE action decoding.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: BOOL region16_union_rect(REGION16* dst, const REGION16* src, const RECTANGLE_16* rect) { const RECTANGLE_16* srcExtents; RECTANGLE_16* dstExtents; const RECTANGLE_16* currentBand, *endSrcRect, *nextBand; REGION16_DATA* newItems = NULL; RECTANGLE_16* dstRect = NULL; UINT32 usedRects, srcNbRects; UINT16 topInterBand; assert(src); assert(src->data); assert(dst); srcExtents = region16_extents(src); dstExtents = region16_extents_noconst(dst); if (!region16_n_rects(src)) { dst->extents = *rect; dst->data = allocateRegion(1); if (!dst->data) return FALSE; dstRect = region16_rects_noconst(dst); dstRect->top = rect->top; dstRect->left = rect->left; dstRect->right = rect->right; dstRect->bottom = rect->bottom; return TRUE; } newItems = allocateRegion((1 + region16_n_rects(src)) * 4); if (!newItems) return FALSE; dstRect = (RECTANGLE_16*)(&newItems[1]); usedRects = 0; if (rect->top < srcExtents->top) { dstRect->top = rect->top; dstRect->left = rect->left; dstRect->right = rect->right; dstRect->bottom = MIN(srcExtents->top, rect->bottom); usedRects++; dstRect++; } currentBand = region16_rects(src, &srcNbRects); endSrcRect = currentBand + srcNbRects; while (currentBand < endSrcRect) { if ((currentBand->bottom <= rect->top) || (rect->bottom <= currentBand->top) || rectangle_contained_in_band(currentBand, endSrcRect, rect)) { region16_copy_band_with_union(dstRect, currentBand, endSrcRect, currentBand->top, currentBand->bottom, NULL, &usedRects, &nextBand, &dstRect); topInterBand = rect->top; } else { UINT16 mergeTop = currentBand->top; UINT16 mergeBottom = currentBand->bottom; if (rect->top > currentBand->top) { region16_copy_band_with_union(dstRect, currentBand, endSrcRect, currentBand->top, rect->top, NULL, &usedRects, &nextBand, &dstRect); mergeTop = rect->top; } if (rect->bottom < currentBand->bottom) mergeBottom = rect->bottom; region16_copy_band_with_union(dstRect, currentBand, endSrcRect, mergeTop, mergeBottom, rect, &usedRects, &nextBand, &dstRect); if (rect->bottom < currentBand->bottom) { region16_copy_band_with_union(dstRect, currentBand, endSrcRect, mergeBottom, currentBand->bottom, NULL, &usedRects, &nextBand, &dstRect); } topInterBand = currentBand->bottom; } if ((nextBand < endSrcRect) && (nextBand->top != currentBand->bottom) && (rect->bottom > currentBand->bottom) && (rect->top < nextBand->top)) { dstRect->right = rect->right; dstRect->left = rect->left; dstRect->top = topInterBand; dstRect->bottom = MIN(nextBand->top, rect->bottom); dstRect++; usedRects++; } currentBand = nextBand; } if (srcExtents->bottom < rect->bottom) { dstRect->top = MAX(srcExtents->bottom, rect->top); dstRect->left = rect->left; dstRect->right = rect->right; dstRect->bottom = rect->bottom; usedRects++; dstRect++; } if ((src == dst) && (src->data->size > 0) && (src->data != &empty_region)) free(src->data); dstExtents->top = MIN(rect->top, srcExtents->top); dstExtents->left = MIN(rect->left, srcExtents->left); dstExtents->bottom = MAX(rect->bottom, srcExtents->bottom); dstExtents->right = MAX(rect->right, srcExtents->right); newItems->size = sizeof(REGION16_DATA) + (usedRects * sizeof(RECTANGLE_16)); dst->data = realloc(newItems, newItems->size); if (!dst->data) { free(newItems); return FALSE; } dst->data->nbRects = usedRects; return region16_simplify_bands(dst); }
Description: libfreerdp/codec/region.c in FreeRDP through 1.1.x and 2.x through 2.0.0-rc4 has memory leaks because a supplied realloc pointer (i.e., the first argument to realloc) is also used for a realloc return value.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int process_line(URLContext *h, char *line, int line_count, int *new_location) { HTTPContext *s = h->priv_data; const char *auto_method =  h->flags & AVIO_FLAG_READ ? ""POST"" : ""GET""; char *tag, *p, *end, *method, *resource, *version; int ret; if (line[0] == '\0') { s->end_header = 1; return 0; } p = line; if (line_count == 0) { if (s->is_connected_server) { method = p; while (*p && !av_isspace(*p)) p++; *(p++) = '\0'; av_log(h, AV_LOG_TRACE, ""Received method: %s\n"", method); if (s->method) { if (av_strcasecmp(s->method, method)) { av_log(h, AV_LOG_ERROR, ""Received and expected HTTP method do not match. (%s expected, %s received)\n"", s->method, method); return ff_http_averror(400, AVERROR(EIO)); } } else { av_log(h, AV_LOG_TRACE, ""Autodetected %s HTTP method\n"", auto_method); if (av_strcasecmp(auto_method, method)) { av_log(h, AV_LOG_ERROR, ""Received and autodetected HTTP method did not match "" ""(%s autodetected %s received)\n"", auto_method, method); return ff_http_averror(400, AVERROR(EIO)); } if (!(s->method = av_strdup(method))) return AVERROR(ENOMEM); } while (av_isspace(*p)) p++; resource = p; while (!av_isspace(*p)) p++; *(p++) = '\0'; av_log(h, AV_LOG_TRACE, ""Requested resource: %s\n"", resource); if (!(s->resource = av_strdup(resource))) return AVERROR(ENOMEM); while (av_isspace(*p)) p++; version = p; while (*p && !av_isspace(*p)) p++; *p = '\0'; if (av_strncasecmp(version, ""HTTP/"", 5)) { av_log(h, AV_LOG_ERROR, ""Malformed HTTP version string.\n""); return ff_http_averror(400, AVERROR(EIO)); } av_log(h, AV_LOG_TRACE, ""HTTP version string: %s\n"", version); } else { while (!av_isspace(*p) && *p != '\0') p++; while (av_isspace(*p)) p++; s->http_code = strtol(p, &end, 10); av_log(h, AV_LOG_TRACE, ""http_code=%d\n"", s->http_code); if ((ret = check_http_code(h, s->http_code, end)) < 0) return ret; } } else { while (*p != '\0' && *p != ':') p++; if (*p != ':') return 1; *p  = '\0'; tag = line; p++; while (av_isspace(*p)) p++; if (!av_strcasecmp(tag, ""Location"")) { if ((ret = parse_location(s, p)) < 0) return ret; *new_location = 1; } else if (!av_strcasecmp(tag, ""Content-Length"") && s->filesize == -1) { s->filesize = strtoll(p, NULL, 10); } else if (!av_strcasecmp(tag, ""Content-Range"")) { parse_content_range(h, p); } else if (!av_strcasecmp(tag, ""Accept-Ranges"") && !strncmp(p, ""bytes"", 5) && s->seekable == -1) { h->is_streamed = 0; } else if (!av_strcasecmp(tag, ""Transfer-Encoding"") && !av_strncasecmp(p, ""chunked"", 7)) { s->filesize  = -1; s->chunksize = 0; } else if (!av_strcasecmp(tag, ""WWW-Authenticate"")) { ff_http_auth_handle_header(&s->auth_state, tag, p); } else if (!av_strcasecmp(tag, ""Authentication-Info"")) { ff_http_auth_handle_header(&s->auth_state, tag, p); } else if (!av_strcasecmp(tag, ""Proxy-Authenticate"")) { ff_http_auth_handle_header(&s->proxy_auth_state, tag, p); } else if (!av_strcasecmp(tag, ""Connection"")) { if (!strcmp(p, ""close"")) s->willclose = 1; } else if (!av_strcasecmp(tag, ""Server"")) { if (!av_strcasecmp(p, ""AkamaiGHost"")) { s->is_akamai = 1; } else if (!av_strncasecmp(p, ""MediaGateway"", 12)) { s->is_mediagateway = 1; } } else if (!av_strcasecmp(tag, ""Content-Type"")) { av_free(s->mime_type); s->mime_type = av_strdup(p); } else if (!av_strcasecmp(tag, ""Set-Cookie"")) { if (parse_cookie(s, p, &s->cookie_dict)) av_log(h, AV_LOG_WARNING, ""Unable to parse '%s'\n"", p); } else if (!av_strcasecmp(tag, ""Icy-MetaInt"")) { s->icy_metaint = strtoll(p, NULL, 10); } else if (!av_strncasecmp(tag, ""Icy-"", 4)) { if ((ret = parse_icy(s, tag, p)) < 0) return ret; } else if (!av_strcasecmp(tag, ""Content-Encoding"")) { if ((ret = parse_content_encoding(h, p)) < 0) return ret; } } return 1; }
Description: Heap-based buffer overflow in libavformat/http.c in FFmpeg before 2.8.10, 3.0.x before 3.0.5, 3.1.x before 3.1.6, and 3.2.x before 3.2.2 allows remote web servers to execute arbitrary code via a negative chunk size in an HTTP response.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int amf_namf_comm_handle_n1_n2_message_transfer( ogs_sbi_stream_t *stream, ogs_sbi_message_t *recvmsg) { int status; amf_ue_t *amf_ue = NULL; amf_sess_t *sess = NULL; ogs_pkbuf_t *n1buf = NULL; ogs_pkbuf_t *n2buf = NULL; ogs_pkbuf_t *gmmbuf = NULL; ogs_pkbuf_t *ngapbuf = NULL; char *supi = NULL; uint8_t pdu_session_id = OGS_NAS_PDU_SESSION_IDENTITY_UNASSIGNED; ogs_sbi_message_t sendmsg; ogs_sbi_response_t *response = NULL; OpenAPI_n1_n2_message_transfer_req_data_t *N1N2MessageTransferReqData; OpenAPI_n1_n2_message_transfer_rsp_data_t N1N2MessageTransferRspData; OpenAPI_n1_message_container_t *n1MessageContainer = NULL; OpenAPI_ref_to_binary_data_t *n1MessageContent = NULL; OpenAPI_n2_info_container_t *n2InfoContainer = NULL; OpenAPI_n2_sm_information_t *smInfo = NULL; OpenAPI_n2_info_content_t *n2InfoContent = NULL; OpenAPI_ref_to_binary_data_t *ngapData = NULL; ogs_assert(stream); ogs_assert(recvmsg); N1N2MessageTransferReqData = recvmsg->N1N2MessageTransferReqData; if (!N1N2MessageTransferReqData) { ogs_error(""No N1N2MessageTransferReqData""); return OGS_ERROR; } if (N1N2MessageTransferReqData->is_pdu_session_id == false) { ogs_error(""No PDU Session Identity""); return OGS_ERROR; } pdu_session_id = N1N2MessageTransferReqData->pdu_session_id; supi = recvmsg->h.resource.component[1]; if (!supi) { ogs_error(""No SUPI""); return OGS_ERROR; } amf_ue = amf_ue_find_by_supi(supi); if (!amf_ue) { ogs_error(""No UE context [%s]"", supi); return OGS_ERROR; } sess = amf_sess_find_by_psi(amf_ue, pdu_session_id); if (!sess) { ogs_error(""[%s] No PDU Session Context [%d]"", amf_ue->supi, pdu_session_id); return OGS_ERROR; } n1MessageContainer = N1N2MessageTransferReqData->n1_message_container; if (n1MessageContainer) { n1MessageContent = n1MessageContainer->n1_message_content; if (!n1MessageContent || !n1MessageContent->content_id) { ogs_error(""No n1MessageContent""); return OGS_ERROR; } n1buf = ogs_sbi_find_part_by_content_id( recvmsg, n1MessageContent->content_id); if (!n1buf) { ogs_error(""[%s] No N1 SM Content"", amf_ue->supi); return OGS_ERROR; } n1buf = ogs_pkbuf_copy(n1buf); ogs_assert(n1buf); } n2InfoContainer = N1N2MessageTransferReqData->n2_info_container; if (n2InfoContainer) { smInfo = n2InfoContainer->sm_info; if (!smInfo) { ogs_error(""No smInfo""); return OGS_ERROR; } n2InfoContent = smInfo->n2_info_content; if (!n2InfoContent) { ogs_error(""No n2InfoContent""); return OGS_ERROR; } ngapData = n2InfoContent->ngap_data; if (!ngapData || !ngapData->content_id) { ogs_error(""No ngapData""); return OGS_ERROR; } n2buf = ogs_sbi_find_part_by_content_id( recvmsg, ngapData->content_id); if (!n2buf) { ogs_error(""[%s] No N2 SM Content"", amf_ue->supi); return OGS_ERROR; } n2buf = ogs_pkbuf_copy(n2buf); ogs_assert(n2buf); } memset(&sendmsg, 0, sizeof(sendmsg)); status = OGS_SBI_HTTP_STATUS_OK; memset(&N1N2MessageTransferRspData, 0, sizeof(N1N2MessageTransferRspData)); N1N2MessageTransferRspData.cause = OpenAPI_n1_n2_message_transfer_cause_N1_N2_TRANSFER_INITIATED; sendmsg.N1N2MessageTransferRspData = &N1N2MessageTransferRspData; switch (n2InfoContent->ngap_ie_type) { case OpenAPI_ngap_ie_type_PDU_RES_SETUP_REQ: if (!n2buf) { ogs_error(""[%s] No N2 SM Content"", amf_ue->supi); return OGS_ERROR; } if (n1buf) { gmmbuf = gmm_build_dl_nas_transport(sess, OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0); ogs_assert(gmmbuf); } if (gmmbuf) { ran_ue_t *ran_ue = NULL; ran_ue = ran_ue_cycle(amf_ue->ran_ue); ogs_assert(ran_ue); if (sess->pdu_session_establishment_accept) { ogs_pkbuf_free(sess->pdu_session_establishment_accept); sess->pdu_session_establishment_accept = NULL; } if (ran_ue->initial_context_setup_request_sent == true) { ngapbuf = ngap_sess_build_pdu_session_resource_setup_request( sess, gmmbuf, n2buf); ogs_assert(ngapbuf); } else { ngapbuf = ngap_sess_build_initial_context_setup_request( sess, gmmbuf, n2buf); ogs_assert(ngapbuf); ran_ue->initial_context_setup_request_sent = true; } if (SESSION_CONTEXT_IN_SMF(sess)) { if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK) ogs_error(""nas_5gs_send_to_gnb() failed""); } else { sess->pdu_session_establishment_accept = ngapbuf; } } else { if (CM_IDLE(amf_ue)) { ogs_sbi_server_t *server = NULL; ogs_sbi_header_t header; ogs_sbi_client_t *client = NULL; ogs_sockaddr_t *addr = NULL; if (!N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri) { ogs_error(""[%s:%d] No n1-n2-failure-notification-uri"", amf_ue->supi, sess->psi); return OGS_ERROR; } addr = ogs_sbi_getaddr_from_uri( N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri); if (!addr) { ogs_error(""[%s:%d] Invalid URI [%s]"", amf_ue->supi, sess->psi, N1N2MessageTransferReqData-> n1n2_failure_txf_notif_uri); return OGS_ERROR;; } client = ogs_sbi_client_find(addr); if (!client) { client = ogs_sbi_client_add(addr); ogs_assert(client); } OGS_SETUP_SBI_CLIENT(&sess->paging, client); ogs_freeaddrinfo(addr); status = OGS_SBI_HTTP_STATUS_ACCEPTED; N1N2MessageTransferRspData.cause = OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE; server = ogs_sbi_server_from_stream(stream); ogs_assert(server); memset(&header, 0, sizeof(header)); header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM; header.api.version = (char *)OGS_SBI_API_V1; header.resource.component[0] = (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS; header.resource.component[1] = amf_ue->supi; header.resource.component[2] = (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES; header.resource.component[3] = sess->sm_context_ref; sendmsg.http.location = ogs_sbi_server_uri(server, &header); AMF_SESS_STORE_PAGING_INFO( sess, sendmsg.http.location, N1N2MessageTransferReqData->n1n2_failure_txf_notif_uri); AMF_SESS_STORE_N2_TRANSFER( sess, pdu_session_resource_setup_request, n2buf); ogs_assert(OGS_OK == ngap_send_paging(amf_ue)); } else if (CM_CONNECTED(amf_ue)) { ogs_assert(OGS_OK == ngap_send_pdu_resource_setup_request(sess, n2buf)); } else { ogs_fatal(""[%s] Invalid AMF-UE state"", amf_ue->supi); ogs_assert_if_reached(); } } break; case OpenAPI_ngap_ie_type_PDU_RES_MOD_REQ: if (!n1buf) { ogs_error(""[%s] No N1 SM Content"", amf_ue->supi); return OGS_ERROR; } if (!n2buf) { ogs_error(""[%s] No N2 SM Content"", amf_ue->supi); return OGS_ERROR; } if (CM_IDLE(amf_ue)) { ogs_sbi_server_t *server = NULL; ogs_sbi_header_t header; status = OGS_SBI_HTTP_STATUS_ACCEPTED; N1N2MessageTransferRspData.cause = OpenAPI_n1_n2_message_transfer_cause_ATTEMPTING_TO_REACH_UE; server = ogs_sbi_server_from_stream(stream); ogs_assert(server); memset(&header, 0, sizeof(header)); header.service.name = (char *)OGS_SBI_SERVICE_NAME_NAMF_COMM; header.api.version = (char *)OGS_SBI_API_V1; header.resource.component[0] = (char *)OGS_SBI_RESOURCE_NAME_UE_CONTEXTS; header.resource.component[1] = amf_ue->supi; header.resource.component[2] = (char *)OGS_SBI_RESOURCE_NAME_N1_N2_MESSAGES; header.resource.component[3] = sess->sm_context_ref; sendmsg.http.location = ogs_sbi_server_uri(server, &header); AMF_SESS_STORE_PAGING_INFO( sess, sendmsg.http.location, NULL); AMF_SESS_STORE_5GSM_MESSAGE(sess, OGS_NAS_5GS_PDU_SESSION_MODIFICATION_COMMAND, n1buf, n2buf); ogs_assert(OGS_OK == ngap_send_paging(amf_ue)); } else if (CM_CONNECTED(amf_ue)) { gmmbuf = gmm_build_dl_nas_transport(sess, OGS_NAS_PAYLOAD_CONTAINER_N1_SM_INFORMATION, n1buf, 0, 0); ogs_assert(gmmbuf); ngapbuf = ngap_build_pdu_session_resource_modify_request( sess, gmmbuf, n2buf); ogs_assert(ngapbuf); if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK) ogs_error(""nas_5gs_send_to_gnb() failed""); } else { ogs_fatal(""[%s] Invalid AMF-UE state"", amf_ue->supi); ogs_assert_if_reached(); } break; case OpenAPI_ngap_ie_type_PDU_RES_REL_CMD: if (!n2buf) { ogs_error(""[%s] No N2 SM Content"", amf_ue->supi); return OGS_ERROR; } if (n1buf) ogs_pkbuf_free(n1buf); if (CM_IDLE(amf_ue)) { if (n2buf) ogs_pkbuf_free(n2buf); if (N1N2MessageTransferReqData->is_skip_ind == true && N1N2MessageTransferReqData->skip_ind == true) { N1N2MessageTransferRspData.cause = OpenAPI_n1_n2_message_transfer_cause_N1_MSG_NOT_TRANSFERRED; } else { ogs_fatal(""[%s] No skipInd"", amf_ue->supi); ogs_assert_if_reached(); } } else if (CM_CONNECTED(amf_ue)) { ngapbuf = ngap_build_pdu_session_resource_release_command( sess, NULL, n2buf); ogs_assert(ngapbuf); if (nas_5gs_send_to_gnb(amf_ue, ngapbuf) != OGS_OK) ogs_error(""nas_5gs_send_to_gnb() failed""); } else { ogs_fatal(""[%s] Invalid AMF-UE state"", amf_ue->supi); ogs_assert_if_reached(); } break; default: ogs_error(""Not implemented ngap_ie_type[%d]"", n2InfoContent->ngap_ie_type); ogs_assert_if_reached(); } response = ogs_sbi_build_response(&sendmsg, status); ogs_assert(response); ogs_assert(true == ogs_sbi_server_send_response(stream, response)); if (sendmsg.http.location) ogs_free(sendmsg.http.location); return OGS_OK; }
Description: A null pointer dereference in src/amf/namf-handler.c in Open5GS 2.3.6 and earlier allows remote attackers to Denial of Service via a crafted sbi request to amf.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int deassign_device(struct domain *d, uint16_t seg, uint8_t bus, uint8_t devfn) { const struct domain_iommu *hd = dom_iommu(d); struct pci_dev *pdev; int ret = 0; if ( !is_iommu_enabled(d) ) return -EINVAL; ASSERT(pcidevs_locked()); pdev = pci_get_pdev_by_domain(d, seg, bus, devfn); if ( !pdev ) return -ENODEV; while ( pdev->phantom_stride ) { devfn += pdev->phantom_stride; if ( PCI_SLOT(devfn) != PCI_SLOT(pdev->devfn) ) break; ret = hd->platform_ops->reassign_device(d, hardware_domain, devfn, pci_to_dev(pdev)); if ( !ret ) continue; printk(XENLOG_G_ERR ""%pd: deassign %04x:%02x:%02x.%u failed (%d)\n"", d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn), ret); return ret; } devfn = pdev->devfn; ret = hd->platform_ops->reassign_device(d, hardware_domain, devfn, pci_to_dev(pdev)); if ( ret ) { dprintk(XENLOG_G_ERR, ""%pd: deassign device (%04x:%02x:%02x.%u) failed\n"", d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn)); return ret; } pdev->fault.count = 0; return ret; }
Description: An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static long __media_device_enum_links(struct media_device *mdev, struct media_links_enum *links) { struct media_entity *entity; entity = find_entity(mdev, links->entity); if (entity == NULL) return -EINVAL; if (links->pads) { unsigned int p; for (p = 0; p < entity->num_pads; p++) { struct media_pad_desc pad; media_device_kpad_to_upad(&entity->pads[p], &pad); if (copy_to_user(&links->pads[p], &pad, sizeof(pad))) return -EFAULT; } } if (links->links) { struct media_link_desc __user *ulink; unsigned int l; for (l = 0, ulink = links->links; l < entity->num_links; l++) { struct media_link_desc link; if (entity->links[l].source->entity != entity) continue; media_device_kpad_to_upad(entity->links[l].source, &link.source); media_device_kpad_to_upad(entity->links[l].sink, &link.sink); link.flags = entity->links[l].flags; if (copy_to_user(ulink, &link, sizeof(*ulink))) return -EFAULT; ulink++; } } return 0; }
Description: drivers/media/media-device.c in the Linux kernel before 3.11, as used in Android before 2016-08-05 on Nexus 5 and 7 (2013) devices, does not properly initialize certain data structures, which allows local users to obtain sensitive information via a crafted application, aka Android internal bug 28750150 and Qualcomm internal bug CR570757, a different vulnerability than CVE-2014-1739.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int device_assigned(u16 seg, u8 bus, u8 devfn) { struct pci_dev *pdev; pcidevs_lock(); pdev = pci_get_pdev_by_domain(hardware_domain, seg, bus, devfn); pcidevs_unlock(); return pdev ? 0 : -EBUSY; }
Description: An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int insert_pin( sc_pkcs15_card_t *p15card, const char       *path, unsigned char     id, unsigned char     auth_id, unsigned char     pin_reference, int               min_length, const char       *label, int               pin_flags ){ sc_card_t *card=p15card->card; sc_context_t *ctx=p15card->card->ctx; sc_file_t *f = NULL; struct sc_pkcs15_auth_info pin_info; struct sc_pkcs15_object pin_obj; int r; memset(&pin_info, 0, sizeof(pin_info)); pin_info.auth_id.len      = 1; pin_info.auth_id.value[0] = id; pin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN; pin_info.attrs.pin.reference        = pin_reference; pin_info.attrs.pin.flags            = pin_flags; pin_info.attrs.pin.type             = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC; pin_info.attrs.pin.min_length       = min_length; pin_info.attrs.pin.stored_length    = 16; pin_info.attrs.pin.max_length       = 16; pin_info.attrs.pin.pad_char         = '\0'; pin_info.logged_in = SC_PIN_STATE_UNKNOWN; sc_format_path(path, &pin_info.path); memset(&pin_obj, 0, sizeof(pin_obj)); strlcpy(pin_obj.label, label, sizeof(pin_obj.label)); pin_obj.flags            = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE; pin_obj.auth_id.len      = auth_id ? 0 : 1; pin_obj.auth_id.value[0] = auth_id; if(card->type == SC_CARD_TYPE_TCOS_V3) { unsigned char buf[256]; int i, rec_no=0; if (pin_info.path.len >= 2) { pin_info.path.len -= 2; } sc_append_file_id(&pin_info.path, 0x5049); if (sc_select_file(card, &pin_info.path, NULL) != SC_SUCCESS) { sc_log(ctx,  ""Select(%s) failed\n"", sc_print_path(&pin_info.path)); return 1; } sc_log(ctx,  ""Searching for PIN-Ref %02X\n"", pin_reference); while ((r = sc_read_record(card, ++rec_no, buf, sizeof(buf), SC_RECORD_BY_REC_NR)) > 0) { int found = 0, fbz = -1; if (buf[0] != 0xA0) continue; for (i = 2; i < buf[1] + 2; i += 2 + buf[i + 1]) { if (buf[i] == 0x83 && buf[i + 1] == 1 && buf[i + 2] == pin_reference) { ++found; } if (buf[i] == 0x90) { fbz = buf[i + 1 + buf[i + 1]]; } } if (found) { pin_info.tries_left = fbz; break; } } if (r <= 0) { sc_log(ctx, ""No EF_PWDD-Record found\n""); return 1; } } else { if (sc_select_file(card, &pin_info.path, &f) != SC_SUCCESS || !f->prop_attr || f->prop_attr_len < 4){ sc_log(ctx, ""Select(%s) failed\n"", path); sc_file_free(f); return 1; } pin_info.tries_left = f->prop_attr[3]; sc_file_free(f); } r=sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info); if(r!=SC_SUCCESS){ sc_log(ctx,  ""sc_pkcs15emu_add_pin_obj(%s) failed\n"", path); return 4; } sc_log(ctx,  ""%s: OK, FBZ=%d\n"", path, pin_info.tries_left); return 0; }
Description: A use after return issue was found in Opensc before version 0.22.0 in insert_pin function that could potentially crash programs using the library.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static ssize_t nports_show(struct device *dev, struct device_attribute *attr, char *out) { char *s = out; out += sprintf(out, ""%d\n"", VHCI_PORTS * vhci_num_controllers); return out - s; }
Description: The vhci_hcd driver in the Linux Kernel before version 4.14.8 and 4.4.114 allows allows local attackers to disclose kernel memory addresses. Successful exploitation requires that a USB device is attached over IP.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void messageAddArgument(message *m, const char *arg) { int offset; char *p; assert(m != NULL); if(arg == NULL) return; while(isspace(*arg)) arg++; if(*arg == '\0') return; cli_dbgmsg(""messageAddArgument, arg='%s'\n"", arg); if(!usefulArg(arg)) return; for(offset = 0; offset < m->numberOfArguments; offset++) if(m->mimeArguments[offset] == NULL) break; else if(strcasecmp(arg, m->mimeArguments[offset]) == 0) return; if(offset == m->numberOfArguments) { char **q; m->numberOfArguments++; q = (char **)cli_realloc(m->mimeArguments, m->numberOfArguments * sizeof(char *)); if(q == NULL) { m->numberOfArguments--; return; } m->mimeArguments = q; } p = m->mimeArguments[offset] = rfc2231(arg); if(!p) { cli_dbgmsg(""messageAddArgument, error from rfc2231()\n""); return; } if(strchr(p, '=') == NULL) { if(strncmp(p, ""filename"", 8) == 0) { cli_dbgmsg(""Possible data corruption fixed\n""); p[8] = '='; } else { if(*p) cli_dbgmsg(""messageAddArgument, '%s' contains no '='\n"", p); free(m->mimeArguments[offset]); m->mimeArguments[offset] = NULL; return; } } if((strncasecmp(p, ""filename="", 9) == 0) || (strncasecmp(p, ""name="", 5) == 0)) if(messageGetMimeType(m) == NOMIME) { cli_dbgmsg(""Force mime encoding to application\n""); messageSetMimeType(m, ""application""); } }
Description: libclamav/message.c in ClamAV 0.99.2 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted e-mail message.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int main (int argc, char *argv[]) { int objectsCount = 0; Guint numOffset = 0; std::vector<Object> pages; std::vector<Guint> offsets; XRef *yRef, *countRef; FILE *f; OutStream *outStr; int i; int j, rootNum; std::vector<PDFDoc *>docs; int majorVersion = 0; int minorVersion = 0; char *fileName = argv[argc - 1]; int exitCode; exitCode = 99; const GBool ok = parseArgs (argDesc, &argc, argv); if (!ok || argc < 3 || printVersion || printHelp) { fprintf(stderr, ""pdfunite version %s\n"", PACKAGE_VERSION); fprintf(stderr, ""%s\n"", popplerCopyright); fprintf(stderr, ""%s\n"", xpdfCopyright); if (!printVersion) { printUsage(""pdfunite"", ""<PDF-sourcefile-1>..<PDF-sourcefile-n> <PDF-destfile>"", argDesc); } if (printVersion || printHelp) exitCode = 0; return exitCode; } exitCode = 0; globalParams = new GlobalParams(); for (i = 1; i < argc - 1; i++) { GooString *gfileName = new GooString(argv[i]); PDFDoc *doc = new PDFDoc(gfileName, NULL, NULL, NULL); if (doc->isOk() && !doc->isEncrypted()) { docs.push_back(doc); if (doc->getPDFMajorVersion() > majorVersion) { majorVersion = doc->getPDFMajorVersion(); minorVersion = doc->getPDFMinorVersion(); } else if (doc->getPDFMajorVersion() == majorVersion) { if (doc->getPDFMinorVersion() > minorVersion) { minorVersion = doc->getPDFMinorVersion(); } } } else if (doc->isOk()) { error(errUnimplemented, -1, ""Could not merge encrypted files ('{0:s}')"", argv[i]); return -1; } else { error(errSyntaxError, -1, ""Could not merge damaged documents ('{0:s}')"", argv[i]); return -1; } } if (!(f = fopen(fileName, ""wb""))) { error(errIO, -1, ""Could not open file '{0:s}'"", fileName); return -1; } outStr = new FileOutStream(f, 0); yRef = new XRef(); countRef = new XRef(); yRef->add(0, 65535, 0, gFalse); PDFDoc::writeHeader(outStr, majorVersion, minorVersion); Object intents; Object afObj; Object ocObj; Object names; if (docs.size() >= 1) { Object catObj; docs[0]->getXRef()->getCatalog(&catObj); Dict *catDict = catObj.getDict(); catDict->lookup(""OutputIntents"", &intents); catDict->lookupNF(""AcroForm"", &afObj); Ref *refPage = docs[0]->getCatalog()->getPageRef(1); if (!afObj.isNull()) { docs[0]->markAcroForm(&afObj, yRef, countRef, 0, refPage->num, refPage->num); } catDict->lookupNF(""OCProperties"", &ocObj); if (!ocObj.isNull() && ocObj.isDict()) { docs[0]->markPageObjects(ocObj.getDict(), yRef, countRef, 0, refPage->num, refPage->num); } catDict->lookup(""Names"", &names); if (!names.isNull() && names.isDict()) { docs[0]->markPageObjects(names.getDict(), yRef, countRef, 0, refPage->num, refPage->num); } if (intents.isArray() && intents.arrayGetLength() > 0) { for (i = 1; i < (int) docs.size(); i++) { Object pagecatObj, pageintents; docs[i]->getXRef()->getCatalog(&pagecatObj); Dict *pagecatDict = pagecatObj.getDict(); pagecatDict->lookup(""OutputIntents"", &pageintents); if (pageintents.isArray() && pageintents.arrayGetLength() > 0) { for (j = intents.arrayGetLength() - 1; j >= 0; j--) { Object intent; intents.arrayGet(j, &intent, 0); if (intent.isDict()) { Object idf; intent.dictLookup(""OutputConditionIdentifier"", &idf); if (idf.isString()) { GooString *gidf = idf.getString(); GBool removeIntent = gTrue; for (int k = 0; k < pageintents.arrayGetLength(); k++) { Object pgintent; pageintents.arrayGet(k, &pgintent, 0); if (pgintent.isDict()) { Object pgidf; pgintent.dictLookup(""OutputConditionIdentifier"", &pgidf); if (pgidf.isString()) { GooString *gpgidf = pgidf.getString(); if (gpgidf->cmp(gidf) == 0) { pgidf.free(); removeIntent = gFalse; break; } } pgidf.free(); } } if (removeIntent) { intents.arrayRemove(j); error(errSyntaxWarning, -1, ""Output intent {0:s} missing in pdf {1:s}, removed"", gidf->getCString(), docs[i]->getFileName()->getCString()); } } else { intents.arrayRemove(j); error(errSyntaxWarning, -1, ""Invalid output intent dict, missing required OutputConditionIdentifier""); } idf.free(); } else { intents.arrayRemove(j); } intent.free(); } } else { error(errSyntaxWarning, -1, ""Output intents differs, remove them all""); intents.free(); break; } pagecatObj.free(); pageintents.free(); } } if (intents.isArray() && intents.arrayGetLength() > 0) { for (j = intents.arrayGetLength() - 1; j >= 0; j--) { Object intent; intents.arrayGet(j, &intent, 0); if (intent.isDict()) { docs[0]->markPageObjects(intent.getDict(), yRef, countRef, numOffset, 0, 0); } else { intents.arrayRemove(j); } intent.free(); } } catObj.free(); } for (i = 0; i < (int) docs.size(); i++) { for (j = 1; j <= docs[i]->getNumPages(); j++) { PDFRectangle *cropBox = NULL; if (docs[i]->getCatalog()->getPage(j)->isCropped()) cropBox = docs[i]->getCatalog()->getPage(j)->getCropBox(); docs[i]->replacePageDict(j, docs[i]->getCatalog()->getPage(j)->getRotate(), docs[i]->getCatalog()->getPage(j)->getMediaBox(), cropBox); Ref *refPage = docs[i]->getCatalog()->getPageRef(j); Object page; docs[i]->getXRef()->fetch(refPage->num, refPage->gen, &page); Dict *pageDict = page.getDict(); Dict *resDict = docs[i]->getCatalog()->getPage(j)->getResourceDict(); if (resDict) { Object *newResource = new Object(); newResource->initDict(resDict); pageDict->set(""Resources"", newResource); delete newResource; } pages.push_back(page); offsets.push_back(numOffset); docs[i]->markPageObjects(pageDict, yRef, countRef, numOffset, refPage->num, refPage->num); Object annotsObj; pageDict->lookupNF(""Annots"", &annotsObj); if (!annotsObj.isNull()) { docs[i]->markAnnotations(&annotsObj, yRef, countRef, numOffset, refPage->num, refPage->num); annotsObj.free(); } } Object pageCatObj, pageNames, pageForm; docs[i]->getXRef()->getCatalog(&pageCatObj); Dict *pageCatDict = pageCatObj.getDict(); pageCatDict->lookup(""Names"", &pageNames); if (!pageNames.isNull() && pageNames.isDict()) { if (!names.isDict()) { names.free(); names.initDict(yRef); } doMergeNameDict(docs[i], yRef, countRef, 0, 0, names.getDict(), pageNames.getDict(), numOffset); } pageCatDict->lookup(""AcroForm"", &pageForm); if (i > 0 && !pageForm.isNull() && pageForm.isDict()) { if (afObj.isNull()) { pageCatDict->lookupNF(""AcroForm"", &afObj); } else if (afObj.isDict()) { doMergeFormDict(afObj.getDict(), pageForm.getDict(), numOffset); } } pageForm.free(); pageNames.free(); pageCatObj.free(); objectsCount += docs[i]->writePageObjects(outStr, yRef, numOffset, gTrue); numOffset = yRef->getNumObjects() + 1; } rootNum = yRef->getNumObjects() + 1; yRef->add(rootNum, 0, outStr->getPos(), gTrue); outStr->printf(""%d 0 obj\n"", rootNum); outStr->printf(""<< /Type /Catalog /Pages %d 0 R"", rootNum + 1); if (intents.isArray() && intents.arrayGetLength() > 0) { outStr->printf("" /OutputIntents [""); for (j = 0; j < intents.arrayGetLength(); j++) { Object intent; intents.arrayGet(j, &intent, 0); if (intent.isDict()) { PDFDoc::writeObject(&intent, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0); } intent.free(); } outStr->printf(""]""); } intents.free(); if (!afObj.isNull()) { outStr->printf("" /AcroForm ""); PDFDoc::writeObject(&afObj, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0); afObj.free(); } if (!ocObj.isNull() && ocObj.isDict()) { outStr->printf("" /OCProperties ""); PDFDoc::writeObject(&ocObj, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0); ocObj.free(); } if (!names.isNull() && names.isDict()) { outStr->printf("" /Names ""); PDFDoc::writeObject(&names, outStr, yRef, 0, NULL, cryptRC4, 0, 0, 0); names.free(); } outStr->printf("">>\nendobj\n""); objectsCount++; yRef->add(rootNum + 1, 0, outStr->getPos(), gTrue); outStr->printf(""%d 0 obj\n"", rootNum + 1); outStr->printf(""<< /Type /Pages /Kids [""); for (j = 0; j < (int) pages.size(); j++) outStr->printf("" %d 0 R"", rootNum + j + 2); outStr->printf("" ] /Count %zd >>\nendobj\n"", pages.size()); objectsCount++; for (i = 0; i < (int) pages.size(); i++) { yRef->add(rootNum + i + 2, 0, outStr->getPos(), gTrue); outStr->printf(""%d 0 obj\n"", rootNum + i + 2); outStr->printf(""<< ""); Dict *pageDict = pages[i].getDict(); for (j = 0; j < pageDict->getLength(); j++) { if (j > 0) outStr->printf("" ""); const char *key = pageDict->getKey(j); Object value; pageDict->getValNF(j, &value); if (strcmp(key, ""Parent"") == 0) { outStr->printf(""/Parent %d 0 R"", rootNum + 1); } else { outStr->printf(""/%s "", key); PDFDoc::writeObject(&value, outStr, yRef, offsets[i], NULL, cryptRC4, 0, 0, 0); } value.free(); } outStr->printf("" >>\nendobj\n""); objectsCount++; } Goffset uxrefOffset = outStr->getPos(); Ref ref; ref.num = rootNum; ref.gen = 0; Dict *trailerDict = PDFDoc::createTrailerDict(objectsCount, gFalse, 0, &ref, yRef, fileName, outStr->getPos()); PDFDoc::writeXRefTableTrailer(trailerDict, yRef, gTrue,                                 uxrefOffset, outStr, yRef); delete trailerDict; outStr->close(); delete outStr; fclose(f); delete yRef; delete countRef; for (j = 0; j < (int) pages.size (); j++) pages[j].free(); for (i = 0; i < (int) docs.size (); i++) delete docs[i]; delete globalParams; return exitCode; }
Description: poppler since version 0.17.3 has been vulnerable to NULL pointer dereference in pdfunite triggered by specially crafted documents.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void OAuth2Filter::finishFlow() { if (found_bearer_token_) { if (config_->forwardBearerToken()) { setBearerToken(*request_headers_, access_token_); } config_->stats().oauth_success_.inc(); decoder_callbacks_->continueDecoding(); return; } std::string token_payload; if (config_->forwardBearerToken()) { token_payload = absl::StrCat(host_, new_expires_, access_token_, id_token_, refresh_token_); } else { token_payload = absl::StrCat(host_, new_expires_); } auto& crypto_util = Envoy::Common::Crypto::UtilitySingleton::get(); auto token_secret = config_->tokenSecret(); std::vector<uint8_t> token_secret_vec(token_secret.begin(), token_secret.end()); const std::string pre_encoded_token = Hex::encode(crypto_util.getSha256Hmac(token_secret_vec, token_payload)); std::string encoded_token; absl::Base64Escape(pre_encoded_token, &encoded_token); const std::string cookie_tail = fmt::format(CookieTailFormatString, new_expires_); const std::string cookie_tail_http_only = fmt::format(CookieTailHttpOnlyFormatString, new_expires_); Http::ResponseHeaderMapPtr response_headers{Http::createHeaderMap<Http::ResponseHeaderMapImpl>( {{Http::Headers::get().Status, std::to_string(enumToInt(Http::Code::Found))}})}; const CookieNames& cookie_names = config_->cookieNames(); response_headers->addReferenceKey( Http::Headers::get().SetCookie, absl::StrCat(cookie_names.oauth_hmac_, ""="", encoded_token, cookie_tail_http_only)); response_headers->addReferenceKey( Http::Headers::get().SetCookie, absl::StrCat(cookie_names.oauth_expires_, ""="", new_expires_, cookie_tail_http_only)); if (config_->forwardBearerToken()) { response_headers->addReferenceKey( Http::Headers::get().SetCookie, absl::StrCat(cookie_names.bearer_token_, ""="", access_token_, cookie_tail)); if (id_token_ != EMPTY_STRING) { response_headers->addReferenceKey(Http::Headers::get().SetCookie, absl::StrCat(""IdToken="", id_token_, cookie_tail)); } if (refresh_token_ != EMPTY_STRING) { response_headers->addReferenceKey(Http::Headers::get().SetCookie, absl::StrCat(""RefreshToken="", refresh_token_, cookie_tail)); } } response_headers->setLocation(state_); decoder_callbacks_->encodeHeaders(std::move(response_headers), true, REDIRECT_LOGGED_IN); config_->stats().oauth_success_.inc(); decoder_callbacks_->continueDecoding(); }
Description: Envoy is a cloud-native high-performance proxy. In versions prior to 1.22.1 the OAuth filter implementation does not include a mechanism for validating access tokens, so by design when the HMAC signed cookie is missing a full authentication flow should be triggered. However, the current implementation assumes that access tokens are always validated thus allowing access in the presence of any access token attached to the request. Users are advised to upgrade. There is no known workaround for this issue.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void pfcp_recv_cb(short when, ogs_socket_t fd, void *data) { int rv; ssize_t size; sgwc_event_t *e = NULL; ogs_pkbuf_t *pkbuf = NULL; ogs_sockaddr_t from; ogs_pfcp_node_t *node = NULL; ogs_pfcp_header_t *h = NULL; ogs_assert(fd != INVALID_SOCKET); pkbuf = ogs_pkbuf_alloc(NULL, OGS_MAX_SDU_LEN); ogs_assert(pkbuf); ogs_pkbuf_put(pkbuf, OGS_MAX_SDU_LEN); size = ogs_recvfrom(fd, pkbuf->data, pkbuf->len, 0, &from); if (size <= 0) { ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno, ""ogs_recvfrom() failed""); ogs_pkbuf_free(pkbuf); return; } ogs_pkbuf_trim(pkbuf, size); h = (ogs_pfcp_header_t *)pkbuf->data; if (h->version > OGS_PFCP_VERSION) { ogs_pfcp_header_t rsp; ogs_error(""Not supported version[%d]"", h->version); memset(&rsp, 0, sizeof rsp); rsp.flags = (OGS_PFCP_VERSION << 5); rsp.type = OGS_PFCP_VERSION_NOT_SUPPORTED_RESPONSE_TYPE; rsp.length = htobe16(4); rsp.sqn_only = h->sqn_only; if (ogs_sendto(fd, &rsp, 8, 0, &from) < 0) { ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno, ""ogs_sendto() failed""); } ogs_pkbuf_free(pkbuf); return; } e = sgwc_event_new(SGWC_EVT_SXA_MESSAGE); ogs_assert(e); node = ogs_pfcp_node_find(&ogs_pfcp_self()->pfcp_peer_list, &from); if (!node) { node = ogs_pfcp_node_add(&ogs_pfcp_self()->pfcp_peer_list, &from); ogs_assert(node); node->sock = data; pfcp_node_fsm_init(node, false); } e->pfcp_node = node; e->pkbuf = pkbuf; rv = ogs_queue_push(ogs_app()->queue, e); if (rv != OGS_OK) { ogs_error(""ogs_queue_push() failed:%d"", (int)rv); ogs_pkbuf_free(e->pkbuf); sgwc_event_free(e); } }
Description: A vulnerability has been found in Open5GS up to 2.4.10 and classified as problematic. This vulnerability affects unknown code in the library lib/core/ogs-tlv-msg.c of the component UDP Packet Handler. The manipulation leads to denial of service. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. VDB-209686 is the identifier assigned to this vulnerability.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void gs_manager_destroy_windows (GSManager *manager) { GdkDisplay  *display; GSList      *l; g_return_if_fail (manager != NULL); g_return_if_fail (GS_IS_MANAGER (manager)); if (manager->priv->windows == NULL) { return; } display = gdk_display_get_default (); g_signal_handlers_disconnect_by_func (gdk_display_get_default_screen (display), on_screen_monitors_changed, manager); for (l = manager->priv->windows; l; l = l->next) { gs_window_destroy (l->data); } g_slist_free (manager->priv->windows); manager->priv->windows = NULL; }
Description: mate-screensaver before 1.20.2 in MATE Desktop Environment allows physically proximate attackers to view screen content and possibly control applications. By unplugging and re-plugging or power-cycling external output devices (such as additionally attached graphical outputs via HDMI, VGA, DVI, etc.) the content of a screensaver-locked session can be revealed. In some scenarios, the attacker can execute applications, such as by clicking with a mouse.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void shut(pid_t pid) { EUID_ASSERT(); EUID_ROOT(); char *comm = pid_proc_comm(pid); EUID_USER(); if (comm) { if (strcmp(comm, ""firejail"") != 0) { fprintf(stderr, ""Error: this is not a firejail sandbox\n""); exit(1); } free(comm); } else errExit(""/proc/PID/comm""); uid_t uid = getuid(); if (uid != 0) { uid_t sandbox_uid = pid_get_uid(pid); if (uid != sandbox_uid) { fprintf(stderr, ""Error: permission is denied to shutdown a sandbox created by a different user.\n""); exit(1); } } printf(""Sending SIGTERM to %u\n"", pid); kill(pid, SIGTERM); int monsec = 10; char *monfile; if (asprintf(&monfile, ""/proc/%d/cmdline"", pid) == -1) errExit(""asprintf""); int killdone = 0; usleep(200000);  while (monsec) { sleep(1); monsec--; FILE *fp = fopen(monfile, ""r""); if (!fp) { killdone = 1; break; } char c; size_t count = fread(&c, 1, 1, fp); fclose(fp); if (count == 0) { killdone = 1; break; } } free(monfile); if (!killdone) { pid_t child; if (find_child(pid, &child) == 0) { printf(""Sending SIGKILL to %u\n"", child); kill(child, SIGKILL); } printf(""Sending SIGKILL to %u\n"", pid); kill(pid, SIGKILL); } EUID_ROOT(); delete_run_files(pid); }
Description: Firejail before 0.9.60 allows truncation (resizing to length 0) of the firejail binary on the host by running exploit code inside a firejail sandbox and having the sandbox terminated. To succeed, certain conditions need to be fulfilled: The jail (with the exploit code inside) needs to be started as root, and it also needs to be terminated as root from the host (either by stopping it ungracefully (e.g., SIGKILL), or by using the --shutdown control command). This is similar to CVE-2019-5736.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static bool __oom_reap_task_mm(struct task_struct *tsk, struct mm_struct *mm) { struct mmu_gather tlb; struct vm_area_struct *vma; bool ret = true; mutex_lock(&oom_lock); if (!down_read_trylock(&mm->mmap_sem)) { ret = false; trace_skip_task_reaping(tsk->pid); goto unlock_oom; } if (mm_has_notifiers(mm)) { up_read(&mm->mmap_sem); schedule_timeout_idle(HZ); goto unlock_oom; } if (test_bit(MMF_OOM_SKIP, &mm->flags)) { up_read(&mm->mmap_sem); trace_skip_task_reaping(tsk->pid); goto unlock_oom; } trace_start_task_reaping(tsk->pid); set_bit(MMF_UNSTABLE, &mm->flags); tlb_gather_mmu(&tlb, mm, 0, -1); for (vma = mm->mmap ; vma; vma = vma->vm_next) { if (!can_madv_dontneed_vma(vma)) continue; if (vma_is_anonymous(vma) || !(vma->vm_flags & VM_SHARED)) unmap_page_range(&tlb, vma, vma->vm_start, vma->vm_end, NULL); } tlb_finish_mmu(&tlb, 0, -1); pr_info(""oom_reaper: reaped process %d (%s), now anon-rss:%lukB, file-rss:%lukB, shmem-rss:%lukB\n"", task_pid_nr(tsk), tsk->comm, K(get_mm_counter(mm, MM_ANONPAGES)), K(get_mm_counter(mm, MM_FILEPAGES)), K(get_mm_counter(mm, MM_SHMEMPAGES))); up_read(&mm->mmap_sem); trace_finish_task_reaping(tsk->pid); unlock_oom: mutex_unlock(&oom_lock); return ret; }
Description: The __oom_reap_task_mm function in mm/oom_kill.c in the Linux kernel before 4.14.4 mishandles gather operations, which allows attackers to cause a denial of service (TLB entry leak or use-after-free) or possibly have unspecified other impact by triggering a copy_to_user call within a certain time window.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: mp_err mp_mul_2d(const mp_int *a, int b, mp_int *c) { mp_digit d; mp_err   err; if (a != c) { if ((err = mp_copy(a, c)) != MP_OKAY) { return err; } } if (c->alloc < (c->used + (b / MP_DIGIT_BIT) + 1)) { if ((err = mp_grow(c, c->used + (b / MP_DIGIT_BIT) + 1)) != MP_OKAY) { return err; } } if (b >= MP_DIGIT_BIT) { if ((err = mp_lshd(c, b / MP_DIGIT_BIT)) != MP_OKAY) { return err; } } d = (mp_digit)(b % MP_DIGIT_BIT); if (d != 0u) { mp_digit *tmpc, shift, mask, r, rr; int x; mask = ((mp_digit)1 << d) - (mp_digit)1; shift = (mp_digit)MP_DIGIT_BIT - d; tmpc = c->dp; r    = 0; for (x = 0; x < c->used; x++) { rr = (*tmpc >> shift) & mask; *tmpc = ((*tmpc << d) | r) & MP_MASK; ++tmpc; r = rr; } if (r != 0u) { c->dp[(c->used)++] = r; } } mp_clamp(c); return MP_OKAY; }
Description: Integer Overflow vulnerability in mp_grow in libtom libtommath before commit beba892bc0d4e4ded4d667ab1d2a94f4d75109a9, allows attackers to execute arbitrary code and cause a denial of service (DoS).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void gps_tracker( void ) { ssize_t unused; int gpsd_sock; char line[256], *temp; struct sockaddr_in gpsd_addr; int ret, is_json, pos; fd_set read_fd; struct timeval timeout; pos = 0; gpsd_sock = socket( AF_INET, SOCK_STREAM, 0 ); if( gpsd_sock < 0 ) { return; } gpsd_addr.sin_family      = AF_INET; gpsd_addr.sin_port        = htons( 2947 ); gpsd_addr.sin_addr.s_addr = inet_addr( ""127.0.0.1"" ); if( connect( gpsd_sock, (struct sockaddr *) &gpsd_addr, sizeof( gpsd_addr ) ) < 0 ) { return; } FD_ZERO(&read_fd); FD_SET(gpsd_sock, &read_fd); timeout.tv_sec = 1; timeout.tv_usec = 0; is_json = select(gpsd_sock + 1, &read_fd, NULL, NULL, &timeout); if (is_json) { if( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 ) return; is_json = (line[0] == '{'); if (is_json) { memset( line, 0, sizeof( line ) ); strcpy(line, ""?WATCH={\""json\"":true};\n""); if( send( gpsd_sock, line, 22, 0 ) != 22 ) return; memset(line, 0, sizeof(line)); if( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 ) return; if (strncmp(line, ""{\""class\"":\""DEVICES\"",\""devices\"":[]}"", 32) == 0) { close(gpsd_sock); return; } else { pos = strlen(line); } } } while( G.do_exit == 0 ) { usleep( 500000 ); memset( G.gps_loc, 0, sizeof( float ) * 5 ); if (is_json) { if (pos == sizeof( line )) { memset(line, 0, sizeof(line)); pos = 0; } if( recv( gpsd_sock, line + pos, sizeof( line ) - 1, 0 ) <= 0 ) return; temp = strstr(line, ""{\""class\"":\""TPV\""""); if (temp == NULL) { continue; } if (strchr(temp, '}') == NULL) { pos = strlen(temp); if (temp != line) { memmove(line, temp, pos); memset(line + pos, 0, sizeof(line) - pos); } } temp = strstr(temp, ""\""lat\"":""); if (temp == NULL) { continue; } ret = sscanf(temp + 6, ""%f"", &G.gps_loc[0]); temp = strstr(temp, ""\""lon\"":""); if (temp == NULL) { continue; } ret = sscanf(temp + 6, ""%f"", &G.gps_loc[1]); temp = strstr(temp, ""\""alt\"":""); if (temp == NULL) { continue; } ret = sscanf(temp + 6, ""%f"", &G.gps_loc[4]); temp = strstr(temp, ""\""speed\"":""); if (temp == NULL) { continue; } ret = sscanf(temp + 6, ""%f"", &G.gps_loc[2]); temp = strstr(temp, ""{\""class\"":\""TPV\""""); if (temp == NULL) { memset( line, 0, sizeof( line ) ); pos = 0; } else { pos = strlen(temp); memmove(line, temp, pos); memset(line + pos, 0, sizeof(line) - pos); } } else { memset( line, 0, sizeof( line ) ); snprintf( line,  sizeof( line ) - 1, ""PVTAD\r\n"" ); if( send( gpsd_sock, line, 7, 0 ) != 7 ) return; memset( line, 0, sizeof( line ) ); if( recv( gpsd_sock, line, sizeof( line ) - 1, 0 ) <= 0 ) return; if( memcmp( line, ""GPSD,P="", 7 ) != 0 ) continue; if( line[7] == '?' ) continue; ret = sscanf( line + 7, ""%f %f"", &G.gps_loc[0], &G.gps_loc[1] ); if( ( temp = strstr( line, ""V="" ) ) == NULL ) continue; ret = sscanf( temp + 2, ""%f"", &G.gps_loc[2] );  if( ( temp = strstr( line, ""T="" ) ) == NULL ) continue; ret = sscanf( temp + 2, ""%f"", &G.gps_loc[3] );  if( ( temp = strstr( line, ""A="" ) ) == NULL ) continue; ret = sscanf( temp + 2, ""%f"", &G.gps_loc[4] );  } if (G.record_data) fputs( line, G.f_gps ); G.save_gps = 1; if (G.do_exit == 0) { unused = write( G.gc_pipe[1], G.gps_loc, sizeof( float ) * 5 ); kill( getppid(), SIGUSR2 ); } } }
Description: Stack-based buffer overflow in the gps_tracker function in airodump-ng.c in Aircrack-ng before 1.2 RC 1 allows local users to execute arbitrary code or gain privileges via unspecified vectors.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void async_polkit_query_free(AsyncPolkitQuery *q) { if (!q) return; sd_bus_slot_unref(q->slot); if (q->registry && q->request) hashmap_remove(q->registry, q->request); sd_bus_message_unref(q->request); sd_bus_message_unref(q->reply); free(q->action); strv_free(q->details); free(q); }
Description: A heap use-after-free vulnerability was found in systemd before version v245-rc1, where asynchronous Polkit queries are performed while handling dbus messages. A local unprivileged attacker can abuse this flaw to crash systemd services or potentially execute code and elevate their privileges, by sending specially crafted dbus messages.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void formUpdateBuffer(Anchor *a, Buffer *buf, FormItemList *form) { Buffer save; char *p; int spos, epos, rows, c_rows, pos, col = 0; Line *l; copyBuffer(&save, buf); gotoLine(buf, a->start.line); switch (form->type) { case FORM_TEXTAREA: case FORM_INPUT_TEXT: case FORM_INPUT_FILE: case FORM_INPUT_PASSWORD: case FORM_INPUT_CHECKBOX: case FORM_INPUT_RADIO: #ifdef MENU_SELECT case FORM_SELECT: #endif spos = a->start.pos; epos = a->end.pos; break; default: spos = a->start.pos + 1; epos = a->end.pos - 1; } switch (form->type) { case FORM_INPUT_CHECKBOX: case FORM_INPUT_RADIO: if (form->checked) buf->currentLine->lineBuf[spos] = '*'; else buf->currentLine->lineBuf[spos] = ' '; break; case FORM_INPUT_TEXT: case FORM_INPUT_FILE: case FORM_INPUT_PASSWORD: case FORM_TEXTAREA: #ifdef MENU_SELECT case FORM_SELECT: if (form->type == FORM_SELECT) { p = form->label->ptr; updateSelectOption(form, form->select_option); } else #endif p = form->value->ptr; l = buf->currentLine; if (!l) break; if (form->type == FORM_TEXTAREA) { int n = a->y - buf->currentLine->linenumber; if (n > 0) for (; l && n; l = l->prev, n--) ; else if (n < 0) for (; l && n; l = l->prev, n++) ; if (!l) break; } rows = form->rows ? form->rows : 1; col = COLPOS(l, a->start.pos); for (c_rows = 0; c_rows < rows; c_rows++, l = l->next) { if (rows > 1) { pos = columnPos(l, col); a = retrieveAnchor(buf->formitem, l->linenumber, pos); if (a == NULL) break; spos = a->start.pos; epos = a->end.pos; } if (a->start.line != a->end.line || spos > epos || epos >= l->len) break; pos = form_update_line(l, &p, spos, epos, COLPOS(l, epos) - col, rows > 1, form->type == FORM_INPUT_PASSWORD); if (pos != epos) { shiftAnchorPosition(buf->href, buf->hmarklist, a->start.line, spos, pos - epos); shiftAnchorPosition(buf->name, buf->hmarklist, a->start.line, spos, pos - epos); shiftAnchorPosition(buf->img, buf->hmarklist, a->start.line, spos, pos - epos); shiftAnchorPosition(buf->formitem, buf->hmarklist, a->start.line, spos, pos - epos); } } break; } copyBuffer(buf, &save); arrangeLine(buf); }
Description: An issue was discovered in the Tatsuya Kinoshita w3m fork before 0.5.3-31. w3m allows remote attackers to cause a denial of service (segmentation fault and crash) via a crafted HTML page.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int spl_filesystem_file_read_csv(spl_filesystem_object *intern, char delimiter, char enclosure, char escape, zval *return_value TSRMLS_DC)  { int ret = SUCCESS; do { ret = spl_filesystem_file_read(intern, 1 TSRMLS_CC); } while (ret == SUCCESS && !intern->u.file.current_line_len && SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY)); if (ret == SUCCESS) { size_t buf_len = intern->u.file.current_line_len; char *buf = estrndup(intern->u.file.current_line, buf_len); if (intern->u.file.current_zval) { zval_ptr_dtor(&intern->u.file.current_zval); } ALLOC_INIT_ZVAL(intern->u.file.current_zval); php_fgetcsv(intern->u.file.stream, delimiter, enclosure, escape, buf_len, buf, intern->u.file.current_zval TSRMLS_CC); if (return_value) { if (Z_TYPE_P(return_value) != IS_NULL) { zval_dtor(return_value); ZVAL_NULL(return_value); } ZVAL_ZVAL(return_value, intern->u.file.current_zval, 1, 0); } } return ret; }
Description: Integer overflow in the SplFileObject::fread function in spl_directory.c in the SPL extension in PHP before 5.5.37 and 5.6.x before 5.6.23 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a large integer argument, a related issue to CVE-2016-5096.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void process_constructors (RBinFile *bf, RList *ret, int bits) { RList *secs = sections (bf); RListIter *iter; RBinSection *sec; int i, type; r_list_foreach (secs, iter, sec) { type = -1; if (!strcmp (sec->name, "".fini_array"")) { type = R_BIN_ENTRY_TYPE_FINI; } else if (!strcmp (sec->name, "".init_array"")) { type = R_BIN_ENTRY_TYPE_INIT; } else if (!strcmp (sec->name, "".preinit_array"")) { type = R_BIN_ENTRY_TYPE_PREINIT; } if (type != -1) { ut8 *buf = calloc (sec->size, 1); if (!buf) { continue; } (void)r_buf_read_at (bf->buf, sec->paddr, buf, sec->size); if (bits == 32) { for (i = 0; i < sec->size; i += 4) { ut32 addr32 = r_read_le32 (buf + i); if (addr32) { RBinAddr *ba = newEntry (sec->paddr + i, (ut64)addr32, type, bits); r_list_append (ret, ba); } } } else { for (i = 0; i < sec->size; i += 8) { ut64 addr64 = r_read_le64 (buf + i); if (addr64) { RBinAddr *ba = newEntry (sec->paddr + i, addr64, type, bits); r_list_append (ret, ba); } } } free (buf); } } r_list_free (secs); }
Description: The r_read_le32() function in radare2 2.5.0 allows remote attackers to cause a denial of service (heap-based out-of-bounds read and application crash) via a crafted ELF file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void GetOutboundPinholeTimeout(struct upnphttp * h, const char * action, const char * ns) { int r; static const char resp[] = ""<u:%sResponse "" ""xmlns:u=\""%s\"">"" ""<OutboundPinholeTimeout>%d</OutboundPinholeTimeout>"" ""</u:%sResponse>""; char body[512]; int bodylen; struct NameValueParserData data; char * int_ip, * int_port, * rem_host, * rem_port, * protocol; int opt=0; unsigned short iport, rport; if (GETFLAG(IPV6FCFWDISABLEDMASK)) { SoapError(h, 702, ""FirewallDisabled""); return; } ParseNameValue(h->req_buf + h->req_contentoff, h->req_contentlen, &data); int_ip = GetValueFromNameValueList(&data, ""InternalClient""); int_port = GetValueFromNameValueList(&data, ""InternalPort""); rem_host = GetValueFromNameValueList(&data, ""RemoteHost""); rem_port = GetValueFromNameValueList(&data, ""RemotePort""); protocol = GetValueFromNameValueList(&data, ""Protocol""); if (!int_port || !ext_port || !protocol) { ClearNameValueList(&data); SoapError(h, 402, ""Invalid Args""); return; } rport = (unsigned short)atoi(rem_port); iport = (unsigned short)atoi(int_port); syslog(LOG_INFO, ""%s: retrieving timeout for outbound pinhole from [%s]:%hu to [%s]:%hu protocol %s"", action, int_ip, iport,rem_host, rport, protocol); r = -1; switch(r) { case 1: bodylen = snprintf(body, sizeof(body), resp, action, ns, opt, action); BuildSendAndCloseSoapResp(h, body, bodylen); break; case -5: SoapError(h, 705, ""ProtocolNotSupported""); break; default: SoapError(h, 501, ""ActionFailed""); } ClearNameValueList(&data); }
Description: A Denial Of Service vulnerability in MiniUPnP MiniUPnPd through 2.1 exists due to a NULL pointer dereference in GetOutboundPinholeTimeout in upnpsoap.c for int_port.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void push_symbol(Str str, char symbol, int width, int n) { char buf[2], *p; int i; #ifdef USE_M17N if (width == 2) p = alt2_symbol[(int)symbol]; else #endif p = alt_symbol[(int)symbol]; for (i = 0; i < 2 && *p; i++, p++) buf[i] = (*p == ' ') ? NBSP_CODE : *p; Strcat(str, Sprintf(""<_SYMBOL TYPE=%d>"", symbol)); for (; n > 0; n--) Strcat_charp_n(str, buf, i); Strcat_charp(str, ""</_SYMBOL>""); }
Description: An issue was discovered in the Tatsuya Kinoshita w3m fork before 0.5.3-33. w3m allows remote attackers to cause a denial of service (heap buffer overflow and crash) via a crafted HTML page.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void ReadJPEG( JPEGReader* pJPEGReader, void* pInputStream, long* pLines, Size const & previewSize ) { jpeg_decompress_struct cinfo; ErrorManagerStruct jerr; if ( setjmp( jerr.setjmp_buffer ) ) { jpeg_destroy_decompress( &cinfo ); return; } cinfo.err = jpeg_std_error( &jerr.pub ); jerr.pub.error_exit = errorExit; jerr.pub.output_message = outputMessage; jpeg_create_decompress( &cinfo ); jpeg_svstream_src( &cinfo, pInputStream ); SourceManagerStruct *source = reinterpret_cast<SourceManagerStruct*>(cinfo.src); jpeg_read_header( &cinfo, TRUE ); cinfo.scale_num = 1; cinfo.scale_denom = 1; cinfo.output_gamma = 1.0; cinfo.raw_data_out = FALSE; cinfo.quantize_colors = FALSE; long nPreviewWidth = previewSize.Width(); long nPreviewHeight = previewSize.Height(); if( nPreviewWidth || nPreviewHeight ) { if( nPreviewWidth == 0 ) { nPreviewWidth = ( cinfo.image_width * nPreviewHeight ) / cinfo.image_height; if( nPreviewWidth <= 0 ) { nPreviewWidth = 1; } } else if( nPreviewHeight == 0 ) { nPreviewHeight = ( cinfo.image_height * nPreviewWidth ) / cinfo.image_width; if( nPreviewHeight <= 0 ) { nPreviewHeight = 1; } } for( cinfo.scale_denom = 1; cinfo.scale_denom < 8; cinfo.scale_denom *= 2 ) { if( cinfo.image_width < nPreviewWidth * cinfo.scale_denom ) break; if( cinfo.image_height < nPreviewHeight * cinfo.scale_denom ) break; } if( cinfo.scale_denom > 1 ) { cinfo.dct_method            = JDCT_FASTEST; cinfo.do_fancy_upsampling   = FALSE; cinfo.do_block_smoothing    = FALSE; } } jpeg_start_decompress( &cinfo ); long nWidth = cinfo.output_width; long nHeight = cinfo.output_height; bool bGray = (cinfo.output_components == 1); JPEGCreateBitmapParam aCreateBitmapParam; aCreateBitmapParam.nWidth = nWidth; aCreateBitmapParam.nHeight = nHeight; aCreateBitmapParam.density_unit = cinfo.density_unit; aCreateBitmapParam.X_density = cinfo.X_density; aCreateBitmapParam.Y_density = cinfo.Y_density; aCreateBitmapParam.bGray = bGray; bool bBitmapCreated = pJPEGReader->CreateBitmap(aCreateBitmapParam); if (bBitmapCreated) { Bitmap::ScopedWriteAccess pAccess(pJPEGReader->GetBitmap()); if (pAccess) { int nPixelSize = 3; J_COLOR_SPACE best_out_color_space = JCS_RGB; ScanlineFormat eScanlineFormat = ScanlineFormat::N24BitTcRgb; ScanlineFormat eFinalFormat = pAccess->GetScanlineFormat(); if (eFinalFormat == ScanlineFormat::N32BitTcBgra) { best_out_color_space = JCS_EXT_BGRA; eScanlineFormat = eFinalFormat; nPixelSize = 4; } else if (eFinalFormat == ScanlineFormat::N32BitTcRgba) { best_out_color_space = JCS_EXT_RGBA; eScanlineFormat = eFinalFormat; nPixelSize = 4; } else if (eFinalFormat == ScanlineFormat::N32BitTcArgb) { best_out_color_space = JCS_EXT_ARGB; eScanlineFormat = eFinalFormat; nPixelSize = 4; } if ( cinfo.jpeg_color_space == JCS_YCbCr ) cinfo.out_color_space = best_out_color_space; else if ( cinfo.jpeg_color_space == JCS_YCCK ) cinfo.out_color_space = JCS_CMYK; if (cinfo.out_color_space != JCS_CMYK && cinfo.out_color_space != JCS_GRAYSCALE && cinfo.out_color_space != best_out_color_space) { SAL_WARN(""vcl.filter"", ""jpg with unknown out color space, forcing to :"" << best_out_color_space); cinfo.out_color_space = best_out_color_space; } JSAMPLE* aRangeLimit = cinfo.sample_range_limit; std::vector<sal_uInt8> pScanLineBuffer(nWidth * (bGray ? 1 : nPixelSize)); std::vector<sal_uInt8> pCYMKBuffer; if (cinfo.out_color_space == JCS_CMYK) { pCYMKBuffer.resize(nWidth * 4); } std::unique_ptr<BitmapColor[]> pCols; if (bGray) { pCols.reset(new BitmapColor[256]); for (sal_uInt16 n = 0; n < 256; n++) { const sal_uInt8 cGray = n; pCols[n] = pAccess->GetBestMatchingColor(BitmapColor(cGray, cGray, cGray)); } } for (*pLines = 0; *pLines < nHeight && !source->no_data_available; (*pLines)++) { size_t yIndex = *pLines; sal_uInt8* p = (cinfo.out_color_space == JCS_CMYK) ? pCYMKBuffer.data() : pScanLineBuffer.data(); jpeg_read_scanlines(&cinfo, reinterpret_cast<JSAMPARRAY>(&p), 1); if (bGray) { for (long x = 0; x < nWidth; ++x) { sal_uInt8 nColorGray = pScanLineBuffer[x]; pAccess->SetPixel(yIndex, x, pCols[nColorGray]); } } else if (cinfo.out_color_space == JCS_CMYK) { for (long cmyk = 0, x = 0; cmyk < nWidth * 4; cmyk += 4, ++x) { int color_C = 255 - pCYMKBuffer[cmyk + 0]; int color_M = 255 - pCYMKBuffer[cmyk + 1]; int color_Y = 255 - pCYMKBuffer[cmyk + 2]; int color_K = 255 - pCYMKBuffer[cmyk + 3]; sal_uInt8 cRed = aRangeLimit[255L - (color_C + color_K)]; sal_uInt8 cGreen = aRangeLimit[255L - (color_M + color_K)]; sal_uInt8 cBlue = aRangeLimit[255L - (color_Y + color_K)]; pAccess->SetPixel(yIndex, x, BitmapColor(cRed, cGreen, cBlue)); } } else { pAccess->CopyScanline(yIndex, pScanLineBuffer.data(), eScanlineFormat, pScanLineBuffer.size()); } if (cinfo.err->msg_code == 113) break; } } } if (bBitmapCreated) { jpeg_finish_decompress( &cinfo ); } else { jpeg_abort_decompress( &cinfo ); } jpeg_destroy_decompress( &cinfo ); }
Description: LibreOffice before 2017-03-17 has an out-of-bounds write caused by a heap-based buffer overflow related to the ReadJPEG function in vcl/source/filter/jpeg/jpegc.cxx.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: ssize_t enc_untrusted_recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen) { int klinux_flags = TokLinuxRecvSendFlag(flags); if (klinux_flags == 0 && flags != 0) { errno = EINVAL; return -1; } MessageWriter input; input.Push<int>(sockfd); input.Push<uint64_t>(len); input.Push<int>(klinux_flags); MessageReader output; const auto status = NonSystemCallDispatcher( ::asylo::host_call::kRecvFromHandler, &input, &output); CheckStatusAndParamCount(status, output, ""enc_untrusted_recvfrom"", 4); int result = output.next<int>(); int klinux_errno = output.next<int>(); if (result == -1) { errno = FromkLinuxErrorNumber(klinux_errno); return result; } auto buffer_received = output.next(); memcpy(buf, buffer_received.data(), len); if (src_addr != nullptr && addrlen != nullptr) { auto klinux_sockaddr_buf = output.next(); const struct klinux_sockaddr *klinux_addr = klinux_sockaddr_buf.As<struct klinux_sockaddr>(); FromkLinuxSockAddr(klinux_addr, klinux_sockaddr_buf.size(), src_addr, addrlen, TrustedPrimitives::BestEffortAbort); } return result; }
Description: A buffer length validation vulnerability in Asylo versions prior to 0.6.0 allows an attacker to read data they should not have access to. The 'enc_untrusted_recvfrom' function generates a return value which is deserialized by 'MessageReader', and copied into three different 'extents'. The length of the third 'extents' is controlled by the outside world, and not verified on copy, allowing the attacker to force Asylo to copy trusted memory data into an untrusted buffer of significantly small length.. We recommend updating Asylo to version 0.6.0 or later.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int adjust_ptr_min_max_vals(struct bpf_verifier_env *env, struct bpf_insn *insn, const struct bpf_reg_state *ptr_reg, const struct bpf_reg_state *off_reg) { struct bpf_verifier_state *vstate = env->cur_state; struct bpf_func_state *state = vstate->frame[vstate->curframe]; struct bpf_reg_state *regs = state->regs, *dst_reg; bool known = tnum_is_const(off_reg->var_off); s64 smin_val = off_reg->smin_value, smax_val = off_reg->smax_value, smin_ptr = ptr_reg->smin_value, smax_ptr = ptr_reg->smax_value; u64 umin_val = off_reg->umin_value, umax_val = off_reg->umax_value, umin_ptr = ptr_reg->umin_value, umax_ptr = ptr_reg->umax_value; struct bpf_insn_aux_data tmp_aux = {}; u8 opcode = BPF_OP(insn->code); u32 dst = insn->dst_reg; int ret; dst_reg = &regs[dst]; if ((known && (smin_val != smax_val || umin_val != umax_val)) || smin_val > smax_val || umin_val > umax_val) { __mark_reg_unknown(env, dst_reg); return 0; } if (BPF_CLASS(insn->code) != BPF_ALU64) { if (opcode == BPF_SUB && env->allow_ptr_leaks) { __mark_reg_unknown(env, dst_reg); return 0; } verbose(env, ""R%d 32-bit pointer arithmetic prohibited\n"", dst); return -EACCES; } switch (ptr_reg->type) { case PTR_TO_MAP_VALUE_OR_NULL: verbose(env, ""R%d pointer arithmetic on %s prohibited, null-check it first\n"", dst, reg_type_str[ptr_reg->type]); return -EACCES; case CONST_PTR_TO_MAP: if (known && smin_val == 0 && opcode == BPF_ADD) break; fallthrough; case PTR_TO_PACKET_END: case PTR_TO_SOCKET: case PTR_TO_SOCKET_OR_NULL: case PTR_TO_SOCK_COMMON: case PTR_TO_SOCK_COMMON_OR_NULL: case PTR_TO_TCP_SOCK: case PTR_TO_TCP_SOCK_OR_NULL: case PTR_TO_XDP_SOCK: verbose(env, ""R%d pointer arithmetic on %s prohibited\n"", dst, reg_type_str[ptr_reg->type]); return -EACCES; default: break; } dst_reg->type = ptr_reg->type; dst_reg->id = ptr_reg->id; if (!check_reg_sane_offset(env, off_reg, ptr_reg->type) || !check_reg_sane_offset(env, ptr_reg, ptr_reg->type)) return -EINVAL; __mark_reg32_unbounded(dst_reg); if (sanitize_needed(opcode)) { ret = sanitize_ptr_alu(env, insn, ptr_reg, off_reg, dst_reg, &tmp_aux, false); if (ret < 0) return sanitize_err(env, insn, ret, off_reg, dst_reg); } switch (opcode) { case BPF_ADD: if (known && (ptr_reg->off + smin_val == (s64)(s32)(ptr_reg->off + smin_val))) { dst_reg->smin_value = smin_ptr; dst_reg->smax_value = smax_ptr; dst_reg->umin_value = umin_ptr; dst_reg->umax_value = umax_ptr; dst_reg->var_off = ptr_reg->var_off; dst_reg->off = ptr_reg->off + smin_val; dst_reg->raw = ptr_reg->raw; break; } if (signed_add_overflows(smin_ptr, smin_val) || signed_add_overflows(smax_ptr, smax_val)) { dst_reg->smin_value = S64_MIN; dst_reg->smax_value = S64_MAX; } else { dst_reg->smin_value = smin_ptr + smin_val; dst_reg->smax_value = smax_ptr + smax_val; } if (umin_ptr + umin_val < umin_ptr || umax_ptr + umax_val < umax_ptr) { dst_reg->umin_value = 0; dst_reg->umax_value = U64_MAX; } else { dst_reg->umin_value = umin_ptr + umin_val; dst_reg->umax_value = umax_ptr + umax_val; } dst_reg->var_off = tnum_add(ptr_reg->var_off, off_reg->var_off); dst_reg->off = ptr_reg->off; dst_reg->raw = ptr_reg->raw; if (reg_is_pkt_pointer(ptr_reg)) { dst_reg->id = ++env->id_gen; memset(&dst_reg->raw, 0, sizeof(dst_reg->raw)); } break; case BPF_SUB: if (dst_reg == off_reg) { verbose(env, ""R%d tried to subtract pointer from scalar\n"", dst); return -EACCES; } if (ptr_reg->type == PTR_TO_STACK) { verbose(env, ""R%d subtraction from stack pointer prohibited\n"", dst); return -EACCES; } if (known && (ptr_reg->off - smin_val == (s64)(s32)(ptr_reg->off - smin_val))) { dst_reg->smin_value = smin_ptr; dst_reg->smax_value = smax_ptr; dst_reg->umin_value = umin_ptr; dst_reg->umax_value = umax_ptr; dst_reg->var_off = ptr_reg->var_off; dst_reg->id = ptr_reg->id; dst_reg->off = ptr_reg->off - smin_val; dst_reg->raw = ptr_reg->raw; break; } if (signed_sub_overflows(smin_ptr, smax_val) || signed_sub_overflows(smax_ptr, smin_val)) { dst_reg->smin_value = S64_MIN; dst_reg->smax_value = S64_MAX; } else { dst_reg->smin_value = smin_ptr - smax_val; dst_reg->smax_value = smax_ptr - smin_val; } if (umin_ptr < umax_val) { dst_reg->umin_value = 0; dst_reg->umax_value = U64_MAX; } else { dst_reg->umin_value = umin_ptr - umax_val; dst_reg->umax_value = umax_ptr - umin_val; } dst_reg->var_off = tnum_sub(ptr_reg->var_off, off_reg->var_off); dst_reg->off = ptr_reg->off; dst_reg->raw = ptr_reg->raw; if (reg_is_pkt_pointer(ptr_reg)) { dst_reg->id = ++env->id_gen; if (smin_val < 0) memset(&dst_reg->raw, 0, sizeof(dst_reg->raw)); } break; case BPF_AND: case BPF_OR: case BPF_XOR: verbose(env, ""R%d bitwise operator %s on pointer prohibited\n"", dst, bpf_alu_string[opcode >> 4]); return -EACCES; default: verbose(env, ""R%d pointer arithmetic with %s operator prohibited\n"", dst, bpf_alu_string[opcode >> 4]); return -EACCES; } if (!check_reg_sane_offset(env, dst_reg, ptr_reg->type)) return -EINVAL; __update_reg_bounds(dst_reg); __reg_deduce_bounds(dst_reg); __reg_bound_offset(dst_reg); if (sanitize_check_bounds(env, insn, dst_reg) < 0) return -EACCES; if (sanitize_needed(opcode)) { ret = sanitize_ptr_alu(env, insn, dst_reg, off_reg, dst_reg, &tmp_aux, true); if (ret < 0) return sanitize_err(env, insn, ret, off_reg, dst_reg); } return 0; }
Description: kernel/bpf/verifier.c in the Linux kernel through 5.12.7 enforces incorrect limits for pointer arithmetic operations, aka CID-bb01a1bba579. This can be abused to perform out-of-bounds reads and writes in kernel memory, leading to local privilege escalation to root. In particular, there is a corner case where the off reg causes a masking direction change, which then results in an incorrect final aux->alu_limit.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void release_card(struct l1oip *hc) { intch; if (timer_pending(&hc->keep_tl)) del_timer(&hc->keep_tl); if (timer_pending(&hc->timeout_tl)) del_timer(&hc->timeout_tl); cancel_work_sync(&hc->workq); if (hc->socket_thread) l1oip_socket_close(hc); if (hc->registered && hc->chan[hc->d_idx].dch) mISDN_unregister_device(&hc->chan[hc->d_idx].dch->dev); for (ch = 0; ch < 128; ch++) { if (hc->chan[ch].dch) { mISDN_freedchannel(hc->chan[ch].dch); kfree(hc->chan[ch].dch); } if (hc->chan[ch].bch) { mISDN_freebchannel(hc->chan[ch].bch); kfree(hc->chan[ch].bch); #ifdef REORDER_DEBUG dev_kfree_skb(hc->chan[ch].disorder_skb); #endif } } spin_lock(&l1oip_lock); list_del(&hc->list); spin_unlock(&l1oip_lock); kfree(hc); }
Description: A vulnerability, which was classified as critical, has been found in Linux Kernel. Affected by this issue is the function del_timer of the file drivers/isdn/mISDN/l1oip_core.c of the component Bluetooth. The manipulation leads to use after free. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211088.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void TiffImage::readMetadata() { #ifdef DEBUG std::cerr << ""Reading TIFF file "" << io_->path() << ""\n""; #endif if (io_->open() != 0) throw Error(kerDataSourceOpenFailed, io_->path(), strError()); IoCloser closer(*io_); if (!isTiffType(*io_, false)) { if (io_->error() || io_->eof()) throw Error(kerFailedToReadImageData); throw Error(kerNotAnImage, ""TIFF""); } clearMetadata(); ByteOrder bo = TiffParser::decode(exifData_, iptcData_, xmpData_, io_->mmap(), (uint32_t) io_->size()); setByteOrder(bo); Exiv2::ExifKey            key(""Exif.Image.InterColorProfile""); Exiv2::ExifData::iterator pos   = exifData_.findKey(key); if ( pos != exifData_.end()  ) { iccProfile_.alloc(pos->count()*pos->typeSize()); pos->copy(iccProfile_.pData_,bo); } }
Description: An issue was discovered in Exiv2 v0.26. The function Exiv2::DataValue::copy in value.cpp has a NULL pointer dereference.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static inline void io_uring_files_cancel(struct files_struct *files) { if (current->io_uring && !xa_empty(&current->io_uring->xa)) __io_uring_files_cancel(files); }
Description: There is a logic error in io_uring's implementation which can be used to trigger a use-after-free vulnerability leading to privilege escalation.

In the io_prep_async_work function the assumption that the last io_grab_identity call cannot return false is not true, and in this case the function will use the init_cred or the previous linked requests identity to do operations instead of using the current identity. This can lead to reference counting issues causing use-after-free. We recommend upgrading past version 5.10.161.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: inline void StringData::setSize(int len) { assertx(!isImmutable() && !hasMultipleRefs()); assertx(len >= 0 && len <= capacity()); mutableData()[len] = 0; m_lenAndHash = len; assertx(m_hash == 0); assertx(checkSane()); }
Description: xbuf_format_converter, used as part of exif_read_data, was appending a terminating null character to the generated string, but was not using its standard append char function. As a result, if the buffer was full, it would result in an out-of-bounds write. This issue affects HHVM versions prior to 4.56.3, all versions between 4.57.0 and 4.80.1, all versions between 4.81.0 and 4.93.1, and versions 4.94.0, 4.95.0, 4.96.0, 4.97.0, 4.98.0.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void free_nested(struct kvm_vcpu *vcpu) { struct vcpu_vmx *vmx = to_vmx(vcpu); if (!vmx->nested.vmxon && !vmx->nested.smm.vmxon) return; vmx->nested.vmxon = false; vmx->nested.smm.vmxon = false; free_vpid(vmx->nested.vpid02); vmx->nested.posted_intr_nv = -1; vmx->nested.current_vmptr = -1ull; if (enable_shadow_vmcs) { vmx_disable_shadow_vmcs(vmx); vmcs_clear(vmx->vmcs01.shadow_vmcs); free_vmcs(vmx->vmcs01.shadow_vmcs); vmx->vmcs01.shadow_vmcs = NULL; } kfree(vmx->nested.cached_vmcs12); kfree(vmx->nested.cached_shadow_vmcs12); if (vmx->nested.apic_access_page) { kvm_release_page_dirty(vmx->nested.apic_access_page); vmx->nested.apic_access_page = NULL; } if (vmx->nested.virtual_apic_page) { kvm_release_page_dirty(vmx->nested.virtual_apic_page); vmx->nested.virtual_apic_page = NULL; } if (vmx->nested.pi_desc_page) { kunmap(vmx->nested.pi_desc_page); kvm_release_page_dirty(vmx->nested.pi_desc_page); vmx->nested.pi_desc_page = NULL; vmx->nested.pi_desc = NULL; } kvm_mmu_free_roots(vcpu, &vcpu->arch.guest_mmu, KVM_MMU_ROOTS_ALL); nested_release_evmcs(vcpu); free_loaded_vmcs(&vmx->nested.vmcs02); }
Description: The KVM implementation in the Linux kernel through 4.20.5 has a Use-after-Free.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: struct clock_source *dcn20_clock_source_create( struct dc_context *ctx, struct dc_bios *bios, enum clock_source_id id, const struct dce110_clk_src_regs *regs, bool dp_clk_src) { struct dce110_clk_src *clk_src = kzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL); if (!clk_src) return NULL; if (dcn20_clk_src_construct(clk_src, ctx, bios, id, regs, &cs_shift, &cs_mask)) { clk_src->base.dp_clk_src = dp_clk_src; return &clk_src->base; } BREAK_TO_DEBUGGER(); return NULL; }
Description: Memory leaks in *clock_source_create() functions under drivers/gpu/drm/amd/display/dc in the Linux kernel before 5.3.8 allow attackers to cause a denial of service (memory consumption). This affects the dce112_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce112/dce112_resource.c, the dce100_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce100/dce100_resource.c, the dcn10_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn10/dcn10_resource.c, the dcn20_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dcn20/dcn20_resource.c, the dce120_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce120/dce120_resource.c, the dce110_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce110/dce110_resource.c, and the dce80_clock_source_create() function in drivers/gpu/drm/amd/display/dc/dce80/dce80_resource.c, aka CID-055e547478a1.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static guint32 s7comm_decode_ud_cyclic_subfunc(tvbuff_t *tvb, proto_tree *data_tree, guint8 type,                 guint8 subfunc,              guint16 dlength,             guint32 offset)              { gboolean know_data = FALSE; guint32 offset_old; guint32 len_item; guint8 item_count; guint8 i; switch (subfunc) { case S7COMM_UD_SUBF_CYCLIC_MEM: item_count = tvb_get_guint8(tvb, offset + 1);      proto_tree_add_uint(data_tree, hf_s7comm_param_itemcount, tvb, offset, 2, item_count); offset += 2; if (type == S7COMM_UD_TYPE_REQ) {                    proto_tree_add_item(data_tree, hf_s7comm_cycl_interval_timebase, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; proto_tree_add_item(data_tree, hf_s7comm_cycl_interval_time, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; for (i = 0; i < item_count; i++) { offset_old = offset; offset = s7comm_decode_param_item(tvb, offset, data_tree, i); len_item = offset - offset_old; if ((len_item % 2) && (i < item_count)) { offset += 1; } } } else if (type == S7COMM_UD_TYPE_RES || type == S7COMM_UD_TYPE_PUSH) {    offset = s7comm_decode_response_read_data(tvb, data_tree, item_count, offset); } know_data = TRUE; break; } if (know_data == FALSE && dlength > 4) { proto_tree_add_item(data_tree, hf_s7comm_userdata_data, tvb, offset, dlength - 4, ENC_NA); offset += dlength; } return offset; }
Description: In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-s7comm.c had an infinite loop that was addressed by correcting off-by-one errors.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int snd_timer_user_release(struct inode *inode, struct file *file) { struct snd_timer_user *tu; if (file->private_data) { tu = file->private_data; file->private_data = NULL; if (tu->timeri) snd_timer_close(tu->timeri); kfree(tu->queue); kfree(tu->tqueue); kfree(tu); } return 0; }
Description: sound/core/timer.c in the Linux kernel before 4.4.1 uses an incorrect type of mutex, which allows local users to cause a denial of service (race condition, use-after-free, and system crash) via a crafted ioctl call.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int ovl_setattr(struct dentry *dentry, struct iattr *attr) { int err; struct dentry *upperdentry; err = ovl_want_write(dentry); if (err) goto out; err = ovl_copy_up(dentry); if (!err) { upperdentry = ovl_dentry_upper(dentry); mutex_lock(&upperdentry->d_inode->i_mutex); err = notify_change(upperdentry, attr, NULL); mutex_unlock(&upperdentry->d_inode->i_mutex); } ovl_drop_write(dentry); out: return err; }
Description: The overlayfs implementation in the Linux kernel through 4.5.2 does not properly maintain POSIX ACL xattr data, which allows local users to gain privileges by leveraging a group-writable setgid directory.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void mcf_fec_do_tx(mcf_fec_state *s) { uint32_t addr; mcf_fec_bd bd; int frame_size; int len; uint8_t frame[FEC_MAX_FRAME_SIZE]; uint8_t *ptr; DPRINTF(""do_tx\n""); ptr = frame; frame_size = 0; addr = s->tx_descriptor; while (1) { mcf_fec_read_bd(&bd, addr); DPRINTF(""tx_bd %x flags %04x len %d data %08x\n"", addr, bd.flags, bd.length, bd.data); if ((bd.flags & FEC_BD_R) == 0) { break; } len = bd.length; if (frame_size + len > FEC_MAX_FRAME_SIZE) { len = FEC_MAX_FRAME_SIZE - frame_size; s->eir |= FEC_INT_BABT; } cpu_physical_memory_read(bd.data, ptr, len); ptr += len; frame_size += len; if (bd.flags & FEC_BD_L) { DPRINTF(""Sending packet\n""); qemu_send_packet(qemu_get_queue(s->nic), frame, len); ptr = frame; frame_size = 0; s->eir |= FEC_INT_TXF; } s->eir |= FEC_INT_TXB; bd.flags &= ~FEC_BD_R; mcf_fec_write_bd(&bd, addr); if ((bd.flags & FEC_BD_W) != 0) { addr = s->etdsr; } else { addr += 8; } } s->tx_descriptor = addr; }
Description: The mcf_fec_do_tx function in hw/net/mcf_fec.c in QEMU (aka Quick Emulator) does not properly limit the buffer descriptor count when transmitting packets, which allows local guest OS administrators to cause a denial of service (infinite loop and QEMU process crash) via vectors involving a buffer descriptor with a length of 0 and crafted values in bd.flags.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void SoftMP3::onQueueFilled(OMX_U32 ) { if (mSignalledError || mOutputPortSettingsChange != NONE) { return; } List<BufferInfo *> &inQueue = getPortQueue(0); List<BufferInfo *> &outQueue = getPortQueue(1); while ((!inQueue.empty() || (mSawInputEos && !mSignalledOutputEos)) && !outQueue.empty()) { BufferInfo *inInfo = NULL; OMX_BUFFERHEADERTYPE *inHeader = NULL; if (!inQueue.empty()) { inInfo = *inQueue.begin(); inHeader = inInfo->mHeader; } BufferInfo *outInfo = *outQueue.begin(); OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader; outHeader->nFlags = 0; if (inHeader) { if (inHeader->nOffset == 0 && inHeader->nFilledLen) { mAnchorTimeUs = inHeader->nTimeStamp; mNumFramesOutput = 0; } if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) { mSawInputEos = true; } mConfig->pInputBuffer = inHeader->pBuffer + inHeader->nOffset; mConfig->inputBufferCurrentLength = inHeader->nFilledLen; } else { mConfig->pInputBuffer = NULL; mConfig->inputBufferCurrentLength = 0; } mConfig->inputBufferMaxLength = 0; mConfig->inputBufferUsedLength = 0; mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t); if ((int32)outHeader->nAllocLen < mConfig->outputFrameSize) { ALOGE(""input buffer too small: got %u, expected %u"", outHeader->nAllocLen, mConfig->outputFrameSize); android_errorWriteLog(0x534e4554, ""27793371""); notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL); mSignalledError = true; return; } mConfig->pOutputBuffer = reinterpret_cast<int16_t *>(outHeader->pBuffer); ERROR_CODE decoderErr; if ((decoderErr = pvmp3_framedecoder(mConfig, mDecoderBuf)) != NO_DECODING_ERROR) { ALOGV(""mp3 decoder returned error %d"", decoderErr); if (decoderErr != NO_ENOUGH_MAIN_DATA_ERROR && decoderErr != SIDE_INFO_ERROR) { ALOGE(""mp3 decoder returned error %d"", decoderErr); notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL); mSignalledError = true; return; } if (mConfig->outputFrameSize == 0) { mConfig->outputFrameSize = kOutputBufferSize / sizeof(int16_t); } if (decoderErr == NO_ENOUGH_MAIN_DATA_ERROR && mSawInputEos) { if (!mIsFirst) { outHeader->nOffset = 0; outHeader->nFilledLen = kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t); memset(outHeader->pBuffer, 0, outHeader->nFilledLen); } outHeader->nFlags = OMX_BUFFERFLAG_EOS; mSignalledOutputEos = true; } else { ALOGV_IF(mIsFirst, ""insufficient data for first frame, sending silence""); memset(outHeader->pBuffer, 0, mConfig->outputFrameSize * sizeof(int16_t)); if (inHeader) { mConfig->inputBufferUsedLength = inHeader->nFilledLen; } } } else if (mConfig->samplingRate != mSamplingRate || mConfig->num_channels != mNumChannels) { mSamplingRate = mConfig->samplingRate; mNumChannels = mConfig->num_channels; notify(OMX_EventPortSettingsChanged, 1, 0, NULL); mOutputPortSettingsChange = AWAITING_DISABLED; return; } if (mIsFirst) { mIsFirst = false; outHeader->nOffset = kPVMP3DecoderDelay * mNumChannels * sizeof(int16_t); outHeader->nFilledLen = mConfig->outputFrameSize * sizeof(int16_t) - outHeader->nOffset; } else if (!mSignalledOutputEos) { outHeader->nOffset = 0; outHeader->nFilledLen = mConfig->outputFrameSize * sizeof(int16_t); } outHeader->nTimeStamp = mAnchorTimeUs + (mNumFramesOutput * 1000000ll) / mSamplingRate; if (inHeader) { CHECK_GE(inHeader->nFilledLen, mConfig->inputBufferUsedLength); inHeader->nOffset += mConfig->inputBufferUsedLength; inHeader->nFilledLen -= mConfig->inputBufferUsedLength; if (inHeader->nFilledLen == 0) { inInfo->mOwnedByUs = false; inQueue.erase(inQueue.begin()); inInfo = NULL; notifyEmptyBufferDone(inHeader); inHeader = NULL; } } mNumFramesOutput += mConfig->outputFrameSize / mNumChannels; outInfo->mOwnedByUs = false; outQueue.erase(outQueue.begin()); outInfo = NULL; notifyFillBufferDone(outHeader); outHeader = NULL; } }
Description: Multiple buffer overflows in codecs/mp3dec/SoftMP3.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 allow attackers to gain privileges via a crafted application, aka internal bug 29422022.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int gnutls_handshake(gnutls_session_t session) { const version_entry_st *vers = get_version(session); int ret; if (unlikely(session->internals.initial_negotiation_completed)) { if (vers->tls13_sem) { if (session->security_parameters.entity == GNUTLS_CLIENT) { return gnutls_session_key_update(session, GNUTLS_KU_PEER); } else { return 0; } } } if (STATE == STATE0) { unsigned int tmo_ms; struct timespec *end; struct timespec *start; if (session->internals.priorities == NULL || session->internals.priorities->cs.size == 0) return gnutls_assert_val(GNUTLS_E_NO_PRIORITIES_WERE_SET); ret = _gnutls_epoch_setup_next(session, 0, NULL); if (ret < 0) return gnutls_assert_val(ret); session->internals.used_exts = 0; session->internals.hsk_flags = 0; session->internals.handshake_in_progress = 1; session->internals.vc_status = -1; gnutls_gettime(&session->internals.handshake_start_time); tmo_ms = session->internals.handshake_timeout_ms; end = &session->internals.handshake_abs_timeout; start = &session->internals.handshake_start_time; if (tmo_ms && end->tv_sec == 0 && end->tv_nsec == 0) { end->tv_sec = start->tv_sec + (start->tv_nsec + tmo_ms * 1000000LL) / 1000000000LL; end->tv_nsec = (start->tv_nsec + tmo_ms * 1000000LL) % 1000000000LL; } } if (session->internals.recv_state == RECV_STATE_FALSE_START) { session_invalidate(session); return gnutls_assert_val(GNUTLS_E_HANDSHAKE_DURING_FALSE_START); } if (session->security_parameters.entity == GNUTLS_CLIENT) { do { ret = handshake_client(session); } while (ret == 1); } else { ret = handshake_server(session); } if (ret < 0) { if (_gnutls_abort_handshake(session, ret) == 0) STATE = STATE0; return ret; } if (session->internals.recv_state != RECV_STATE_FALSE_START && session->internals.recv_state != RECV_STATE_EARLY_START) { _gnutls_handshake_hash_buffers_clear(session); if (IS_DTLS(session) == 0) { _gnutls_handshake_io_buffer_clear(session); } else { _dtls_async_timer_init(session); } _gnutls_handshake_internal_state_clear(session); _gnutls_buffer_clear(&session->internals.record_presend_buffer); _gnutls_epoch_bump(session); } if (!IS_SERVER(session) && vers->tls13_sem) { struct timespec handshake_finish_time; gnutls_gettime(&handshake_finish_time); if (!(session->internals.hsk_flags & HSK_HRR_RECEIVED)) { session->internals.ertt = timespec_sub_ms(&handshake_finish_time, &session->internals.handshake_start_time)/2; } else { session->internals.ertt = timespec_sub_ms(&handshake_finish_time, &session->internals.handshake_start_time)/4; } } return 0; }
Description: An issue was discovered in GnuTLS before 3.6.15. A server can trigger a NULL pointer dereference in a TLS 1.3 client if a no_renegotiation alert is sent with unexpected timing, and then an invalid second handshake occurs. The crash happens in the application's error handling path, where the gnutls_deinit function is called after detecting a handshake failure.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static UINT drive_process_irp_write(DRIVE_DEVICE* drive, IRP* irp) { DRIVE_FILE* file; UINT32 Length; UINT64 Offset; if (!drive || !irp || !irp->input || !irp->output || !irp->Complete) return ERROR_INVALID_PARAMETER; if (Stream_GetRemainingLength(irp->input) < 32) return ERROR_INVALID_DATA; Stream_Read_UINT32(irp->input, Length); Stream_Read_UINT64(irp->input, Offset); Stream_Seek(irp->input, 20);  file = drive_get_file_by_id(drive, irp->FileId); if (!file) { irp->IoStatus = STATUS_UNSUCCESSFUL; Length = 0; } else if (!drive_file_seek(file, Offset)) { irp->IoStatus = drive_map_windows_err(GetLastError()); Length = 0; } else if (!drive_file_write(file, Stream_Pointer(irp->input), Length)) { irp->IoStatus = drive_map_windows_err(GetLastError()); Length = 0; } Stream_Write_UINT32(irp->output, Length); Stream_Write_UINT8(irp->output, 0);  return irp->Complete(irp); }
Description: In FreeRDP before 2.1.0, there is an out-of-bound read in irp functions (parallel_process_irp_create, serial_process_irp_create, drive_process_irp_write, printer_process_irp_write, rdpei_recv_pdu, serial_process_irp_write). This has been fixed in 2.1.0.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void native_tss_update_io_bitmap(void) { struct tss_struct *tss = this_cpu_ptr(&cpu_tss_rw); struct thread_struct *t = &current->thread; u16 *base = &tss->x86_tss.io_bitmap_base; if (!test_thread_flag(TIF_IO_BITMAP)) { tss_invalidate_io_bitmap(tss); return; } if (IS_ENABLED(CONFIG_X86_IOPL_IOPERM) && t->iopl_emul == 3) { *base = IO_BITMAP_OFFSET_VALID_ALL; } else { struct io_bitmap *iobm = t->io_bitmap; if (tss->io_bitmap.prev_sequence != iobm->sequence) tss_copy_io_bitmap(tss, iobm); *base = IO_BITMAP_OFFSET_VALID_MAP; } refresh_tss_limit(); }
Description: An issue was discovered in the Linux kernel 5.5 through 5.7.9, as used in Xen through 4.13.x for x86 PV guests. An attacker may be granted the I/O port permissions of an unrelated task. This occurs because tss_invalidate_io_bitmap mishandling causes a loss of synchronization between the I/O bitmaps of TSS and Xen, aka CID-cadfad870154.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: tvbuff_t * tvb_uncompress(tvbuff_t *tvb, const int offset, int comprlen) { gint       err; guint      bytes_out      = 0; guint8    *compr; guint8    *uncompr        = NULL; tvbuff_t  *uncompr_tvb    = NULL; z_streamp  strm; Bytef     *strmbuf; guint      inits_done     = 0; gint       wbits          = MAX_WBITS; guint8    *next; guint      bufsiz; #ifdef TVB_Z_DEBUG guint      inflate_passes = 0; guint      bytes_in       = tvb_captured_length_remaining(tvb, offset); #endif if (tvb == NULL) { return NULL; } compr = (guint8 *)tvb_memdup(NULL, tvb, offset, comprlen); if (!compr) return NULL; bufsiz = tvb_captured_length_remaining(tvb, offset) * 2; bufsiz = CLAMP(bufsiz, TVB_Z_MIN_BUFSIZ, TVB_Z_MAX_BUFSIZ); #ifdef TVB_Z_DEBUG printf(""bufsiz: %u bytes\n"", bufsiz); #endif next = compr; strm            = g_new0(z_stream, 1); strm->next_in   = next; strm->avail_in  = comprlen; strmbuf         = (Bytef *)g_malloc0(bufsiz); strm->next_out  = strmbuf; strm->avail_out = bufsiz; err = inflateInit2(strm, wbits); inits_done = 1; if (err != Z_OK) { inflateEnd(strm); g_free(strm); g_free(compr); g_free(strmbuf); return NULL; } while (1) { memset(strmbuf, '\0', bufsiz); strm->next_out  = strmbuf; strm->avail_out = bufsiz; err = inflate(strm, Z_SYNC_FLUSH); if (err == Z_OK || err == Z_STREAM_END) { guint bytes_pass = bufsiz - strm->avail_out; #ifdef TVB_Z_DEBUG ++inflate_passes; #endif if (uncompr == NULL) { uncompr = (guint8 *)((bytes_pass || err != Z_STREAM_END) ? g_memdup(strmbuf, bytes_pass) : g_strdup("""")); } else { guint8 *new_data = (guint8 *)g_malloc0(bytes_out + bytes_pass); memcpy(new_data, uncompr, bytes_out); memcpy(new_data + bytes_out, strmbuf, bytes_pass); g_free(uncompr); uncompr = new_data; } bytes_out += bytes_pass; if (err == Z_STREAM_END) { inflateEnd(strm); g_free(strm); g_free(strmbuf); break; } } else if (err == Z_BUF_ERROR) { inflateEnd(strm); g_free(strm); g_free(strmbuf); if (uncompr != NULL) { break; } else { g_free(compr); return NULL; } } else if (err == Z_DATA_ERROR && inits_done == 1 && uncompr == NULL && comprlen >= 2 && (*compr  == 0x1f) && (*(compr + 1) == 0x8b)) { Bytef *c = compr + 2; Bytef  flags = 0; if (comprlen < 10 || *c != Z_DEFLATED) { inflateEnd(strm); g_free(strm); g_free(compr); g_free(strmbuf); return NULL; } c++; flags = *c; c++; c += 6; if (flags & (1 << 2)) { guint16 xsize = 0; if (c-compr < comprlen) { xsize += *c; c++; } if (c-compr < comprlen) { xsize += *c << 8; c++; } c += xsize; } if (flags & (1 << 3)) { while ((c - compr) < comprlen && *c != '\0') { c++; } c++; } if (flags & (1 << 4)) { while ((c - compr) < comprlen && *c != '\0') { c++; } c++; } inflateReset(strm); next = c; strm->next_in = next; if (c - compr > comprlen) { inflateEnd(strm); g_free(strm); g_free(compr); g_free(strmbuf); return NULL; } comprlen -= (int) (c - compr); inflateEnd(strm); inflateInit2(strm, wbits); inits_done++; } else if (err == Z_DATA_ERROR && uncompr == NULL && inits_done <= 3) { wbits = -MAX_WBITS; inflateReset(strm); strm->next_in   = next; strm->avail_in  = comprlen; inflateEnd(strm); memset(strmbuf, '\0', bufsiz); strm->next_out  = strmbuf; strm->avail_out = bufsiz; err = inflateInit2(strm, wbits); inits_done++; if (err != Z_OK) { g_free(strm); g_free(strmbuf); g_free(compr); g_free(uncompr); return NULL; } } else { inflateEnd(strm); g_free(strm); g_free(strmbuf); if (uncompr == NULL) { g_free(compr); return NULL; } break; } } #ifdef TVB_Z_DEBUG printf(""inflate() total passes: %u\n"", inflate_passes); printf(""bytes  in: %u\nbytes out: %u\n\n"", bytes_in, bytes_out); #endif if (uncompr != NULL) { uncompr_tvb =  tvb_new_real_data((guint8*) uncompr, bytes_out, bytes_out); tvb_set_free_cb(uncompr_tvb, g_free); } g_free(compr); return uncompr_tvb; }
Description: Buffer overflow in the tvb_uncompress function in epan/tvbuff_zlib.c in Wireshark 1.12.x before 1.12.9 and 2.0.x before 2.0.1 allows remote attackers to cause a denial of service (application crash) via a crafted packet with zlib compression.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void sas_unregister_devs_sas_addr(struct domain_device *parent, int phy_id, bool last) { struct expander_device *ex_dev = &parent->ex_dev; struct ex_phy *phy = &ex_dev->ex_phy[phy_id]; struct domain_device *child, *n, *found = NULL; if (last) { list_for_each_entry_safe(child, n, &ex_dev->children, siblings) { if (SAS_ADDR(child->sas_addr) == SAS_ADDR(phy->attached_sas_addr)) { set_bit(SAS_DEV_GONE, &child->state); if (child->dev_type == SAS_EDGE_EXPANDER_DEVICE || child->dev_type == SAS_FANOUT_EXPANDER_DEVICE) sas_unregister_ex_tree(parent->port, child); else sas_unregister_dev(parent->port, child); found = child; break; } } sas_disable_routing(parent, phy->attached_sas_addr); } memset(phy->attached_sas_addr, 0, SAS_ADDR_SIZE); if (phy->port) { sas_port_delete_phy(phy->port, phy->phy); sas_device_set_phy(found, phy->port); if (phy->port->num_phys == 0) sas_port_delete(phy->port); phy->port = NULL; } }
Description: The Serial Attached SCSI (SAS) implementation in the Linux kernel through 4.15.9 mishandles a mutex within libsas, which allows local users to cause a denial of service (deadlock) by triggering certain error-handling code.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: inline bool IsAligned(const void *ptr) { return IsAlignedOn(ptr, GetAlignmentOf<T>()); }
Description: Crypto++ through 8.4 contains a timing side channel in ECDSA signature generation. Function FixedSizeAllocatorWithCleanup could write to memory outside of the allocation if the allocated memory was not 16-byte aligned. NOTE: this issue exists because the CVE-2019-14318 fix was intentionally removed for functionality reasons.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int sg_build_indirect(Sg_scatter_hold * schp, Sg_fd * sfp, int buff_size) { int ret_sz = 0, i, k, rem_sz, num, mx_sc_elems; int sg_tablesize = sfp->parentdp->sg_tablesize; int blk_size = buff_size, order; gfp_t gfp_mask = GFP_ATOMIC | __GFP_COMP | __GFP_NOWARN; struct sg_device *sdp = sfp->parentdp; if (blk_size < 0) return -EFAULT; if (0 == blk_size) ++blk_size; blk_size = ALIGN(blk_size, SG_SECTOR_SZ); SCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp, ""sg_build_indirect: buff_size=%d, blk_size=%d\n"", buff_size, blk_size)); mx_sc_elems = sg_build_sgat(schp, sfp, sg_tablesize); if (mx_sc_elems < 0) return mx_sc_elems; num = scatter_elem_sz; if (unlikely(num != scatter_elem_sz_prev)) { if (num < PAGE_SIZE) { scatter_elem_sz = PAGE_SIZE; scatter_elem_sz_prev = PAGE_SIZE; } else scatter_elem_sz_prev = num; } if (sdp->device->host->unchecked_isa_dma) gfp_mask |= GFP_DMA; if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO)) gfp_mask |= __GFP_ZERO; order = get_order(num); retry: ret_sz = 1 << (PAGE_SHIFT + order); for (k = 0, rem_sz = blk_size; rem_sz > 0 && k < mx_sc_elems; k++, rem_sz -= ret_sz) { num = (rem_sz > scatter_elem_sz_prev) ? scatter_elem_sz_prev : rem_sz; schp->pages[k] = alloc_pages(gfp_mask, order); if (!schp->pages[k]) goto out; if (num == scatter_elem_sz_prev) { if (unlikely(ret_sz > scatter_elem_sz_prev)) { scatter_elem_sz = ret_sz; scatter_elem_sz_prev = ret_sz; } } SCSI_LOG_TIMEOUT(5, sg_printk(KERN_INFO, sfp->parentdp, ""sg_build_indirect: k=%d, num=%d, ret_sz=%d\n"", k, num, ret_sz)); } schp->page_order = order; schp->k_use_sg = k; SCSI_LOG_TIMEOUT(5, sg_printk(KERN_INFO, sfp->parentdp, ""sg_build_indirect: k_use_sg=%d, rem_sz=%d\n"", k, rem_sz)); schp->bufflen = blk_size; if (rem_sz > 0) return -ENOMEM; return 0; out: for (i = 0; i < k; i++) __free_pages(schp->pages[i], order); if (--order >= 0) goto retry; return -ENOMEM; }
Description: Linux Kernel version 3.18 to 4.16 incorrectly handles an SG_IO ioctl on /dev/sg0 with dxfer_direction=SG_DXFER_FROM_DEV and an empty 6-byte cmdp. This may lead to copying up to 1000 kernel heap pages to the userspace. This has been fixed upstream in https://github.com/torvalds/linux/commit/a45b599ad808c3c982fdcdc12b0b8611c2f92824 already. The problem has limited scope, as users don't usually have permissions to access SCSI devices. On the other hand, e.g. the Nero user manual suggests doing `chmod o+r+w /dev/sg*` to make the devices accessible. NOTE: third parties dispute the relevance of this report, noting that the requirement for an attacker to have both the CAP_SYS_ADMIN and CAP_SYS_RAWIO capabilities makes it ""virtually impossible to exploit.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void WasmBinaryBuilder::pushExpression(Expression* curr) { auto type = curr->type; if (type.isTuple()) { Builder builder(wasm); std::vector<Type> finalTypes; if (!wasm.features.hasGCNNLocals()) { for (auto t : type) { if (t.isNonNullable()) { t = Type(t.getHeapType(), Nullable); } finalTypes.push_back(t); } } auto nullableType = Type(Tuple(finalTypes)); Index tuple = builder.addVar(currFunction, nullableType); expressionStack.push_back(builder.makeLocalSet(tuple, curr)); for (Index i = 0; i < nullableType.size(); ++i) { Expression* value = builder.makeTupleExtract(builder.makeLocalGet(tuple, nullableType), i); if (nullableType[i] != type[i]) { value = builder.makeRefAs(RefAsNonNull, value); } expressionStack.push_back(value); } } else { expressionStack.push_back(curr); } }
Description: A Denial of Service vulnerability exists in Binaryen 103 due to an Invalid memory address dereference in wasm::WasmBinaryBuilder::visitLet.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void __do_SAK(struct tty_struct *tty) { #ifdef TTY_SOFT_SAK tty_hangup(tty); #else struct task_struct *g, *p; struct pid *session; inti; if (!tty) return; session = tty->session; tty_ldisc_flush(tty); tty_driver_flush_buffer(tty); read_lock(&tasklist_lock); do_each_pid_task(session, PIDTYPE_SID, p) { tty_notice(tty, ""SAK: killed process %d (%s): by session\n"", task_pid_nr(p), p->comm); group_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID); } while_each_pid_task(session, PIDTYPE_SID, p); do_each_thread(g, p) { if (p->signal->tty == tty) { tty_notice(tty, ""SAK: killed process %d (%s): by controlling tty\n"", task_pid_nr(p), p->comm); group_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID); continue; } task_lock(p); i = iterate_fd(p->files, 0, this_tty, tty); if (i != 0) { tty_notice(tty, ""SAK: killed process %d (%s): by fd#%d\n"", task_pid_nr(p), p->comm, i - 1); group_send_sig_info(SIGKILL, SEND_SIG_PRIV, p, PIDTYPE_SID); } task_unlock(p); } while_each_thread(g, p); read_unlock(&tasklist_lock); #endif }
Description: A locking inconsistency issue was discovered in the tty subsystem of the Linux kernel through 5.9.13. drivers/tty/tty_io.c and drivers/tty/tty_jobctrl.c may allow a read-after-free attack against TIOCGSID, aka CID-c8bcd9c5be24.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static struct sk_buff *tun_napi_alloc_frags(struct tun_file *tfile, size_t len, const struct iov_iter *it) { struct sk_buff *skb; size_t linear; int err; int i; if (it->nr_segs > MAX_SKB_FRAGS + 1) return ERR_PTR(-EMSGSIZE); local_bh_disable(); skb = napi_get_frags(&tfile->napi); local_bh_enable(); if (!skb) return ERR_PTR(-ENOMEM); linear = iov_iter_single_seg_count(it); err = __skb_grow(skb, linear); if (err) goto free; skb->len = len; skb->data_len = len - linear; skb->truesize += skb->data_len; for (i = 1; i < it->nr_segs; i++) { size_t fragsz = it->iov[i].iov_len; struct page *page; void *frag; if (fragsz == 0 || fragsz > PAGE_SIZE) { err = -EINVAL; goto free; } frag = netdev_alloc_frag(fragsz); if (!frag) { err = -ENOMEM; goto free; } page = virt_to_head_page(frag); skb_fill_page_desc(skb, i - 1, page, frag - page_address(page), fragsz); } return skb; free: napi_free_frags(&tfile->napi); return ERR_PTR(err); }
Description: An out-of-bounds memory access flaw was found in the Linux kernel’s TUN/TAP device driver functionality in how a user generates a malicious (too big) networking packet when napi frags is enabled. This flaw allows a local user to crash or potentially escalate their privileges on the system.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int gs_can_open(struct net_device *netdev) { struct gs_can *dev = netdev_priv(netdev); struct gs_usb *parent = dev->parent; int rc, i; struct gs_device_mode *dm; u32 ctrlmode; rc = open_candev(netdev); if (rc) return rc; if (atomic_add_return(1, &parent->active_channels) == 1) { for (i = 0; i < GS_MAX_RX_URBS; i++) { struct urb *urb; u8 *buf; urb = usb_alloc_urb(0, GFP_KERNEL); if (!urb) return -ENOMEM; buf = usb_alloc_coherent(dev->udev, sizeof(struct gs_host_frame), GFP_KERNEL, &urb->transfer_dma); if (!buf) { netdev_err(netdev, ""No memory left for USB buffer\n""); usb_free_urb(urb); return -ENOMEM; } usb_fill_bulk_urb(urb, dev->udev, usb_rcvbulkpipe(dev->udev, GSUSB_ENDPOINT_IN), buf, sizeof(struct gs_host_frame), gs_usb_receive_bulk_callback, parent); urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP; usb_anchor_urb(urb, &parent->rx_submitted); rc = usb_submit_urb(urb, GFP_KERNEL); if (rc) { if (rc == -ENODEV) netif_device_detach(dev->netdev); netdev_err(netdev, ""usb_submit failed (err=%d)\n"", rc); usb_unanchor_urb(urb); break; } usb_free_urb(urb); } } dm = kmalloc(sizeof(*dm), GFP_KERNEL); if (!dm) return -ENOMEM; ctrlmode = dev->can.ctrlmode; dm->flags = 0; if (ctrlmode & CAN_CTRLMODE_LOOPBACK) dm->flags |= GS_CAN_MODE_LOOP_BACK; else if (ctrlmode & CAN_CTRLMODE_LISTENONLY) dm->flags |= GS_CAN_MODE_LISTEN_ONLY; if (ctrlmode & CAN_CTRLMODE_ONE_SHOT) dm->flags |= GS_CAN_MODE_ONE_SHOT; if (ctrlmode & CAN_CTRLMODE_3_SAMPLES) dm->flags |= GS_CAN_MODE_TRIPLE_SAMPLE; dm->mode = GS_CAN_MODE_START; rc = usb_control_msg(interface_to_usbdev(dev->iface), usb_sndctrlpipe(interface_to_usbdev(dev->iface), 0), GS_USB_BREQ_MODE, USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_INTERFACE, dev->channel, 0, dm, sizeof(*dm), 1000); if (rc < 0) { netdev_err(netdev, ""Couldn't start device (err=%d)\n"", rc); kfree(dm); return rc; } kfree(dm); dev->can.state = CAN_STATE_ERROR_ACTIVE; if (!(dev->can.ctrlmode & CAN_CTRLMODE_LISTENONLY)) netif_start_queue(netdev); return 0; }
Description: A memory leak in the gs_can_open() function in drivers/net/can/usb/gs_usb.c in the Linux kernel before 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering usb_submit_urb() failures, aka CID-fb5be6a7b486.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void rose_stop_idletimer(struct sock *sk) { del_timer(&rose_sk(sk)->idletimer); }
Description: There are use-after-free vulnerabilities caused by timer handler in net/rose/rose_timer.c of linux that allow attackers to crash linux kernel without any privileges.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void GenEnum(const EnumDef &enum_def) { code_.SetValue(""ENUM_NAME"", Name(enum_def)); code_.SetValue(""BASE_TYPE"", GetEnumTypeForDecl(enum_def.underlying_type)); code_.SetValue(""ENUM_NAME_SNAKE"", MakeSnakeCase(Name(enum_def))); code_.SetValue(""ENUM_NAME_CAPS"", MakeUpper(MakeSnakeCase(Name(enum_def)))); const EnumVal *minv = enum_def.MinValue(); const EnumVal *maxv = enum_def.MaxValue(); FLATBUFFERS_ASSERT(minv && maxv); code_.SetValue(""ENUM_MIN_BASE_VALUE"", enum_def.ToString(*minv)); code_.SetValue(""ENUM_MAX_BASE_VALUE"", enum_def.ToString(*maxv)); if (IsBitFlagsEnum(enum_def)) { code_ += ""#[allow(non_upper_case_globals)]""; code_ += ""mod bitflags_{{ENUM_NAME_SNAKE}} {""; code_ += ""  flatbuffers::bitflags::bitflags! {""; GenComment(enum_def.doc_comment, ""    ""); code_ += ""    #[derive(Default)]""; code_ += ""    pub struct {{ENUM_NAME}}: {{BASE_TYPE}} {""; ForAllEnumValues1(enum_def, [&](const EnumVal &ev) { this->GenComment(ev.doc_comment, ""      ""); code_ += ""      const {{VARIANT}} = {{VALUE}};""; }); code_ += ""    }""; code_ += ""  }""; code_ += ""}""; code_ += ""pub use self::bitflags_{{ENUM_NAME_SNAKE}}::{{ENUM_NAME}};""; code_ += """"; code_.SetValue(""FROM_BASE"", ""unsafe { Self::from_bits_unchecked(b) }""); code_.SetValue(""INTO_BASE"", ""self.bits()""); } else { const std::string deprecation_warning = ""#[deprecated(since = \""2.0.0\"", note = \""Use associated constants"" "" instead. This will no longer be generated in 2021.\"")]""; code_ += deprecation_warning; code_ += ""pub const ENUM_MIN_{{ENUM_NAME_CAPS}}: {{BASE_TYPE}}"" "" = {{ENUM_MIN_BASE_VALUE}};""; code_ += deprecation_warning; code_ += ""pub const ENUM_MAX_{{ENUM_NAME_CAPS}}: {{BASE_TYPE}}"" "" = {{ENUM_MAX_BASE_VALUE}};""; auto num_fields = NumToString(enum_def.size()); code_ += deprecation_warning; code_ += ""#[allow(non_camel_case_types)]""; code_ += ""pub const ENUM_VALUES_{{ENUM_NAME_CAPS}}: [{{ENUM_NAME}}; "" + num_fields + ""] = [""; ForAllEnumValues1(enum_def, [&](const EnumVal &ev) { code_ += ""  "" + GetEnumValue(enum_def, ev) + "",""; }); code_ += ""];""; code_ += """"; GenComment(enum_def.doc_comment); code_ += ""#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, "" ""Default)]""; code_ += ""#[repr(transparent)]""; code_ += ""pub struct {{ENUM_NAME}}(pub {{BASE_TYPE}});""; code_ += ""#[allow(non_upper_case_globals)]""; code_ += ""impl {{ENUM_NAME}} {""; ForAllEnumValues1(enum_def, [&](const EnumVal &ev) { this->GenComment(ev.doc_comment, ""  ""); code_ += ""  pub const {{VARIANT}}: Self = Self({{VALUE}});""; }); code_ += """"; code_ += ""  pub const ENUM_MIN: {{BASE_TYPE}} = {{ENUM_MIN_BASE_VALUE}};""; code_ += ""  pub const ENUM_MAX: {{BASE_TYPE}} = {{ENUM_MAX_BASE_VALUE}};""; code_ += ""  pub const ENUM_VALUES: &'static [Self] = &[""; ForAllEnumValues(enum_def, [&]() { code_ += ""    Self::{{VARIANT}},""; }); code_ += ""  ];""; code_ += ""        code_ += ""  pub fn variant_name(self) -> Option<&'static str> {""; code_ += ""    match self {""; ForAllEnumValues(enum_def, [&]() { code_ += ""      Self::{{VARIANT}} => Some(\""{{VARIANT}}\""),""; }); code_ += ""      _ => None,""; code_ += ""    }""; code_ += ""  }""; code_ += ""}""; code_ += ""impl std::fmt::Debug for {{ENUM_NAME}} {""; code_ += ""  fn fmt(&self, f: &mut std::fmt::Formatter) ->"" "" std::fmt::Result {""; code_ += ""    if let Some(name) = self.variant_name() {""; code_ += ""      f.write_str(name)""; code_ += ""    } else {""; code_ += ""      f.write_fmt(format_args!(\""<UNKNOWN {:?}>\"", self.0))""; code_ += ""    }""; code_ += ""  }""; code_ += ""}""; code_.SetValue(""FROM_BASE"", ""Self(b)""); code_.SetValue(""INTO_BASE"", ""self.0""); } code_ += ""impl<'a> flatbuffers::Follow<'a> for {{ENUM_NAME}} {""; code_ += ""  type Inner = Self;""; code_ += ""  #[inline]""; code_ += ""  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {""; code_ += ""    let b = flatbuffers::read_scalar_at::<{{BASE_TYPE}}>(buf,"" "" loc);""; code_ += ""    {{FROM_BASE}}""; code_ += ""  }""; code_ += ""}""; code_ += """"; code_ += ""impl flatbuffers::Push for {{ENUM_NAME}} {""; code_ += ""    type Output = {{ENUM_NAME}};""; code_ += ""    #[inline]""; code_ += ""    fn push(&self, dst: &mut [u8], _rest: &[u8]) {""; code_ += ""        flatbuffers::emplace_scalar::<{{BASE_TYPE}}>"" ""(dst, {{INTO_BASE}});""; code_ += ""    }""; code_ += ""}""; code_ += """"; code_ += ""impl flatbuffers::EndianScalar for {{ENUM_NAME}} {""; code_ += ""  #[inline]""; code_ += ""  fn to_little_endian(self) -> Self {""; code_ += ""    let b = {{BASE_TYPE}}::to_le({{INTO_BASE}});""; code_ += ""    {{FROM_BASE}}""; code_ += ""  }""; code_ += ""  #[inline]""; code_ += ""  #[allow(clippy::wrong_self_convention)]""; code_ += ""  fn from_little_endian(self) -> Self {""; code_ += ""    let b = {{BASE_TYPE}}::from_le({{INTO_BASE}});""; code_ += ""    {{FROM_BASE}}""; code_ += ""  }""; code_ += ""}""; code_ += """"; code_ += ""impl<'a> flatbuffers::Verifiable for {{ENUM_NAME}} {""; code_ += ""  #[inline]""; code_ += ""  fn run_verifier(""; code_ += ""    v: &mut flatbuffers::Verifier, pos: usize""; code_ += ""  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {""; code_ += ""    use self::flatbuffers::Verifiable;""; code_ += ""    {{BASE_TYPE}}::run_verifier(v, pos)""; code_ += ""  }""; code_ += ""}""; code_ += """"; code_ += ""impl flatbuffers::SimpleToVerifyInSlice for {{ENUM_NAME}} {}""; if (enum_def.is_union) { code_.SetValue(""NAME"", Name(enum_def)); code_.SetValue(""UNION_OFFSET_NAME"", Name(enum_def) + ""UnionTableOffset""); code_ += ""pub struct {{UNION_OFFSET_NAME}} {}""; code_ += """"; if (parser_.opts.generate_object_based_api) { GenUnionObject(enum_def); } } }
Description: An issue was discovered in the flatbuffers crate through 2020-04-11 for Rust. read_scalar (and read_scalar_at) can transmute values without unsafe blocks.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static struct slave *rlb_arp_xmit(struct sk_buff *skb, struct bonding *bond) { struct slave *tx_slave = NULL; struct net_device *dev; struct arp_pkt *arp; if (!pskb_network_may_pull(skb, sizeof(*arp))) return NULL; arp = (struct arp_pkt *)skb_network_header(skb); if (!bond_slave_has_mac_rx(bond, arp->mac_src)) return NULL; dev = ip_dev_find(dev_net(bond->dev), arp->ip_src); if (dev) { if (netif_is_bridge_master(dev)) return NULL; } if (arp->op_code == htons(ARPOP_REPLY)) { tx_slave = rlb_choose_channel(skb, bond, arp); if (tx_slave) bond_hw_addr_copy(arp->mac_src, tx_slave->dev->dev_addr, tx_slave->dev->addr_len); netdev_dbg(bond->dev, ""(slave %s): Server sent ARP Reply packet\n"", tx_slave ? tx_slave->dev->name : ""NULL""); } else if (arp->op_code == htons(ARPOP_REQUEST)) { tx_slave = rlb_choose_channel(skb, bond, arp); bond->alb_info.rlb_update_delay_counter = RLB_UPDATE_DELAY; rlb_req_update_subnet_clients(bond, arp->ip_src); netdev_dbg(bond->dev, ""(slave %s): Server sent ARP Request packet\n"", tx_slave ? tx_slave->dev->name : ""NULL""); } return tx_slave; }
Description: A vulnerability was found in Linux Kernel and classified as problematic. Affected by this issue is the function rlb_arp_xmit of the file drivers/net/bonding/bond_alb.c of the component IPsec. The manipulation leads to memory leak. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211928.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void BTM_PINCodeReply (BD_ADDR bd_addr, UINT8 res, UINT8 pin_len, UINT8 *p_pin, UINT32 trusted_mask[]) { tBTM_SEC_DEV_REC *p_dev_rec; BTM_TRACE_API (""BTM_PINCodeReply(): PairState: %s   PairFlags: 0x%02x  PinLen:%d  Result:%d"", btm_pair_state_descr(btm_cb.pairing_state), btm_cb.pairing_flags, pin_len, res); if (btm_cb.pairing_state != BTM_PAIR_STATE_WAIT_LOCAL_PIN) { BTM_TRACE_WARNING (""BTM_PINCodeReply() - Wrong State: %d"", btm_cb.pairing_state); return; } if (memcmp (bd_addr, btm_cb.pairing_bda, BD_ADDR_LEN) != 0) { BTM_TRACE_ERROR (""BTM_PINCodeReply() - Wrong BD Addr""); return; } if ((p_dev_rec = btm_find_dev (bd_addr)) == NULL) { BTM_TRACE_ERROR (""BTM_PINCodeReply() - no dev CB""); return; } if ( (pin_len > PIN_CODE_LEN) || (pin_len == 0) || (p_pin == NULL) ) res = BTM_ILLEGAL_VALUE; if (res != BTM_SUCCESS) { if ((btm_cb.pairing_flags & BTM_PAIR_FLAGS_PEER_STARTED_DD) || ((btm_cb.pairing_flags & BTM_PAIR_FLAGS_WE_STARTED_DD) && (btm_cb.pairing_flags & BTM_PAIR_FLAGS_DISC_WHEN_DONE)) ) { btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE); btm_cb.acl_disc_reason = HCI_ERR_HOST_REJECT_SECURITY; btsnd_hcic_pin_code_neg_reply (bd_addr); } else { p_dev_rec->security_required = BTM_SEC_NONE; btm_sec_change_pairing_state (BTM_PAIR_STATE_IDLE); } return; } if (trusted_mask) BTM_SEC_COPY_TRUSTED_DEVICE(trusted_mask, p_dev_rec->trusted_mask); p_dev_rec->sec_flags   |= BTM_SEC_LINK_KEY_AUTHED; if ( (btm_cb.pairing_flags & BTM_PAIR_FLAGS_WE_STARTED_DD) &&  (p_dev_rec->hci_handle == BTM_SEC_INVALID_HANDLE) &&  (btm_cb.security_mode_changed == FALSE) ) { btm_cb.pin_code_len = pin_len; memcpy (btm_cb.pin_code, p_pin, pin_len); btm_cb.security_mode_changed = TRUE; #ifdef APPL_AUTH_WRITE_EXCEPTION if(!(APPL_AUTH_WRITE_EXCEPTION)(p_dev_rec->bd_addr)) #endif btsnd_hcic_write_auth_enable (TRUE); btm_cb.acl_disc_reason = 0xff ; if (btm_cb.pairing_flags & BTM_PAIR_FLAGS_REJECTED_CONNECT) { BTM_TRACE_WARNING (""BTM_PINCodeReply(): waiting HCI_Connection_Complete after rejected incoming connection""); btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_PIN_REQ); } else if (p_dev_rec->sm4 & BTM_SM4_CONN_PEND) { BTM_TRACE_WARNING (""BTM_PINCodeReply(): link is connecting so wait pin code request from peer""); btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_PIN_REQ); } else if (btm_sec_dd_create_conn(p_dev_rec) != BTM_CMD_STARTED) { btm_sec_change_pairing_state (BTM_PAIR_STATE_IDLE); p_dev_rec->sec_flags &= ~BTM_SEC_LINK_KEY_AUTHED; if (btm_cb.api.p_auth_complete_callback) (*btm_cb.api.p_auth_complete_callback) (p_dev_rec->bd_addr,  p_dev_rec->dev_class, p_dev_rec->sec_bd_name, HCI_ERR_AUTH_FAILURE); } return; } btm_sec_change_pairing_state (BTM_PAIR_STATE_WAIT_AUTH_COMPLETE); btm_cb.acl_disc_reason = HCI_SUCCESS; #ifdef PORCHE_PAIRING_CONFLICT BTM_TRACE_EVENT(""BTM_PINCodeReply(): Saving pin_len: %d btm_cb.pin_code_len: %d"", pin_len, btm_cb.pin_code_len); if (btm_cb.pin_code_len == 0) memcpy (btm_cb.pin_code, p_pin, pin_len); btm_cb.pin_code_len_saved = pin_len; #endif btsnd_hcic_pin_code_req_reply (bd_addr, pin_len, p_pin); }
Description: The PORCHE_PAIRING_CONFLICT feature in Bluetooth in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 allows remote attackers to bypass intended pairing restrictions via a crafted device, aka internal bug 26551752.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int wolfSSH_SFTP_RecvWrite(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz) #ifndef USE_WINDOWS_API { WFD    fd; word32 sz; int    ret  = WS_SUCCESS; word32 idx  = 0; word32 ofst[2] = {0,0}; word32 outSz = 0; byte*  out   = NULL; char  suc[] = ""Write File Success""; char  err[] = ""Write File Error""; char* res  = suc; byte  type = WOLFSSH_FTP_OK; if (ssh == NULL) { return WS_BAD_ARGUMENT; } WLOG(WS_LOG_SFTP, ""Receiving WOLFSSH_FTP_WRITE""); ato32(data + idx, &sz); idx += UINT32_SZ; if (sz + idx > maxSz || sz > WOLFSSH_MAX_HANDLE) { WLOG(WS_LOG_SFTP, ""Error with file handle size""); res  = err; type = WOLFSSH_FTP_FAILURE; ret  = WS_BAD_FILE_E; } if (ret == WS_SUCCESS) { WMEMSET((byte*)&fd, 0, sizeof(WFD)); WMEMCPY((byte*)&fd, data + idx, sz); idx += sz; ato32(data + idx, &ofst[1]); idx += UINT32_SZ; ato32(data + idx, &ofst[0]); idx += UINT32_SZ; ato32(data + idx, &sz); idx += UINT32_SZ; ret = WPWRITE(fd, data + idx, sz, ofst); if (ret < 0) { #if defined(WOLFSSL_NUCLEUS) && defined(DEBUG_WOLFSSH) if (ret == NUF_NOSPC) { WLOG(WS_LOG_SFTP, ""Ran out of memory""); } #endif WLOG(WS_LOG_SFTP, ""Error writing to file""); res  = err; type = WOLFSSH_FTP_FAILURE; ret  = WS_INVALID_STATE_E; } else { ret = WS_SUCCESS; } } if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, ""English"", NULL, &outSz) != WS_SIZE_ONLY) { return WS_FATAL_ERROR; } out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER); if (out == NULL) { return WS_MEMORY_E; } if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, ""English"", out, &outSz) != WS_SUCCESS) { WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER); return WS_FATAL_ERROR; } wolfSSH_SFTP_RecvSetSend(ssh, out, outSz); return ret; }
Description: WolfSSH v1.4.7 was discovered to contain an integer overflow via the function wolfSSH_SFTP_RecvRMDIR.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void coroutine_fn v9fs_link(void *opaque) { V9fsPDU *pdu = opaque; int32_t dfid, oldfid; V9fsFidState *dfidp, *oldfidp; V9fsString name; size_t offset = 7; int err = 0; v9fs_string_init(&name); err = pdu_unmarshal(pdu, offset, ""dds"", &dfid, &oldfid, &name); if (err < 0) { goto out_nofid; } trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data); if (name_is_illegal(name.data)) { err = -ENOENT; goto out_nofid; } if (!strcmp(""."", name.data) || !strcmp("".."", name.data)) { err = -EEXIST; goto out_nofid; } dfidp = get_fid(pdu, dfid); if (dfidp == NULL) { err = -ENOENT; goto out_nofid; } oldfidp = get_fid(pdu, oldfid); if (oldfidp == NULL) { err = -ENOENT; goto out; } err = v9fs_co_link(pdu, oldfidp, dfidp, &name); if (!err) { err = offset; } out: put_fid(pdu, dfidp); out_nofid: v9fs_string_free(&name); pdu_complete(pdu, err); }
Description: Memory leak in the v9fs_link function in hw/9pfs/9p.c in QEMU (aka Quick Emulator) allows local guest OS administrators to cause a denial of service (memory consumption) via vectors involving a reference to the source fid object.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: double js_strtod(const char *string, char **endPtr) { int sign, expSign = FALSE; double fraction, dblExp, *d; register const char *p; register int c; int exp = 0; int fracExp = 0; int mantSize; int decPt; const char *pExp; p = string; while (*p == ' ' || *p == '\t' || *p == '\n' || *p == '\r') { p += 1; } if (*p == '-') { sign = TRUE; p += 1; } else { if (*p == '+') { p += 1; } sign = FALSE; } decPt = -1; for (mantSize = 0; ; mantSize += 1) { c = *p; if (!(c>='0'&&c<='9')) { if ((c != '.') || (decPt >= 0)) { break; } decPt = mantSize; } p += 1; } pExp = p; p -= mantSize; if (decPt < 0) { decPt = mantSize; } else { mantSize -= 1; } if (mantSize > 18) { fracExp = decPt - 18; mantSize = 18; } else { fracExp = decPt - mantSize; } if (mantSize == 0) { fraction = 0.0; p = string; goto done; } else { int frac1, frac2; frac1 = 0; for ( ; mantSize > 9; mantSize -= 1) { c = *p; p += 1; if (c == '.') { c = *p; p += 1; } frac1 = 10*frac1 + (c - '0'); } frac2 = 0; for (; mantSize > 0; mantSize -= 1) { c = *p; p += 1; if (c == '.') { c = *p; p += 1; } frac2 = 10*frac2 + (c - '0'); } fraction = (1.0e9 * frac1) + frac2; } p = pExp; if ((*p == 'E') || (*p == 'e')) { p += 1; if (*p == '-') { expSign = TRUE; p += 1; } else { if (*p == '+') { p += 1; } expSign = FALSE; } while ((*p >= '0') && (*p <= '9')) { exp = exp * 10 + (*p - '0'); p += 1; } } if (expSign) { exp = fracExp - exp; } else { exp = fracExp + exp; } if (exp < 0) { expSign = TRUE; exp = -exp; } else { expSign = FALSE; } if (exp > maxExponent) { exp = maxExponent; errno = ERANGE; } dblExp = 1.0; for (d = powersOf10; exp != 0; exp >>= 1, d += 1) { if (exp & 01) { dblExp *= *d; } } if (expSign) { fraction /= dblExp; } else { fraction *= dblExp; } done: if (endPtr != NULL) { *endPtr = (char *) p; } if (sign) { return -fraction; } return fraction; }
Description: The js_strtod function in jsdtoa.c in Artifex MuJS through 1.0.2 has an integer overflow because of incorrect exponent validation.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void CDataFileReader::UnloadData(int Index) { if(Index < 0) return; mem_free(m_pDataFile->m_ppDataPtrs[Index]); m_pDataFile->m_ppDataPtrs[Index] = 0x0; }
Description: In Teeworlds 0.7.2, there is a failed bounds check in CDataFileReader::GetData() and CDataFileReader::ReplaceData() and related functions in engine/shared/datafile.cpp that can lead to an arbitrary free and out-of-bounds pointer write, possibly resulting in remote code execution.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void ok_jpg_decode2(ok_jpg_decoder *decoder) { ok_jpg *jpg = decoder->jpg; uint8_t jpg_header[2]; if (!ok_read(decoder, jpg_header, 2)) { return; } if (jpg_header[0] != 0xFF || jpg_header[1] != 0xD8) { ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Invalid signature (not a JPEG file)""); return; } while (!decoder->eoi_found) { int marker; if (decoder->next_marker != 0) { marker = decoder->next_marker; decoder->next_marker = 0; } else { while (true) { uint8_t b; if (!ok_read(decoder, &b, 1)) { return; } if (b == 0xFF) { if (!ok_read(decoder, &b, 1)) { return; } if (b != 0 && b != 0xFF) { marker = b; break; } } } } bool success = true; if (marker == 0xC0 || marker == 0xC1 || marker == 0xC2) { decoder->progressive = (marker == 0xC2); success = ok_jpg_read_sof(decoder); if (success && decoder->info_only) { return; } } else if (marker == 0xC4) { success = decoder->info_only ? ok_jpg_skip_segment(decoder) : ok_jpg_read_dht(decoder); } else if (marker >= 0xD0 && marker <= 0xD7) { decoder->next_marker = marker; success = ok_jpg_decode_restart_if_needed(decoder); if (success) { success = ok_jpg_scan_to_next_marker(decoder); } } else if (marker == 0xD9) { decoder->eoi_found = true; if (!decoder->info_only && decoder->progressive) { ok_jpg_progressive_finish(decoder); } } else if (marker == 0xDA) { if (!decoder->info_only) { success = ok_jpg_read_sos(decoder); } else { success = ok_jpg_skip_segment(decoder); if (success) { success = ok_jpg_scan_to_next_marker(decoder); } } } else if (marker == 0xDB) { success = decoder->info_only ? ok_jpg_skip_segment(decoder) : ok_jpg_read_dqt(decoder); } else if (marker == 0xDD) { success = ok_jpg_read_dri(decoder); } else if (marker == 0xE1) { success = ok_jpg_read_exif(decoder); } else if ((marker >= 0xE0 && marker <= 0xEF) || marker == 0xFE) { success = ok_jpg_skip_segment(decoder); } else if (marker == 0xFF) { } else { ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Unsupported or corrupt JPEG""); success = false; } if (!success) { return; } } if (decoder->num_components == 0) { ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""SOF not found""); } else { for (int i = 0; i < decoder->num_components; i++) { if (!decoder->components[i].complete) { ok_jpg_error(jpg, OK_JPG_ERROR_INVALID, ""Missing JPEG image data""); break; } } } }
Description: ok-file-formats master 2021-9-12 is affected by a buffer overflow in ok_jpg_convert_data_unit_grayscale and ok_jpg_convert_YCbCr_to_RGB.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void opj_pi_update_decode_poc (opj_pi_iterator_t * p_pi, opj_tcp_t * p_tcp, OPJ_UINT32 p_max_precision, OPJ_UINT32 p_max_res) { OPJ_UINT32 pino; OPJ_UINT32 l_bound; opj_pi_iterator_t * l_current_pi = 00; opj_poc_t* l_current_poc = 0; OPJ_ARG_NOT_USED(p_max_res); assert(p_pi != 00); assert(p_tcp != 00); l_bound = p_tcp->numpocs+1; l_current_pi = p_pi; l_current_poc = p_tcp->pocs; for(pino = 0;pino<l_bound;++pino) { l_current_pi->poc.prg = l_current_poc->prg;  l_current_pi->first = 1; l_current_pi->poc.resno0 = l_current_poc->resno0;  l_current_pi->poc.compno0 = l_current_poc->compno0;  l_current_pi->poc.layno0 = 0; l_current_pi->poc.precno0 = 0; l_current_pi->poc.resno1 = l_current_poc->resno1;  l_current_pi->poc.compno1 = l_current_poc->compno1;  l_current_pi->poc.layno1 = l_current_poc->layno1;  l_current_pi->poc.precno1 = p_max_precision; ++l_current_pi; ++l_current_poc; } }
Description: The opj_pi_update_decode_poc function in pi.c in OpenJPEG, as used in PDFium in Google Chrome before 48.0.2564.109, miscalculates a certain layer index value, which allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted PDF document.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void btif_dm_auth_cmpl_evt (tBTA_DM_AUTH_CMPL *p_auth_cmpl) { bt_bdaddr_t bd_addr; bt_status_t status = BT_STATUS_FAIL; bt_bond_state_t state = BT_BOND_STATE_NONE; BOOLEAN skip_sdp = FALSE; bdcpy(bd_addr.address, p_auth_cmpl->bd_addr); if ( (p_auth_cmpl->success == TRUE) && (p_auth_cmpl->key_present) ) { if ((p_auth_cmpl->key_type < HCI_LKEY_TYPE_DEBUG_COMB)  || (p_auth_cmpl->key_type == HCI_LKEY_TYPE_AUTH_COMB) || (p_auth_cmpl->key_type == HCI_LKEY_TYPE_CHANGED_COMB) || (!pairing_cb.is_temp)) { bt_status_t ret; BTIF_TRACE_DEBUG(""%s: Storing link key. key_type=0x%x, is_temp=%d"", __FUNCTION__, p_auth_cmpl->key_type, pairing_cb.is_temp); ret = btif_storage_add_bonded_device(&bd_addr, p_auth_cmpl->key, p_auth_cmpl->key_type, pairing_cb.pin_code_len); ASSERTC(ret == BT_STATUS_SUCCESS, ""storing link key failed"", ret); } else { BTIF_TRACE_DEBUG(""%s: Temporary key. Not storing. key_type=0x%x, is_temp=%d"", __FUNCTION__, p_auth_cmpl->key_type, pairing_cb.is_temp); if(pairing_cb.is_temp) { BTIF_TRACE_DEBUG(""%s: sending BT_BOND_STATE_NONE for Temp pairing"", __FUNCTION__); bond_state_changed(BT_STATUS_SUCCESS, &bd_addr, BT_BOND_STATE_NONE); return; } } } if (p_auth_cmpl->success) { pairing_cb.timeout_retries = 0; status = BT_STATUS_SUCCESS; state = BT_BOND_STATE_BONDED; bdcpy(bd_addr.address, p_auth_cmpl->bd_addr); if (check_sdp_bl(&bd_addr) && check_cod_hid(&bd_addr, COD_HID_MAJOR)) { ALOGW(""%s:skip SDP"", __FUNCTION__); skip_sdp = TRUE; } if(!pairing_cb.is_local_initiated && skip_sdp) { bond_state_changed(status, &bd_addr, state); ALOGW(""%s: Incoming HID Connection"",__FUNCTION__); bt_property_t prop; bt_bdaddr_t bd_addr; bt_uuid_t  uuid; char uuid_str[128] = UUID_HUMAN_INTERFACE_DEVICE; string_to_uuid(uuid_str, &uuid); prop.type = BT_PROPERTY_UUIDS; prop.val = uuid.uu; prop.len = MAX_UUID_SIZE; HAL_CBACK(bt_hal_cbacks, remote_device_properties_cb, BT_STATUS_SUCCESS, &bd_addr, 1, &prop); } else { pairing_cb.sdp_attempts = 1;; if(btif_dm_inquiry_in_progress) btif_dm_cancel_discovery(); btif_dm_get_remote_services(&bd_addr); } } else { switch(p_auth_cmpl->fail_reason) { case HCI_ERR_PAGE_TIMEOUT: if (blacklistPairingRetries(bd_addr.address) && pairing_cb.timeout_retries) { BTIF_TRACE_WARNING(""%s() - Pairing timeout; retrying (%d) ..."", __FUNCTION__, pairing_cb.timeout_retries); --pairing_cb.timeout_retries; btif_dm_cb_create_bond (&bd_addr, BTA_TRANSPORT_UNKNOWN); return; } case HCI_ERR_CONNECTION_TOUT: status =  BT_STATUS_RMT_DEV_DOWN; break; case HCI_ERR_PAIRING_NOT_ALLOWED: status = BT_STATUS_AUTH_REJECTED; break; case HCI_ERR_LMP_RESPONSE_TIMEOUT: status =  BT_STATUS_AUTH_FAILURE; break; case HCI_ERR_AUTH_FAILURE: case HCI_ERR_KEY_MISSING: btif_storage_remove_bonded_device(&bd_addr); case HCI_ERR_HOST_REJECT_SECURITY: case HCI_ERR_ENCRY_MODE_NOT_ACCEPTABLE: case HCI_ERR_UNIT_KEY_USED: case HCI_ERR_PAIRING_WITH_UNIT_KEY_NOT_SUPPORTED: case HCI_ERR_INSUFFCIENT_SECURITY: case HCI_ERR_PEER_USER: case HCI_ERR_UNSPECIFIED: BTIF_TRACE_DEBUG("" %s() Authentication fail reason %d"", __FUNCTION__, p_auth_cmpl->fail_reason); if (pairing_cb.autopair_attempts  == 1) { BTIF_TRACE_DEBUG(""%s(): Adding device to blacklist "", __FUNCTION__); if (check_cod(&bd_addr, COD_AV_HEADSETS) || check_cod(&bd_addr, COD_AV_HANDSFREE) || check_cod(&bd_addr, COD_AV_HEADPHONES) || check_cod(&bd_addr, COD_AV_PORTABLE_AUDIO) || check_cod(&bd_addr, COD_AV_HIFI_AUDIO) || check_cod(&bd_addr, COD_HID_POINTING)) { btif_storage_add_device_to_autopair_blacklist (&bd_addr); } pairing_cb.autopair_attempts++; BTIF_TRACE_DEBUG(""%s() auto pair failed. Reinitiate Bond"", __FUNCTION__); btif_dm_cb_create_bond (&bd_addr, BTA_TRANSPORT_UNKNOWN); return; } else { status =  BT_STATUS_AUTH_FAILURE; } break; default: status =  BT_STATUS_FAIL; } if (check_cod(&bd_addr, COD_HID_POINTING)) { BTIF_TRACE_DEBUG(""%s(): removing hid pointing device from nvram"", __FUNCTION__); btif_storage_remove_bonded_device(&bd_addr); } bond_state_changed(status, &bd_addr, state); } }
Description: btif/src/btif_dm.c in Android before 5.1 does not properly enforce the temporary nature of a Bluetooth pairing, which allows user-assisted remote attackers to bypass intended access restrictions via crafted Bluetooth packets after the tapping of a crafted NFC tag.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static struct pending_op *pending_ccc_new(struct bt_att *att, struct gatt_db_attribute *attrib, uint16_t value, uint8_t link_type) { struct pending_op *op; struct btd_device *device; device = att_get_device(att); if (!device) { error(""Unable to find device object""); return NULL; } op = new0(struct pending_op, 1); op->data.iov_base = UINT_TO_PTR(value); op->data.iov_len = sizeof(value); op->device = device; op->attrib = attrib; op->link_type = link_type; return op; }
Description: An issue was discovered in gatt-database.c in BlueZ 5.61. A use-after-free can occur when a client disconnects during D-Bus processing of a WriteValue call.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: ssize_t fuse_listxattr(struct dentry *entry, char *list, size_t size) { struct inode *inode = d_inode(entry); struct fuse_mount *fm = get_fuse_mount(inode); FUSE_ARGS(args); struct fuse_getxattr_in inarg; struct fuse_getxattr_out outarg; ssize_t ret; if (!fuse_allow_current_process(fm->fc)) return -EACCES; if (fm->fc->no_listxattr) return -EOPNOTSUPP; memset(&inarg, 0, sizeof(inarg)); inarg.size = size; args.opcode = FUSE_LISTXATTR; args.nodeid = get_node_id(inode); args.in_numargs = 1; args.in_args[0].size = sizeof(inarg); args.in_args[0].value = &inarg; args.out_numargs = 1; if (size) { args.out_argvar = true; args.out_args[0].size = size; args.out_args[0].value = list; } else { args.out_args[0].size = sizeof(outarg); args.out_args[0].value = &outarg; } ret = fuse_simple_request(fm, &args); if (!ret && !size) ret = min_t(ssize_t, outarg.size, XATTR_LIST_MAX); if (ret > 0 && size) ret = fuse_verify_xattr_list(list, ret); if (ret == -ENOSYS) { fm->fc->no_listxattr = 1; ret = -EOPNOTSUPP; } return ret; }
Description: An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void operator()(OpKernelContext* ctx, const CPUDevice& d, int64 num_batches, int64 samples_per_batch, int64 num_elements, const BCastList<4>& bcast, typename TTypes<T>::ConstFlat means, typename TTypes<T>::ConstFlat stddevs, typename TTypes<T>::ConstFlat minvals, typename TTypes<T>::ConstFlat maxvals, const random::PhiloxRandom& gen, typename TTypes<T>::Flat output) { const T kStdDevsInsideBoundsToUseRandnSampler = T(1.3); auto worker_threads = *(ctx->device()->tensorflow_cpu_worker_threads()); auto do_work = [num_batches, samples_per_batch, &ctx, &bcast, &means, &stddevs, &minvals, &maxvals, &gen, &output, kStdDevsInsideBoundsToUseRandnSampler](int start_output, int limit_output) { random::PhiloxRandom gen_copy = gen; using Uniform = random::UniformDistribution<random::PhiloxRandom, T>; Uniform dist; using Normal = random::NormalDistribution<random::PhiloxRandom, T>; Normal normal_dist; gen_copy.Skip((start_output * 2 * kMaxIterations + Uniform::kResultElementCount - 1) / Uniform::kResultElementCount); Eigen::array<T, Uniform::kResultElementCount> z; Eigen::array<T, Uniform::kResultElementCount> g; const bool should_bcast = bcast.IsBroadcastingRequired(); const auto& means_batch_indices = bcast.batch_indices(0); const auto& stddevs_batch_indices = bcast.batch_indices(1); const auto& minvals_batch_indices = bcast.batch_indices(2); const auto& maxvals_batch_indices = bcast.batch_indices(3); auto output_flat = output.data(); for (int64 output_idx = start_output; output_idx < limit_output; ) { int64 batch_idx = output_idx / samples_per_batch; T* const output_batch_offset = output_flat + batch_idx; T mean, stddev, minval, maxval; if (should_bcast) { mean = means(means_batch_indices[batch_idx]); stddev = stddevs(stddevs_batch_indices[batch_idx]); minval = minvals(minvals_batch_indices[batch_idx]); maxval = maxvals(maxvals_batch_indices[batch_idx]); } else { mean = means(batch_idx); stddev = stddevs(batch_idx); minval = minvals(batch_idx); maxval = maxvals(batch_idx); } OP_REQUIRES(ctx, stddev > T(0) && minval < maxval && (Eigen::numext::isfinite(minval) || Eigen::numext::isfinite(maxval)), errors::InvalidArgument(""Invalid parameters"")); int num_iterations = 0; if ((Eigen::numext::isinf(minval) && minval < T(0)) || maxval < mean) { std::swap(minval, maxval); stddev = -stddev; } const T normMin = (minval - mean) / stddev; const T normMax = (maxval - mean) / stddev; const T sqrtFactor = Eigen::numext::sqrt((normMin * normMin) + T(4)); const T cutoff = T(2) * Eigen::numext::exp(T(0.5) + (normMin * (normMin - sqrtFactor)) / T(4)) / (normMin + sqrtFactor); const T diff = normMax - normMin; if (((normMin < -kStdDevsInsideBoundsToUseRandnSampler) && (normMax >= T(0.))) || ((normMax > kStdDevsInsideBoundsToUseRandnSampler) && (normMin <= T(0.)))) { for (int64 sample_idx = output_idx % samples_per_batch; sample_idx < samples_per_batch && output_idx < limit_output;) { const auto randn_sample = normal_dist(&gen_copy); const int size = randn_sample.size(); for (int i = 0; i < size; ++i) { if ((randn_sample[i] >= normMin) && (randn_sample[i] <= normMax)) { output_batch_offset[sample_idx * num_batches] = randn_sample[i] * stddev + mean; ++sample_idx; ++output_idx; if (sample_idx >= samples_per_batch || output_idx >= limit_output) { break; } num_iterations = 0; } else { ++num_iterations; if (num_iterations > kMaxIterations) { LOG(ERROR) << ""TruncatedNormal randn rejection sampler "" << ""exceeded maximum iterations for "" << ""normMin="" << normMin << "" normMax="" << normMax << "" kMaxIterations="" << kMaxIterations; ctx->SetStatus(errors::Internal( ""TruncatedNormal randn rejection sampler failed to accept"" "" a sample."")); return; } } } } } else if (diff < cutoff) { const T plusFactor = (normMin < T(0)) ? T(0) : normMin * normMin; for (int64 sample_idx = output_idx % samples_per_batch; sample_idx < samples_per_batch && output_idx < limit_output;) { const auto rand = dist(&gen_copy); const int size = rand.size(); for (int i = 0; i < size; i++) { z[i] = rand[i] * diff + normMin; g[i] = (plusFactor - z[i] * z[i]) / T(2.0); } const auto u = dist(&gen_copy); for (int i = 0; i < size; i++) { auto accept = u[i] <= Eigen::numext::exp(g[i]); if (accept || num_iterations + 1 >= kMaxIterations) { if (!accept) { LOG(ERROR) << ""TruncatedNormal uniform rejection sampler "" << ""exceeded max iterations. Sample may contain "" << ""outliers.""; ctx->SetStatus(errors::Internal( ""TruncatedNormal uniform rejection sampler failed to "" "" accept a sample."")); return; } output_batch_offset[sample_idx * num_batches] = z[i] * stddev + mean; ++sample_idx; ++output_idx; if (sample_idx >= samples_per_batch || output_idx >= limit_output) { break; } num_iterations = 0; } else { num_iterations++; } } } } else { const T alpha = (normMin + Eigen::numext::sqrt((normMin * normMin) + T(4))) / T(2); for (int64 sample_idx = output_idx % samples_per_batch; sample_idx < samples_per_batch && output_idx < limit_output;) { auto rand = dist(&gen_copy); const int size = rand.size(); int i = 0; while (i < size) { const T z = -Eigen::numext::log(rand[i]) / alpha + normMin; i++; const T x = normMin < alpha ? alpha - z : normMin - alpha; const T g = Eigen::numext::exp(-x * x / T(2.0)); const T u = rand[i]; i++; auto accept = (u <= g && z < normMax); if (accept || num_iterations + 1 >= kMaxIterations) { if (!accept) { LOG(ERROR) << ""TruncatedNormal exponential distribution "" << ""rejection sampler exceeds max iterations. "" << ""Sample may contain outliers.""; ctx->SetStatus(errors::Internal( ""TruncatedNormal exponential distribution rejection"" "" sampler failed to accept a sample."")); return; } output_batch_offset[sample_idx * num_batches] = z * stddev + mean; ++sample_idx; ++output_idx; if (sample_idx >= samples_per_batch || output_idx >= limit_output) { break; } num_iterations = 0; } else { num_iterations++; } } } } } }; const int64 batchInitCost = (Eigen::TensorOpCost::AddCost<T>() + Eigen::TensorOpCost::MulCost<T>()) * 2 + Eigen::TensorOpCost::AddCost<T>() + Eigen::TensorOpCost::MulCost<T>() + Eigen::internal::functor_traits< Eigen::internal::scalar_sqrt_op<T>>::Cost + Eigen::TensorOpCost::MulCost<T>() * 4 + Eigen::internal::functor_traits<Eigen::internal::scalar_exp_op<T>>::Cost + Eigen::TensorOpCost::AddCost<T>(); const int64 uniformSampleCost = random::PhiloxRandom::kElementCost + random::UniformDistribution<random::PhiloxRandom, T>::kElementCost; const int64 uniformRejectionSamplingCost = uniformSampleCost + Eigen::TensorOpCost::MulCost<T>() + Eigen::TensorOpCost::AddCost<T>() + Eigen::TensorOpCost::MulCost<T>() * 2 + Eigen::TensorOpCost::AddCost<T>() + uniformSampleCost + Eigen::internal::functor_traits< Eigen::internal::scalar_exp_op<T>>::Cost + Eigen::TensorOpCost::MulCost<T>() + Eigen::TensorOpCost::AddCost<T>(); const int64 batchCost = batchInitCost + uniformRejectionSamplingCost * 2; Shard(worker_threads.num_threads, worker_threads.workers, num_elements, batchCost, do_work); }
Description: In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `Shard` API in TensorFlow expects the last argument to be a function taking two `int64` (i.e., `long long`) arguments. However, there are several places in TensorFlow where a lambda taking `int` or `int32` arguments is being used. In these cases, if the amount of work to be parallelized is large enough, integer truncation occurs. Depending on how the two arguments of the lambda are used, this can result in segfaults, read/write outside of heap allocated arrays, stack overflows, or data corruption. The issue is patched in commits 27b417360cbd671ef55915e4bb6bb06af8b8a832 and ca8c013b5e97b1373b3bb1c97ea655e69f31a575, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void send_guest_pirq(struct domain *d, const struct pirq *pirq) { int port; struct evtchn *chn; if ( pirq == NULL || (port = pirq->evtchn) == 0 ) { BUG_ON(!is_hvm_domain(d)); return; } chn = evtchn_from_port(d, port); evtchn_port_set_pending(d, chn->notify_vcpu_id, chn); }
Description: An issue was discovered in Xen through 4.14.x. There are evtchn_reset() race conditions. Uses of EVTCHNOP_reset (potentially by a guest on itself) or XEN_DOMCTL_soft_reset (by itself covered by XSA-77) can lead to the violation of various internal assumptions. This may lead to out of bounds memory accesses or triggering of bug checks. In particular, x86 PV guests may be able to elevate their privilege to that of the host. Host and guest crashes are also possible, leading to a Denial of Service (DoS). Information leaks cannot be ruled out. All Xen versions from 4.5 onwards are vulnerable. Xen versions 4.4 and earlier are not vulnerable.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int xdp_umem_reg(struct xdp_umem *umem, struct xdp_umem_reg *mr) { bool unaligned_chunks = mr->flags & XDP_UMEM_UNALIGNED_CHUNK_FLAG; u32 chunk_size = mr->chunk_size, headroom = mr->headroom; unsigned int chunks, chunks_per_page; u64 addr = mr->addr, size = mr->len; int size_chk, err; if (chunk_size < XDP_UMEM_MIN_CHUNK_SIZE || chunk_size > PAGE_SIZE) { return -EINVAL; } if (mr->flags & ~(XDP_UMEM_UNALIGNED_CHUNK_FLAG | XDP_UMEM_USES_NEED_WAKEUP)) return -EINVAL; if (!unaligned_chunks && !is_power_of_2(chunk_size)) return -EINVAL; if (!PAGE_ALIGNED(addr)) { return -EINVAL; } if ((addr + size) < addr) return -EINVAL; chunks = (unsigned int)div_u64(size, chunk_size); if (chunks == 0) return -EINVAL; if (!unaligned_chunks) { chunks_per_page = PAGE_SIZE / chunk_size; if (chunks < chunks_per_page || chunks % chunks_per_page) return -EINVAL; } size_chk = chunk_size - headroom - XDP_PACKET_HEADROOM; if (size_chk < 0) return -EINVAL; umem->address = (unsigned long)addr; umem->chunk_mask = unaligned_chunks ? XSK_UNALIGNED_BUF_ADDR_MASK : ~((u64)chunk_size - 1); umem->size = size; umem->headroom = headroom; umem->chunk_size_nohr = chunk_size - headroom; umem->npgs = size / PAGE_SIZE; umem->pgs = NULL; umem->user = NULL; umem->flags = mr->flags; INIT_LIST_HEAD(&umem->xsk_list); spin_lock_init(&umem->xsk_list_lock); refcount_set(&umem->users, 1); err = xdp_umem_account_pages(umem); if (err) return err; err = xdp_umem_pin_pages(umem); if (err) goto out_account; umem->pages = kvcalloc(umem->npgs, sizeof(*umem->pages), GFP_KERNEL_ACCOUNT); if (!umem->pages) { err = -ENOMEM; goto out_pin; } err = xdp_umem_map_pages(umem); if (!err) return 0; kvfree(umem->pages); out_pin: xdp_umem_unpin_pages(umem); out_account: xdp_umem_unaccount_pages(umem); return err; }
Description: An issue was discovered in the Linux kernel before 5.6.7. xdp_umem_reg in net/xdp/xdp_umem.c has an out-of-bounds write (by a user with the CAP_NET_ADMIN capability) because of a lack of headroom validation.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void Com_WriteConfig_f( void ) { charfilename[MAX_QPATH]; if ( Cmd_Argc() != 2 ) { Com_Printf( ""Usage: writeconfig <filename>\n"" ); return; } Q_strncpyz( filename, Cmd_Argv(1), sizeof( filename ) ); COM_DefaultExtension( filename, sizeof( filename ), "".cfg"" ); Com_Printf( ""Writing %s.\n"", filename ); Com_WriteConfigToFile( filename ); }
Description: In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int _libssh2_packet_add(LIBSSH2_SESSION * session, unsigned char *data, size_t datalen, int macstate) { int rc = 0; char *message = NULL; char *language = NULL; size_t message_len = 0; size_t language_len = 0; LIBSSH2_CHANNEL *channelp = NULL; size_t data_head = 0; unsigned char msg = data[0]; switch(session->packAdd_state) { case libssh2_NB_state_idle: _libssh2_debug(session, LIBSSH2_TRACE_TRANS, ""Packet type %d received, length=%d"", (int) msg, (int) datalen); if((macstate == LIBSSH2_MAC_INVALID) && (!session->macerror || LIBSSH2_MACERROR(session, (char *) data, datalen))) { LIBSSH2_FREE(session, data); return _libssh2_error(session, LIBSSH2_ERROR_INVALID_MAC, ""Invalid MAC received""); } session->packAdd_state = libssh2_NB_state_allocated; break; case libssh2_NB_state_jump1: goto libssh2_packet_add_jump_point1; case libssh2_NB_state_jump2: goto libssh2_packet_add_jump_point2; case libssh2_NB_state_jump3: goto libssh2_packet_add_jump_point3; case libssh2_NB_state_jump4: goto libssh2_packet_add_jump_point4; case libssh2_NB_state_jump5: goto libssh2_packet_add_jump_point5; default:  break; } if(session->packAdd_state == libssh2_NB_state_allocated) { switch(msg) { case SSH_MSG_DISCONNECT: if(datalen >= 5) { size_t reason = _libssh2_ntohu32(data + 1); if(datalen >= 9) { message_len = _libssh2_ntohu32(data + 5); if(message_len < datalen-13) { message = (char *) data + 9; language_len = _libssh2_ntohu32(data + 9 + message_len); language = (char *) data + 9 + message_len + 4; if(language_len > (datalen-13-message_len)) { language = message = NULL; language_len = message_len = 0; } } else message_len = 0; } if(session->ssh_msg_disconnect) { LIBSSH2_DISCONNECT(session, reason, message, message_len, language, language_len); } _libssh2_debug(session, LIBSSH2_TRACE_TRANS, ""Disconnect(%d): %s(%s)"", reason, message, language); } LIBSSH2_FREE(session, data); session->socket_state = LIBSSH2_SOCKET_DISCONNECTED; session->packAdd_state = libssh2_NB_state_idle; return _libssh2_error(session, LIBSSH2_ERROR_SOCKET_DISCONNECT, ""socket disconnect""); case SSH_MSG_IGNORE: if(datalen >= 2) { if(session->ssh_msg_ignore) { LIBSSH2_IGNORE(session, (char *) data + 1, datalen - 1); } } else if(session->ssh_msg_ignore) { LIBSSH2_IGNORE(session, """", 0); } LIBSSH2_FREE(session, data); session->packAdd_state = libssh2_NB_state_idle; return 0; case SSH_MSG_DEBUG: if(datalen >= 2) { int always_display = data[1]; if(datalen >= 6) { message_len = _libssh2_ntohu32(data + 2); if(message_len <= (datalen - 10)) { message = (char *) data + 6; language_len = _libssh2_ntohu32(data + 6 + message_len); if(language_len <= (datalen - 10 - message_len)) language = (char *) data + 10 + message_len; } } if(session->ssh_msg_debug) { LIBSSH2_DEBUG(session, always_display, message, message_len, language, language_len); } } _libssh2_debug(session, LIBSSH2_TRACE_TRANS, ""Debug Packet: %s"", message); LIBSSH2_FREE(session, data); session->packAdd_state = libssh2_NB_state_idle; return 0; case SSH_MSG_GLOBAL_REQUEST: if(datalen >= 5) { uint32_t len = 0; unsigned char want_reply = 0; len = _libssh2_ntohu32(data + 1); if(datalen >= (6 + len)) { want_reply = data[5 + len]; _libssh2_debug(session, LIBSSH2_TRACE_CONN, ""Received global request type %.*s (wr %X)"", len, data + 5, want_reply); } if(want_reply) { static const unsigned char packet = SSH_MSG_REQUEST_FAILURE; libssh2_packet_add_jump_point5: session->packAdd_state = libssh2_NB_state_jump5; rc = _libssh2_transport_send(session, &packet, 1, NULL, 0); if(rc == LIBSSH2_ERROR_EAGAIN) return rc; } } LIBSSH2_FREE(session, data); session->packAdd_state = libssh2_NB_state_idle; return 0; case SSH_MSG_CHANNEL_EXTENDED_DATA: data_head += 4; case SSH_MSG_CHANNEL_DATA: data_head += 9; if(datalen >= data_head) channelp = _libssh2_channel_locate(session, _libssh2_ntohu32(data + 1)); if(!channelp) { _libssh2_error(session, LIBSSH2_ERROR_CHANNEL_UNKNOWN, ""Packet received for unknown channel""); LIBSSH2_FREE(session, data); session->packAdd_state = libssh2_NB_state_idle; return 0; } #ifdef LIBSSH2DEBUG { uint32_t stream_id = 0; if(msg == SSH_MSG_CHANNEL_EXTENDED_DATA) stream_id = _libssh2_ntohu32(data + 5); _libssh2_debug(session, LIBSSH2_TRACE_CONN, ""%d bytes packet_add() for %lu/%lu/%lu"", (int) (datalen - data_head), channelp->local.id, channelp->remote.id, stream_id); } #endif if((channelp->remote.extended_data_ignore_mode == LIBSSH2_CHANNEL_EXTENDED_DATA_IGNORE) && (msg == SSH_MSG_CHANNEL_EXTENDED_DATA)) { LIBSSH2_FREE(session, data); _libssh2_debug(session, LIBSSH2_TRACE_CONN, ""Ignoring extended data and refunding %d bytes"", (int) (datalen - 13)); if(channelp->read_avail + datalen - data_head >= channelp->remote.window_size) datalen = channelp->remote.window_size - channelp->read_avail + data_head; channelp->remote.window_size -= datalen - data_head; _libssh2_debug(session, LIBSSH2_TRACE_CONN, ""shrinking window size by %lu bytes to %lu, "" ""read_avail %lu"", datalen - data_head, channelp->remote.window_size, channelp->read_avail); session->packAdd_channelp = channelp; libssh2_packet_add_jump_point1: session->packAdd_state = libssh2_NB_state_jump1; rc = _libssh2_channel_receive_window_adjust(session-> packAdd_channelp, datalen - 13, 1, NULL); if(rc == LIBSSH2_ERROR_EAGAIN) return rc; session->packAdd_state = libssh2_NB_state_idle; return 0; } if(channelp->remote.packet_size < (datalen - data_head)) { _libssh2_error(session, LIBSSH2_ERROR_CHANNEL_PACKET_EXCEEDED, ""Packet contains more data than we offered"" "" to receive, truncating""); datalen = channelp->remote.packet_size + data_head; } if(channelp->remote.window_size <= channelp->read_avail) { _libssh2_error(session, LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED, ""The current receive window is full,"" "" data ignored""); LIBSSH2_FREE(session, data); session->packAdd_state = libssh2_NB_state_idle; return 0; } channelp->remote.eof = 0; if(channelp->read_avail + datalen - data_head > channelp->remote.window_size) { _libssh2_error(session, LIBSSH2_ERROR_CHANNEL_WINDOW_EXCEEDED, ""Remote sent more data than current "" ""window allows, truncating""); datalen = channelp->remote.window_size - channelp->read_avail + data_head; } channelp->read_avail += datalen - data_head; _libssh2_debug(session, LIBSSH2_TRACE_CONN, ""increasing read_avail by %lu bytes to %lu/%lu"", (long)(datalen - data_head), (long)channelp->read_avail, (long)channelp->remote.window_size); break; case SSH_MSG_CHANNEL_EOF: if(datalen >= 5) channelp = _libssh2_channel_locate(session, _libssh2_ntohu32(data + 1)); if(!channelp) ; else { _libssh2_debug(session, LIBSSH2_TRACE_CONN, ""EOF received for channel %lu/%lu"", channelp->local.id, channelp->remote.id); channelp->remote.eof = 1; } LIBSSH2_FREE(session, data); session->packAdd_state = libssh2_NB_state_idle; return 0; case SSH_MSG_CHANNEL_REQUEST: if(datalen >= 9) { uint32_t channel = _libssh2_ntohu32(data + 1); uint32_t len = _libssh2_ntohu32(data + 5); unsigned char want_reply = 1; if((len + 9) < datalen) want_reply = data[len + 9]; _libssh2_debug(session, LIBSSH2_TRACE_CONN, ""Channel %d received request type %.*s (wr %X)"", channel, len, data + 9, want_reply); if(len == sizeof(""exit-status"") - 1 && (sizeof(""exit-status"") - 1 + 9) <= datalen && !memcmp(""exit-status"", data + 9, sizeof(""exit-status"") - 1)) { if(datalen >= 20) channelp = _libssh2_channel_locate(session, channel); if(channelp && (sizeof(""exit-status"") + 13) <= datalen) { channelp->exit_status = _libssh2_ntohu32(data + 9 + sizeof(""exit-status"")); _libssh2_debug(session, LIBSSH2_TRACE_CONN, ""Exit status %lu received for "" ""channel %lu/%lu"", channelp->exit_status, channelp->local.id, channelp->remote.id); } } else if(len == sizeof(""exit-signal"") - 1 && (sizeof(""exit-signal"") - 1 + 9) <= datalen && !memcmp(""exit-signal"", data + 9, sizeof(""exit-signal"") - 1)) { if(datalen >= 20) channelp = _libssh2_channel_locate(session, channel); if(channelp && (sizeof(""exit-signal"") + 13) <= datalen) { uint32_t namelen = _libssh2_ntohu32(data + 9 + sizeof(""exit-signal"")); if(namelen <= UINT_MAX - 1) { channelp->exit_signal = LIBSSH2_ALLOC(session, namelen + 1); } else { channelp->exit_signal = NULL; } if(!channelp->exit_signal) rc = _libssh2_error(session, LIBSSH2_ERROR_ALLOC, ""memory for signal name""); else if((sizeof(""exit-signal"") + 13 + namelen <= datalen)) { memcpy(channelp->exit_signal, data + 13 + sizeof(""exit-signal""), namelen); channelp->exit_signal[namelen] = '\0'; _libssh2_debug(session, LIBSSH2_TRACE_CONN, ""Exit signal %s received for "" ""channel %lu/%lu"", channelp->exit_signal, channelp->local.id, channelp->remote.id); } } } if(want_reply) { unsigned char packet[5]; libssh2_packet_add_jump_point4: session->packAdd_state = libssh2_NB_state_jump4; packet[0] = SSH_MSG_CHANNEL_FAILURE; memcpy(&packet[1], data + 1, 4); rc = _libssh2_transport_send(session, packet, 5, NULL, 0); if(rc == LIBSSH2_ERROR_EAGAIN) return rc; } } LIBSSH2_FREE(session, data); session->packAdd_state = libssh2_NB_state_idle; return rc; case SSH_MSG_CHANNEL_CLOSE: if(datalen >= 5) channelp = _libssh2_channel_locate(session, _libssh2_ntohu32(data + 1)); if(!channelp) { LIBSSH2_FREE(session, data); session->packAdd_state = libssh2_NB_state_idle; return 0; } _libssh2_debug(session, LIBSSH2_TRACE_CONN, ""Close received for channel %lu/%lu"", channelp->local.id, channelp->remote.id); channelp->remote.close = 1; channelp->remote.eof = 1; LIBSSH2_FREE(session, data); session->packAdd_state = libssh2_NB_state_idle; return 0; case SSH_MSG_CHANNEL_OPEN: if(datalen < 17) ; else if((datalen >= (sizeof(""forwarded-tcpip"") + 4)) && ((sizeof(""forwarded-tcpip"") - 1) == _libssh2_ntohu32(data + 1)) && (memcmp(data + 5, ""forwarded-tcpip"", sizeof(""forwarded-tcpip"") - 1) == 0)) { memset(&session->packAdd_Qlstn_state, 0, sizeof(session->packAdd_Qlstn_state)); libssh2_packet_add_jump_point2: session->packAdd_state = libssh2_NB_state_jump2; rc = packet_queue_listener(session, data, datalen, &session->packAdd_Qlstn_state); } else if((datalen >= (sizeof(""x11"") + 4)) && ((sizeof(""x11"") - 1) == _libssh2_ntohu32(data + 1)) && (memcmp(data + 5, ""x11"", sizeof(""x11"") - 1) == 0)) { memset(&session->packAdd_x11open_state, 0, sizeof(session->packAdd_x11open_state)); libssh2_packet_add_jump_point3: session->packAdd_state = libssh2_NB_state_jump3; rc = packet_x11_open(session, data, datalen, &session->packAdd_x11open_state); } if(rc == LIBSSH2_ERROR_EAGAIN) return rc; LIBSSH2_FREE(session, data); session->packAdd_state = libssh2_NB_state_idle; return rc; case SSH_MSG_CHANNEL_WINDOW_ADJUST: if(datalen < 9) ; else { uint32_t bytestoadd = _libssh2_ntohu32(data + 5); channelp = _libssh2_channel_locate(session, _libssh2_ntohu32(data + 1)); if(channelp) { channelp->local.window_size += bytestoadd; _libssh2_debug(session, LIBSSH2_TRACE_CONN, ""Window adjust for channel %lu/%lu, "" ""adding %lu bytes, new window_size=%lu"", channelp->local.id, channelp->remote.id, bytestoadd, channelp->local.window_size); } } LIBSSH2_FREE(session, data); session->packAdd_state = libssh2_NB_state_idle; return 0; default: break; } session->packAdd_state = libssh2_NB_state_sent; } if(session->packAdd_state == libssh2_NB_state_sent) { LIBSSH2_PACKET *packetp = LIBSSH2_ALLOC(session, sizeof(LIBSSH2_PACKET)); if(!packetp) { _libssh2_debug(session, LIBSSH2_ERROR_ALLOC, ""memory for packet""); LIBSSH2_FREE(session, data); session->packAdd_state = libssh2_NB_state_idle; return LIBSSH2_ERROR_ALLOC; } packetp->data = data; packetp->data_len = datalen; packetp->data_head = data_head; _libssh2_list_add(&session->packets, &packetp->node); session->packAdd_state = libssh2_NB_state_sent1; } if((msg == SSH_MSG_KEXINIT && !(session->state & LIBSSH2_STATE_EXCHANGING_KEYS)) || (session->packAdd_state == libssh2_NB_state_sent2)) { if(session->packAdd_state == libssh2_NB_state_sent1) { _libssh2_debug(session, LIBSSH2_TRACE_TRANS, ""Renegotiating Keys""); session->packAdd_state = libssh2_NB_state_sent2; } session->readPack_state = libssh2_NB_state_idle; session->packet.total_num = 0; session->packAdd_state = libssh2_NB_state_idle; session->fullpacket_state = libssh2_NB_state_idle; memset(&session->startup_key_state, 0, sizeof(key_exchange_state_t)); rc = _libssh2_kex_exchange(session, 1, &session->startup_key_state); if(rc == LIBSSH2_ERROR_EAGAIN) return rc; } session->packAdd_state = libssh2_NB_state_idle; return 0; }
Description: In libssh2 v1.9.0 and earlier versions, the SSH_MSG_DISCONNECT logic in packet.c has an integer overflow in a bounds check, enabling an attacker to specify an arbitrary (out-of-bounds) offset for a subsequent memory read. A crafted SSH server may be able to disclose sensitive information or cause a denial of service condition on the client system when a user connects to the server.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int export(AVFilterContext *ctx, StreamContext *sc, int input) { SignatureContext* sic = ctx->priv; char filename[1024]; if (sic->nb_inputs > 1) { av_assert0(av_get_frame_filename(filename, sizeof(filename), sic->filename, input) == 0); } else { strcpy(filename, sic->filename); } if (sic->format == FORMAT_XML) { return xml_export(ctx, sc, filename); } else { return binary_export(ctx, sc, filename); } }
Description: The export function in libavfilter/vf_signature.c in FFmpeg through 3.4.2 allows remote attackers to cause a denial of service (out-of-array access) or possibly have unspecified other impact via a long filename.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int setupStream(PRTSP_MESSAGE response, char* target, int* error) { RTSP_MESSAGE request; int ret; char* transportValue; *error = -1; ret = initializeRtspRequest(&request, ""SETUP"", target); if (ret != 0) { if (hasSessionId) { if (!addOption(&request, ""Session"", sessionIdString)) { ret = 0; goto FreeMessage; } } if (ServerMajorVersion >= 6) { transportValue = ""unicast;X-GS-ClientPort=50000-50001""; } else { transportValue = "" ""; } if (addOption(&request, ""Transport"", transportValue) && addOption(&request, ""If-Modified-Since"", ""Thu, 01 Jan 1970 00:00:00 GMT"")) { ret = transactRtspMessage(&request, response, 0, error); } else { ret = 0; } FreeMessage: freeMessage(&request); } return ret; }
Description: Moonlight-common-c contains the core GameStream client code shared between Moonlight clients. Moonlight-common-c is vulnerable to buffer overflow starting in commit f57bd745b4cbed577ea654fad4701bea4d38b44c. A malicious game streaming server could exploit a buffer overflow vulnerability to crash a moonlight client. Achieving RCE is possible but unlikely, due to stack canaries in use by modern compiler toolchains. The published binaries for official clients Qt, Android, iOS/tvOS, and Embedded are built with stack canaries, but some unofficial clients may not use stack canaries. This vulnerability takes place after the pairing process, so it requires the client to be tricked into pairing to a malicious host. It is not possible to perform using a man-in-the-middle due to public key pinning that takes place during the pairing process. The bug was addressed in commit b2497a3918a6d79808d9fd0c04734786e70d5954.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int rtnl_fill_link_ifmap(struct sk_buff *skb, struct net_device *dev) { struct rtnl_link_ifmap map = { .mem_start   = dev->mem_start, .mem_end     = dev->mem_end, .base_addr   = dev->base_addr, .irq         = dev->irq, .dma         = dev->dma, .port        = dev->if_port, }; if (nla_put(skb, IFLA_MAP, sizeof(map), &map)) return -EMSGSIZE; return 0; }
Description: The rtnl_fill_link_ifmap function in net/core/rtnetlink.c in the Linux kernel before 4.5.5 does not initialize a certain data structure, which allows local users to obtain sensitive information from kernel stack memory by reading a Netlink message.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool feed(const char* buffer, int length) { const static http_parser_settings settings_{ on_message_begin, on_method, on_url, on_header_field, on_header_value, on_headers_complete, on_body, on_message_complete, }; int nparsed = http_parser_execute(this, &settings_, buffer, length); if (http_errno != CHPE_OK) { return false; } return nparsed == length; }
Description: HTTP applications (servers) based on Crow through 1.0+4 may allow a Use-After-Free and code execution when HTTP pipelining is used. The HTTP parser supports HTTP pipelining, but the asynchronous Connection layer is unaware of HTTP pipelining. Specifically, the Connection layer is unaware that it has begun processing a later request before it has finished processing an earlier request.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void sqlg_vec_ts (sql_comp_t * sc, table_source_t * ts) { key_source_t *ks = ts->ts_order_ks; search_spec_t *sp; dk_set_t ssl_list = ks->ks_out_slots; int cast_changes_card = 0; int n_k_ssl = sp_ssl_count (sc, ks->ks_spec.ksp_spec_array, &ks->ks_n_vec_sort_cols, &cast_changes_card), ign = 0; int n_r_ssl = sp_ssl_count (sc, ks->ks_row_spec, NULL, &cast_changes_card); int fill = 0, inx = 0, n_out; if (ts->ts_alternate) { sqlg_vec_alt_ts (sc, ts); return; } ts->src_gen.src_batch_size = cc_new_instance_slot (sc->sc_cc); ks->ks_ts = ts; sc->sc_vec_first_of_qf = sqlg_qn_first_of (sc, (data_source_t *) ts); ASG_SSL (res, all_res, ts->ts_current_of); if (!ks->ks_is_qf_first) { ks->ks_vec_cast = (state_slot_t **) dk_alloc_box_zero (sizeof (caddr_t) * (n_r_ssl + n_k_ssl), DV_BIN); ks->ks_vec_source = (state_slot_ref_t **) dk_alloc_box_zero (sizeof (caddr_t) * (n_r_ssl + n_k_ssl), DV_BIN); ks->ks_dc_val_cast = (dc_val_cast_t *) dk_alloc_box_zero (sizeof (caddr_t) * (n_r_ssl + n_k_ssl), DV_BIN); for (sp = ks->ks_spec.ksp_spec_array; sp; sp = sp->sp_next) { sc->sc_vec_current_col = sch_id_to_col (wi_inst.wi_schema, sp->sp_cl.cl_col_id); if (sp->sp_min_ssl) { sqlg_vec_cast (sc, ks->ks_vec_source, ks->ks_vec_cast, ks->ks_dc_val_cast, &sp->sp_min_ssl, fill, &ks->ks_last_vec_param, &sp->sp_cl.cl_sqt, cast_changes_card); if (sc->sc_in_cursor_def && sp->sp_min_ssl->ssl_type == SSL_VARIABLE) ks->ks_copy_search_pars = 1; fill++; } if (sp->sp_max_ssl) { sqlg_vec_cast (sc, ks->ks_vec_source, ks->ks_vec_cast, ks->ks_dc_val_cast, &sp->sp_max_ssl, fill, &ks->ks_last_vec_param, &sp->sp_cl.cl_sqt, cast_changes_card); if (sc->sc_in_cursor_def && sp->sp_max_ssl->ssl_type == SSL_VARIABLE) ks->ks_copy_search_pars = 1; fill++; } } for (sp = ks->ks_row_spec; sp; sp = sp->sp_next) { sc->sc_vec_current_col = sch_id_to_col (wi_inst.wi_schema, sp->sp_cl.cl_col_id); if (ks->ks_key->key_is_col) { dtp_t min_op = sp->sp_min_op, max_op = sp->sp_max_op; if (!sp->sp_col_filter) sp->sp_col_filter = col_find_op (CE_OP_CODE (sp->sp_min_op, sp->sp_max_op)); if (!sp->sp_col_filter && (CMP_GT == min_op || CMP_GTE == min_op || CMP_LT == max_op || CMP_LTE == max_op)) sp->sp_col_filter = col_find_op (CE_ALL_LTGT); } if (sp->sp_min_ssl) { sql_type_t target_sqt = sp->sp_cl.cl_sqt; if (ks->ks_key->key_is_col) target_sqt.sqt_dtp = target_sqt.sqt_col_dtp; sqlg_vec_cast (sc, ks->ks_vec_source, ks->ks_vec_cast, ks->ks_dc_val_cast, &sp->sp_min_ssl, fill, &ks->ks_last_vec_param, &target_sqt, cast_changes_card); if (!ks->ks_first_row_vec_ssl && SSL_IS_VEC_OR_REF (sp->sp_min_ssl)) ks->ks_first_row_vec_ssl = sp->sp_min_ssl; if (sc->sc_in_cursor_def && sp->sp_min_ssl->ssl_type == SSL_VARIABLE) ks->ks_copy_search_pars = 1; fill++; } if (sp->sp_max_ssl) { sql_type_t target_sqt = sp->sp_cl.cl_sqt; if (ks->ks_key->key_is_col) target_sqt.sqt_dtp = target_sqt.sqt_col_dtp; sqlg_vec_cast (sc, ks->ks_vec_source, ks->ks_vec_cast, ks->ks_dc_val_cast, &sp->sp_max_ssl, fill, &ks->ks_last_vec_param, &target_sqt, cast_changes_card); if (!ks->ks_first_row_vec_ssl && SSL_IS_VEC_OR_REF (sp->sp_max_ssl)) ks->ks_first_row_vec_ssl = sp->sp_max_ssl; if (sc->sc_in_cursor_def && sp->sp_max_ssl->ssl_type == SSL_VARIABLE) ks->ks_copy_search_pars = 1; fill++; } } sc->sc_vec_current_col = NULL; } sc->sc_vec_first_of_qf = NULL; sqlg_vec_ts_out_alias (sc, ts); n_out = dk_set_length (ks->ks_out_slots); ks->ks_v_out_map = (v_out_map_t *) dk_alloc_box_zero (n_out * sizeof (v_out_map_t), DV_BIN); ssl_list = ks->ks_out_slots; inx = 0; if (ks->ks_is_proc_view) { dk_set_free (ks->ks_out_cols); ks->ks_out_cols = dk_set_copy (ks->ks_key->key_parts); } DO_SET (dbe_column_t *, col, &ks->ks_out_cols) { state_slot_t *ssl = (state_slot_t *) ssl_list->data, *shadow; oid_t col_id = IS_BOX_POINTER (col) ? col->col_id : (oid_t) (ptrlong) col; if (ssl->ssl_alias_of) ssl = ssl->ssl_alias_of; shadow = (state_slot_t *) gethash ((void *) (ptrlong) ssl->ssl_index, sc->sc_vec_ssl_shadow); if (shadow) ssl_list->data = (void *) (ssl = shadow); if (!IS_BOX_POINTER (col)) col = key_col_by_id (ks->ks_key, (ptrlong) col); ssl_list = ssl_list->next; if (!ks->ks_is_last || ks->ks_key->key_is_col) { if (ks->ks_key->key_bit_cl && col_id == ks->ks_key->key_bit_cl->cl_col_id) ks->ks_v_out_map[inx].om_is_null = OM_BM_COL; else if (CI_ROW == col_id) { if (ks->ks_key->key_is_col) sqlc_new_error (sc->sc_cc, ""37000"", ""COL.."", ""Can't select _row from a column-wise key""); ks->ks_v_out_map[inx].om_ref = dc_itc_append_row; ssl->ssl_dtp = DV_ARRAY_OF_POINTER; } else if (ks->ks_key->key_is_col) { ks->ks_v_out_map[inx].om_cl = *cl_list_find (ks->ks_key->key_row_var, col_id); ks->ks_v_out_map[inx].om_ce_op = col_find_op (CE_DECODE); } else ks->ks_v_out_map[inx].om_cl = *key_find_cl (ks->ks_key, col_id); ks->ks_v_out_map[inx].om_ssl = ssl; if (col) ks->ks_v_out_map[inx].om_ref = col_ref_func (ks->ks_key, col, ks->ks_v_out_map[inx].om_ssl); ssl->ssl_type = SSL_VEC; if (!ssl->ssl_box_index) ssl->ssl_box_index = cc_new_instance_slot (sc->sc_cc); ssl_set_dc_type (ssl); } ASG_SSL (NULL, NULL, ssl); t_set_delete (&sc->sc_ssl_prereset_only, (void *) ssl); inx++; } END_DO_SET (); if (ks->ks_vec_cast) { int inx; DO_BOX (state_slot_t *, ssl, inx, ks->ks_vec_cast) { if (ssl) sethash ((void *) (ptrlong) ssl->ssl_index, sc->sc_vec_last_ref, (void *) ts); } END_DO_BOX; } if (ks->ks_key->key_is_col) ks->ks_row_check = itc_col_row_check_dummy; else if (!ks->ks_is_last) ks->ks_row_check = ks->ks_key->key_is_bitmap ? itc_bm_vec_row_check : itc_vec_row_check; ks->ks_param_nos = cc_new_instance_slot (sc->sc_cc); DO_SET (state_slot_t *, ssl, &ks->ks_always_null) ASG_SSL (NULL, NULL, ssl);  END_DO_SET (); t_set_push (&sc->sc_vec_pred, (void *) ts); DO_SET (search_spec_t *, sp, &ks->ks_hash_spec) { hash_range_spec_t *hrng = (hash_range_spec_t *) sp->sp_min_ssl; REF_SSL (res, hrng->hrng_ht); } END_DO_SET (); cv_vec_slots (sc, ks->ks_local_test, NULL, NULL, &ign); if (ks->ks_local_code && !ks->ks_is_last) { ks->ks_ts->src_gen.src_after_code = ks->ks_local_code; ks->ks_local_code = NULL; } else { ign = VEC_SINGLE_STATE; cv_vec_slots (sc, ks->ks_local_code, NULL, NULL, &ign); sqlg_new_vec_ssls (sc, &ks->ks_ts->src_gen); } sc->sc_vec_pred = sc->sc_vec_pred->next; sqlg_ts_qp_copy (sc, ts); REF_SSL (res, ks->ks_set_no); if (IS_QN (ts, sort_read_input)) { ts->clb.clb_nth_set = cc_new_instance_slot (sc->sc_cc); ts->ts_sort_read_mask = sqlg_ts_sort_read_mask (sc, ts); } }
Description: An issue in the box_mpy function of openlink virtuoso-opensource v7.2.11 allows attackers to cause a Denial of Service (DoS) after running a SELECT statement.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void SSLNetVConnection::net_read_io(NetHandler *nh, EThread *lthread) { int ret; int64_t r     = 0; int64_t bytes = 0; NetState *s   = &this->read; if (HttpProxyPort::TRANSPORT_BLIND_TUNNEL == this->attributes) { this->super::net_read_io(nh, lthread); return; } MUTEX_TRY_LOCK_FOR(lock, s->vio.mutex, lthread, s->vio._cont); if (!lock.is_locked()) { readReschedule(nh); return; } if (this->closed) { this->super::net_read_io(nh, lthread); return; } if (sslClientRenegotiationAbort == true) { this->read.triggered = 0; readSignalError(nh, (int)r); Debug(""ssl"", ""[SSLNetVConnection::net_read_io] client renegotiation setting read signal error""); return; } if (!s->enabled || s->vio.op != VIO::READ) { read_disable(nh, this); return; } MIOBufferAccessor &buf = s->vio.buffer; int64_t ntodo          = s->vio.ntodo(); ink_assert(buf.writer()); if (!getSSLHandShakeComplete()) { int err; if (get_context() == NET_VCONNECTION_OUT) { ret = sslStartHandShake(SSL_EVENT_CLIENT, err); } else { ret = sslStartHandShake(SSL_EVENT_SERVER, err); } if (this->handShakeReader) { if (this->attributes != HttpProxyPort::TRANSPORT_BLIND_TUNNEL) { if (BIO_eof(SSL_get_rbio(this->ssl))) { this->handShakeReader->consume(this->handShakeBioStored); this->handShakeBioStored = 0; if (this->handShakeReader->is_read_avail_more_than(0)) { char *start              = this->handShakeReader->start(); char *end                = this->handShakeReader->end(); this->handShakeBioStored = end - start; BIO *rbio = BIO_new_mem_buf(start, this->handShakeBioStored); BIO_set_mem_eof_return(rbio, -1); SSL_set0_rbio(this->ssl, rbio); } } } else { this->readSignalDone(VC_EVENT_READ_COMPLETE, nh); if (!this->getSSLHandShakeComplete()) { this->sslHandShakeComplete = 1; NetState *s            = &this->read; MIOBufferAccessor &buf = s->vio.buffer; int64_t r              = buf.writer()->write(this->handShakeHolder); s->vio.nbytes += r; s->vio.ndone += r; this->free_handshake_buffers(); if (r > 0) { this->readSignalDone(VC_EVENT_READ_COMPLETE, nh); } } return;       } } if (ret == EVENT_ERROR) { this->read.triggered = 0; readSignalError(nh, err); } else if (ret == SSL_HANDSHAKE_WANT_READ || ret == SSL_HANDSHAKE_WANT_ACCEPT) { if (SSLConfigParams::ssl_handshake_timeout_in > 0) { double handshake_time = ((double)(Thread::get_hrtime() - sslHandshakeBeginTime) / 1000000000); Debug(""ssl"", ""ssl handshake for vc %p, took %.3f seconds, configured handshake_timer: %d"", this, handshake_time, SSLConfigParams::ssl_handshake_timeout_in); if (handshake_time > SSLConfigParams::ssl_handshake_timeout_in) { Debug(""ssl"", ""ssl handshake for vc %p, expired, release the connection"", this); read.triggered = 0; nh->read_ready_list.remove(this); readSignalError(nh, VC_EVENT_EOS); return; } } if (this->handShakeReader) { ink_release_assert(BIO_eof(SSL_get_rbio(this->ssl)) && !handShakeReader->is_read_avail_more_than(0)); BIO *rbio = BIO_new_fd(this->get_socket(), BIO_NOCLOSE); BIO_set_mem_eof_return(rbio, -1); SSL_set0_rbio(this->ssl, rbio); free_handshake_buffers(); } else { Debug(""ssl"", ""Want read from socket""); } read.triggered = 0; nh->read_ready_list.remove(this); readReschedule(nh); } else if (ret == SSL_HANDSHAKE_WANT_CONNECT || ret == SSL_HANDSHAKE_WANT_WRITE) { write.triggered = 0; nh->write_ready_list.remove(this); writeReschedule(nh); } else if (ret == EVENT_DONE) { if (ntodo <= 0) { readSignalDone(VC_EVENT_READ_COMPLETE, nh); } else { read.triggered = 1; if (read.enabled) { nh->read_ready_list.in_or_enqueue(this); } } } else if (ret == SSL_WAIT_FOR_HOOK) { } else { readReschedule(nh); } return; } if (ntodo <= 0 || !buf.writer()->write_avail()) { read_disable(nh, this); return; } do { ret = ssl_read_from_net(this, lthread, r); if (ret == SSL_READ_READY || ret == SSL_READ_ERROR_NONE) { bytes += r; } ink_assert(bytes >= 0); } while ((ret == SSL_READ_READY && bytes == 0) || ret == SSL_READ_ERROR_NONE); if (bytes > 0) { if (ret == SSL_READ_WOULD_BLOCK || ret == SSL_READ_READY) { if (readSignalAndUpdate(VC_EVENT_READ_READY) != EVENT_CONT) { Debug(""ssl"", ""ssl_read_from_net, readSignal != EVENT_CONT""); return; } } } switch (ret) { case SSL_READ_READY: readReschedule(nh); return; break; case SSL_WRITE_WOULD_BLOCK: case SSL_READ_WOULD_BLOCK: if (lock.get_mutex() != s->vio.mutex.get()) { Debug(""ssl"", ""ssl_read_from_net, mutex switched""); if (ret == SSL_READ_WOULD_BLOCK) { readReschedule(nh); } else { writeReschedule(nh); } return; } read.triggered = 0; nh->read_ready_list.remove(this); Debug(""ssl"", ""read_from_net, read finished - would block""); #ifdef TS_USE_PORT if (ret == SSL_READ_WOULD_BLOCK) { readReschedule(nh); } else { writeReschedule(nh); } #endif break; case SSL_READ_EOS: read.triggered = 0; readSignalDone(VC_EVENT_EOS, nh); if (bytes > 0) { Debug(""ssl"", ""read_from_net, read finished - EOS""); } else { Debug(""ssl"", ""read_from_net, read finished - 0 useful bytes read, bytes used by SSL layer""); } break; case SSL_READ_COMPLETE: readSignalDone(VC_EVENT_READ_COMPLETE, nh); Debug(""ssl"", ""read_from_net, read finished - signal done""); break; case SSL_READ_ERROR: this->read.triggered = 0; readSignalError(nh, (int)r); Debug(""ssl"", ""read_from_net, read finished - read error""); break; } }
Description: A carefully crafted invalid TLS handshake can cause Apache Traffic Server (ATS) to segfault. This affects version 6.2.2. To resolve this issue users running 6.2.2 should upgrade to 6.2.3 or later versions.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void evtchn_destroy(struct domain *d) { unsigned int i; BUG_ON(!d->is_dying); spin_barrier(&d->event_lock); for ( i = 0; port_is_valid(d, i); i++ ) evtchn_close(d, i, 0); ASSERT(!d->active_evtchns); clear_global_virq_handlers(d); evtchn_fifo_destroy(d); }
Description: An issue was discovered in Xen through 4.14.x. There is a lack of preemption in evtchn_reset() / evtchn_destroy(). In particular, the FIFO event channel model allows guests to have a large number of event channels active at a time. Closing all of these (when resetting all event channels or when cleaning up after the guest) may take extended periods of time. So far, there was no arrangement for preemption at suitable intervals, allowing a CPU to spend an almost unbounded amount of time in the processing of these operations. Malicious or buggy guest kernels can mount a Denial of Service (DoS) attack affecting the entire system. All Xen versions are vulnerable in principle. Whether versions 4.3 and older are vulnerable depends on underlying hardware characteristics.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static const char* ConvertScalar(PyObject* v, Eigen::half* out) { Safe_PyObjectPtr as_float = make_safe(PyNumber_Float(v)); double v_double = PyFloat_AS_DOUBLE(as_float.get()); *out = Eigen::half(v_double); return nullptr; }
Description: In TensorFlow before 1.15.2 and 2.0.1, converting a string (from Python) to a tf.float16 value results in a segmentation fault in eager mode as the format checks for this use case are only in the graph mode. This issue can lead to denial of service in inference/training where a malicious attacker can send a data point which contains a string instead of a tf.float16 value. Similar effects can be obtained by manipulating saved models and checkpoints whereby replacing a scalar tf.float16 value with a scalar string will trigger this issue due to automatic conversions. This can be easily reproduced by tf.constant(""hello"", tf.float16), if eager execution is enabled. This issue is patched in TensorFlow 1.15.1 and 2.0.1 with this vulnerability patched. TensorFlow 2.1.0 was released after we fixed the issue, thus it is not affected. Users are encouraged to switch to TensorFlow 1.15.1, 2.0.1 or 2.1.0.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int xt_compat_check_entry_offsets(const void *base, unsigned int target_offset, unsigned int next_offset) { const struct compat_xt_entry_target *t; const char *e = base; if (target_offset + sizeof(*t) > next_offset) return -EINVAL; t = (void *)(e + target_offset); if (t->u.target_size < sizeof(*t)) return -EINVAL; if (target_offset + t->u.target_size > next_offset) return -EINVAL; if (strcmp(t->u.user.name, XT_STANDARD_TARGET) == 0 && target_offset + sizeof(struct compat_xt_standard_target) != next_offset) return -EINVAL; return 0; }
Description: The compat IPT_SO_SET_REPLACE and IP6T_SO_SET_REPLACE setsockopt implementations in the netfilter subsystem in the Linux kernel before 4.6.3 allow local users to gain privileges or cause a denial of service (memory corruption) by leveraging in-container root access to provide a crafted offset value that triggers an unintended decrement.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int errorexec_find(i_ctx_t *i_ctx_p, ref *perror_object) { long i; const ref *ep; for (i = 0; (ep = ref_stack_index(&e_stack, i)) != 0; ++i) { if (r_is_estack_mark(ep)) { if (ep->value.opproc == oparray_cleanup) { uint opindex = (uint)ep[1].value.intval; if (opindex == 0)  continue; op_index_ref(imemory, opindex, perror_object); return 1; } if (ep->value.opproc == oparray_no_cleanup) return 0;        if (ep->value.opproc == errorexec_cleanup) { if (r_has_type(ep + 1, t_null)) return 0; *perror_object = ep[1];  return 1; } } } return 0; }
Description: Artifex Ghostscript allows attackers to bypass a sandbox protection mechanism by leveraging exposure of system operators in the saved execution stack in an error object.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int ext4_mb_add_groupinfo(struct super_block *sb, ext4_group_t group, struct ext4_group_desc *desc) { int i; int metalen = 0; struct ext4_sb_info *sbi = EXT4_SB(sb); struct ext4_group_info **meta_group_info; struct kmem_cache *cachep = get_groupinfo_cache(sb->s_blocksize_bits); if (group % EXT4_DESC_PER_BLOCK(sb) == 0) { metalen = sizeof(*meta_group_info) << EXT4_DESC_PER_BLOCK_BITS(sb); meta_group_info = kmalloc(metalen, GFP_NOFS); if (meta_group_info == NULL) { ext4_msg(sb, KERN_ERR, ""can't allocate mem "" ""for a buddy group""); goto exit_meta_group_info; } sbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)] = meta_group_info; } meta_group_info = sbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)]; i = group & (EXT4_DESC_PER_BLOCK(sb) - 1); meta_group_info[i] = kmem_cache_zalloc(cachep, GFP_NOFS); if (meta_group_info[i] == NULL) { ext4_msg(sb, KERN_ERR, ""can't allocate buddy mem""); goto exit_group_info; } set_bit(EXT4_GROUP_INFO_NEED_INIT_BIT, &(meta_group_info[i]->bb_state)); if (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) { meta_group_info[i]->bb_free = ext4_free_clusters_after_init(sb, group, desc); } else { meta_group_info[i]->bb_free = ext4_free_group_clusters(sb, desc); } INIT_LIST_HEAD(&meta_group_info[i]->bb_prealloc_list); init_rwsem(&meta_group_info[i]->alloc_sem); meta_group_info[i]->bb_free_root = RB_ROOT; meta_group_info[i]->bb_largest_free_order = -1;   #ifdef DOUBLE_CHECK { struct buffer_head *bh; meta_group_info[i]->bb_bitmap = kmalloc(sb->s_blocksize, GFP_NOFS); BUG_ON(meta_group_info[i]->bb_bitmap == NULL); bh = ext4_read_block_bitmap(sb, group); BUG_ON(IS_ERR_OR_NULL(bh)); memcpy(meta_group_info[i]->bb_bitmap, bh->b_data, sb->s_blocksize); put_bh(bh); } #endif return 0; exit_group_info: if (group % EXT4_DESC_PER_BLOCK(sb) == 0) { kfree(sbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)]); sbi->s_group_info[group >> EXT4_DESC_PER_BLOCK_BITS(sb)] = NULL; } exit_meta_group_info: return -ENOMEM; }
Description: A flaw was found in Linux kernel in the ext4 filesystem code. A use-after-free is possible in ext4_ext_remove_space() function when mounting and operating a crafted ext4 image.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u, int closing, int tx_ring) { struct pgv *pg_vec = NULL; struct packet_sock *po = pkt_sk(sk); int was_running, order = 0; struct packet_ring_buffer *rb; struct sk_buff_head *rb_queue; __be16 num; int err = -EINVAL; struct tpacket_req *req = &req_u->req; if (!closing && tx_ring && (po->tp_version > TPACKET_V2)) { net_warn_ratelimited(""Tx-ring is not supported.\n""); goto out; } rb = tx_ring ? &po->tx_ring : &po->rx_ring; rb_queue = tx_ring ? &sk->sk_write_queue : &sk->sk_receive_queue; err = -EBUSY; if (!closing) { if (atomic_read(&po->mapped)) goto out; if (packet_read_pending(rb)) goto out; } if (req->tp_block_nr) { err = -EBUSY; if (unlikely(rb->pg_vec)) goto out; switch (po->tp_version) { case TPACKET_V1: po->tp_hdrlen = TPACKET_HDRLEN; break; case TPACKET_V2: po->tp_hdrlen = TPACKET2_HDRLEN; break; case TPACKET_V3: po->tp_hdrlen = TPACKET3_HDRLEN; break; } err = -EINVAL; if (unlikely((int)req->tp_block_size <= 0)) goto out; if (unlikely(!PAGE_ALIGNED(req->tp_block_size))) goto out; if (po->tp_version >= TPACKET_V3 && (int)(req->tp_block_size - BLK_PLUS_PRIV(req_u->req3.tp_sizeof_priv)) <= 0) goto out; if (unlikely(req->tp_frame_size < po->tp_hdrlen + po->tp_reserve)) goto out; if (unlikely(req->tp_frame_size & (TPACKET_ALIGNMENT - 1))) goto out; rb->frames_per_block = req->tp_block_size / req->tp_frame_size; if (unlikely(rb->frames_per_block == 0)) goto out; if (unlikely((rb->frames_per_block * req->tp_block_nr) != req->tp_frame_nr)) goto out; err = -ENOMEM; order = get_order(req->tp_block_size); pg_vec = alloc_pg_vec(req, order); if (unlikely(!pg_vec)) goto out; switch (po->tp_version) { case TPACKET_V3: if (!tx_ring) init_prb_bdqc(po, rb, pg_vec, req_u); break; default: break; } } else { err = -EINVAL; if (unlikely(req->tp_frame_nr)) goto out; } lock_sock(sk); spin_lock(&po->bind_lock); was_running = po->running; num = po->num; if (was_running) { po->num = 0; __unregister_prot_hook(sk, false); } spin_unlock(&po->bind_lock); synchronize_net(); err = -EBUSY; mutex_lock(&po->pg_vec_lock); if (closing || atomic_read(&po->mapped) == 0) { err = 0; spin_lock_bh(&rb_queue->lock); swap(rb->pg_vec, pg_vec); rb->frame_max = (req->tp_frame_nr - 1); rb->head = 0; rb->frame_size = req->tp_frame_size; spin_unlock_bh(&rb_queue->lock); swap(rb->pg_vec_order, order); swap(rb->pg_vec_len, req->tp_block_nr); rb->pg_vec_pages = req->tp_block_size/PAGE_SIZE; po->prot_hook.func = (po->rx_ring.pg_vec) ? tpacket_rcv : packet_rcv; skb_queue_purge(rb_queue); if (atomic_read(&po->mapped)) pr_err(""packet_mmap: vma is busy: %d\n"", atomic_read(&po->mapped)); } mutex_unlock(&po->pg_vec_lock); spin_lock(&po->bind_lock); if (was_running) { po->num = num; register_prot_hook(sk); } spin_unlock(&po->bind_lock); if (closing && (po->tp_version > TPACKET_V2)) { if (!tx_ring) prb_shutdown_retire_blk_timer(po, rb_queue); } release_sock(sk); if (pg_vec) free_pg_vec(pg_vec, order, req->tp_block_nr); out: return err; }
Description: Race condition in net/packet/af_packet.c in the Linux kernel through 4.8.12 allows local users to gain privileges or cause a denial of service (use-after-free) by leveraging the CAP_NET_RAW capability to change a socket version, related to the packet_set_ring and packet_setsockopt functions.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int MOD_EXP_CTIME_COPY_TO_PREBUF(const BIGNUM *b, int top, unsigned char *buf, int idx, int width) { size_t i, j; if (top > b->top) top = b->top;            for (i = 0, j = idx; i < top * sizeof b->d[0]; i++, j += width) { buf[j] = ((unsigned char *)b->d)[i]; } return 1; }
Description: The MOD_EXP_CTIME_COPY_FROM_PREBUF function in crypto/bn/bn_exp.c in OpenSSL 1.0.1 before 1.0.1s and 1.0.2 before 1.0.2g does not properly consider cache-bank access times during modular exponentiation, which makes it easier for local users to discover RSA keys by running a crafted application on the same Intel Sandy Bridge CPU core as a victim and leveraging cache-bank conflicts, aka a ""CacheBleed"" attack.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void init_copy(mrb_state *mrb, mrb_value dest, mrb_value obj) { switch (mrb_type(obj)) { case MRB_TT_CLASS: case MRB_TT_MODULE: copy_class(mrb, dest, obj); mrb_iv_copy(mrb, dest, obj); mrb_iv_remove(mrb, dest, mrb_intern_lit(mrb, ""__classname__"")); break; case MRB_TT_OBJECT: case MRB_TT_SCLASS: case MRB_TT_HASH: case MRB_TT_DATA: case MRB_TT_EXCEPTION: mrb_iv_copy(mrb, dest, obj); break; case MRB_TT_ISTRUCT: mrb_istruct_copy(dest, obj); break; default: break; } mrb_funcall(mrb, dest, ""initialize_copy"", 1, obj); }
Description: The init_copy function in kernel.c in mruby 1.4.1 makes initialize_copy calls for TT_ICLASS objects, which allows attackers to cause a denial of service (mrb_hash_keys uninitialized pointer and application crash) or possibly have unspecified other impact.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: zend_object_iterator *spl_filesystem_tree_get_iterator(zend_class_entry *ce, zval *object, int by_ref TSRMLS_DC) { spl_filesystem_iterator *iterator; spl_filesystem_object *dir_object; if (by_ref) { zend_error(E_ERROR, ""An iterator cannot be used with foreach by reference""); } dir_object = (spl_filesystem_object*)zend_object_store_get_object(object TSRMLS_CC); iterator   = spl_filesystem_object_to_iterator(dir_object); if (iterator->intern.data == NULL) { iterator->intern.data = object; iterator->intern.funcs = &spl_filesystem_tree_it_funcs; } zval_add_ref(&object); return (zend_object_iterator*)iterator; }
Description: Integer overflow in the SplFileObject::fread function in spl_directory.c in the SPL extension in PHP before 5.5.37 and 5.6.x before 5.6.23 allows remote attackers to cause a denial of service or possibly have unspecified other impact via a large integer argument, a related issue to CVE-2016-5096.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int tcos_select_file(sc_card_t *card, const sc_path_t *in_path, sc_file_t **file_out) { sc_context_t *ctx; sc_apdu_t apdu; sc_file_t *file=NULL; u8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf; unsigned int i; int r, pathlen; assert(card != NULL && in_path != NULL); ctx=card->ctx; memcpy(path, in_path->value, in_path->len); pathlen = in_path->len; sc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04); switch (in_path->type) { case SC_PATH_TYPE_FILE_ID: if (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS; case SC_PATH_TYPE_FROM_CURRENT: apdu.p1 = 9; break; case SC_PATH_TYPE_DF_NAME: apdu.p1 = 4; break; case SC_PATH_TYPE_PATH: apdu.p1 = 8; if (pathlen >= 2 && memcmp(path, ""\x3F\x00"", 2) == 0) path += 2, pathlen -= 2; if (pathlen == 0) apdu.p1 = 0; break; case SC_PATH_TYPE_PARENT: apdu.p1 = 3; pathlen = 0; break; default: SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS); } if( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT; apdu.lc = pathlen; apdu.data = path; apdu.datalen = pathlen; if (file_out != NULL) { apdu.resp = buf; apdu.resplen = sizeof(buf); apdu.le = 256; } else { apdu.resplen = 0; apdu.le = 0;  apdu.p2 = 0x0C;  apdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT; } r = sc_transmit_apdu(card, &apdu); SC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, ""APDU transmit failed""); r = sc_check_sw(card, apdu.sw1, apdu.sw2); if (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r); if (apdu.resplen < 1 || apdu.resp[0] != 0x62){ sc_debug(ctx, SC_LOG_DEBUG_NORMAL, ""received invalid template %02X\n"", apdu.resp[0]); SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED); } file = sc_file_new(); if (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY); *file_out = file; file->path = *in_path; for(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){ int j, len=apdu.resp[i+1]; unsigned char type=apdu.resp[i], *d=apdu.resp+i+2; switch (type) { case 0x80: case 0x81: file->size=0; for(j=0; j<len; ++j) file->size = (file->size<<8) | d[j]; break; case 0x82: file->shareable = (d[0] & 0x40) ? 1 : 0; file->ef_structure = d[0] & 7; switch ((d[0]>>3) & 7) { case 0: file->type = SC_FILE_TYPE_WORKING_EF; break; case 7: file->type = SC_FILE_TYPE_DF; break; default: sc_debug(ctx, SC_LOG_DEBUG_NORMAL, ""invalid file type %02X in file descriptor\n"", d[0]); SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED); } break; case 0x83: file->id = (d[0]<<8) | d[1]; break; case 0x84: memcpy(file->name, d, len); file->namelen = len; break; case 0x86: sc_file_set_sec_attr(file, d, len);  break; default: if (len>0) sc_file_set_prop_attr(file, d, len);  } } file->magic = SC_FILE_MAGIC; parse_sec_attr(card, file, file->sec_attr, file->sec_attr_len); return 0; }
Description: Several buffer overflows when handling responses from a Muscle Card in muscle_list_files in libopensc/card-muscle.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int  main(int argc, char *argv[]) { int optct, rcode; pcap_t *dlt_pcap; #ifdef ENABLE_FRAGROUTE char ebuf[FRAGROUTE_ERRBUF_LEN]; #endif tcprewrite_init(); optct = optionProcess(&tcprewriteOptions, argc, argv); argc -= optct; argv += optct; post_args(argc, argv); if (tcpedit_init(&tcpedit, pcap_datalink(options.pin)) < 0) { errx(-1, ""Error initializing tcpedit: %s"", tcpedit_geterr(tcpedit)); } rcode = tcpedit_post_args(tcpedit); if (rcode < 0) { tcpedit_close(&tcpedit); errx(-1, ""Unable to parse args: %s"", tcpedit_geterr(tcpedit)); } else if (rcode == 1) { warnx(""%s"", tcpedit_geterr(tcpedit)); } if (tcpedit_validate(tcpedit) < 0) { tcpedit_close(&tcpedit); errx(-1, ""Unable to edit packets given options:\n%s"", tcpedit_geterr(tcpedit)); } fuzzing_init(tcpedit->fuzz_seed, tcpedit->fuzz_factor); options.outfile = safe_strdup(OPT_ARG(OUTFILE)); dbgx(1, ""Rewriting DLT to %s"", pcap_datalink_val_to_name(tcpedit_get_output_dlt(tcpedit))); if ((dlt_pcap = pcap_open_dead(tcpedit_get_output_dlt(tcpedit), 65535)) == NULL) { tcpedit_close(&tcpedit); err(-1, ""Unable to open dead pcap handle.""); } dbgx(1, ""DLT of dlt_pcap is %s"", pcap_datalink_val_to_name(pcap_datalink(dlt_pcap))); #ifdef ENABLE_FRAGROUTE if (options.fragroute_args) { if ((options.frag_ctx = fragroute_init(65535, pcap_datalink(dlt_pcap), options.fragroute_args, ebuf)) == NULL) { tcpedit_close(&tcpedit); errx(-1, ""%s"", ebuf); } } #endif #ifdef ENABLE_VERBOSE if (options.verbose) { tcpdump_open(&tcpdump, dlt_pcap); } #endif if ((options.pout = pcap_dump_open(dlt_pcap, options.outfile)) == NULL) { tcpedit_close(&tcpedit); errx(-1, ""Unable to open output pcap file: %s"", pcap_geterr(dlt_pcap)); } pcap_close(dlt_pcap); if (rewrite_packets(tcpedit, options.pin, options.pout) == TCPEDIT_ERROR) { tcpedit_close(&tcpedit); errx(-1, ""Error rewriting packets: %s"", tcpedit_geterr(tcpedit)); } pcap_dump_close(options.pout); pcap_close(options.pin); tcpedit_close(&tcpedit); #ifdef ENABLE_VERBOSE tcpdump_close(&tcpdump); #endif #ifdef ENABLE_FRAGROUTE if (options.frag_ctx) { fragroute_close(options.frag_ctx); } #endif #ifdef ENABLE_DMALLOC dmalloc_shutdown(); #endif restore_stdin(); return 0; }
Description: Tcpreplay v4.4.1 has a heap-based buffer overflow in do_checksum_math at /tcpedit/checksum.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static const char * vips_utf8_strcasestr( const char *haystack_start, const char *needle_start,  int len_bytes ) { int needle_len = g_utf8_strlen( needle_start, -1 ); int needle_len_bytes = strlen( needle_start ); const char *haystack; for( haystack = haystack_start;  haystack - haystack_start <= len_bytes - needle_len_bytes;  haystack = g_utf8_find_next_char( haystack, NULL ) ) { const char *needle_char; const char *haystack_char; int i; haystack_char = haystack; needle_char = needle_start; for( i = 0; i < needle_len; i++ ) { gunichar a =  g_utf8_get_char_validated( haystack_char,  haystack_start + len_bytes - haystack ); gunichar b =  g_utf8_get_char_validated( needle_char, -1 ); if( a == (gunichar) -1 || a == (gunichar) -2 || b == (gunichar) -1 || b == (gunichar) -2 ) return( NULL ); if( a == (gunichar) 0 ) return( NULL ); if( g_unichar_tolower( a ) != g_unichar_tolower( b ) ) break; haystack_char =  g_utf8_find_next_char( haystack_char,  haystack_start + len_bytes ); needle_char =  g_utf8_find_next_char( needle_char, NULL ); } if( i == needle_len ) return( haystack ); } return( NULL ); }
Description: libvips is a demand-driven, horizontally threaded image processing library. A specially crafted SVG input can cause libvips versions 8.14.3 or earlier to segfault when attempting to parse a malformed UTF-8 character. Users should upgrade to libvips version 8.14.4 (or later) when processing untrusted input.

 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void copyin_link(struct new_cpio_header *file_hdr, int in_file_des) { char *link_name = NULL; int res; link_name = (char *)xmalloc((unsigned int)file_hdr->c_filesize + 1); link_name[file_hdr->c_filesize] = '\0'; tape_buffered_read(link_name, in_file_des, file_hdr->c_filesize); tape_skip_padding(in_file_des, file_hdr->c_filesize); res = symlink(link_name, file_hdr->c_name); if (res < 0) { fprintf(stderr, ""%s: symlink %s: %s\n"", progname, file_hdr->c_name, strerror(errno)); free(link_name); return; } if ((lchown(file_hdr->c_name, file_hdr->c_uid, file_hdr->c_gid) < 0) && errno != EPERM) { fprintf(stderr, ""%s: lchown %s: %s\n"", progname, file_hdr->c_name, strerror(errno)); } free(link_name); }
Description: An issue was discovered in klibc before 2.0.9. An integer overflow in the cpio command may result in a NULL pointer dereference on 64-bit systems.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: opj_volume_t* pgxtovolume(char *relpath, opj_cparameters_t *parameters) { FILE *f = NULL; int w, h, prec; unsigned long offset; int i, s, numcomps, maxvalue, sliceno, slicepos, maxslice = 0; OPJ_COLOR_SPACE color_space; opj_volume_cmptparm_t cmptparm;  opj_volume_t * volume = NULL; char endian1, endian2, sign; char signtmp[32]; char temp[32]; opj_volume_comp_t *comp = NULL; DIR *dirp; struct dirent *direntp; char *tmp = NULL, *tmp2 = NULL, *point = NULL, *pgx = NULL; char tmpdirpath[MAX_PATH]; char dirpath[MAX_PATH]; char pattern[MAX_PATH]; char pgxfiles[MAX_SLICES][MAX_PATH]; int pgxslicepos[MAX_SLICES]; char tmpno[3]; numcomps = 1; color_space = CLRSPC_GRAY; sliceno = 0; maxvalue = 0; memset(pgxfiles, 0, MAX_SLICES * MAX_PATH * sizeof(char)); memset(&cmptparm, 0, sizeof(opj_volume_cmptparm_t)); if ((tmp = strrchr(relpath, '-')) == NULL) { sliceno = 1; maxslice = 1; strcpy(pgxfiles[0], relpath); } else { strcpy(tmpdirpath, relpath); if ((tmp = strrchr(tmpdirpath, '/')) != NULL) { tmp++; *tmp = '\0'; strcpy(dirpath, tmpdirpath); } else { strcpy(dirpath, ""./""); } if ((tmp = strrchr(relpath, '/')) != NULL) { tmp++; } else { tmp = relpath; } if ((tmp2 = strrchr(tmp, '-')) != NULL) { *tmp2 = '\0'; } else { fprintf(stdout, ""[ERROR] tmp2 ha dado null. no ha encontrado el * %s %s"", tmp, relpath); return NULL; } strcpy(pattern, tmp); dirp = opendir(dirpath); if (dirp == NULL) { fprintf(stdout, ""[ERROR] Infile must be a .pgx file or a directory that contain pgx files""); return NULL; } while ((direntp = readdir(dirp)) != NULL) { if (strcmp(""."", direntp->d_name) == 0 || strcmp("".."", direntp->d_name) == 0) { continue; } if (((pgx = strstr(direntp->d_name, pattern)) != NULL) && ((tmp2 = strstr(direntp->d_name, "".pgx"")) != NULL)) { strcpy(tmp, dirpath); tmp = strcat(tmp, direntp->d_name); if ((tmp2 = strpbrk(direntp->d_name, ""0123456789"")) == NULL) { continue; } i = 0; while (tmp2 != NULL) { tmpno[i++] = *tmp2; point = tmp2; tmp2 = strpbrk(tmp2 + 1, ""0123456789""); } tmpno[i] = '\0'; if ((point = strpbrk(point, ""."")) == NULL) { break; } slicepos = atoi(tmpno); pgxslicepos[sliceno] = slicepos - 1; sliceno++; if (slicepos > maxslice) { maxslice = slicepos; } strcpy(pgxfiles[slicepos - 1], tmp); } } } if (!sliceno) { fprintf(stdout, ""[ERROR] No slices with this pattern founded !! Please check input volume name\n""); return NULL; } for (s = 0; s < sliceno; s++) { int pos = maxslice == sliceno ? s : pgxslicepos[s]; f = fopen(pgxfiles[pos], ""rb""); if (!f) { fprintf(stdout, ""[ERROR] Failed to open %s for reading !\n"", pgxfiles[s]); return NULL; } fprintf(stdout, ""[INFO] Loading %s \n"", pgxfiles[pos]); fseek(f, 0, SEEK_SET); fscanf(f, ""PG%[ \t]%c%c%[ \t+-]%d%[ \t]%d%[ \t]%d"", temp, &endian1, &endian2, signtmp, &prec, temp, &w, temp, &h); i = 0; sign = '+'; while (signtmp[i] != '\0') { if (signtmp[i] == '-') { sign = '-'; } i++; } fgetc(f); if (endian1 == 'M' && endian2 == 'L') { cmptparm.bigendian = 1; } else if (endian2 == 'M' && endian1 == 'L') { cmptparm.bigendian = 0; } else { fprintf(stdout, ""[ERROR] Bad pgx header, please check input file\n""); fclose(f); return NULL; } if (s == 0) { cmptparm.x0 = parameters->volume_offset_x0; cmptparm.y0 = parameters->volume_offset_y0; cmptparm.z0 = parameters->volume_offset_z0; cmptparm.w = !cmptparm.x0 ? (w - 1) * parameters->subsampling_dx + 1 : cmptparm.x0 + (w - 1) * parameters->subsampling_dx + 1; cmptparm.h = !cmptparm.y0 ? (h - 1) * parameters->subsampling_dy + 1 : cmptparm.y0 + (h - 1) * parameters->subsampling_dy + 1; cmptparm.l = !cmptparm.z0 ? (sliceno - 1) * parameters->subsampling_dz + 1 : cmptparm.z0 + (sliceno - 1) * parameters->subsampling_dz + 1; if (sign == '-') { cmptparm.sgnd = 1; } else { cmptparm.sgnd = 0; } cmptparm.prec = prec; cmptparm.bpp = prec; cmptparm.dcoffset = parameters->dcoffset; cmptparm.dx = parameters->subsampling_dx; cmptparm.dy = parameters->subsampling_dy; cmptparm.dz = parameters->subsampling_dz; volume = opj_volume_create(numcomps, &cmptparm, color_space); if (!volume) { fclose(f); return NULL; } volume->x0 = cmptparm.x0; volume->y0 = cmptparm.y0; volume->z0 = cmptparm.z0; volume->x1 = cmptparm.w; volume->y1 = cmptparm.h; volume->z1 = cmptparm.l; comp = &volume->comps[0]; } offset = w * h * s; for (i = 0; i < w * h; i++) { int v; if (comp->prec <= 8) { if (!comp->sgnd) { v = readuchar(f); } else { v = (char) readuchar(f); } } else if (comp->prec <= 16) { if (!comp->sgnd) { v = readushort(f, cmptparm.bigendian); } else { v = (short) readushort(f, cmptparm.bigendian); } } else { if (!comp->sgnd) { v = readuint(f, cmptparm.bigendian); } else { v = (int) readuint(f, cmptparm.bigendian); } } if (v > maxvalue) { maxvalue = v; } comp->data[i + offset] = v; } fclose(f); }  comp->bpp = int_floorlog2(maxvalue) + 1; if (sliceno != 1) { closedir(dirp); } return volume; }
Description: In OpenJPEG 2.3.0, a stack-based buffer overflow was discovered in the pgxtoimage function in jpwl/convert.c. The vulnerability causes an out-of-bounds write, which may lead to remote denial of service or possibly remote code execution.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static struct desc_struct *get_desc(unsigned short sel) { struct desc_ptr gdt_desc = {0, 0}; unsigned long desc_base; #ifdef CONFIG_MODIFY_LDT_SYSCALL if ((sel & SEGMENT_TI_MASK) == SEGMENT_LDT) { struct desc_struct *desc = NULL; struct ldt_struct *ldt; sel >>= 3; mutex_lock(&current->active_mm->context.lock); ldt = current->active_mm->context.ldt; if (ldt && sel < ldt->nr_entries) desc = &ldt->entries[sel]; mutex_unlock(&current->active_mm->context.lock); return desc; } #endif native_store_gdt(&gdt_desc); desc_base = sel & ~(SEGMENT_RPL_MASK | SEGMENT_TI_MASK); if (desc_base > gdt_desc.size) return NULL; return (struct desc_struct *)(gdt_desc.address + desc_base); }
Description: In arch/x86/lib/insn-eval.c in the Linux kernel before 5.1.9, there is a use-after-free for access to an LDT entry because of a race condition between modify_ldt() and a #BR exception for an MPX bounds violation.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int is_ref(const uint8_t *data, size_t beg, size_t end, size_t *last, struct link_ref **refs) { size_t i = 0; size_t id_offset, id_end; size_t link_offset, link_end; size_t title_offset, title_end; size_t line_end; if (beg + 3 >= end) return 0; if (data[beg] == ' ') { i = 1; if (data[beg + 1] == ' ') { i = 2; if (data[beg + 2] == ' ') { i = 3; if (data[beg + 3] == ' ') return 0; } } } i += beg; if (data[i] != '[') return 0; i++; id_offset = i; while (i < end && data[i] != '\n' && data[i] != '\r' && data[i] != ']') i++; if (i >= end || data[i] != ']') return 0; id_end = i; i++; if (i >= end || data[i] != ':') return 0; i++; while (i < end && data[i] == ' ') i++; if (i < end && (data[i] == '\n' || data[i] == '\r')) { i++; if (i < end && data[i] == '\r' && data[i - 1] == '\n') i++; } while (i < end && data[i] == ' ') i++; if (i >= end) return 0; if (data[i] == '<') i++; link_offset = i; while (i < end && data[i] != ' ' && data[i] != '\n' && data[i] != '\r') i++; if (data[i - 1] == '>') link_end = i - 1; else link_end = i; while (i < end && data[i] == ' ') i++; if (i < end && data[i] != '\n' && data[i] != '\r' && data[i] != '\'' && data[i] != '""' && data[i] != '(') return 0; line_end = 0; if (i >= end || data[i] == '\r' || data[i] == '\n') line_end = i; if (i + 1 < end && data[i] == '\n' && data[i + 1] == '\r') line_end = i + 1; if (line_end) { i = line_end + 1; while (i < end && data[i] == ' ') i++; } title_offset = title_end = 0; if (i + 1 < end && (data[i] == '\'' || data[i] == '""' || data[i] == '(')) { i++; title_offset = i; while (i < end && data[i] != '\n' && data[i] != '\r') i++; if (i + 1 < end && data[i] == '\n' && data[i + 1] == '\r') title_end = i + 1; elsetitle_end = i; i -= 1; while (i > title_offset && data[i] == ' ') i -= 1; if (i > title_offset && (data[i] == '\'' || data[i] == '""' || data[i] == ')')) { line_end = title_end; title_end = i; } } if (!line_end || link_end == link_offset) return 0;  if (last) *last = line_end; if (refs) { struct link_ref *ref; ref = add_link_ref(refs, data + id_offset, id_end - id_offset); if (!ref) return 0; ref->link = bufnew(link_end - link_offset); bufput(ref->link, data + link_offset, link_end - link_offset); if (title_end > title_offset) { ref->title = bufnew(title_end - title_offset); bufput(ref->title, data + title_offset, title_end - title_offset); } } return 1; }
Description: Snudown is a reddit-specific fork of the Sundown Markdown parser used by GitHub, with Python integration added. In affected versions snudown was found to be vulnerable to denial of service attacks to its reference table implementation. References written in markdown ` [reference_name]: https://www.example.com` are inserted into a hash table which was found to have a weak hash function, meaning that an attacker can reliably generate a large number of collisions for it. This makes the hash table vulnerable to a hash-collision DoS attack, a type of algorithmic complexity attack. Further the hash table allowed for duplicate entries resulting in long retrieval times. Proofs of concept and further discussion of the hash collision issue are discussed on the snudown GHSA(https://github.com/reddit/snudown/security/advisories/GHSA-6gvv-9q92-w5f6). Users are advised to update to version 1.7.0.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void OnPdfResourceIntercepted( const GURL& original_url, const content::ResourceRequestInfo::WebContentsGetter& web_contents_getter) { content::WebContents* web_contents = web_contents_getter.Run(); if (!web_contents) return; if (!WebContentsPreferences::IsPluginsEnabled(web_contents)) { auto browser_context = web_contents->GetBrowserContext(); auto download_manager = content::BrowserContext::GetDownloadManager(browser_context); download_manager->DownloadUrl( content::DownloadUrlParameters::CreateForWebContentsMainFrame( web_contents, original_url)); return; } content::NavigationController::LoadURLParams params( GURL(base::StringPrintf(""%sindex.html?%s=%s"", kPdfViewerUIOrigin, kPdfPluginSrc, net::EscapeUrlEncodedData(original_url.spec(), false).c_str()))); web_contents->GetController().LoadURLWithParams(params); }
Description: Github Electron version 1.6.4 - 1.6.11 and 1.7.0 - 1.7.5 is vulnerable to a URL Spoofing problem when opening PDFs in PDFium resulting loading arbitrary PDFs that a hacker can control.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void VvcUnitWithProfile::profile_tier_level(bool profileTierPresentFlag, int MaxNumSubLayersMinus1) { if (profileTierPresentFlag) { profile_idc = m_reader.getBits(7); bool tier_flag = m_reader.getBit(); } level_idc = m_reader.getBits(8); m_reader.skipBits(2);   if (profileTierPresentFlag) {                                   if (m_reader.getBit())          { m_reader.skipBits(32); m_reader.skipBits(32); m_reader.skipBits(7); m_reader.skipBits(m_reader.getBits(8));          } m_reader.skipBits(m_reader.getBitsLeft() % 8);      } std::vector<int> ptl_sublayer_level_present_flag; ptl_sublayer_level_present_flag.resize(MaxNumSubLayersMinus1); for (int i = MaxNumSubLayersMinus1 - 1; i >= 0; i--) ptl_sublayer_level_present_flag[i] = m_reader.getBit(); m_reader.skipBits(m_reader.getBitsLeft() % 8);   for (int i = MaxNumSubLayersMinus1 - 1; i >= 0; i--) if (ptl_sublayer_level_present_flag[i]) m_reader.skipBits(8);      if (profileTierPresentFlag) { int ptl_num_sub_profiles = m_reader.getBits(8); for (int i = 0; i < ptl_num_sub_profiles; i++) m_reader.skipBits(32);      } }
Description: There is an Assertion `num <= INT_BIT' failed at BitStreamReader::skipBits in /bitStream.h:132 of tsMuxer git-c6a0277.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int efi_capsule_release(struct inode *inode, struct file *file) { struct capsule_info *cap_info = file->private_data; kfree(cap_info->pages); kfree(cap_info->phys); kfree(file->private_data); file->private_data = NULL; return 0; }
Description: An issue was discovered in the Linux kernel through 5.19.8. drivers/firmware/efi/capsule-loader.c has a race condition with a resultant use-after-free.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int rtl8xxxu_submit_int_urb(struct ieee80211_hw *hw) { struct rtl8xxxu_priv *priv = hw->priv; struct urb *urb; u32 val32; int ret; urb = usb_alloc_urb(0, GFP_KERNEL); if (!urb) return -ENOMEM; usb_fill_int_urb(urb, priv->udev, priv->pipe_interrupt, priv->int_buf, USB_INTR_CONTENT_LENGTH, rtl8xxxu_int_complete, priv, 1); usb_anchor_urb(urb, &priv->int_anchor); ret = usb_submit_urb(urb, GFP_KERNEL); if (ret) { usb_unanchor_urb(urb); goto error; } val32 = rtl8xxxu_read32(priv, REG_USB_HIMR); val32 |= USB_HIMR_CPWM; rtl8xxxu_write32(priv, REG_USB_HIMR, val32); error: return ret; }
Description: A memory leak in the rtl8xxxu_submit_int_urb() function in drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering usb_submit_urb() failures, aka CID-a2cdd07488e6.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int im_vips2dz( IMAGE *in, const char *filename ) { char *p, *q; char name[FILENAME_MAX]; char mode[FILENAME_MAX]; char buf[FILENAME_MAX]; int i; VipsForeignDzLayout layout = VIPS_FOREIGN_DZ_LAYOUT_DZ;  char *suffix = "".jpeg""; int overlap = 0; int tile_size = 256; VipsForeignDzDepth depth = VIPS_FOREIGN_DZ_DEPTH_ONEPIXEL;  gboolean centre = FALSE; VipsAngle angle = VIPS_ANGLE_D0;  im_strncpy( name, filename, FILENAME_MAX );  if( (p = strchr( name, ':' )) ) { *p = '\0'; im_strncpy( mode, p + 1, FILENAME_MAX );  } strcpy( buf, mode );  p = &buf[0]; if( (q = im_getnextoption( &p )) ) { if( (i = vips_enum_from_nick( ""im_vips2dz"",  VIPS_TYPE_FOREIGN_DZ_LAYOUT, q )) < 0 )  return( -1 ); layout = i; } if( (q = im_getnextoption( &p )) )  suffix = g_strdup( q ); if( (q = im_getnextoption( &p )) )  overlap = atoi( q );  if( (q = im_getnextoption( &p )) )  tile_size = atoi( q );  if( (q = im_getnextoption( &p )) ) { if( (i = vips_enum_from_nick( ""im_vips2dz"",  VIPS_TYPE_FOREIGN_DZ_DEPTH, q )) < 0 ) return( -1 ); depth = i; } if( (q = im_getnextoption( &p )) ) { if( im_isprefix( ""cen"", q ) )  centre = TRUE; } if( (q = im_getnextoption( &p )) ) { if( (i = vips_enum_from_nick( ""im_vips2dz"",  VIPS_TYPE_ANGLE, q )) < 0 ) return( -1 ); angle = i; } if( vips_dzsave( in, name, ""layout"", layout, ""suffix"", suffix, ""overlap"", overlap, ""tile_size"", tile_size, ""depth"", depth, ""centre"", centre, ""angle"", angle, NULL ) ) return( -1 ); return( 0 ); }
Description: im_vips2dz in /libvips/libvips/deprecated/im_vips2dz.c in libvips before 8.8.2 has an uninitialized variable which may cause the leakage of remote server path or stack address.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int current_quote( oparg_T*oap, longcount, intinclude,    intquotechar){ char_u*line = ml_get_curline(); intcol_end; intcol_start = curwin->w_cursor.col; intinclusive = FALSE; intvis_empty = TRUE;    intvis_bef_curs = FALSE;    intdid_exclusive_adj = FALSE;      intinside_quotes = FALSE;    intselected_quote = FALSE;    inti; intrestore_vis_bef = FALSE;  if (VIsual_active) { if (VIsual.lnum != curwin->w_cursor.lnum) return FALSE; vis_bef_curs = LT_POS(VIsual, curwin->w_cursor); vis_empty = EQUAL_POS(VIsual, curwin->w_cursor); if (*p_sel == 'e') { if (vis_bef_curs) { dec_cursor(); did_exclusive_adj = TRUE; } else if (!vis_empty) { dec(&VIsual); did_exclusive_adj = TRUE; } vis_empty = EQUAL_POS(VIsual, curwin->w_cursor); if (!vis_bef_curs && !vis_empty) { pos_T t = curwin->w_cursor; curwin->w_cursor = VIsual; VIsual = t; vis_bef_curs = TRUE; restore_vis_bef = TRUE; } } } if (!vis_empty) { if (vis_bef_curs) { inside_quotes = VIsual.col > 0 && line[VIsual.col - 1] == quotechar && line[curwin->w_cursor.col] != NUL && line[curwin->w_cursor.col + 1] == quotechar; i = VIsual.col; col_end = curwin->w_cursor.col; } else { inside_quotes = curwin->w_cursor.col > 0 && line[curwin->w_cursor.col - 1] == quotechar && line[VIsual.col] != NUL && line[VIsual.col + 1] == quotechar; i = curwin->w_cursor.col; col_end = VIsual.col; } while (i <= col_end) if (line[i++] == quotechar) { selected_quote = TRUE; break; } } if (!vis_empty && line[col_start] == quotechar) { if (vis_bef_curs) { col_start = find_next_quote(line, col_start + 1, quotechar, NULL); if (col_start < 0) goto abort_search; col_end = find_next_quote(line, col_start + 1, quotechar, curbuf->b_p_qe); if (col_end < 0) { col_end = col_start; col_start = curwin->w_cursor.col; } } else { col_end = find_prev_quote(line, col_start, quotechar, NULL); if (line[col_end] != quotechar) goto abort_search; col_start = find_prev_quote(line, col_end, quotechar, curbuf->b_p_qe); if (line[col_start] != quotechar) { col_start = col_end; col_end = curwin->w_cursor.col; } } } else if (line[col_start] == quotechar || !vis_empty) { intfirst_col = col_start; if (!vis_empty) { if (vis_bef_curs) first_col = find_next_quote(line, col_start, quotechar, NULL); else first_col = find_prev_quote(line, col_start, quotechar, NULL); } col_start = 0; for (;;) { col_start = find_next_quote(line, col_start, quotechar, NULL); if (col_start < 0 || col_start > first_col) goto abort_search; col_end = find_next_quote(line, col_start + 1, quotechar, curbuf->b_p_qe); if (col_end < 0) goto abort_search; if (col_start <= first_col && first_col <= col_end) break; col_start = col_end + 1; } } else { col_start = find_prev_quote(line, col_start, quotechar, curbuf->b_p_qe); if (line[col_start] != quotechar) { col_start = find_next_quote(line, col_start, quotechar, NULL); if (col_start < 0) goto abort_search; } col_end = find_next_quote(line, col_start + 1, quotechar, curbuf->b_p_qe); if (col_end < 0) goto abort_search; } if (include) { if (VIM_ISWHITE(line[col_end + 1])) while (VIM_ISWHITE(line[col_end + 1])) ++col_end; else while (col_start > 0 && VIM_ISWHITE(line[col_start - 1])) --col_start; } if (!include && count < 2 && (vis_empty || !inside_quotes)) ++col_start; curwin->w_cursor.col = col_start; if (VIsual_active) { if (vis_empty || (vis_bef_curs && !selected_quote && (inside_quotes || (line[VIsual.col] != quotechar && (VIsual.col == 0 || line[VIsual.col - 1] != quotechar))))) { VIsual = curwin->w_cursor; redraw_curbuf_later(INVERTED); } } else { oap->start = curwin->w_cursor; oap->motion_type = MCHAR; } curwin->w_cursor.col = col_end; if ((include || count > 1 || (!vis_empty && inside_quotes) ) && inc_cursor() == 2) inclusive = TRUE; if (VIsual_active) { if (vis_empty || vis_bef_curs) { if (*p_sel != 'e') dec_cursor(); } else { if (inside_quotes || (!selected_quote && line[VIsual.col] != quotechar && (line[VIsual.col] == NUL || line[VIsual.col + 1] != quotechar))) { dec_cursor(); VIsual = curwin->w_cursor; } curwin->w_cursor.col = col_start; } if (VIsual_mode == 'V') { VIsual_mode = 'v'; redraw_cmdline = TRUE;} } else { oap->inclusive = inclusive; } return OK; abort_search: if (VIsual_active && *p_sel == 'e') { if (did_exclusive_adj) inc_cursor(); if (restore_vis_bef) { pos_T t = curwin->w_cursor; curwin->w_cursor = VIsual; VIsual = t; } } return FALSE; }
Description: Buffer Over-read in GitHub repository vim/vim prior to 8.2.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void gic_raise_inflight_irq(struct vcpu *v, unsigned int virtual_irq) { struct pending_irq *n = irq_to_pending(v, virtual_irq); if ( unlikely(!n) ) return; ASSERT(spin_is_locked(&v->arch.vgic.lock)); if ( list_empty(&n->lr_queue) ) { if ( v == current ) gic_update_one_lr(v, n->lr); } #ifdef GIC_DEBUG else gdprintk(XENLOG_DEBUG, ""trying to inject irq=%u into d%dv%d, when it is still lr_pending\n"", virtual_irq, v->domain->domain_id, v->vcpu_id); #endif }
Description: Xen through 4.8.x mishandles virtual interrupt injection, which allows guest OS users to cause a denial of service (hypervisor crash), aka XSA-223.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: XcursorComment * XcursorCommentCreate (XcursorUInt comment_type, int length) { XcursorComment  *comment; if (length > XCURSOR_COMMENT_MAX_LEN) return NULL; comment = malloc (sizeof (XcursorComment) + length + 1); if (!comment) return NULL; comment->version = XCURSOR_COMMENT_VERSION; comment->comment_type = comment_type; comment->comment = (char *) (comment + 1); comment->comment[0] = '\0'; return comment; }
Description: libXcursor before 1.1.15 has various integer overflows that could lead to heap buffer overflows when processing malicious cursors, e.g., with programs like GIMP. It is also possible that an attack vector exists against the related code in cursor/xcursor.c in Wayland through 1.14.0.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int update_discovery_filter(struct btd_adapter *adapter) { struct mgmt_cp_start_service_discovery *sd_cp; GSList *l; DBG(""""); if (discovery_filter_to_mgmt_cp(adapter, &sd_cp)) { btd_error(adapter->dev_id, ""discovery_filter_to_mgmt_cp returned error""); return -ENOMEM; } for (l = adapter->discovery_list; l; l = g_slist_next(l)) { struct discovery_client *client = l->data; if (!client->discovery_filter) continue; if (client->discovery_filter->discoverable) break; } set_discovery_discoverable(adapter, l ? true : false); if (filters_equal(adapter->current_discovery_filter, sd_cp) && adapter->discovering != 0) { DBG(""filters were equal, deciding to not restart the scan.""); g_free(sd_cp); return 0; } g_free(adapter->current_discovery_filter); adapter->current_discovery_filter = sd_cp; trigger_start_discovery(adapter, 0); return -EINPROGRESS; }
Description: bluetoothd from bluez incorrectly saves adapters' Discoverable status when a device is powered down, and restores it when powered up. If a device is powered down while discoverable, it will be discoverable when powered on again. This could lead to inadvertent exposure of the bluetooth stack to physically nearby attackers.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: ACPI_STATUS AcpiDsCreateOperands ( ACPI_WALK_STATE         *WalkState, ACPI_PARSE_OBJECT       *FirstArg) { ACPI_STATUS             Status = AE_OK; ACPI_PARSE_OBJECT       *Arg; ACPI_PARSE_OBJECT       *Arguments[ACPI_OBJ_NUM_OPERANDS]; UINT32                  ArgCount = 0; UINT32                  Index = WalkState->NumOperands; UINT32                  i; ACPI_FUNCTION_TRACE_PTR (DsCreateOperands, FirstArg); Arg = FirstArg; while (Arg) { if (Index >= ACPI_OBJ_NUM_OPERANDS) { return_ACPI_STATUS (AE_BAD_DATA); } Arguments[Index] = Arg; WalkState->Operands [Index] = NULL; Arg = Arg->Common.Next; ArgCount++; Index++; } ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, ""NumOperands %d, ArgCount %d, Index %d\n"", WalkState->NumOperands, ArgCount, Index)); Index--; for (i = 0; i < ArgCount; i++) { Arg = Arguments[Index]; WalkState->OperandIndex = (UINT8) Index; Status = AcpiDsCreateOperand (WalkState, Arg, Index); if (ACPI_FAILURE (Status)) { goto Cleanup; } ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, ""Created Arg #%u (%p) %u args total\n"", Index, Arg, ArgCount)); Index--; } return_ACPI_STATUS (Status); Cleanup: AcpiDsObjStackPopAndDelete (ArgCount, WalkState); ACPI_EXCEPTION ((AE_INFO, Status, ""While creating Arg %u"", Index)); return_ACPI_STATUS (Status); }
Description: The acpi_ds_create_operands() function in drivers/acpi/acpica/dsutils.c in the Linux kernel through 4.12.9 does not flush the operand cache and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int fuse_direntplus_link(struct file *file, struct fuse_direntplus *direntplus, u64 attr_version) { struct fuse_entry_out *o = &direntplus->entry_out; struct fuse_dirent *dirent = &direntplus->dirent; struct dentry *parent = file->f_path.dentry; struct qstr name = QSTR_INIT(dirent->name, dirent->namelen); struct dentry *dentry; struct dentry *alias; struct inode *dir = d_inode(parent); struct fuse_conn *fc; struct inode *inode; DECLARE_WAIT_QUEUE_HEAD_ONSTACK(wq); if (!o->nodeid) { return 0; } if (name.name[0] == '.') { if (name.len == 1) return 0; if (name.name[1] == '.' && name.len == 2) return 0; } if (invalid_nodeid(o->nodeid)) return -EIO; if (fuse_invalid_attr(&o->attr)) return -EIO; fc = get_fuse_conn(dir); name.hash = full_name_hash(parent, name.name, name.len); dentry = d_lookup(parent, &name); if (!dentry) { retry: dentry = d_alloc_parallel(parent, &name, &wq); if (IS_ERR(dentry)) return PTR_ERR(dentry); } if (!d_in_lookup(dentry)) { struct fuse_inode *fi; inode = d_inode(dentry); if (!inode || get_node_id(inode) != o->nodeid || ((o->attr.mode ^ inode->i_mode) & S_IFMT)) { d_invalidate(dentry); dput(dentry); goto retry; } if (is_bad_inode(inode)) { dput(dentry); return -EIO; } fi = get_fuse_inode(inode); spin_lock(&fi->lock); fi->nlookup++; spin_unlock(&fi->lock); forget_all_cached_acls(inode); fuse_change_attributes(inode, &o->attr, entry_attr_timeout(o), attr_version); } else { inode = fuse_iget(dir->i_sb, o->nodeid, o->generation, &o->attr, entry_attr_timeout(o), attr_version); if (!inode) inode = ERR_PTR(-ENOMEM); alias = d_splice_alias(inode, dentry); d_lookup_done(dentry); if (alias) { dput(dentry); dentry = alias; } if (IS_ERR(dentry)) return PTR_ERR(dentry); } if (fc->readdirplus_auto) set_bit(FUSE_I_INIT_RDPLUS, &get_fuse_inode(inode)->state); fuse_change_entry_timeout(dentry, o); dput(dentry); return 0; }
Description: An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void put_ucounts(struct ucounts *ucounts) { unsigned long flags; if (atomic_dec_and_test(&ucounts->count)) { spin_lock_irqsave(&ucounts_lock, flags); hlist_del_init(&ucounts->node); spin_unlock_irqrestore(&ucounts_lock, flags); kfree(ucounts); } }
Description: Race condition in kernel/ucount.c in the Linux kernel through 4.10.2 allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via crafted system calls that leverage certain decrement behavior that causes incorrect interaction between put_ucounts and get_ucounts.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void dwc2_handle_packet(DWC2State *s, uint32_t devadr, USBDevice *dev, USBEndpoint *ep, uint32_t index, bool send) { DWC2Packet *p; uint32_t hcchar = s->hreg1[index]; uint32_t hctsiz = s->hreg1[index + 4]; uint32_t hcdma = s->hreg1[index + 5]; uint32_t chan, epnum, epdir, eptype, mps, pid, pcnt, len, tlen, intr = 0; uint32_t tpcnt, stsidx, actual = 0; bool do_intr = false, done = false; epnum = get_field(hcchar, HCCHAR_EPNUM); epdir = get_bit(hcchar, HCCHAR_EPDIR); eptype = get_field(hcchar, HCCHAR_EPTYPE); mps = get_field(hcchar, HCCHAR_MPS); pid = get_field(hctsiz, TSIZ_SC_MC_PID); pcnt = get_field(hctsiz, TSIZ_PKTCNT); len = get_field(hctsiz, TSIZ_XFERSIZE); if (len > DWC2_MAX_XFER_SIZE) { qemu_log_mask(LOG_GUEST_ERROR, ""%s: HCTSIZ transfer size too large\n"", __func__); return; } chan = index >> 3; p = &s->packet[chan]; trace_usb_dwc2_handle_packet(chan, dev, &p->packet, epnum, types[eptype], dirs[epdir], mps, len, pcnt); if (eptype == USB_ENDPOINT_XFER_CONTROL && pid == TSIZ_SC_MC_PID_SETUP) { pid = USB_TOKEN_SETUP; } else { pid = epdir ? USB_TOKEN_IN : USB_TOKEN_OUT; } if (send) { tlen = len; if (p->small) { if (tlen > mps) { tlen = mps; } } if (pid != USB_TOKEN_IN) { trace_usb_dwc2_memory_read(hcdma, tlen); if (dma_memory_read(&s->dma_as, hcdma, s->usb_buf[chan], tlen) != MEMTX_OK) { qemu_log_mask(LOG_GUEST_ERROR, ""%s: dma_memory_read failed\n"", __func__); } } usb_packet_init(&p->packet); usb_packet_setup(&p->packet, pid, ep, 0, hcdma, pid != USB_TOKEN_IN, true); usb_packet_addbuf(&p->packet, s->usb_buf[chan], tlen); p->async = DWC2_ASYNC_NONE; usb_handle_packet(dev, &p->packet); } else { tlen = p->len; } stsidx = -p->packet.status; assert(stsidx < sizeof(pstatus) / sizeof(*pstatus)); actual = p->packet.actual_length; trace_usb_dwc2_packet_status(pstatus[stsidx], actual); babble: if (p->packet.status != USB_RET_SUCCESS && p->packet.status != USB_RET_NAK && p->packet.status != USB_RET_STALL && p->packet.status != USB_RET_ASYNC) { trace_usb_dwc2_packet_error(pstatus[stsidx]); } if (p->packet.status == USB_RET_ASYNC) { trace_usb_dwc2_async_packet(&p->packet, chan, dev, epnum, dirs[epdir], tlen); usb_device_flush_ep_queue(dev, ep); assert(p->async != DWC2_ASYNC_INFLIGHT); p->devadr = devadr; p->epnum = epnum; p->epdir = epdir; p->mps = mps; p->pid = pid; p->index = index; p->pcnt = pcnt; p->len = tlen; p->async = DWC2_ASYNC_INFLIGHT; p->needs_service = false; return; } if (p->packet.status == USB_RET_SUCCESS) { if (actual > tlen) { p->packet.status = USB_RET_BABBLE; goto babble; } if (pid == USB_TOKEN_IN) { trace_usb_dwc2_memory_write(hcdma, actual); if (dma_memory_write(&s->dma_as, hcdma, s->usb_buf[chan], actual) != MEMTX_OK) { qemu_log_mask(LOG_GUEST_ERROR, ""%s: dma_memory_write failed\n"", __func__); } } tpcnt = actual / mps; if (actual % mps) { tpcnt++; if (pid == USB_TOKEN_IN) { done = true; } } pcnt -= tpcnt < pcnt ? tpcnt : pcnt; set_field(&hctsiz, pcnt, TSIZ_PKTCNT); len -= actual < len ? actual : len; set_field(&hctsiz, len, TSIZ_XFERSIZE); s->hreg1[index + 4] = hctsiz; hcdma += actual; s->hreg1[index + 5] = hcdma; if (!pcnt || len == 0 || actual == 0) { done = true; } } else { intr |= pintr[stsidx]; if (p->packet.status == USB_RET_NAK && (eptype == USB_ENDPOINT_XFER_CONTROL || eptype == USB_ENDPOINT_XFER_BULK)) { intr &= ~HCINTMSK_RESERVED14_31; s->hreg1[index + 2] |= intr; do_intr = true; } else { intr |= HCINTMSK_CHHLTD; done = true; } } usb_packet_cleanup(&p->packet); if (done) { hcchar &= ~HCCHAR_CHENA; s->hreg1[index] = hcchar; if (!(intr & HCINTMSK_CHHLTD)) { intr |= HCINTMSK_CHHLTD | HCINTMSK_XFERCOMPL; } intr &= ~HCINTMSK_RESERVED14_31; s->hreg1[index + 2] |= intr; p->needs_service = false; trace_usb_dwc2_packet_done(pstatus[stsidx], actual, len, pcnt); dwc2_update_hc_irq(s, index); return; } p->devadr = devadr; p->epnum = epnum; p->epdir = epdir; p->mps = mps; p->pid = pid; p->index = index; p->pcnt = pcnt; p->len = len; p->needs_service = true; trace_usb_dwc2_packet_next(pstatus[stsidx], len, pcnt); if (do_intr) { dwc2_update_hc_irq(s, index); } }
Description: A divide-by-zero issue was found in dwc2_handle_packet in hw/usb/hcd-dwc2.c in the hcd-dwc2 USB host controller emulation of QEMU. A malicious guest could use this flaw to crash the QEMU process on the host, resulting in a denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool MessageReceiver::proc_Submsg_Heartbeat( CDRMessage_t* msg, SubmessageHeader_t* smh) const { eprosima::shared_lock<eprosima::shared_mutex> guard(mtx_); bool endiannessFlag = (smh->flags & BIT(0)) != 0; bool finalFlag = (smh->flags & BIT(1)) != 0; bool livelinessFlag = (smh->flags & BIT(2)) != 0; if (endiannessFlag) { msg->msg_endian = LITTLEEND; } else { msg->msg_endian = BIGEND; } GUID_t readerGUID; GUID_t writerGUID; readerGUID.guidPrefix = dest_guid_prefix_; CDRMessage::readEntityId(msg, &readerGUID.entityId); writerGUID.guidPrefix = source_guid_prefix_; CDRMessage::readEntityId(msg, &writerGUID.entityId); SequenceNumber_t firstSN; SequenceNumber_t lastSN; CDRMessage::readSequenceNumber(msg, &firstSN); CDRMessage::readSequenceNumber(msg, &lastSN); if (lastSN < firstSN && lastSN != firstSN - 1) { EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING ""Invalid Heartbeat received ("" << firstSN << "") - ("" << lastSN << ""), ignoring""); return false; } uint32_t HBCount; if (!CDRMessage::readUInt32(msg, &HBCount)) { EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING ""Unable to read heartbeat count from heartbeat message""); return false; } findAllReaders(readerGUID.entityId, [&writerGUID, &HBCount, &firstSN, &lastSN, finalFlag, livelinessFlag](RTPSReader* reader) { reader->processHeartbeatMsg(writerGUID, HBCount, firstSN, lastSN, finalFlag, livelinessFlag); }); return true; }
Description: eprosima Fast DDS is a C++ implementation of the Data Distribution Service standard of the Object Management Group. Prior to versions 2.9.1 and 2.6.5, improper validation of sequence numbers may lead to remotely reachable assertion failure. This can remotely crash any Fast-DDS process. Versions 2.9.1 and 2.6.5 contain a patch for this issue.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int          Read(void* pDestBuffer, int nSize) { if ( m_nPos + nSize >= m_nLen ) nSize = m_nLen - m_nPos - 1; memcpy( pDestBuffer, (m_sFile + m_nPos), nSize ); m_nPos += nSize; return nSize; }
Description: Onlyoffice Document Server v6.0.0 and below and Core 6.1.0.26 and below were discovered to contain a heap overflow via the component DesktopEditor/fontengine/fontconverter/FontFileBase.h.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int rsa_oaep_sha1_decrypt(const struct rsa_private_key *key, size_t label_length, const uint8_t *label, size_t *length, uint8_t *message, const mpz_t gibberish) { mpz_t m; int res; struct sha1_ctx ctx; mpz_init(m); rsa_compute_root(key, m, gibberish); res = pkcs1_oaep_decrypt (key->size, m, SHA1_DIGEST_SIZE, &ctx, &nettle_sha1, (nettle_hash_init_func*)&sha1_init, (nettle_hash_update_func*)&sha1_update, (nettle_hash_digest_func*)&sha1_digest, label_length, label, length, message); mpz_clear(m); return res; }
Description: Rhonabwy 0.9.99 through 1.1.x before 1.1.7 doesn't check the RSA private key length before RSA-OAEP decryption. This allows attackers to cause a Denial of Service via a crafted JWE (JSON Web Encryption) token.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static Sdb *store_versioninfo_gnu_verdef(ELFOBJ *bin, Elf_(Shdr) *shdr, int sz) { const char *section_name = """"; const char *link_section_name = """"; char *end = NULL; Elf_(Shdr) *link_shdr = NULL; ut8 dfs[sizeof (Elf_(Verdef))] = {0}; Sdb *sdb; int cnt, i; if (shdr->sh_link > bin->ehdr.e_shnum) { return false; } link_shdr = &bin->shdr[shdr->sh_link]; if (shdr->sh_size < 1) { return false; } Elf_(Verdef) *defs = calloc (shdr->sh_size, sizeof (char)); if (!defs) { return false; } if (bin->shstrtab && shdr->sh_name < bin->shstrtab_size) { section_name = &bin->shstrtab[shdr->sh_name]; } if (link_shdr && bin->shstrtab && link_shdr->sh_name < bin->shstrtab_size) { link_section_name = &bin->shstrtab[link_shdr->sh_name]; } if (!defs) { bprintf (""Warning: Cannot allocate memory (Check Elf_(Verdef))\n""); return NULL; } sdb = sdb_new0 (); end = (char *)defs + shdr->sh_size; sdb_set (sdb, ""section_name"", section_name, 0); sdb_num_set (sdb, ""entries"", shdr->sh_info, 0); sdb_num_set (sdb, ""addr"", shdr->sh_addr, 0); sdb_num_set (sdb, ""offset"", shdr->sh_offset, 0); sdb_num_set (sdb, ""link"", shdr->sh_link, 0); sdb_set (sdb, ""link_section_name"", link_section_name, 0); for (cnt = 0, i = 0; cnt < shdr->sh_info && ((char *)defs + i < end); ++cnt) { Sdb *sdb_verdef = sdb_new0 (); char *vstart = ((char*)defs) + i; char key[32] = {0}; Elf_(Verdef) *verdef = (Elf_(Verdef)*)vstart; Elf_(Verdaux) aux = {0}; int j = 0; int isum = 0; r_buf_read_at (bin->b, shdr->sh_offset + i, dfs, sizeof (Elf_(Verdef))); verdef->vd_version = READ16 (dfs, j) verdef->vd_flags = READ16 (dfs, j) verdef->vd_ndx = READ16 (dfs, j) verdef->vd_cnt = READ16 (dfs, j) verdef->vd_hash = READ32 (dfs, j) verdef->vd_aux = READ32 (dfs, j) verdef->vd_next = READ32 (dfs, j) vstart += verdef->vd_aux; if (vstart > end || vstart + sizeof (Elf_(Verdaux)) > end) { sdb_free (sdb_verdef); goto out_error; } j = 0; aux.vda_name = READ32 (vstart, j) aux.vda_next = READ32 (vstart, j) isum = i + verdef->vd_aux; if (aux.vda_name > bin->dynstr_size) { sdb_free (sdb_verdef); goto out_error; } sdb_num_set (sdb_verdef, ""idx"", i, 0); sdb_num_set (sdb_verdef, ""vd_version"", verdef->vd_version, 0); sdb_num_set (sdb_verdef, ""vd_ndx"", verdef->vd_ndx, 0); sdb_num_set (sdb_verdef, ""vd_cnt"", verdef->vd_cnt, 0); sdb_set (sdb_verdef, ""vda_name"", &bin->dynstr[aux.vda_name], 0); sdb_set (sdb_verdef, ""flags"", get_ver_flags (verdef->vd_flags), 0); for (j = 1; j < verdef->vd_cnt; ++j) { int k; Sdb *sdb_parent = sdb_new0 (); isum += aux.vda_next; vstart += aux.vda_next; if (vstart > end || vstart + sizeof(Elf_(Verdaux)) > end) { sdb_free (sdb_verdef); sdb_free (sdb_parent); goto out_error; } k = 0; aux.vda_name = READ32 (vstart, k) aux.vda_next = READ32 (vstart, k) if (aux.vda_name > bin->dynstr_size) { sdb_free (sdb_verdef); sdb_free (sdb_parent); goto out_error; } sdb_num_set (sdb_parent, ""idx"", isum, 0); sdb_num_set (sdb_parent, ""parent"", j, 0); sdb_set (sdb_parent, ""vda_name"", &bin->dynstr[aux.vda_name], 0); snprintf (key, sizeof (key), ""parent%d"", j - 1); sdb_ns_set (sdb_verdef, key, sdb_parent); } snprintf (key, sizeof (key), ""verdef%d"", cnt); sdb_ns_set (sdb, key, sdb_verdef); if (!verdef->vd_next) { sdb_free (sdb_verdef); goto out_error; } i += verdef->vd_next; }
Description: The store_versioninfo_gnu_verdef function in libr/bin/format/elf/elf.c in radare2 2.0.0 allows remote attackers to cause a denial of service (r_read_le16 invalid write and application crash) or possibly have unspecified other impact via a crafted ELF file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: unsigned int sudoers_lookup(struct sudo_nss_list *snl, struct sudoers_context *ctx, time_t now, sudoers_lookup_callback_fn_t callback, void *cb_data, int *cmnd_status, int pwflag) { struct defaults_list *defs = NULL; struct sudoers_parse_tree *parse_tree = NULL; struct cmndspec *cs = NULL; struct sudo_nss *nss; struct cmnd_info info; unsigned int validated = FLAG_NO_USER | FLAG_NO_HOST; int m, match = UNSPEC; debug_decl(sudoers_lookup, SUDOERS_DEBUG_PARSER); if (pwflag) { debug_return_uint(sudoers_lookup_pseudo(snl, ctx, now, callback, cb_data, pwflag)); } if (!set_perms(ctx, PERM_RUNAS)) debug_return_uint(validated); TAILQ_FOREACH(nss, snl, entries) { if (nss->query(ctx, nss, ctx->user.pw) == -1) { SET(validated, VALIDATE_ERROR); break; } m = sudoers_lookup_check(nss, ctx, &validated, &info, now, callback, cb_data, &cs, &defs); if (m != UNSPEC) { match = m; parse_tree = nss->parse_tree; } if (!sudo_nss_can_continue(nss, m)) break; } if (match != UNSPEC) { if (info.cmnd_path != NULL) { free(ctx->user.cmnd); ctx->user.cmnd = info.cmnd_path; if (ctx->user.cmnd_stat != NULL) *ctx->user.cmnd_stat = info.cmnd_stat; *cmnd_status = info.status; } if (defs != NULL) (void)update_defaults(ctx, parse_tree, defs, SETDEF_GENERIC, false); if (!apply_cmndspec(ctx, cs)) SET(validated, VALIDATE_ERROR); else if (match == ALLOW) SET(validated, VALIDATE_SUCCESS); else SET(validated, VALIDATE_FAILURE); } if (!restore_perms()) SET(validated, VALIDATE_ERROR); debug_return_uint(validated); }
Description: Sudo before 1.9.15 might allow row hammer attacks (for authentication bypass or privilege escalation) because application logic sometimes is based on not equaling an error value (instead of equaling a success value), and because the values do not resist flips of a single bit.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void scroll_cursor_bot(int min_scroll, int set_topbot) { intused; intscrolled = 0; intextra = 0; inti; linenr_Tline_count; linenr_Told_topline = curwin->w_topline; intold_skipcol = curwin->w_skipcol; lineoff_Tloff; lineoff_Tboff; #ifdef FEAT_DIFF intold_topfill = curwin->w_topfill; intfill_below_window; #endif linenr_Told_botline = curwin->w_botline; linenr_Told_valid = curwin->w_valid; intold_empty_rows = curwin->w_empty_rows; linenr_Tcln;        longso = get_scrolloff_value(); intdo_sms = curwin->w_p_wrap && curwin->w_p_sms; cln = curwin->w_cursor.lnum; if (set_topbot) { int set_skipcol = FALSE; used = 0; curwin->w_botline = cln + 1; #ifdef FEAT_DIFF loff.fill = 0; #endif for (curwin->w_topline = curwin->w_botline; curwin->w_topline > 1; curwin->w_topline = loff.lnum) { loff.lnum = curwin->w_topline; topline_back_winheight(&loff, FALSE); if (loff.height == MAXCOL) break; if (used + loff.height > curwin->w_height) { if (do_sms) { if (used < curwin->w_height) { int plines_offset = used + loff.height - curwin->w_height; used = curwin->w_height; #ifdef FEAT_DIFF curwin->w_topfill = loff.fill; #endif curwin->w_topline = loff.lnum; curwin->w_skipcol = skipcol_from_plines( curwin, plines_offset); set_skipcol = TRUE; } } break; } used += loff.height; #ifdef FEAT_DIFF curwin->w_topfill = loff.fill; #endif } set_empty_rows(curwin, used); curwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP; if (curwin->w_topline != old_topline #ifdef FEAT_DIFF || curwin->w_topfill != old_topfill #endif || set_skipcol || curwin->w_skipcol != 0) { curwin->w_valid &= ~(VALID_WROW|VALID_CROW); if (set_skipcol) redraw_later(UPD_NOT_VALID); else reset_skipcol(); } } else validate_botline(); #ifdef FEAT_DIFF used = plines_nofill(cln); #else validate_cheight(); used = curwin->w_cline_height; #endif if (cln >= curwin->w_botline) { scrolled = used; if (cln == curwin->w_botline) scrolled -= curwin->w_empty_rows; if (do_sms) { int top_plines = #ifdef FEAT_DIFF plines_win_nofill #else plines_win #endif (curwin, curwin->w_topline, FALSE); int skip_lines = 0; int width1 = curwin->w_width - curwin_col_off(); int width2 = width1 + curwin_col_off2(); if (curwin->w_skipcol > width1) skip_lines += (curwin->w_skipcol - width1) / width2 + 1; else if (curwin->w_skipcol > 0) skip_lines = 1; top_plines -= skip_lines; if (top_plines > curwin->w_height) { scrolled += (top_plines - curwin->w_height); } } } #ifdef FEAT_FOLDING if (!hasFolding(curwin->w_cursor.lnum, &loff.lnum, &boff.lnum)) #endif { loff.lnum = cln; boff.lnum = cln; } #ifdef FEAT_DIFF loff.fill = 0; boff.fill = 0; fill_below_window = diff_check_fill(curwin, curwin->w_botline) - curwin->w_filler_rows; #endif while (loff.lnum > 1) { if ((((scrolled <= 0 || scrolled >= min_scroll) && extra >= (mouse_dragging > 0 ? mouse_dragging - 1 : so)) || boff.lnum + 1 > curbuf->b_ml.ml_line_count) && loff.lnum <= curwin->w_botline #ifdef FEAT_DIFF && (loff.lnum < curwin->w_botline || loff.fill >= fill_below_window) #endif ) break; topline_back(&loff); if (loff.height == MAXCOL) used = MAXCOL; else used += loff.height; if (used > curwin->w_height) break; if (loff.lnum >= curwin->w_botline #ifdef FEAT_DIFF && (loff.lnum > curwin->w_botline || loff.fill <= fill_below_window) #endif ) { scrolled += loff.height; if (loff.lnum == curwin->w_botline #ifdef FEAT_DIFF && loff.fill == 0 #endif ) scrolled -= curwin->w_empty_rows; } if (boff.lnum < curbuf->b_ml.ml_line_count) { botline_forw(&boff); used += boff.height; if (used > curwin->w_height) break; if (extra < ( mouse_dragging > 0 ? mouse_dragging - 1 : so) || scrolled < min_scroll) { extra += boff.height; if (boff.lnum >= curwin->w_botline #ifdef FEAT_DIFF || (boff.lnum + 1 == curwin->w_botline && boff.fill > curwin->w_filler_rows) #endif ) { scrolled += boff.height; if (boff.lnum == curwin->w_botline #ifdef FEAT_DIFF && boff.fill == 0 #endif ) scrolled -= curwin->w_empty_rows; } } } } if (scrolled <= 0) line_count = 0; else if (used > curwin->w_height) line_count = used; else { line_count = 0; #ifdef FEAT_DIFF boff.fill = curwin->w_topfill; #endif boff.lnum = curwin->w_topline - 1; for (i = 0; i < scrolled && boff.lnum < curwin->w_botline; ) { botline_forw(&boff); i += boff.height; ++line_count; } if (i < scrolled)    line_count = 9999; } if (line_count >= curwin->w_height && line_count > min_scroll) scroll_cursor_halfway(FALSE, TRUE); else if (line_count > 0) { if (do_sms) scrollup(scrolled, TRUE);  else scrollup(line_count, TRUE); } if (curwin->w_topline == old_topline && curwin->w_skipcol == old_skipcol && set_topbot) { curwin->w_botline = old_botline; curwin->w_empty_rows = old_empty_rows; curwin->w_valid = old_valid; } curwin->w_valid |= VALID_TOPLINE; }
Description: Divide By Zero in vim/vim from 9.0.1367-1 to 9.0.1367-3

 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static port::StatusOr<CudnnRnnSequenceTensorDescriptor> Create( GpuExecutor* parent, int max_seq_length, int batch_size, int data_size, const absl::Span<const int>& seq_lengths, bool time_major, cudnnDataType_t data_type) { CHECK_GT(max_seq_length, 0); int dims[] = {batch_size, data_size, 1}; int strides[] = {dims[1] * dims[2], dims[2], 1}; TensorDescriptor tensor_desc = CreateTensorDescriptor(); RETURN_IF_CUDNN_ERROR(cudnnSetTensorNdDescriptor( tensor_desc.get(), data_type, sizeof(dims) / sizeof(dims[0]), dims, strides)); const int* seq_lengths_array = seq_lengths.data(); RNNDataDescriptor data_desc = CreateRNNDataDescriptor(); float padding_fill = 0.0f; cudnnRNNDataLayout_t layout; if (time_major) { layout = CUDNN_RNN_DATA_LAYOUT_SEQ_MAJOR_UNPACKED; } else { layout = CUDNN_RNN_DATA_LAYOUT_BATCH_MAJOR_UNPACKED; } RETURN_IF_CUDNN_ERROR(cudnnSetRNNDataDescriptor( data_desc.get(),  data_type, layout, max_seq_length, batch_size, data_size, seq_lengths_array, (void*)&padding_fill)); return CudnnRnnSequenceTensorDescriptor( parent, max_seq_length, batch_size, data_size, data_type, std::move(data_desc), std::move(tensor_desc)); }
Description: In affected versions of TensorFlow running an LSTM/GRU model where the LSTM/GRU layer receives an input with zero-length results in a CHECK failure when using the CUDA backend. This can result in a query-of-death vulnerability, via denial of service, if users can control the input to the layer. This is fixed in versions 1.15.5, 2.0.4, 2.1.3, 2.2.2, 2.3.2, and 2.4.0.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void tcp_internal_pacing(struct sock *sk, const struct sk_buff *skb) { u64 len_ns; u32 rate; if (!tcp_needs_internal_pacing(sk)) return; rate = sk->sk_pacing_rate; if (!rate || rate == ~0U) return; len_ns = (u64)skb->len * NSEC_PER_SEC; do_div(len_ns, rate); hrtimer_start(&tcp_sk(sk)->pacing_timer, ktime_add_ns(ktime_get(), len_ns), HRTIMER_MODE_ABS_PINNED_SOFT); sock_hold(sk); }
Description: An issue was discovered in the Linux Kernel from 4.18 to 4.19, an improper update of sock reference in TCP pacing can lead to memory/netns leak, which can be used by remote clients.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static ssize_t nbd_co_send_reply(NBDRequestData *req, NBDReply *reply, int len) { NBDClient *client = req->client; ssize_t rc, ret; g_assert(qemu_in_coroutine()); qemu_co_mutex_lock(&client->send_lock); client->send_coroutine = qemu_coroutine_self(); nbd_set_handlers(client); if (!len) { rc = nbd_send_reply(client->ioc, reply); } else { qio_channel_set_cork(client->ioc, true); rc = nbd_send_reply(client->ioc, reply); if (rc >= 0) { ret = write_sync(client->ioc, req->data, len); if (ret != len) { rc = -EIO; } } qio_channel_set_cork(client->ioc, false); } client->send_coroutine = NULL; nbd_set_handlers(client); qemu_co_mutex_unlock(&client->send_lock); return rc; }
Description: An assertion-failure flaw was found in Qemu before 2.10.1, in the Network Block Device (NBD) server's initial connection negotiation, where the I/O coroutine was undefined. This could crash the qemu-nbd server if a client sent unexpected data during connection negotiation. A remote user or process could use this flaw to crash the qemu-nbd server resulting in denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: H264SwDecRet H264SwDecInit(H264SwDecInst *decInst, u32 noOutputReordering) { u32 rv = 0; decContainer_t *pDecCont; DEC_API_TRC(""H264SwDecInit#""); if ( ((-1)>>1) != (-1) ) { DEC_API_TRC(""H264SwDecInit# ERROR: Right shift is not signed""); return(H264SWDEC_INITFAIL); } if (decInst == NULL) { DEC_API_TRC(""H264SwDecInit# ERROR: decInst == NULL""); return(H264SWDEC_PARAM_ERR); } pDecCont = (decContainer_t *)H264SwDecMalloc(sizeof(decContainer_t)); if (pDecCont == NULL) { DEC_API_TRC(""H264SwDecInit# ERROR: Memory allocation failed""); return(H264SWDEC_MEMFAIL); } #ifdef H264DEC_TRACE sprintf(pDecCont->str, ""H264SwDecInit# decInst %p noOutputReordering %d"", (void*)decInst, noOutputReordering); DEC_API_TRC(pDecCont->str); #endif rv = h264bsdInit(&pDecCont->storage, noOutputReordering); if (rv != HANTRO_OK) { H264SwDecRelease(pDecCont); return(H264SWDEC_MEMFAIL); } pDecCont->decStat  = INITIALIZED; pDecCont->picNumber = 0; #ifdef H264DEC_TRACE sprintf(pDecCont->str, ""H264SwDecInit# OK: return %p"", (void*)pDecCont); DEC_API_TRC(pDecCont->str); #endif *decInst = (decContainer_t *)pDecCont; return(H264SWDEC_OK); }
Description: Multiple integer overflows in the h264dec component in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allow remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file that triggers a large memory allocation, aka internal bug 27855419.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int relinquish_p2m_mapping(struct domain *d) { struct p2m_domain *p2m = p2m_get_hostp2m(d); unsigned long count = 0; p2m_type_t t; int rc = 0; unsigned int order; gfn_t start, end; p2m_write_lock(p2m); start = p2m->lowest_mapped_gfn; end = p2m->max_mapped_gfn; for ( ; gfn_x(start) < gfn_x(end); start = gfn_next_boundary(start, order) ) { mfn_t mfn = p2m_get_entry(p2m, start, &t, NULL, &order, NULL); count++; if ( !(count % 512) && hypercall_preempt_check() ) { rc = -ERESTART; break; } if ( !mfn_eq(mfn, INVALID_MFN) ) { rc = __p2m_set_entry(p2m, start, order, INVALID_MFN, p2m_invalid, p2m_access_rwx); if ( unlikely(rc) ) { printk(XENLOG_G_ERR ""Unable to remove mapping gfn=%#""PRI_gfn"" order=%u from the p2m of domain %d\n"", gfn_x(start), order, d->domain_id); break; } } } p2m->lowest_mapped_gfn = start; p2m_write_unlock(p2m); return rc; }
Description: An issue was discovered in Xen through 4.12.x allowing ARM guest OS users to cause a denial of service via a XENMEM_add_to_physmap hypercall. p2m->max_mapped_gfn is used by the functions p2m_resolve_translation_fault() and p2m_get_entry() to sanity check guest physical frame. The rest of the code in the two functions will assume that there is a valid root table and check that with BUG_ON(). The function p2m_get_root_pointer() will ignore the unused top bits of a guest physical frame. This means that the function p2m_set_entry() will alias the frame. However, p2m->max_mapped_gfn will be updated using the original frame. It would be possible to set p2m->max_mapped_gfn high enough to cover a frame that would lead p2m_get_root_pointer() to return NULL in p2m_get_entry() and p2m_resolve_translation_fault(). Additionally, the sanity check on p2m->max_mapped_gfn is off-by-one allowing ""highest mapped + 1"" to be considered valid. However, p2m_get_root_pointer() will return NULL. The problem could be triggered with a specially crafted hypercall XENMEM_add_to_physmap{, _batch} followed by an access to an address (via hypercall or direct access) that passes the sanity check but cause p2m_get_root_pointer() to return NULL. A malicious guest administrator may cause a hypervisor crash, resulting in a Denial of Service (DoS). Xen version 4.8 and newer are vulnerable. Only Arm systems are vulnerable. x86 systems are not affected.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) { const Tensor first_partition_tensor = context->input(kFirstPartitionInputIndex); const RowPartitionType first_partition_type = row_partition_types_[0]; switch (first_partition_type) { case RowPartitionType::FIRST_DIM_SIZE: *result = first_partition_tensor.scalar<INDEX_TYPE>()(); return Status::OK(); case RowPartitionType::VALUE_ROWIDS: return errors::InvalidArgument( ""Cannot handle VALUE_ROWIDS in first dimension.""); case RowPartitionType::ROW_SPLITS: *result = first_partition_tensor.shape().dim_size(0) - 1; return Status::OK(); default: return errors::InvalidArgument( ""Cannot handle type "", RowPartitionTypeToString(first_partition_type)); } }
Description: TensorFlow is an end-to-end open source platform for machine learning. Sending invalid argument for `row_partition_types` of `tf.raw_ops.RaggedTensorToTensor` API results in a null pointer dereference and undefined behavior. The [implementation](https://github.com/tensorflow/tensorflow/blob/47a06f40411a69c99f381495f490536972152ac0/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L328) accesses the first element of a user supplied list of values without validating that the provided list is not empty. We have patched the issue in GitHub commit 301ae88b331d37a2a16159b65b255f4f9eb39314. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int OJPEGDecode(TIFF* tif, uint8* buf, tmsize_t cc, uint16 s) { OJPEGState* sp=(OJPEGState*)tif->tif_data; (void)s; if (sp->libjpeg_jpeg_query_style==0) { if (OJPEGDecodeRaw(tif,buf,cc)==0) return(0); } else { if (OJPEGDecodeScanlines(tif,buf,cc)==0) return(0); } return(1); }
Description: LibTIFF 4.0.7 allows remote attackers to cause a denial of service (divide-by-zero error and application crash) via a crafted TIFF image, related to libtiff/tif_ojpeg.c:816:8.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static gint dissect_wccp2_alternate_mask_value_set_list(tvbuff_t *tvb, int offset, int length, packet_info *pinfo, proto_tree *info_tree, wccp_address_table* addr_table) { proto_tree *list_tree; guint num_of_val_elements; guint i; if (length < 4) return length - 4; list_tree = proto_tree_add_subtree(info_tree, tvb, offset, length, ett_alternate_mask_value_set, NULL, ""Alternate Mask/Value Set List""); num_of_val_elements = tvb_get_ntohl(tvb, offset); proto_tree_add_uint(list_tree, hf_alt_assignment_mask_value_set_list_num_elements, tvb, offset, 4, num_of_val_elements); EAT(4); for(i=0;i<num_of_val_elements;i++) { gint new_length; new_length=dissect_wccp2_alternate_mask_value_set_element(tvb, offset, length, i, pinfo, list_tree, addr_table); NOTE_EATEN_LENGTH(new_length); } return length; }
Description: In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-wccp.c had a large loop that was addressed by ensuring that a calculated length was monotonically increasing.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int add_uint_string(proto_tree *tree, int hf_string, tvbuff_t *tvb, int offset) { proto_item* ti; int length; ti = proto_tree_add_item(tree, hf_string, tvb, offset, 4, ENC_ASCII|ENC_BIG_ENDIAN); length = dword_align(tvb_get_ntohl(tvb, offset))+4; proto_item_set_len(ti, length); int ret_offset = offset + length; if (length < 4 || ret_offset < offset) { expert_add_info_format(NULL, ti, &ei_gdsdb_invalid_length, ""Invalid length: %d"", length); return tvb_reported_length_remaining(tvb, offset); } return ret_offset; }
Description: GDSDB infinite loop in Wireshark 4.0.0 to 4.0.5 and 3.6.0 to 3.6.13 allows denial of service via packet injection or crafted capture file
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int io_rw_init_file(struct io_kiocb *req, fmode_t mode) { struct kiocb *kiocb = &req->rw.kiocb; struct io_ring_ctx *ctx = req->ctx; struct file *file = req->file; int ret; if (unlikely(!file || !(file->f_mode & mode))) return -EBADF; if (!io_req_ffs_set(req)) req->flags |= io_file_get_flags(file) << REQ_F_SUPPORT_NOWAIT_BIT; kiocb->ki_flags = iocb_flags(file); ret = kiocb_set_rw_flags(kiocb, req->rw.flags); if (unlikely(ret)) return ret; if ((kiocb->ki_flags & IOCB_NOWAIT) || ((file->f_flags & O_NONBLOCK) && !io_file_supports_nowait(req))) req->flags |= REQ_F_NOWAIT; if (ctx->flags & IORING_SETUP_IOPOLL) { if (!(kiocb->ki_flags & IOCB_DIRECT) || !file->f_op->iopoll) return -EOPNOTSUPP; kiocb->ki_flags |= IOCB_HIPRI | IOCB_ALLOC_CACHE; kiocb->ki_complete = io_complete_rw_iopoll; req->iopoll_completed = 0; } else { if (kiocb->ki_flags & IOCB_HIPRI) return -EINVAL; kiocb->ki_complete = io_complete_rw; } return 0; }
Description: An issue was discovered in the Linux kernel through 5.17.5. io_rw_init_file in fs/io_uring.c lacks initialization of kiocb->private.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: AP4_StszAtom::AP4_StszAtom(AP4_UI32        size,  AP4_UI08        version, AP4_UI32        flags, AP4_ByteStream& stream) : AP4_Atom(AP4_ATOM_TYPE_STSZ, size, version, flags) { stream.ReadUI32(m_SampleSize); stream.ReadUI32(m_SampleCount); if (m_SampleSize == 0) {                 if (m_SampleCount > (size-8)/4) { m_SampleCount = 0; return; } AP4_Cardinal sample_count = m_SampleCount; m_Entries.SetItemCount(sample_count); unsigned char* buffer = new unsigned char[sample_count*4]; AP4_Result result = stream.Read(buffer, sample_count*4); if (AP4_FAILED(result)) { delete[] buffer; m_Entries.Clear(); m_SampleCount = 0; return; } for (unsigned int i=0; i<sample_count; i++) { m_Entries[i] = AP4_BytesToUInt32BE(&buffer[i*4]); } delete[] buffer; } }
Description: An issue was discovered in Bento4 version 06c39d9. A NULL pointer dereference exists in the AP4_Stz2Atom::GetSampleSize component located in /Core/Ap4Stz2Atom.cpp. It allows an attacker to cause a denial of service (DOS).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void __detach_mounts(struct dentry *dentry) { struct mountpoint *mp; struct mount *mnt; namespace_lock(); mp = lookup_mountpoint(dentry); if (!mp) goto out_unlock; lock_mount_hash(); while (!hlist_empty(&mp->m_list)) { mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list); umount_tree(mnt, 0); } unlock_mount_hash(); put_mountpoint(mp); out_unlock: namespace_unlock(); }
Description: fs/namespace.c in the Linux kernel before 4.0.2 processes MNT_DETACH umount2 system calls without verifying that the MNT_LOCKED flag is unset, which allows local users to bypass intended access restrictions and navigate to filesystem locations beneath a mount by calling umount2 within a user namespace.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int map_vcpu_info(struct vcpu *v, unsigned long gfn, unsigned offset) { struct domain *d = v->domain; void *mapping; vcpu_info_t *new_info; struct page_info *page; if ( offset > (PAGE_SIZE - sizeof(vcpu_info_t)) ) return -EINVAL; if ( !mfn_eq(v->vcpu_info_mfn, INVALID_MFN) ) return -EINVAL; if ( (v != current) && !(v->pause_flags & VPF_down) ) return -EINVAL; page = get_page_from_gfn(d, gfn, NULL, P2M_ALLOC); if ( !page ) return -EINVAL; if ( !get_page_type(page, PGT_writable_page) ) { put_page(page); return -EINVAL; } mapping = __map_domain_page_global(page); if ( mapping == NULL ) { put_page_and_type(page); return -ENOMEM; } new_info = (vcpu_info_t *)(mapping + offset); if ( v->vcpu_info == &dummy_vcpu_info ) { memset(new_info, 0, sizeof(*new_info)); #ifdef XEN_HAVE_PV_UPCALL_MASK __vcpu_info(v, new_info, evtchn_upcall_mask) = 1; #endif } else { memcpy(new_info, v->vcpu_info, sizeof(*new_info)); } v->vcpu_info = new_info; v->vcpu_info_mfn = page_to_mfn(page); smp_wmb(); #ifdef CONFIG_COMPAT if ( !has_32bit_shinfo(d) ) write_atomic(&new_info->native.evtchn_pending_sel, ~0); else #endif write_atomic(&vcpu_info(v, evtchn_pending_sel), ~0); vcpu_mark_events_pending(v); return 0; }
Description: An issue was discovered in Xen through 4.13.x, allowing Arm guest OS users to cause a hypervisor crash because of a missing alignment check in VCPUOP_register_vcpu_info. The hypercall VCPUOP_register_vcpu_info is used by a guest to register a shared region with the hypervisor. The region will be mapped into Xen address space so it can be directly accessed. On Arm, the region is accessed with instructions that require a specific alignment. Unfortunately, there is no check that the address provided by the guest will be correctly aligned. As a result, a malicious guest could cause a hypervisor crash by passing a misaligned address. A malicious guest administrator may cause a hypervisor crash, resulting in a Denial of Service (DoS). All Xen versions are vulnerable. Only Arm systems are vulnerable. x86 systems are not affected.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static bool inferUnaryArith(UnaryOperatorInst *UOI, Type numberResultType) { Value *op = UOI->getSingleOperand(); if (op->getType().isNumberType()) { UOI->setType(numberResultType); return true; } if (op->getType().isBigIntType()) { UOI->setType(Type::createBigInt()); return true; } Type mayBeBigInt = op->getType().canBeBigInt() ? Type::createBigInt() : Type::createNoType(); UOI->setType(Type::unionTy(numberResultType, mayBeBigInt)); return true; }
Description: A type confusion bug in TypedArray prior to commit e6ed9c1a4b02dc219de1648f44cd808a56171b81 could have been used by a malicious attacker to execute arbitrary code via untrusted JavaScript. Note that this is only exploitable in cases where Hermes is used to execute untrusted JavaScript. Hence, most React Native applications are not affected.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: unsigned int arpt_do_table(struct sk_buff *skb, const struct nf_hook_state *state, struct xt_table *table) { unsigned int hook = state->hook; static const char nulldevname[IFNAMSIZ] __attribute__((aligned(sizeof(long)))); unsigned int verdict = NF_DROP; const struct arphdr *arp; struct arpt_entry *e, **jumpstack; const char *indev, *outdev; const void *table_base; unsigned int cpu, stackidx = 0; const struct xt_table_info *private; struct xt_action_param acpar; unsigned int addend; if (!pskb_may_pull(skb, arp_hdr_len(skb->dev))) return NF_DROP; indev = state->in ? state->in->name : nulldevname; outdev = state->out ? state->out->name : nulldevname; local_bh_disable(); addend = xt_write_recseq_begin(); private = READ_ONCE(table->private);  cpu     = smp_processor_id(); table_base = private->entries; jumpstack  = (struct arpt_entry **)private->jumpstack[cpu]; e = get_entry(table_base, private->hook_entry[hook]); acpar.state   = state; acpar.hotdrop = false; arp = arp_hdr(skb); do { const struct xt_entry_target *t; struct xt_counters *counter; if (!arp_packet_match(arp, skb->dev, indev, outdev, &e->arp)) { e = arpt_next_entry(e); continue; } counter = xt_get_this_cpu_counter(&e->counters); ADD_COUNTER(*counter, arp_hdr_len(skb->dev), 1); t = arpt_get_target_c(e); if (!t->u.kernel.target->target) { int v; v = ((struct xt_standard_target *)t)->verdict; if (v < 0) { if (v != XT_RETURN) { verdict = (unsigned int)(-v) - 1; break; } if (stackidx == 0) { e = get_entry(table_base, private->underflow[hook]); } else { e = jumpstack[--stackidx]; e = arpt_next_entry(e); } continue; } if (table_base + v != arpt_next_entry(e)) { if (unlikely(stackidx >= private->stacksize)) { verdict = NF_DROP; break; } jumpstack[stackidx++] = e; } e = get_entry(table_base, v); continue; } acpar.target   = t->u.kernel.target; acpar.targinfo = t->data; verdict = t->u.kernel.target->target(skb, &acpar); if (verdict == XT_CONTINUE) { arp = arp_hdr(skb); e = arpt_next_entry(e); } else { break; } } while (!acpar.hotdrop); xt_write_recseq_end(addend); local_bh_enable(); if (acpar.hotdrop) return NF_DROP; else return verdict; }
Description: An issue was discovered in netfilter in the Linux kernel before 5.10. There can be a use-after-free in the packet processing context, because the per-CPU sequence count is mishandled during concurrent iptables rules replacement. This could be exploited with the CAP_NET_ADMIN capability in an unprivileged namespace. NOTE: cc00bca was reverted in 5.12.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static VALUE from_document(VALUE klass, VALUE document) { xmlDocPtr doc; xmlSchemaParserCtxtPtr ctx; xmlSchemaPtr schema; VALUE errors; VALUE rb_schema; Data_Get_Struct(document, xmlDoc, doc); doc = doc->doc; if (has_blank_nodes_p(DOC_NODE_CACHE(doc))) { rb_raise(rb_eArgError, ""Creating a schema from a document that has blank nodes exposed to Ruby is dangerous""); } ctx = xmlSchemaNewDocParserCtxt(doc); errors = rb_ary_new(); xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher); #ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS xmlSchemaSetParserStructuredErrors( ctx, Nokogiri_error_array_pusher, (void *)errors ); #endif schema = xmlSchemaParse(ctx); xmlSetStructuredErrorFunc(NULL, NULL); xmlSchemaFreeParserCtxt(ctx); if(NULL == schema) { xmlErrorPtr error = xmlGetLastError(); if(error) Nokogiri_error_raise(NULL, error); else rb_raise(rb_eRuntimeError, ""Could not parse document""); return Qnil; } rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema); rb_iv_set(rb_schema, ""@errors"", errors); return rb_schema; return Qnil; }
Description: Nokogiri is a Rubygem providing HTML, XML, SAX, and Reader parsers with XPath and CSS selector support. In Nokogiri before version 1.11.0.rc4 there is an XXE vulnerability. XML Schemas parsed by Nokogiri::XML::Schema are trusted by default, allowing external resources to be accessed over the network, potentially enabling XXE or SSRF attacks. This behavior is counter to the security policy followed by Nokogiri maintainers, which is to treat all input as untrusted by default whenever possible. This is fixed in Nokogiri version 1.11.0.rc4.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool HHVM_FUNCTION(mb_parse_str, const String& encoded_string, VRefParam result ) { php_mb_encoding_handler_info_t info; info.data_type              = PARSE_STRING; info.separator              = "";&""; info.force_register_globals = false; info.report_errors          = 1; info.to_encoding            = MBSTRG(current_internal_encoding); info.to_language            = MBSTRG(current_language); info.from_encodings         = MBSTRG(http_input_list); info.num_from_encodings     = MBSTRG(http_input_list_size); info.from_language          = MBSTRG(current_language); char *encstr = strndup(encoded_string.data(), encoded_string.size()); Array resultArr = Array::Create(); mbfl_encoding *detected = _php_mb_encoding_handler_ex(&info, resultArr, encstr); free(encstr); result.assignIfRef(resultArr); MBSTRG(http_input_identify) = detected; return detected != nullptr; }
Description: Out-of-bounds write in the (1) mb_detect_encoding, (2) mb_send_mail, and (3) mb_detect_order functions in Facebook HHVM before 3.15.0 allows attackers to have unspecified impact via unknown vectors.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int read_header(AVFormatContext *s) { WtvContext *wtv = s->priv_data; unsigned root_sector; int root_size; uint8_t root[WTV_SECTOR_SIZE]; AVIOContext *pb; int64_t timeline_pos; int64_t ret; wtv->epoch          = wtv->pts            = wtv->last_valid_pts = AV_NOPTS_VALUE; avio_skip(s->pb, 0x30); root_size = avio_rl32(s->pb); if (root_size > sizeof(root)) { av_log(s, AV_LOG_ERROR, ""root directory size exceeds sector size\n""); return AVERROR_INVALIDDATA; } avio_skip(s->pb, 4); root_sector = avio_rl32(s->pb); ret = seek_by_sector(s->pb, root_sector, 0); if (ret < 0) return ret; root_size = avio_read(s->pb, root, root_size); if (root_size < 0) return AVERROR_INVALIDDATA; wtv->pb = wtvfile_open(s, root, root_size, ff_timeline_le16); if (!wtv->pb) { av_log(s, AV_LOG_ERROR, ""timeline data missing\n""); return AVERROR_INVALIDDATA; } ret = parse_chunks(s, SEEK_TO_DATA, 0, 0); if (ret < 0) return ret; avio_seek(wtv->pb, -32, SEEK_CUR); timeline_pos = avio_tell(s->pb);  pb = wtvfile_open(s, root, root_size, ff_table_0_entries_legacy_attrib_le16); if (pb) { parse_legacy_attrib(s, pb); wtvfile_close(pb); } s->ctx_flags |= AVFMTCTX_NOHEADER;  if (s->nb_streams) { AVStream *st = s->streams[0]; pb = wtvfile_open(s, root, root_size, ff_table_0_entries_time_le16); if (pb) { while(1) { uint64_t timestamp = avio_rl64(pb); uint64_t frame_nb  = avio_rl64(pb); if (avio_feof(pb)) break; ff_add_index_entry(&wtv->index_entries, &wtv->nb_index_entries, &wtv->index_entries_allocated_size, 0, timestamp, frame_nb, 0, AVINDEX_KEYFRAME); } wtvfile_close(pb); if (wtv->nb_index_entries) { pb = wtvfile_open(s, root, root_size, ff_timeline_table_0_entries_Events_le16); if (pb) { AVIndexEntry *e = wtv->index_entries; AVIndexEntry *e_end = wtv->index_entries + wtv->nb_index_entries - 1; uint64_t last_position = 0; while (1) { uint64_t frame_nb = avio_rl64(pb); uint64_t position = avio_rl64(pb); while (e <= e_end && frame_nb > e->size) { e->pos = last_position; e++; } if (avio_feof(pb)) break; last_position = position; } e_end->pos = last_position; wtvfile_close(pb); st->duration = e_end->timestamp; } } } } avio_seek(s->pb, timeline_pos, SEEK_SET); return 0; }
Description: A Denial of Service vulnerability exists in FFmpeg 4.2 due to a memory leak in the wtvfile_open_sector function in wtvdec.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static uint64_t pac_sub(uint64_t i) { static const uint8_t sub[16] = { 0xb, 0x6, 0x8, 0xf, 0xc, 0x0, 0x9, 0xe, 0x3, 0x7, 0x4, 0x5, 0xd, 0x2, 0x1, 0xa, }; uint64_t o = 0; int b; for (b = 0; b < 64; b += 16) { o |= (uint64_t)sub[(i >> b) & 0xf] << b; } return o; }
Description: A flaw was found in QEMU in the implementation of the Pointer Authentication (PAuth) support for ARM introduced in version 4.0 and fixed in version 5.0.0. A general failure of the signature generation process caused every PAuth-enforced pointer to be signed with the same signature. A local attacker could obtain the signature of a protected pointer and abuse this flaw to bypass PAuth protection for all programs running on QEMU.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void usbredir_handle_interrupt_out_data(USBRedirDevice *dev, USBPacket *p, uint8_t ep) { struct usb_redir_interrupt_packet_header interrupt_packet; uint8_t buf[p->iov.size]; DPRINTF(""interrupt-out ep %02X len %zd id %""PRIu64""\n"", ep, p->iov.size, p->id); interrupt_packet.endpoint  = ep; interrupt_packet.length    = p->iov.size; usb_packet_copy(p, buf, p->iov.size); usbredir_log_data(dev, ""interrupt data out:"", buf, p->iov.size); usbredirparser_send_interrupt_packet(dev->parser, p->id, &interrupt_packet, buf, p->iov.size); usbredirparser_do_write(dev->parser); }
Description: A flaw was found in the USB redirector device (usb-redir) of QEMU. Small USB packets are combined into a single, large transfer request, to reduce the overhead and improve performance. The combined size of the bulk transfer is used to dynamically allocate a variable length array (VLA) on the stack without proper validation. Since the total size is not bounded, a malicious guest could use this flaw to influence the array length and cause the QEMU process to perform an excessive allocation on the stack, resulting in a denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool_pdfioTokenGet(_pdfio_token_t *tb,       char           *buffer,       size_t         bufsize){ if (tb->num_tokens > 0) { tb->num_tokens --; strncpy(buffer, tb->tokens[tb->num_tokens], bufsize - 1); buffer[bufsize - 1] = '\0'; PDFIO_DEBUG(""_pdfioTokenGet(tb=%p, buffer=%p, bufsize=%u): Popping '%s' from stack.\n"", tb, buffer, (unsigned)bufsize, buffer); free(tb->tokens[tb->num_tokens]); tb->tokens[tb->num_tokens] = NULL; return (true); } return (_pdfioTokenRead(tb, buffer, bufsize)); }
Description:  PDFio is a C library for reading and writing PDF files. In versions prior to 1.1.0 a denial of service (DOS) vulnerability exists in the pdfio parser. Crafted pdf files can cause the program to run at 100% utilization and never terminate. The pdf which causes this crash found in testing is about 28kb in size and was discovered via fuzzing. Anyone who uses this library either as a standalone binary or as a library can be DOSed when attempting to parse this type of file. Web servers or other automated processes which rely on this code to turn pdf submissions into plaintext can be DOSed when an attacker uploads the pdf. Please see the linked GHSA for an example pdf. Users are advised to upgrade. There are no known workarounds for this vulnerability.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int enc_untrusted_inet_pton(int af, const char *src, void *dst) { if (!src || !dst) { return 0; } MessageWriter input; input.Push<int>(TokLinuxAfFamily(af)); input.PushByReference(Extent{ src, std::min(strlen(src) + 1, static_cast<size_t>(INET6_ADDRSTRLEN))}); MessageReader output; const auto status = NonSystemCallDispatcher( ::asylo::host_call::kInetPtonHandler, &input, &output); CheckStatusAndParamCount(status, output, ""enc_untrusted_inet_pton"", 3); int result = output.next<int>(); int klinux_errno = output.next<int>(); if (result == -1) { errno = FromkLinuxErrorNumber(klinux_errno); return -1; } auto klinux_addr_buffer = output.next(); size_t max_size = 0; if (af == AF_INET) { max_size = sizeof(struct in_addr); } else if (af == AF_INET6) { max_size = sizeof(struct in6_addr); } memcpy(dst, klinux_addr_buffer.data(), std::min(klinux_addr_buffer.size(), max_size)); return result; }
Description: An arbitrary memory read vulnerability in Asylo versions up to 0.6.0 allows an untrusted attacker to make a call to enc_untrusted_inet_pton using an attacker controlled klinux_addr_buffer parameter. The parameter size is unchecked allowing the attacker to read memory locations outside of the intended buffer size including memory addresses within the secure enclave. We recommend upgrading past commit 8fed5e334131abaf9c5e17307642fbf6ce4a57ec
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int flb_gzip_compress(void *in_data, size_t in_len, void **out_data, size_t *out_len) { int flush; int status; int footer_start; uint8_t *pb; size_t out_size; void *out_buf; z_stream strm; mz_ulong crc; out_size = in_len + 32; out_buf = flb_malloc(out_size); if (!out_buf) { flb_errno(); flb_error(""[gzip] could not allocate outgoing buffer""); return -1; } memset(&strm, '\0', sizeof(strm)); strm.zalloc    = Z_NULL; strm.zfree     = Z_NULL; strm.opaque    = Z_NULL; strm.next_in   = in_data; strm.avail_in  = in_len; strm.total_out = 0; deflateInit2(&strm, Z_DEFAULT_COMPRESSION, Z_DEFLATED, -Z_DEFAULT_WINDOW_BITS, 9, Z_DEFAULT_STRATEGY); gzip_header(out_buf); pb = (uint8_t *) out_buf + FLB_GZIP_HEADER_OFFSET; flush = Z_NO_FLUSH; while (1) { strm.next_out  = pb + strm.total_out; strm.avail_out = out_size - (pb - (uint8_t *) out_buf); if (strm.avail_in == 0) { flush = Z_FINISH; } status = deflate(&strm, flush); if (status == Z_STREAM_END) { break; } else if (status != Z_OK) { deflateEnd(&strm); return -1; } } if (deflateEnd(&strm) != Z_OK) { flb_free(out_buf); return -1; } *out_len = strm.total_out; footer_start = FLB_GZIP_HEADER_OFFSET + *out_len; pb = (uint8_t *) out_buf + footer_start; crc = mz_crc32(MZ_CRC32_INIT, in_data, in_len); *pb++ = crc & 0xFF; *pb++ = (crc >> 8) & 0xFF; *pb++ = (crc >> 16) & 0xFF; *pb++ = (crc >> 24) & 0xFF; *pb++ = in_len & 0xFF; *pb++ = (in_len >> 8) & 0xFF; *pb++ = (in_len >> 16) & 0xFF; *pb++ = (in_len >> 24) & 0xFF; *out_len += FLB_GZIP_HEADER_OFFSET + 8; *out_data = out_buf; return 0; }
Description: flb_gzip_compress in flb_gzip.c in Fluent Bit before 1.6.4 has an out-of-bounds write because it does not use the correct calculation of the maximum gzip data-size expansion.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void shell_spaces_trim(char *str) { u16_t len = shell_strlen(str); u16_t shift = 0U; if (!str) { return; } for (u16_t i = 0; i < len - 1; i++) { if (isspace((int)str[i])) { for (u16_t j = i + 1; j < len; j++) { if (isspace((int)str[j])) { shift++; continue; } if (shift > 0) { memmove(&str[i + 1], &str[j], len - shift + 1); len -= shift; shift = 0U; } break; } } } }
Description: The shell subsystem contains a buffer overflow, whereby an adversary with physical access to the device is able to cause a memory corruption, resulting in denial of service or possibly code execution within the Zephyr kernel. See NCC-NCC-019 This issue affects: zephyrproject-rtos zephyr version 1.14.0 and later versions. version 2.1.0 and later versions.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void sqlc_cursor (sql_comp_t * sc, ST ** ptree, int cr_type) { ST *tree = *ptree; int is_id; int cr_forced_static = 0; sc->sc_no_remote = 1; if (IS_UNION_ST (tree)) { tree = sqlp_view_def (NULL, tree, 1); tree = sqlc_union_dt_wrap (tree); *ptree = tree; } sqlc_top_select_wrap_dt (sc, tree); sql_stmt_comp (sc, ptree); tree = *ptree; if (sc->sc_so) is_id = sqlo_cr_is_identifiable (sc->sc_so, tree); else is_id = sqlc_cr_is_identifiable (sc, tree); if (!is_id) cr_forced_static = 1; { NEW_VARZ (query_cursor_t, qc); if (sc->sc_cc->cc_query->qr_cursor) { qc_free (sc->sc_cc->cc_query->qr_cursor); fprintf (stderr, ""Freeing qc in sqlc_cursor\n""); } sc->sc_cc->cc_query->qr_cursor = qc; sc->sc_cc->cc_query->qr_cursor_type = cr_type; if (sc->sc_so) { if (!cr_forced_static && -1 == sqlo_qc_make_cols (sc->sc_so, qc, tree)) cr_forced_static = 1; } else { if (!cr_forced_static && -1 == qc_make_cols (sc, qc, tree)) cr_forced_static = 1; } if (!cr_forced_static) { qc->qc_cursor_type = cr_type; if (sc->sc_so) sqlo_qc_make_stmts (sc->sc_so, qc); else qc_make_stmts (sc, qc); } else { qc_make_static (sc, qc, ptree); tree = *ptree; } } }
Description: An issue in the sqlc_union_dt_wrap component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void downsample_row_box_filter ( int start, int width, uint32_t *src, uint32_t *dest, int coverage[], int pixel_coverage) { int x = 0; while (x < start) { int box = 1 << FIXED_SHIFT; int start_coverage = coverage[x]; box -= start_coverage; src++; while (box >= pixel_coverage) { src++; box -= pixel_coverage; } x++; } while (x < start + width) { uint32_t a = 0; uint32_t r = 0; uint32_t g = 0; uint32_t b = 0; int box = 1 << FIXED_SHIFT; int start_coverage = coverage[x]; a = ((*src >> 24) & 0xff) * start_coverage; r = ((*src >> 16) & 0xff) * start_coverage; g = ((*src >>  8) & 0xff) * start_coverage; b = ((*src >>  0) & 0xff) * start_coverage; src++; x++; box -= start_coverage; while (box >= pixel_coverage) { a += ((*src >> 24) & 0xff) * pixel_coverage; r += ((*src >> 16) & 0xff) * pixel_coverage; g += ((*src >>  8) & 0xff) * pixel_coverage; b += ((*src >>  0) & 0xff) * pixel_coverage; src++; box -= pixel_coverage; } if (box > 0) { a += ((*src >> 24) & 0xff) * box; r += ((*src >> 16) & 0xff) * box; g += ((*src >>  8) & 0xff) * box; b += ((*src >>  0) & 0xff) * box; } a >>= FIXED_SHIFT; r >>= FIXED_SHIFT; g >>= FIXED_SHIFT; b >>= FIXED_SHIFT; *dest = (a << 24) | (r << 16) | (g << 8) | b; dest++; } }
Description: Poppler 0.74.0 has a heap-based buffer over-read in the CairoRescaleBox.cc downsample_row_box_filter function.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int lag_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; int buf_size = avpkt->size; LagarithContext *l = avctx->priv_data; ThreadFrame frame = { .f = data }; AVFrame *const p  = data; uint8_t frametype = 0; uint32_t offset_gu = 0, offset_bv = 0, offset_ry = 9; uint32_t offs[4]; uint8_t *srcs[4], *dst; int i, j, planes = 3; p->key_frame = 1; frametype = buf[0]; offset_gu = AV_RL32(buf + 1); offset_bv = AV_RL32(buf + 5); switch (frametype) { case FRAME_SOLID_RGBA: avctx->pix_fmt = AV_PIX_FMT_RGB32; if (ff_thread_get_buffer(avctx, &frame, 0) < 0) { av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n""); return -1; } dst = p->data[0]; for (j = 0; j < avctx->height; j++) { for (i = 0; i < avctx->width; i++) AV_WN32(dst + i * 4, offset_gu); dst += p->linesize[0]; } break; case FRAME_ARITH_RGBA: avctx->pix_fmt = AV_PIX_FMT_RGB32; planes = 4; offset_ry += 4; offs[3] = AV_RL32(buf + 9); case FRAME_ARITH_RGB24: case FRAME_U_RGB24: if (frametype == FRAME_ARITH_RGB24 || frametype == FRAME_U_RGB24) avctx->pix_fmt = AV_PIX_FMT_RGB24; if (ff_thread_get_buffer(avctx, &frame, 0) < 0) { av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n""); return -1; } offs[0] = offset_bv; offs[1] = offset_gu; offs[2] = offset_ry; if (!l->rgb_planes) { l->rgb_stride = FFALIGN(avctx->width, 16); l->rgb_planes = av_malloc(l->rgb_stride * avctx->height * planes + 1); if (!l->rgb_planes) { av_log(avctx, AV_LOG_ERROR, ""cannot allocate temporary buffer\n""); return AVERROR(ENOMEM); } } for (i = 0; i < planes; i++) srcs[i] = l->rgb_planes + (i + 1) * l->rgb_stride * avctx->height - l->rgb_stride; if (offset_ry >= buf_size || offset_gu >= buf_size || offset_bv >= buf_size || (planes == 4 && offs[3] >= buf_size)) { av_log(avctx, AV_LOG_ERROR, ""Invalid frame offsets\n""); return AVERROR_INVALIDDATA; } for (i = 0; i < planes; i++) lag_decode_arith_plane(l, srcs[i], avctx->width, avctx->height, -l->rgb_stride, buf + offs[i], buf_size - offs[i]); dst = p->data[0]; for (i = 0; i < planes; i++) srcs[i] = l->rgb_planes + i * l->rgb_stride * avctx->height; for (j = 0; j < avctx->height; j++) { for (i = 0; i < avctx->width; i++) { uint8_t r, g, b, a; r = srcs[0][i]; g = srcs[1][i]; b = srcs[2][i]; r += g; b += g; if (frametype == FRAME_ARITH_RGBA) { a = srcs[3][i]; AV_WN32(dst + i * 4, MKBETAG(a, r, g, b)); } else { dst[i * 3 + 0] = r; dst[i * 3 + 1] = g; dst[i * 3 + 2] = b; } } dst += p->linesize[0]; for (i = 0; i < planes; i++) srcs[i] += l->rgb_stride; } break; case FRAME_ARITH_YUY2: avctx->pix_fmt = AV_PIX_FMT_YUV422P; if (ff_thread_get_buffer(avctx, &frame, 0) < 0) { av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n""); return -1; } if (offset_ry >= buf_size || offset_gu >= buf_size || offset_bv >= buf_size) { av_log(avctx, AV_LOG_ERROR, ""Invalid frame offsets\n""); return AVERROR_INVALIDDATA; } lag_decode_arith_plane(l, p->data[0], avctx->width, avctx->height, p->linesize[0], buf + offset_ry, buf_size - offset_ry); lag_decode_arith_plane(l, p->data[1], avctx->width / 2, avctx->height, p->linesize[1], buf + offset_gu, buf_size - offset_gu); lag_decode_arith_plane(l, p->data[2], avctx->width / 2, avctx->height, p->linesize[2], buf + offset_bv, buf_size - offset_bv); break; case FRAME_ARITH_YV12: avctx->pix_fmt = AV_PIX_FMT_YUV420P; if (ff_thread_get_buffer(avctx, &frame, 0) < 0) { av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n""); return -1; } if (offset_ry >= buf_size || offset_gu >= buf_size || offset_bv >= buf_size) { av_log(avctx, AV_LOG_ERROR, ""Invalid frame offsets\n""); return AVERROR_INVALIDDATA; } lag_decode_arith_plane(l, p->data[0], avctx->width, avctx->height, p->linesize[0], buf + offset_ry, buf_size - offset_ry); lag_decode_arith_plane(l, p->data[2], avctx->width / 2, avctx->height / 2, p->linesize[2], buf + offset_gu, buf_size - offset_gu); lag_decode_arith_plane(l, p->data[1], avctx->width / 2, avctx->height / 2, p->linesize[1], buf + offset_bv, buf_size - offset_bv); break; default: av_log(avctx, AV_LOG_ERROR, ""Unsupported Lagarith frame type: %#x\n"", frametype); return -1; } *got_frame = 1; return buf_size; }
Description: A vulnerability was found in FFmpeg 2.0. It has been rated as critical. Affected by this issue is the function lag_decode_frame. The manipulation leads to memory corruption. The attack may be launched remotely. It is recommended to apply a patch to fix this issue.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void mark_context_stack(mrb_state *mrb, struct mrb_context *c) { size_t i; size_t e; if (c->stack == NULL) return; e = c->stack - c->stbase; if (c->ci) e += c->ci->nregs; if (c->stbase + e > c->stend) e = c->stend - c->stbase; for (i=0; i<e; i++) { mrb_value v = c->stbase[i]; if (!mrb_immediate_p(v)) { if (mrb_basic_ptr(v)->tt == MRB_TT_FREE) { c->stbase[i] = mrb_nil_value(); } else { mrb_gc_mark(mrb, mrb_basic_ptr(v)); } } } }
Description: The mark_context_stack function in gc.c in mruby through 1.2.0 allows attackers to cause a denial of service (heap-based use-after-free and application crash) or possibly have unspecified other impact via a crafted .rb file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static gboolean k12_seek_read(wtap *wth, gint64 seek_off, struct wtap_pkthdr *phdr, Buffer *buf, int *err, gchar **err_info) { k12_t *k12 = (k12_t *)wth->priv; guint8* buffer; gint len; K12_DBG(5,(""k12_seek_read: ENTER"")); if ( file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) { K12_DBG(5,(""k12_seek_read: SEEK ERROR"")); return FALSE; } len = get_record(k12, wth->random_fh, seek_off, TRUE, err, err_info); if (len < 0) { K12_DBG(5,(""k12_seek_read: READ ERROR"")); return FALSE; } else if (len < K12_RECORD_SRC_ID + 4) { K12_DBG(5,(""k12_seek_read: SHORT READ"")); *err = WTAP_ERR_SHORT_READ; return FALSE; } buffer = k12->rand_read_buff; process_packet_data(phdr, buf, buffer, len, k12); K12_DBG(5,(""k12_seek_read: DONE OK"")); return TRUE; }
Description: In Wireshark 2.2.0 to 2.2.4 and 2.0.0 to 2.0.10, there is a K12 file parser crash, triggered by a malformed capture file. This was addressed in wiretap/k12.c by validating the relationships between lengths and offsets.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static bool_t evtchn_fifo_is_busy(const struct domain *d, evtchn_port_t port) { const event_word_t *word = evtchn_fifo_word_from_port(d, port); return word && guest_test_bit(d, EVTCHN_FIFO_LINKED, word); }
Description: An issue was discovered in Xen through 4.14.x. There are evtchn_reset() race conditions. Uses of EVTCHNOP_reset (potentially by a guest on itself) or XEN_DOMCTL_soft_reset (by itself covered by XSA-77) can lead to the violation of various internal assumptions. This may lead to out of bounds memory accesses or triggering of bug checks. In particular, x86 PV guests may be able to elevate their privilege to that of the host. Host and guest crashes are also possible, leading to a Denial of Service (DoS). Information leaks cannot be ruled out. All Xen versions from 4.5 onwards are vulnerable. Xen versions 4.4 and earlier are not vulnerable.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int do_fault(struct mm_struct *mm, struct vm_area_struct *vma, unsigned long address, pte_t *page_table, pmd_t *pmd, unsigned int flags, pte_t orig_pte) { pgoff_t pgoff = (((address & PAGE_MASK) - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff; pte_unmap(page_table); if (!(flags & FAULT_FLAG_WRITE)) return do_read_fault(mm, vma, address, pmd, pgoff, flags, orig_pte); if (!(vma->vm_flags & VM_SHARED)) return do_cow_fault(mm, vma, address, pmd, pgoff, flags, orig_pte); return do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte); }
Description: mm/memory.c in the Linux kernel before 4.1.4 mishandles anonymous pages, which allows local users to gain privileges or cause a denial of service (page tainting) via a crafted application that triggers writing to page zero.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int iw_process_rows_intermediate_to_final(struct iw_context *ctx, int intermed_channel, const struct iw_csdescr *out_csdescr) { int i,j; int z; int k; int retval=0; iw_tmpsample tmpsamp; iw_tmpsample alphasamp = 0.0; iw_tmpsample *inpix_tofree = NULL; iw_tmpsample *outpix_tofree = NULL; int using_errdiffdither = 0; int output_channel; int is_alpha_channel; int bkgd_has_transparency; double tmpbkgdalpha=0.0; int alt_bkgd = 0; struct iw_resize_settings *rs = NULL; int ditherfamily, dithersubtype; struct iw_channelinfo_intermed *int_ci; struct iw_channelinfo_out *out_ci; iw_tmpsample *in_pix = NULL; iw_tmpsample *out_pix = NULL; int num_in_pix; int num_out_pix; num_in_pix = ctx->intermed_canvas_width; num_out_pix = ctx->img2.width; int_ci = &ctx->intermed_ci[intermed_channel]; output_channel = int_ci->corresponding_output_channel; out_ci = &ctx->img2_ci[output_channel]; is_alpha_channel = (int_ci->channeltype==IW_CHANNELTYPE_ALPHA); bkgd_has_transparency = iw_bkgd_has_transparency(ctx); inpix_tofree = (iw_tmpsample*)iw_malloc(ctx, num_in_pix * sizeof(iw_tmpsample)); in_pix = inpix_tofree; outpix_tofree = (iw_tmpsample*)iw_malloc(ctx, num_out_pix * sizeof(iw_tmpsample)); if(!outpix_tofree) goto done; out_pix = outpix_tofree; if(ctx->nearest_color_table && !is_alpha_channel && out_ci->ditherfamily==IW_DITHERFAMILY_NONE && out_ci->color_count==0) { out_ci->use_nearest_color_table = 1; } else { out_ci->use_nearest_color_table = 0; } ditherfamily = out_ci->ditherfamily; dithersubtype = out_ci->dithersubtype; if(ditherfamily==IW_DITHERFAMILY_RANDOM) { if(dithersubtype==IW_DITHERSUBTYPE_SAMEPATTERN && out_ci->channeltype!=IW_CHANNELTYPE_ALPHA) { iwpvt_prng_set_random_seed(ctx->prng,ctx->random_seed); } else { iwpvt_prng_set_random_seed(ctx->prng,ctx->random_seed+out_ci->channeltype); } } if(output_channel>=0 && out_ci->ditherfamily==IW_DITHERFAMILY_ERRDIFF) { using_errdiffdither = 1; for(i=0;i<ctx->img2.width;i++) { for(k=0;k<IW_DITHER_MAXROWS;k++) { ctx->dither_errors[k][i] = 0.0; } } } rs=&ctx->resize_settings[IW_DIMENSION_H]; if(!rs->rrctx) { rs->rrctx = iwpvt_resize_rows_init(ctx,rs,int_ci->channeltype, num_in_pix, num_out_pix); if(!rs->rrctx) goto done; } for(j=0;j<ctx->intermed_canvas_height;j++) { if(is_alpha_channel) { for(i=0;i<num_in_pix;i++) { inpix_tofree[i] = ctx->intermediate_alpha32[((size_t)j)*ctx->intermed_canvas_width+i]; } } else { for(i=0;i<num_in_pix;i++) { inpix_tofree[i] = ctx->intermediate32[((size_t)j)*ctx->intermed_canvas_width+i]; } } iwpvt_resize_row_main(rs->rrctx,in_pix,out_pix); if(ctx->intclamp) clamp_output_samples(ctx,out_pix,num_out_pix); if(is_alpha_channel && outpix_tofree && ctx->final_alpha32) { for(i=0;i<num_out_pix;i++) { ctx->final_alpha32[((size_t)j)*ctx->img2.width+i] = (iw_float32)outpix_tofree[i]; } } if(output_channel == -1) { goto here; } for(z=0;z<ctx->img2.width;z++) { if(using_errdiffdither && (j%2)) i=ctx->img2.width-1-z; else i=z; tmpsamp = out_pix[i]; if(ctx->bkgd_checkerboard) { alt_bkgd = (((ctx->bkgd_check_origin[IW_DIMENSION_H]+i)/ctx->bkgd_check_size)%2) != (((ctx->bkgd_check_origin[IW_DIMENSION_V]+j)/ctx->bkgd_check_size)%2); } if(bkgd_has_transparency) { tmpbkgdalpha = alt_bkgd ? ctx->bkgd2alpha : ctx->bkgd1alpha; } if(int_ci->need_unassoc_alpha_processing) { alphasamp = ctx->final_alpha32[((size_t)j)*ctx->img2.width + i]; if(alphasamp!=0.0) { tmpsamp /= alphasamp; } if(ctx->apply_bkgd && ctx->apply_bkgd_strategy==IW_BKGD_STRATEGY_LATE) { double bkcolor; bkcolor = alt_bkgd ? out_ci->bkgd2_color_lin : out_ci->bkgd1_color_lin; if(bkgd_has_transparency) { tmpsamp = tmpsamp*alphasamp + bkcolor*tmpbkgdalpha*(1.0-alphasamp); } else { tmpsamp = tmpsamp*alphasamp + bkcolor*(1.0-alphasamp); } } } else if(is_alpha_channel && bkgd_has_transparency) { tmpsamp = tmpsamp + tmpbkgdalpha*(1.0-tmpsamp); } if(ctx->img2.sampletype==IW_SAMPLETYPE_FLOATINGPOINT) put_sample_convert_from_linear_flt(ctx,tmpsamp,i,j,output_channel,out_csdescr); else put_sample_convert_from_linear(ctx,tmpsamp,i,j,output_channel,out_csdescr); } if(using_errdiffdither) { for(i=0;i<ctx->img2.width;i++) { for(k=0;k<IW_DITHER_MAXROWS-1;k++) { ctx->dither_errors[k][i] = ctx->dither_errors[k+1][i]; } ctx->dither_errors[IW_DITHER_MAXROWS-1][i] = 0.0; } } here: ; } retval=1; done: if(rs && rs->disable_rrctx_cache && rs->rrctx) { iwpvt_resize_rows_done(rs->rrctx); rs->rrctx = NULL; } if(inpix_tofree) iw_free(ctx,inpix_tofree); if(outpix_tofree) iw_free(ctx,outpix_tofree); return retval; }
Description: imagew-main.c:960:12 in libimageworsener.a in ImageWorsener 1.3.1 allows remote attackers to cause a denial of service (buffer underflow) via a crafted image, related to imagew-bmp.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void Compute(OpKernelContext *ctx) override { const Tensor *a_indices_t, *a_values_t, *a_shape_t, *b_indices_t, *b_values_t, *b_shape_t; OP_REQUIRES_OK(ctx, ctx->input(""a_indices"", &a_indices_t)); OP_REQUIRES_OK(ctx, ctx->input(""a_values"", &a_values_t)); OP_REQUIRES_OK(ctx, ctx->input(""a_shape"", &a_shape_t)); OP_REQUIRES_OK(ctx, ctx->input(""b_indices"", &b_indices_t)); OP_REQUIRES_OK(ctx, ctx->input(""b_values"", &b_values_t)); OP_REQUIRES_OK(ctx, ctx->input(""b_shape"", &b_shape_t)); OP_REQUIRES( ctx, TensorShapeUtils::IsMatrix(a_indices_t->shape()) && TensorShapeUtils::IsMatrix(b_indices_t->shape()), errors::InvalidArgument(""Inputs a_indices and b_indices should be "" ""matrices but received shapes: "", a_indices_t->shape().DebugString(), "", "", b_indices_t->shape().DebugString())); OP_REQUIRES(ctx, TensorShapeUtils::IsVector(a_values_t->shape()) && TensorShapeUtils::IsVector(b_values_t->shape()), errors::InvalidArgument( ""Inputs a_values and b_values should be vectors "" ""but received shapes: "", a_values_t->shape().DebugString(), "" and "", b_values_t->shape().DebugString())); const int64_t a_nnz = a_indices_t->dim_size(0); const int64_t b_nnz = b_indices_t->dim_size(0); const auto a_values = a_values_t->vec<T>(); const auto b_values = b_values_t->vec<T>(); OP_REQUIRES( ctx, a_values.size() == a_nnz && b_values.size() == b_nnz, errors::InvalidArgument(""Expected "", a_nnz, "" and "", b_nnz, "" non-empty input values, got "", a_values.size(), "" and "", b_values.size())); OP_REQUIRES(ctx, TensorShapeUtils::IsVector(a_shape_t->shape()) && TensorShapeUtils::IsVector(b_shape_t->shape()), errors::InvalidArgument( ""Input shapes should be a vector but received shapes "", a_shape_t->shape().DebugString(), "" and "", b_shape_t->shape().DebugString())); const int num_dims = a_indices_t->dim_size(1); OP_REQUIRES( ctx, a_shape_t->NumElements() == num_dims, errors::InvalidArgument(""Second dimension of a_indices and length of "" ""a_shape must match, got "", num_dims, "" and "", a_shape_t->NumElements())); OP_REQUIRES(ctx, num_dims > 0, errors::InvalidArgument(""Tensors must not be empty"")); OP_REQUIRES(ctx, a_shape_t->IsSameSize(*b_shape_t), errors::InvalidArgument( ""Operands do not have the same ranks; got shapes: "", a_shape_t->SummarizeValue(10), "" and "", b_shape_t->SummarizeValue(10))); const auto a_shape = a_shape_t->flat<int64_t>(); const auto b_shape = b_shape_t->flat<int64_t>(); for (int i = 0; i < a_shape_t->NumElements(); ++i) { OP_REQUIRES(ctx, a_shape(i) == b_shape(i), errors::InvalidArgument(""Operands' shapes do not match: got "", a_shape(i), "" and "", b_shape(i), "" for dimension "", i)); } const auto a_indices_mat = a_indices_t->matrix<int64_t>(); const auto b_indices_mat = b_indices_t->matrix<int64_t>(); std::vector<T> a_augmented_values, b_augmented_values; std::vector<std::pair<bool, int64>> entries_to_copy;      UnionSparseIndicesAndValues(a_indices_mat, a_values, a_nnz, b_indices_mat, b_values, b_nnz, num_dims, &a_augmented_values, &b_augmented_values, &entries_to_copy); const int64_t sum_nnz = a_augmented_values.size(); Tensor *output_indices_t, *output_values_t; OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({sum_nnz, num_dims}), &output_indices_t)); OP_REQUIRES_OK( ctx, ctx->allocate_output(1, TensorShape({sum_nnz}), &output_values_t)); auto output_indices_mat = output_indices_t->matrix<int64_t>(); for (int64_t i = 0; i < sum_nnz; ++i) { const bool from_a = entries_to_copy[i].first; const int64_t idx = entries_to_copy[i].second; output_indices_mat.chip<0>(i) = from_a ? a_indices_mat.chip<0>(idx) : b_indices_mat.chip<0>(idx); } using UnalignedTensorMap = Eigen::TensorMap<Eigen::Tensor<const T, 1, Eigen::RowMajor>, Eigen::Unaligned>; auto a_augmented_values_t = UnalignedTensorMap(a_augmented_values.data(), sum_nnz); auto b_augmented_values_t = UnalignedTensorMap(b_augmented_values.data(), sum_nnz); output_values_t->flat<T>().device(ctx->eigen_device<Device>()) = a_augmented_values_t.binaryExpr(b_augmented_values_t, typename Functor::func()); }
Description: TensorFlow is an open source platform for machine learning. Prior to versions 2.12.0 and 2.11.1, when `SparseSparseMaximum` is given invalid sparse tensors as inputs, it can give a null pointer error. A fix is included in TensorFlow version 2.12 and version 2.11.1.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static struct buffer_head * ext4_read_inode_bitmap(struct super_block *sb, ext4_group_t block_group) { struct ext4_group_desc *desc; struct buffer_head *bh = NULL; ext4_fsblk_t bitmap_blk; int err; desc = ext4_get_group_desc(sb, block_group, NULL); if (!desc) return ERR_PTR(-EFSCORRUPTED); bitmap_blk = ext4_inode_bitmap(sb, desc); bh = sb_getblk(sb, bitmap_blk); if (unlikely(!bh)) { ext4_error(sb, ""Cannot read inode bitmap - "" ""block_group = %u, inode_bitmap = %llu"", block_group, bitmap_blk); return ERR_PTR(-EIO); } if (bitmap_uptodate(bh)) goto verify; lock_buffer(bh); if (bitmap_uptodate(bh)) { unlock_buffer(bh); goto verify; } ext4_lock_group(sb, block_group); if (desc->bg_flags & cpu_to_le16(EXT4_BG_INODE_UNINIT)) { memset(bh->b_data, 0, (EXT4_INODES_PER_GROUP(sb) + 7) / 8); ext4_mark_bitmap_end(EXT4_INODES_PER_GROUP(sb), sb->s_blocksize * 8, bh->b_data); set_bitmap_uptodate(bh); set_buffer_uptodate(bh); set_buffer_verified(bh); ext4_unlock_group(sb, block_group); unlock_buffer(bh); return bh; } ext4_unlock_group(sb, block_group); if (buffer_uptodate(bh)) { set_bitmap_uptodate(bh); unlock_buffer(bh); goto verify; } trace_ext4_load_inode_bitmap(sb, block_group); bh->b_end_io = ext4_end_bitmap_read; get_bh(bh); submit_bh(REQ_OP_READ, REQ_META | REQ_PRIO, bh); wait_on_buffer(bh); if (!buffer_uptodate(bh)) { put_bh(bh); ext4_error(sb, ""Cannot read inode bitmap - "" ""block_group = %u, inode_bitmap = %llu"", block_group, bitmap_blk); return ERR_PTR(-EIO); } verify: err = ext4_validate_inode_bitmap(sb, desc, block_group, bh); if (err) goto out; return bh; out: put_bh(bh); return ERR_PTR(err); }
Description: The ext4_valid_block_bitmap function in fs/ext4/balloc.c in the Linux kernel through 4.15.15 allows attackers to cause a denial of service (out-of-bounds read and system crash) via a crafted ext4 image because balloc.c and ialloc.c do not validate bitmap block numbers.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static status addMultiArrayContentJSON(CtxJson *ctx, void* array, const UA_DataType *type,  size_t *index, UA_UInt32 *arrayDimensions, size_t dimensionIndex,  size_t dimensionSize) { if(ctx->depth > UA_JSON_ENCODING_MAX_RECURSION) return UA_STATUSCODE_BADENCODINGERROR; status ret; if(dimensionIndex == (dimensionSize - 1)) { ret = encodeJsonArray(ctx, ((u8*)array) + (type->memSize * *index), arrayDimensions[dimensionIndex], type); (*index) += arrayDimensions[dimensionIndex]; return ret; } ret = writeJsonArrStart(ctx); for(size_t i = 0; i < arrayDimensions[dimensionIndex]; i++) { ret |= writeJsonCommaIfNeeded(ctx); ret |= addMultiArrayContentJSON(ctx, array, type, index, arrayDimensions, dimensionIndex + 1, dimensionSize); ctx->commaNeeded[ctx->depth] = true; if(ret != UA_STATUSCODE_GOOD) return ret; } ret |= writeJsonArrEnd(ctx); return ret; }
Description: Variant_encodeJson in open62541 1.x before 1.0.4 has an out-of-bounds write for a large recursion depth.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Elf32_Sym const *PackLinuxElf32::elf_lookup(char const *name) const { if (hashtab && dynsym && dynstr) { unsigned const nbucket = get_te32(&hashtab[0]); unsigned const *const buckets = &hashtab[2]; unsigned const *const chains = &buckets[nbucket]; unsigned const m = elf_hash(name) % nbucket; if (!nbucket ||  (unsigned)(file_size - ((char const *)buckets - (char const *)(void const *)file_image)) <= sizeof(unsigned)*nbucket ) { char msg[80]; snprintf(msg, sizeof(msg), ""bad nbucket %#x\n"", nbucket); throwCantPack(msg); } unsigned si; for (si= get_te32(&buckets[m]); 0!=si; si= get_te32(&chains[si])) { char const *const p= get_dynsym_name(si, (unsigned)-1); if (0==strcmp(name, p)) { return &dynsym[si]; } } } if (gashtab && dynsym && dynstr) { unsigned const n_bucket = get_te32(&gashtab[0]); unsigned const symbias  = get_te32(&gashtab[1]); unsigned const n_bitmask = get_te32(&gashtab[2]); unsigned const gnu_shift = get_te32(&gashtab[3]); unsigned const *const bitmask = &gashtab[4]; unsigned const *const buckets = &bitmask[n_bitmask]; unsigned const *const hasharr = &buckets[n_bucket]; if (!n_bucket || (void const *)&file_image[file_size] <= (void const *)hasharr) { char msg[80]; snprintf(msg, sizeof(msg), ""bad n_bucket %#x\n"", n_bucket); throwCantPack(msg); } if (!n_bitmask || (unsigned)(file_size - ((char const *)bitmask - (char const *)(void const *)file_image)) <= sizeof(unsigned)*n_bitmask ) { char msg[80]; snprintf(msg, sizeof(msg), ""bad n_bitmask %#x\n"", n_bitmask); throwCantPack(msg); } unsigned const h = gnu_hash(name); unsigned const hbit1 = 037& h; unsigned const hbit2 = 037& (h>>gnu_shift); unsigned const w = get_te32(&bitmask[(n_bitmask -1) & (h>>5)]); if (1& (w>>hbit1) & (w>>hbit2)) { unsigned bucket = get_te32(&buckets[h % n_bucket]); if (n_bucket <= bucket) { char msg[80]; snprintf(msg, sizeof(msg), ""bad DT_GNU_HASH n_bucket{%#x} <= buckets[%d]{%#x}\n"", n_bucket, h % n_bucket, bucket); throwCantPack(msg); } if (0!=bucket) { Elf32_Sym const *dsp = &dynsym[bucket]; unsigned const *hp = &hasharr[bucket - symbias]; do if (0==((h ^ get_te32(hp))>>1)) { unsigned st_name = get_te32(&dsp->st_name); char const *const p = get_str_name(st_name, (unsigned)-1); if (0==strcmp(name, p)) { return dsp; } } while (++dsp, (char const *)hp < (char const *)&file_image[file_size] &&  0==(1u& get_te32(hp++))); } } } return 0; }
Description: An floating point exception was discovered in the elf_lookup function in p_lx_elf.cpp in UPX 4.0.0 via a crafted Mach-O file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: QPDFObjectHandle QPDFObjectHandle::parseInternal(PointerHolder<InputSource> input, std::string const& object_description, QPDFTokenizer& tokenizer, bool& empty, StringDecrypter* decrypter, QPDF* context, bool content_stream) { empty = false; QPDFObjectHandle object; std::vector<std::vector<QPDFObjectHandle> > olist_stack; olist_stack.push_back(std::vector<QPDFObjectHandle>()); std::vector<parser_state_e> state_stack; state_stack.push_back(st_top); std::vector<qpdf_offset_t> offset_stack; qpdf_offset_t offset = input->tell(); offset_stack.push_back(offset); bool done = false; while (! done) { std::vector<QPDFObjectHandle>& olist = olist_stack.back(); parser_state_e state = state_stack.back(); offset = offset_stack.back(); object = QPDFObjectHandle(); QPDFTokenizer::Token token = tokenizer.readToken(input, object_description, true); switch (token.getType()) { case QPDFTokenizer::tt_eof: if (! content_stream) { QTC::TC(""qpdf"", ""QPDFObjectHandle eof in parseInternal""); warn(context, QPDFExc(qpdf_e_damaged_pdf, input->getName(), object_description, input->getLastOffset(), ""unexpected EOF"")); } state = st_eof; break; case QPDFTokenizer::tt_bad: QTC::TC(""qpdf"", ""QPDFObjectHandle bad token in parse""); warn(context, QPDFExc(qpdf_e_damaged_pdf, input->getName(), object_description, input->getLastOffset(), token.getErrorMessage())); object = newNull(); break; case QPDFTokenizer::tt_brace_open: case QPDFTokenizer::tt_brace_close: QTC::TC(""qpdf"", ""QPDFObjectHandle bad brace""); warn(context, QPDFExc(qpdf_e_damaged_pdf, input->getName(), object_description, input->getLastOffset(), ""treating unexpected brace token as null"")); object = newNull(); break; case QPDFTokenizer::tt_array_close: if (state == st_array) { state = st_stop; } else { QTC::TC(""qpdf"", ""QPDFObjectHandle bad array close""); warn(context, QPDFExc(qpdf_e_damaged_pdf, input->getName(), object_description, input->getLastOffset(), ""treating unexpected array close token as null"")); object = newNull(); } break; case QPDFTokenizer::tt_dict_close: if (state == st_dictionary) { state = st_stop; } else { QTC::TC(""qpdf"", ""QPDFObjectHandle bad dictionary close""); warn(context, QPDFExc(qpdf_e_damaged_pdf, input->getName(), object_description, input->getLastOffset(), ""unexpected dictionary close token"")); object = newNull(); } break; case QPDFTokenizer::tt_array_open: case QPDFTokenizer::tt_dict_open: olist_stack.push_back(std::vector<QPDFObjectHandle>()); state = st_start; offset_stack.push_back(input->tell()); state_stack.push_back( (token.getType() == QPDFTokenizer::tt_array_open) ? st_array : st_dictionary); break; case QPDFTokenizer::tt_bool: object = newBool((token.getValue() == ""true"")); break; case QPDFTokenizer::tt_null: object = newNull(); break; case QPDFTokenizer::tt_integer: object = newInteger(QUtil::string_to_ll(token.getValue().c_str())); break; case QPDFTokenizer::tt_real: object = newReal(token.getValue()); break; case QPDFTokenizer::tt_name: object = newName(token.getValue()); break; case QPDFTokenizer::tt_word: { std::string const& value = token.getValue(); if (content_stream) { object = QPDFObjectHandle::newOperator(value); } else if ((value == ""R"") && (state != st_top) && (olist.size() >= 2) && (! olist.at(olist.size() - 1).isIndirect()) && (olist.at(olist.size() - 1).isInteger()) && (! olist.at(olist.size() - 2).isIndirect()) && (olist.at(olist.size() - 2).isInteger())) { if (context == 0) { QTC::TC(""qpdf"", ""QPDFObjectHandle indirect without context""); throw std::logic_error( ""QPDFObjectHandle::parse called without context"" "" on an object with indirect references""); } object = newIndirect( context, olist.at(olist.size() - 2).getIntValue(), olist.at(olist.size() - 1).getIntValue()); olist.pop_back(); olist.pop_back(); } else if ((value == ""endobj"") && (state == st_top)) { object = newNull(); input->seek(input->getLastOffset(), SEEK_SET); empty = true; } else { QTC::TC(""qpdf"", ""QPDFObjectHandle treat word as string""); warn(context, QPDFExc(qpdf_e_damaged_pdf, input->getName(), object_description, input->getLastOffset(), ""unknown token while reading object;"" "" treating as string"")); object = newString(value); } } break; case QPDFTokenizer::tt_string: { std::string val = token.getValue(); if (decrypter) { decrypter->decryptString(val); } object = QPDFObjectHandle::newString(val); } break; default: warn(context, QPDFExc(qpdf_e_damaged_pdf, input->getName(), object_description, input->getLastOffset(), ""treating unknown token type as null while "" ""reading object"")); object = newNull(); break; } if ((! object.isInitialized()) && (! ((state == st_start) || (state == st_stop) || (state == st_eof)))) { throw std::logic_error( ""QPDFObjectHandle::parseInternal: "" ""unexpected uninitialized object""); object = newNull(); } switch (state) { case st_eof: if (state_stack.size() > 1) { warn(context, QPDFExc(qpdf_e_damaged_pdf, input->getName(), object_description, input->getLastOffset(), ""parse error while reading object"")); } done = true; if (! content_stream) { object = newNull(); } break; case st_dictionary: case st_array: setObjectDescriptionFromInput( object, context, object_description, input, input->getLastOffset()); olist.push_back(object); break; case st_top: done = true; break; case st_start: break; case st_stop: if ((state_stack.size() < 2) || (olist_stack.size() < 2)) { throw std::logic_error( ""QPDFObjectHandle::parseInternal: st_stop encountered"" "" with insufficient elements in stack""); } parser_state_e old_state = state_stack.back(); state_stack.pop_back(); if (old_state == st_array) { object = newArray(olist); setObjectDescriptionFromInput( object, context, object_description, input, offset); } else if (old_state == st_dictionary) { std::set<std::string> names; for (std::vector<QPDFObjectHandle>::iterator iter = olist.begin(); iter != olist.end(); ++iter) { if ((! (*iter).isIndirect()) && (*iter).isName()) { names.insert((*iter).getName()); } } std::map<std::string, QPDFObjectHandle> dict; int next_fake_key = 1; for (unsigned int i = 0; i < olist.size(); ++i) { QPDFObjectHandle key_obj = olist.at(i); QPDFObjectHandle val; if (key_obj.isIndirect() || (! key_obj.isName())) { bool found_fake = false; std::string candidate; while (! found_fake) { candidate = ""/QPDFFake"" + QUtil::int_to_string(next_fake_key++); found_fake = (names.count(candidate) == 0); QTC::TC(""qpdf"", ""QPDFObjectHandle found fake"", (found_fake ? 0 : 1)); } warn(context, QPDFExc( qpdf_e_damaged_pdf, input->getName(), object_description, offset, ""expected dictionary key but found"" "" non-name object; inserting key "" + candidate)); val = key_obj; key_obj = newName(candidate); } else if (i + 1 >= olist.size()) { QTC::TC(""qpdf"", ""QPDFObjectHandle no val for last key""); warn(context, QPDFExc( qpdf_e_damaged_pdf, input->getName(), object_description, offset, ""dictionary ended prematurely; "" ""using null as value for last key"")); val = newNull(); setObjectDescriptionFromInput( val, context, object_description, input, offset); } else { val = olist.at(++i); } dict[key_obj.getName()] = val; } object = newDictionary(dict); setObjectDescriptionFromInput( object, context, object_description, input, offset); } olist_stack.pop_back(); offset_stack.pop_back(); if (state_stack.back() == st_top) { done = true; } else { olist_stack.back().push_back(object); } } } setObjectDescriptionFromInput( object, context, object_description, input, offset); return object; }
Description: libqpdf.a in QPDF through 8.0.2 mishandles certain ""expected dictionary key but found non-name object"" cases, allowing remote attackers to cause a denial of service (stack exhaustion), related to the QPDFObjectHandle and QPDF_Dictionary classes, because nesting in direct objects is not restricted.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int fill_thread_core_info(struct elf_thread_core_info *t, const struct user_regset_view *view, long signr, size_t *total) { unsigned int i; unsigned int regset0_size = regset_size(t->task, &view->regsets[0]); fill_prstatus(&t->prstatus, t->task, signr); (void) view->regsets[0].get(t->task, &view->regsets[0], 0, regset0_size, &t->prstatus.pr_reg, NULL); fill_note(&t->notes[0], ""CORE"", NT_PRSTATUS, PRSTATUS_SIZE(t->prstatus, regset0_size), &t->prstatus); *total += notesize(&t->notes[0]); do_thread_regset_writeback(t->task, &view->regsets[0]); for (i = 1; i < view->n; ++i) { const struct user_regset *regset = &view->regsets[i]; do_thread_regset_writeback(t->task, regset); if (regset->core_note_type && regset->get && (!regset->active || regset->active(t->task, regset) > 0)) { int ret; size_t size = regset_size(t->task, regset); void *data = kmalloc(size, GFP_KERNEL); if (unlikely(!data)) return 0; ret = regset->get(t->task, regset, 0, size, data, NULL); if (unlikely(ret)) kfree(data); else { if (regset->core_note_type != NT_PRFPREG) fill_note(&t->notes[i], ""LINUX"", regset->core_note_type, size, data); else { SET_PR_FPVALID(&t->prstatus, 1, regset0_size); fill_note(&t->notes[i], ""CORE"", NT_PRFPREG, size, data); } *total += notesize(&t->notes[i]); } } } return 1; }
Description: A flaw was found in the Linux kernel's implementation of Userspace core dumps. This flaw allows an attacker with a local account to crash a trivial program and exfiltrate private kernel data.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int aa_read_header(AVFormatContext *s) { int i, j, idx, largest_idx = -1; uint32_t nkey, nval, toc_size, npairs, header_seed = 0, start; char key[128], val[128], codec_name[64] = {0}; uint8_t output[24], dst[8], src[8]; int64_t largest_size = -1, current_size = -1, chapter_pos; struct toc_entry { uint32_t offset; uint32_t size; } TOC[MAX_TOC_ENTRIES]; uint32_t header_key_part[4]; uint8_t header_key[16] = {0}; AADemuxContext *c = s->priv_data; AVIOContext *pb = s->pb; AVStream *st; avio_skip(pb, 4);     avio_skip(pb, 4);     toc_size = avio_rb32(pb);     avio_skip(pb, 4);     if (toc_size > MAX_TOC_ENTRIES) return AVERROR_INVALIDDATA; for (i = 0; i < toc_size; i++) {         avio_skip(pb, 4);         TOC[i].offset = avio_rb32(pb);         TOC[i].size = avio_rb32(pb);     } avio_skip(pb, 24);     npairs = avio_rb32(pb);     if (npairs > MAX_DICTIONARY_ENTRIES) return AVERROR_INVALIDDATA; for (i = 0; i < npairs; i++) { memset(val, 0, sizeof(val)); memset(key, 0, sizeof(key)); avio_skip(pb, 1);         nkey = avio_rb32(pb);         nval = avio_rb32(pb);         avio_get_str(pb, nkey, key, sizeof(key)); avio_get_str(pb, nval, val, sizeof(val)); if (!strcmp(key, ""codec"")) { av_log(s, AV_LOG_DEBUG, ""Codec is <%s>\n"", val); strncpy(codec_name, val, sizeof(codec_name) - 1); } else if (!strcmp(key, ""HeaderSeed"")) { av_log(s, AV_LOG_DEBUG, ""HeaderSeed is <%s>\n"", val); header_seed = atoi(val); } else if (!strcmp(key, ""HeaderKey"")) {             av_log(s, AV_LOG_DEBUG, ""HeaderKey is <%s>\n"", val); sscanf(val, ""%""SCNu32""%""SCNu32""%""SCNu32""%""SCNu32, &header_key_part[0], &header_key_part[1], &header_key_part[2], &header_key_part[3]); for (idx = 0; idx < 4; idx++) { AV_WB32(&header_key[idx * 4], header_key_part[idx]);             } av_log(s, AV_LOG_DEBUG, ""Processed HeaderKey is ""); for (i = 0; i < 16; i++) av_log(s, AV_LOG_DEBUG, ""%02x"", header_key[i]); av_log(s, AV_LOG_DEBUG, ""\n""); } else { av_dict_set(&s->metadata, key, val, 0); } } if (c->aa_fixed_key_len != 16) { av_log(s, AV_LOG_ERROR, ""aa_fixed_key value needs to be 16 bytes!\n""); return AVERROR(EINVAL); } if ((c->codec_second_size = get_second_size(codec_name)) == -1) { av_log(s, AV_LOG_ERROR, ""unknown codec <%s>!\n"", codec_name); return AVERROR(EINVAL); } c->tea_ctx = av_tea_alloc(); if (!c->tea_ctx) return AVERROR(ENOMEM); av_tea_init(c->tea_ctx, c->aa_fixed_key, 16); output[0] = output[1] = 0;     memcpy(output + 2, header_key, 16); idx = 0; for (i = 0; i < 3; i++) {         AV_WB32(src, header_seed); AV_WB32(src + 4, header_seed + 1); header_seed += 2; av_tea_crypt(c->tea_ctx, dst, src, 1, NULL, 0);         for (j = 0; j < TEA_BLOCK_SIZE && idx < 18; j+=1, idx+=1) { output[idx] = output[idx] ^ dst[j]; } } memcpy(c->file_key, output + 2, 16);     av_log(s, AV_LOG_DEBUG, ""File key is ""); for (i = 0; i < 16; i++) av_log(s, AV_LOG_DEBUG, ""%02x"", c->file_key[i]); av_log(s, AV_LOG_DEBUG, ""\n""); st = avformat_new_stream(s, NULL); if (!st) { av_freep(&c->tea_ctx); return AVERROR(ENOMEM); } st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO; if (!strcmp(codec_name, ""mp332"")) { st->codecpar->codec_id = AV_CODEC_ID_MP3; st->codecpar->sample_rate = 22050; st->need_parsing = AVSTREAM_PARSE_FULL_RAW; avpriv_set_pts_info(st, 64, 8, 32000 * TIMEPREC); } else if (!strcmp(codec_name, ""acelp85"")) { st->codecpar->codec_id = AV_CODEC_ID_SIPR; st->codecpar->block_align = 19; st->codecpar->channels = 1; st->codecpar->sample_rate = 8500; st->codecpar->bit_rate = 8500; st->need_parsing = AVSTREAM_PARSE_FULL_RAW; avpriv_set_pts_info(st, 64, 8, 8500 * TIMEPREC); } else if (!strcmp(codec_name, ""acelp16"")) { st->codecpar->codec_id = AV_CODEC_ID_SIPR; st->codecpar->block_align = 20; st->codecpar->channels = 1; st->codecpar->sample_rate = 16000; st->codecpar->bit_rate = 16000; st->need_parsing = AVSTREAM_PARSE_FULL_RAW; avpriv_set_pts_info(st, 64, 8, 16000 * TIMEPREC); } for (i = 1; i < toc_size; i++) {         current_size = TOC[i].size; if (current_size > largest_size) { largest_idx = i; largest_size = current_size; } } start = TOC[largest_idx].offset; avio_seek(pb, start, SEEK_SET); st->start_time = 0; c->content_start = start; c->content_end = start + largest_size; while ((chapter_pos = avio_tell(pb)) >= 0 && chapter_pos < c->content_end) { int chapter_idx = s->nb_chapters; uint32_t chapter_size = avio_rb32(pb); if (chapter_size == 0) break; chapter_pos -= start + CHAPTER_HEADER_SIZE * chapter_idx; avio_skip(pb, 4 + chapter_size); if (!avpriv_new_chapter(s, chapter_idx, st->time_base, chapter_pos * TIMEPREC, (chapter_pos + chapter_size) * TIMEPREC, NULL)) return AVERROR(ENOMEM); } st->duration = (largest_size - CHAPTER_HEADER_SIZE * s->nb_chapters) * TIMEPREC; ff_update_cur_dts(s, st, 0); avio_seek(pb, start, SEEK_SET); c->current_chapter_size = 0; c->seek_offset = 0; return 0; }
Description: aa_read_header in libavformat/aadec.c in FFmpeg before 3.2.14 and 4.x before 4.1.4 does not check for sscanf failure and consequently allows use of uninitialized variables.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void ati_cursor_define(ATIVGAState *s) { uint8_t data[1024]; uint8_t *src; int i, j, idx = 0; if ((s->regs.cur_offset & BIT(31)) || s->cursor_guest_mode) { return;  } src = s->vga.vram_ptr + s->regs.cur_offset - (s->regs.cur_hv_offs >> 16) - (s->regs.cur_hv_offs & 0xffff) * 16; for (i = 0; i < 64; i++) { for (j = 0; j < 8; j++, idx++) { data[idx] = src[i * 16 + j]; data[512 + idx] = src[i * 16 + j + 8]; } } if (!s->cursor) { s->cursor = cursor_alloc(64, 64); } cursor_set_mono(s->cursor, s->regs.cur_color1, s->regs.cur_color0, &data[512], 1, &data[0]); dpy_cursor_define(s->vga.con, s->cursor); }
Description: In QEMU 4.1.0, an out-of-bounds read flaw was found in the ATI VGA implementation. It occurs in the ati_cursor_define() routine while handling MMIO write operations through the ati_mm_write() callback. A malicious guest could abuse this flaw to crash the QEMU process, resulting in a denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool QHstsHeaderParser::parse(const QList<QPair<QByteArray, QByteArray>> &headers) { for (const auto &h : headers) { if (h.first == ""Strict-Transport-Security"") { header = h.second; if (parseSTSHeader() && maxAgeFound) { expiry = QDateTime::currentDateTimeUtc().addSecs(maxAge); return true; } } } subDomainsFound = false; return false; }
Description: An issue was discovered in Qt before 5.15.14, 6.x before 6.2.9, and 6.3.x through 6.5.x before 6.5.1. Qt Network incorrectly parses the strict-transport-security (HSTS) header, allowing unencrypted connections to be established, even when explicitly prohibited by the server. This happens if the case used for this header does not exactly match.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) { auto* params = reinterpret_cast<TfLiteDepthwiseConvParams*>(node->builtin_data); OpData* data = reinterpret_cast<OpData*>(node->user_data); bool has_bias = NumInputs(node) == 3; TF_LITE_ENSURE(context, has_bias || NumInputs(node) == 2); const TfLiteTensor* input; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor, &input)); const TfLiteTensor* filter; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kFilterTensor, &filter)); const TfLiteTensor* bias = nullptr; TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1); TfLiteTensor* output; TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, kOutputTensor, &output)); TF_LITE_ENSURE_EQ(context, NumDimensions(input), 4); TF_LITE_ENSURE_EQ(context, NumDimensions(filter), 4); const TfLiteType data_type = input->type; const TfLiteType filter_type = filter->type; const bool is_hybrid = data_type == kTfLiteFloat32 && filter_type == kTfLiteInt8; TF_LITE_ENSURE(context, data_type == kTfLiteFloat32 || data_type == kTfLiteUInt8 || data_type == kTfLiteInt8 || data_type == kTfLiteInt16); TF_LITE_ENSURE_TYPES_EQ(context, output->type, data_type); if (!is_hybrid) { TF_LITE_ENSURE(context, filter->type == data_type || data_type == kTfLiteInt16); } if (data_type == kTfLiteInt16) { TF_LITE_ENSURE_EQ(context, input->params.zero_point, 0); TF_LITE_ENSURE_EQ(context, output->params.zero_point, 0); } TF_LITE_ENSURE_EQ(context, SizeOfDimension(filter, 0), 1); if (has_bias) { TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kBiasTensor, &bias)); if (data_type == kTfLiteUInt8 || data_type == kTfLiteInt8) { TF_LITE_ENSURE_TYPES_EQ(context, bias->type, kTfLiteInt32); TF_LITE_ENSURE_EQ(context, bias->params.zero_point, 0); } else if (data_type == kTfLiteInt16) { TF_LITE_ENSURE_TYPES_EQ(context, bias->type, kTfLiteInt64); TF_LITE_ENSURE_EQ(context, bias->params.zero_point, 0); } else { TF_LITE_ENSURE_TYPES_EQ(context, bias->type, data_type); } TF_LITE_ENSURE_EQ(context, NumDimensions(bias), 1); TF_LITE_ENSURE_EQ(context, SizeOfDimension(filter, 3), SizeOfDimension(bias, 0)); } int channels_out = SizeOfDimension(filter, 3); int width = SizeOfDimension(input, 2); int height = SizeOfDimension(input, 1); int filter_width = SizeOfDimension(filter, 2); int filter_height = SizeOfDimension(filter, 1); int batches = SizeOfDimension(input, 0); auto padding = params->padding; int out_width, out_height; data->padding = ComputePaddingHeightWidth( params->stride_height, params->stride_width, params->dilation_height_factor, params->dilation_width_factor, height, width, filter_height, filter_width, padding, &out_height, &out_width); if (data_type != kTfLiteFloat32) { TF_LITE_ENSURE_EQ(context, filter->quantization.type, kTfLiteAffineQuantization); const auto* affine_quantization = reinterpret_cast<TfLiteAffineQuantization*>( filter->quantization.params); TF_LITE_ENSURE(context, affine_quantization); TF_LITE_ENSURE(context, affine_quantization->scale); TF_LITE_ENSURE(context, (affine_quantization->scale->size == 1 || affine_quantization->scale->size == channels_out)); data->per_channel_output_multiplier.resize(channels_out); data->per_channel_output_shift.resize(channels_out); TF_LITE_ENSURE_STATUS(tflite::PopulateConvolutionQuantizationParams( context, input, filter, bias, output, params->activation, &data->output_multiplier, &data->output_shift, &data->output_activation_min, &data->output_activation_max, data->per_channel_output_multiplier.data(), data->per_channel_output_shift.data(), channels_out)); } if (is_hybrid) { const auto* affine_quantization = reinterpret_cast<TfLiteAffineQuantization*>( filter->quantization.params); TF_LITE_ENSURE(context, affine_quantization); TF_LITE_ENSURE(context, affine_quantization->scale); TF_LITE_ENSURE_EQ( context, affine_quantization->scale->size, filter->dims->data[affine_quantization->quantized_dimension]); int temporaries_count = 0; data->input_quantized_index = temporaries_count; if (data->input_quantized_id == kTensorNotAllocated) { TF_LITE_ENSURE_OK( context, context->AddTensors(context, 1, &data->input_quantized_id)); } ++temporaries_count; data->scaling_factors_index = temporaries_count; if (data->scaling_factors_id == kTensorNotAllocated) { TF_LITE_ENSURE_OK( context, context->AddTensors(context, 1, &data->scaling_factors_id)); } ++temporaries_count; data->input_offset_index = temporaries_count; if (data->input_offset_id == kTensorNotAllocated) { TF_LITE_ENSURE_OK( context, context->AddTensors(context, 1, &data->input_offset_id)); } ++temporaries_count; TfLiteIntArrayFree(node->temporaries); node->temporaries = TfLiteIntArrayCreate(temporaries_count); node->temporaries->data[data->input_quantized_index] = data->input_quantized_id; TfLiteTensor* input_quantized; TF_LITE_ENSURE_OK( context, GetTemporarySafe(context, node, data->input_quantized_index, &input_quantized)); input_quantized->type = kTfLiteInt8; input_quantized->allocation_type = kTfLiteArenaRw; if (!TfLiteIntArrayEqual(input_quantized->dims, input->dims)) { TfLiteIntArray* input_quantized_size = TfLiteIntArrayCopy(input->dims); TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_quantized, input_quantized_size)); } node->temporaries->data[data->scaling_factors_index] = data->scaling_factors_id; TfLiteTensor* scaling_factors; TF_LITE_ENSURE_OK( context, GetTemporarySafe(context, node, data->scaling_factors_index, &scaling_factors)); scaling_factors->type = kTfLiteFloat32; scaling_factors->allocation_type = kTfLiteArenaRw; const int batch_size = SizeOfDimension(input, 0); int scaling_dims[1] = {batch_size}; if (!TfLiteIntArrayEqualsArray(scaling_factors->dims, 1, scaling_dims)) { TfLiteIntArray* scaling_factors_size = TfLiteIntArrayCreate(1); scaling_factors_size->data[0] = batch_size; TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, scaling_factors, scaling_factors_size)); } node->temporaries->data[data->input_offset_index] = data->input_offset_id; TfLiteTensor* input_offsets; TF_LITE_ENSURE_OK(context, GetTemporarySafe(context, node, data->input_offset_index, &input_offsets)); input_offsets->type = kTfLiteInt32; input_offsets->allocation_type = kTfLiteArenaRw; if (!TfLiteIntArrayEqualsArray(input_offsets->dims, 1, scaling_dims)) { TfLiteIntArray* input_offsets_size = TfLiteIntArrayCreate(1); input_offsets_size->data[0] = batch_size; TF_LITE_ENSURE_OK(context, context->ResizeTensor(context, input_offsets, input_offsets_size)); } } TfLiteIntArray* outputSize = TfLiteIntArrayCreate(4); outputSize->data[0] = batches; outputSize->data[1] = out_height; outputSize->data[2] = out_width; outputSize->data[3] = channels_out; return context->ResizeTensor(context, output, outputSize); }
Description: TensorFlow is an end-to-end open source platform for machine learning. In affected versions all TFLite operations that use quantization can be made to use unitialized values. [For example](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/depthwise_conv.cc#L198-L200). The issue stems from the fact that `quantization.params` is only valid if `quantization.type` is different that `kTfLiteNoQuantization`. However, these checks are missing in large parts of the code. We have patched the issue in GitHub commits 537bc7c723439b9194a358f64d871dd326c18887, 4a91f2069f7145aab6ba2d8cfe41be8a110c18a5 and 8933b8a21280696ab119b63263babdb54c298538. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void DidFailProvisionalLoad(const blink::WebURLError& error) override { CallbackAndDie(false); }
Description: extensions/renderer/render_frame_observer_natives.cc in Google Chrome before 49.0.2623.75 does not properly consider object lifetimes and re-entrancy issues during OnDocumentElementCreated handling, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via unknown vectors.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: std::optional<Path> PathGroup::path(const std::string& name, Http::Method method) const { auto group = paths(name); auto it    = std::find_if(std::begin(group), std::end(group), [&](const Path& p) { return p.method == method; }); if (it != std::end(group)) { return std::optional<Path>(*it); } return std::nullopt; }
Description: This affects the package pistacheio/pistache before 0.0.3.20220425. It is possible to traverse directories to fetch arbitrary files from the server.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int confirm_TCP_connection(TCP_Server *tcp_server, const Mono_Time *mono_time, TCP_Secure_Connection *con, const uint8_t *data, uint16_t length) { int index = add_accepted(tcp_server, mono_time, con); if (index == -1) { kill_TCP_secure_connection(con); return -1; } crypto_memzero(con, sizeof(TCP_Secure_Connection)); if (handle_TCP_packet(tcp_server, index, data, length) == -1) { kill_accepted(tcp_server, index); return -1; } return index; }
Description: The TCP Server module in toxcore before 0.2.8 doesn't free the TCP priority queue under certain conditions, which allows a remote attacker to exhaust the system's memory, causing a denial of service (DoS).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void ide_dma_cb(void *opaque, int ret) { IDEState *s = opaque; int n; int64_t sector_num; bool stay_active = false; if (ret == -ECANCELED) { return; } if (ret < 0) { int op = IDE_RETRY_DMA; if (s->dma_cmd == IDE_DMA_READ) op |= IDE_RETRY_READ; else if (s->dma_cmd == IDE_DMA_TRIM) op |= IDE_RETRY_TRIM; if (ide_handle_rw_error(s, -ret, op)) { return; } } n = s->io_buffer_size >> 9; if (n > s->nsector) { n = s->nsector; stay_active = true; } sector_num = ide_get_sector(s); if (n > 0) { dma_buf_commit(s); sector_num += n; ide_set_sector(s, sector_num); s->nsector -= n; } if (s->nsector == 0) { s->status = READY_STAT | SEEK_STAT; ide_set_irq(s->bus); goto eot; } n = s->nsector; s->io_buffer_index = 0; s->io_buffer_size = n * 512; if (s->bus->dma->ops->prepare_buf(s->bus->dma, ide_cmd_is_read(s)) == 0) { s->status = READY_STAT | SEEK_STAT; goto eot; } #ifdef DEBUG_AIO printf(""ide_dma_cb: sector_num=%"" PRId64 "" n=%d, cmd_cmd=%d\n"", sector_num, n, s->dma_cmd); #endif if ((s->dma_cmd == IDE_DMA_READ || s->dma_cmd == IDE_DMA_WRITE) && !ide_sect_range_ok(s, sector_num, n)) { dma_buf_commit(s); ide_dma_error(s); return; } switch (s->dma_cmd) { case IDE_DMA_READ: s->bus->dma->aiocb = dma_blk_read(s->blk, &s->sg, sector_num, ide_dma_cb, s); break; case IDE_DMA_WRITE: s->bus->dma->aiocb = dma_blk_write(s->blk, &s->sg, sector_num, ide_dma_cb, s); break; case IDE_DMA_TRIM: s->bus->dma->aiocb = dma_blk_io(s->blk, &s->sg, sector_num, ide_issue_trim, ide_dma_cb, s, DMA_DIRECTION_TO_DEVICE); break; } return; eot: if (s->dma_cmd == IDE_DMA_READ || s->dma_cmd == IDE_DMA_WRITE) { block_acct_done(blk_get_stats(s->blk), &s->acct); } ide_set_inactive(s, stay_active); }
Description: The ahci_commit_buf function in ide/ahci.c in QEMU allows attackers to cause a denial of service (NULL dereference) when the command header 'ad->cur_cmd' is null.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int do_checksum(tcpedit_t *tcpedit, uint8_t *data, int proto, int len) { ipv4_hdr_t *ipv4; ipv6_hdr_t *ipv6; tcp_hdr_t *tcp; udp_hdr_t *udp; icmpv4_hdr_t *icmp; icmpv6_hdr_t *icmp6; int ip_hl; int sum; sum = 0; ipv4 = NULL; ipv6 = NULL; assert(data); if (!data || len <= 0 || len > 65535) { tcpedit_setwarn(tcpedit, ""%s"", ""Unable to checksum packets with no L3+ data""); return TCPEDIT_WARN; } ipv4 = (ipv4_hdr_t *)data; if (ipv4->ip_v == 6) { ipv6 = (ipv6_hdr_t *)data; ipv4 = NULL; proto = get_ipv6_l4proto(ipv6, len); dbgx(3, ""layer4 proto is 0x%hx"", (uint16_t)proto); ip_hl = (u_char*)get_layer4_v6(ipv6, len) - (u_char*)data; dbgx(3, ""ip_hl proto is 0x%d"", ip_hl); len -= (ip_hl - TCPR_IPV6_H); } else { ip_hl = ipv4->ip_hl << 2; } switch (proto) { case IPPROTO_TCP: tcp = (tcp_hdr_t *)(data + ip_hl); #ifdef STUPID_SOLARIS_CHECKSUM_BUG tcp->th_sum = tcp->th_off << 2; return (TCPEDIT_OK); #endif tcp->th_sum = 0; if (ipv6 != NULL) { sum = do_checksum_math((uint16_t *)&ipv6->ip_src, 32); } else { sum = do_checksum_math((uint16_t *)&ipv4->ip_src, 8); } sum += ntohs(IPPROTO_TCP + len); sum += do_checksum_math((uint16_t *)tcp, len); tcp->th_sum = CHECKSUM_CARRY(sum); break; case IPPROTO_UDP: udp = (udp_hdr_t *)(data + ip_hl); if (udp->uh_sum == 0)  break;  udp->uh_sum = 0; if (ipv6 != NULL) { sum = do_checksum_math((uint16_t *)&ipv6->ip_src, 32); } else { sum = do_checksum_math((uint16_t *)&ipv4->ip_src, 8); } sum += ntohs(IPPROTO_UDP + len); sum += do_checksum_math((uint16_t *)udp, len); udp->uh_sum = CHECKSUM_CARRY(sum); break; case IPPROTO_ICMP: icmp = (icmpv4_hdr_t *)(data + ip_hl); icmp->icmp_sum = 0; if (ipv6 != NULL) { sum = do_checksum_math((uint16_t *)&ipv6->ip_src, 32); icmp->icmp_sum = CHECKSUM_CARRY(sum);                 } sum += do_checksum_math((uint16_t *)icmp, len); icmp->icmp_sum = CHECKSUM_CARRY(sum); break; case IPPROTO_ICMP6: icmp6 = (icmpv6_hdr_t *)(data + ip_hl); icmp6->icmp_sum = 0; if (ipv6 != NULL) { sum = do_checksum_math((u_int16_t *)&ipv6->ip_src, 32); } sum += ntohs(IPPROTO_ICMP6 + len); sum += do_checksum_math((u_int16_t *)icmp6, len); icmp6->icmp_sum = CHECKSUM_CARRY(sum); break; case IPPROTO_IP: if (ipv4) { ipv4->ip_sum = 0; sum = do_checksum_math((uint16_t *)data, ip_hl); ipv4->ip_sum = CHECKSUM_CARRY(sum); } break; case IPPROTO_IGMP: case IPPROTO_GRE: case IPPROTO_OSPF: case IPPROTO_OSPF_LSA: case IPPROTO_VRRP: case TCPR_PROTO_CDP:  case TCPR_PROTO_ISL: default: tcpedit_setwarn(tcpedit, ""Unsupported protocol for checksum: 0x%x"", proto); return TCPEDIT_WARN; } return TCPEDIT_OK; }
Description: An issue was discovered in Tcpreplay 4.3.1. An invalid memory access occurs in do_checksum in checksum.c. It can be triggered by sending a crafted pcap file to the tcpreplay-edit binary. It allows an attacker to cause a Denial of Service (Segmentation fault) or possibly have unspecified other impact.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void r_trie_node_free(RTrieNode **n) { if (!n) { return; } if (!*n) { return; } int i; for (i = 0; i < ALPHABET_SIZE; i++){ r_trie_node_free ((*n)->child[i]); } R_FREE (*n); }
Description: In radare2 2.4.0, there is a heap-based buffer over-read in the dalvik_op function of anal_dalvik.c. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted dex file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int main(int argc, char *argv[]) { FILE *iplist = NULL; plist_t root_node = NULL; char *plist_out = NULL; uint32_t size = 0; int read_size = 0; char *plist_entire = NULL; struct stat filestats; options_t *options = parse_arguments(argc, argv); if (!options) { print_usage(argc, argv); return 0; } iplist = fopen(options->in_file, ""rb""); if (!iplist) { free(options); return 1; } stat(options->in_file, &filestats); plist_entire = (char *) malloc(sizeof(char) * (filestats.st_size + 1)); read_size = fread(plist_entire, sizeof(char), filestats.st_size, iplist); fclose(iplist); if (memcmp(plist_entire, ""bplist00"", 8) == 0) { plist_from_bin(plist_entire, read_size, &root_node); plist_to_xml(root_node, &plist_out, &size); } else { plist_from_xml(plist_entire, read_size, &root_node); plist_to_bin(root_node, &plist_out, &size); } plist_free(root_node); free(plist_entire); if (plist_out) { if (options->out_file != NULL) { FILE *oplist = fopen(options->out_file, ""wb""); if (!oplist) { free(options); return 1; } fwrite(plist_out, size, sizeof(char), oplist); fclose(oplist); } else fwrite(plist_out, size, sizeof(char), stdout); free(plist_out); } else printf(""ERROR: Failed to convert input file.\n""); free(options); return 0; }
Description: The main function in plistutil.c in libimobiledevice libplist through 1.12 allows attackers to obtain sensitive information from process memory or cause a denial of service (buffer over-read) via Apple Property List data that is too short.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool  JpegDecoder::readData( Mat& img ) { volatile bool result = false; int step = (int)img.step; bool color = img.channels() > 1; if( m_state && m_width && m_height ) { jpeg_decompress_struct* cinfo = &((JpegState*)m_state)->cinfo; JpegErrorMgr* jerr = &((JpegState*)m_state)->jerr; JSAMPARRAY buffer = 0; if( setjmp( jerr->setjmp_buffer ) == 0 ) { if ( cinfo->ac_huff_tbl_ptrs[0] == NULL && cinfo->ac_huff_tbl_ptrs[1] == NULL && cinfo->dc_huff_tbl_ptrs[0] == NULL && cinfo->dc_huff_tbl_ptrs[1] == NULL ) { my_jpeg_load_dht( cinfo, my_jpeg_odml_dht, cinfo->ac_huff_tbl_ptrs, cinfo->dc_huff_tbl_ptrs ); } if( color ) { if( cinfo->num_components != 4 ) { cinfo->out_color_space = JCS_RGB; cinfo->out_color_components = 3; } else { cinfo->out_color_space = JCS_CMYK; cinfo->out_color_components = 4; } } else { if( cinfo->num_components != 4 ) { cinfo->out_color_space = JCS_GRAYSCALE; cinfo->out_color_components = 1; } else { cinfo->out_color_space = JCS_CMYK; cinfo->out_color_components = 4; } } jpeg_start_decompress( cinfo ); buffer = (*cinfo->mem->alloc_sarray)((j_common_ptr)cinfo, JPOOL_IMAGE, m_width*4, 1 ); uchar* data = img.ptr(); for( ; m_height--; data += step ) { jpeg_read_scanlines( cinfo, buffer, 1 ); if( color ) { if( cinfo->out_color_components == 3 ) icvCvt_RGB2BGR_8u_C3R( buffer[0], 0, data, 0, cvSize(m_width,1) ); else icvCvt_CMYK2BGR_8u_C4C3R( buffer[0], 0, data, 0, cvSize(m_width,1) ); } else { if( cinfo->out_color_components == 1 ) memcpy( data, buffer[0], m_width ); else icvCvt_CMYK2Gray_8u_C4C1R( buffer[0], 0, data, 0, cvSize(m_width,1) ); } } result = true; jpeg_finish_decompress( cinfo ); } } close(); return result; }
Description: OpenCV (Open Source Computer Vision Library) 3.3 has an out-of-bounds write error in the function FillColorRow1 in utils.cpp when reading an image file by using cv::imread. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-12597.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_rpsi( const void *buf, pj_size_t length, pjmedia_rtcp_fb_rpsi *rpsi) { pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf; pj_uint8_t *p; pj_uint8_t padlen; pj_size_t rpsi_len; PJ_ASSERT_RETURN(buf && rpsi, PJ_EINVAL); PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL); if (hdr->pt != RTCP_PSFB || hdr->count != 3) return PJ_ENOTFOUND; rpsi_len = (pj_ntohs((pj_uint16_t)hdr->length)-2) * 4; if (length < rpsi_len + 12) return PJ_ETOOSMALL; p = (pj_uint8_t*)hdr + sizeof(*hdr); padlen = *p++; rpsi->pt = (*p++ & 0x7F); rpsi->rpsi_bit_len = rpsi_len*8 - 16 - padlen; pj_strset(&rpsi->rpsi, (char*)p, (rpsi->rpsi_bit_len + 7)/8); return PJ_SUCCESS; }
Description: PJSIP is a free and open source multimedia communication library written in C. PJSIP versions 2.12 and prior do not parse incoming RTCP feedback RPSI (Reference Picture Selection Indication) packet, but any app that directly uses pjmedia_rtcp_fb_parse_rpsi() will be affected. A patch is available in the `master` branch of the `pjsip/pjproject` GitHub repository. There are currently no known workarounds.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static MagickBooleanType WritePDBImage(const ImageInfo *image_info,Image *image) { const char *comment; int bits; MagickBooleanType status; PDBImage pdb_image; PDBInfo pdb_info; QuantumInfo *quantum_info; register const PixelPacket *p; register ssize_t x; register unsigned char *q; size_t bits_per_pixel, literal, packets, packet_size, repeat; ssize_t y; unsigned char *buffer, *runlength, *scanline; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); assert(image != (Image *) NULL); assert(image->signature == MagickSignature); if (image->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename); status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception); if (status == MagickFalse) return(status); (void) TransformImageColorspace(image,sRGBColorspace); if ((image -> colors <= 2 ) || (GetImageType(image,&image->exception ) == BilevelType)) { bits_per_pixel=1; } else if (image->colors <= 4) { bits_per_pixel=2; } else if (image->colors <= 8) { bits_per_pixel=3; } else { bits_per_pixel=4; } (void) ResetMagickMemory(&pdb_info,0,sizeof(pdb_info)); (void) CopyMagickString(pdb_info.name,image_info->filename, sizeof(pdb_info.name)); pdb_info.attributes=0; pdb_info.version=0; pdb_info.create_time=time(NULL); pdb_info.modify_time=pdb_info.create_time; pdb_info.archive_time=0; pdb_info.modify_number=0; pdb_info.application_info=0; pdb_info.sort_info=0; (void) CopyMagickMemory(pdb_info.type,""vIMG"",4); (void) CopyMagickMemory(pdb_info.id,""View"",4); pdb_info.seed=0; pdb_info.next_record=0; comment=GetImageProperty(image,""comment""); pdb_info.number_records=(comment == (const char *) NULL ? 1 : 2); (void) WriteBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name); (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.attributes); (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.version); (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.create_time); (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.modify_time); (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.archive_time); (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.modify_number); (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.application_info); (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.sort_info); (void) WriteBlob(image,4,(unsigned char *) pdb_info.type); (void) WriteBlob(image,4,(unsigned char *) pdb_info.id); (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.seed); (void) WriteBlobMSBLong(image,(unsigned int) pdb_info.next_record); (void) WriteBlobMSBShort(image,(unsigned short) pdb_info.number_records); (void) CopyMagickString(pdb_image.name,pdb_info.name,sizeof(pdb_image.name)); pdb_image.version=1;   switch (bits_per_pixel) { case 1: pdb_image.type=(unsigned char) 0xff; break;   case 2: pdb_image.type=(unsigned char) 0x00; break;   default: pdb_image.type=(unsigned char) 0x02;   } pdb_image.reserved_1=0; pdb_image.note=0; pdb_image.x_last=0; pdb_image.y_last=0; pdb_image.reserved_2=0; pdb_image.x_anchor=(unsigned short) 0xffff; pdb_image.y_anchor=(unsigned short) 0xffff; pdb_image.width=(short) image->columns; if (image->columns % 16) pdb_image.width=(short) (16*(image->columns/16+1)); pdb_image.height=(short) image->rows; packets=((bits_per_pixel*image->columns+7)/8); runlength=(unsigned char *) AcquireQuantumMemory(9UL*packets, image->rows*sizeof(*runlength)); if (runlength == (unsigned char *) NULL) ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed""); buffer=(unsigned char *) AcquireQuantumMemory(512,sizeof(*buffer)); if (buffer == (unsigned char *) NULL) ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed""); packet_size=(size_t) (image->depth > 8 ? 2: 1); scanline=(unsigned char *) AcquireQuantumMemory(image->columns,packet_size* sizeof(*scanline)); if (scanline == (unsigned char *) NULL) ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed""); if (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse) (void) TransformImageColorspace(image,sRGBColorspace); quantum_info=AcquireQuantumInfo(image_info,image); if (quantum_info == (QuantumInfo *) NULL) ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed""); bits=8/(int) bits_per_pixel-1;   literal=0; repeat=0; q=runlength; buffer[0]=0x00; for (y=0; y < (ssize_t) image->rows; y++) { p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception); if (p == (const PixelPacket *) NULL) break; (void) ExportQuantumPixels(image,(const CacheView *) NULL,quantum_info, GrayQuantum,scanline,&image->exception); for (x=0; x < (ssize_t) pdb_image.width; x++) { if (x < (ssize_t) image->columns) buffer[literal+repeat]|=(0xff-scanline[x*packet_size]) >> (8-bits_per_pixel) << bits*bits_per_pixel; bits--; if (bits < 0) { if (((literal+repeat) > 0) && (buffer[literal+repeat] == buffer[literal+repeat-1])) { if (repeat == 0) { literal--; repeat++; } repeat++; if (0x7f < repeat) { q=EncodeRLE(q,buffer,literal,repeat); literal=0; repeat=0; } } else { if (repeat >= 2) literal+=repeat; else { q=EncodeRLE(q,buffer,literal,repeat); buffer[0]=buffer[literal+repeat]; literal=0; } literal++; repeat=0; if (0x7f < literal) { q=EncodeRLE(q,buffer,(literal < 0x80 ? literal : 0x80),0); (void) CopyMagickMemory(buffer,buffer+literal+repeat,0x80); literal-=0x80; } } bits=8/(int) bits_per_pixel-1; buffer[literal+repeat]=0x00; } } status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } q=EncodeRLE(q,buffer,literal,repeat); scanline=(unsigned char *) RelinquishMagickMemory(scanline); buffer=(unsigned char *) RelinquishMagickMemory(buffer); quantum_info=DestroyQuantumInfo(quantum_info); (void) WriteBlobMSBLong(image,(unsigned int) (TellBlob(image)+8* pdb_info.number_records)); (void) WriteBlobByte(image,0x40); (void) WriteBlobByte(image,0x6f); (void) WriteBlobByte(image,0x80); (void) WriteBlobByte(image,0); if (pdb_info.number_records > 1) { (void) WriteBlobMSBLong(image,(unsigned int) (TellBlob(image)+8+58+q- runlength)); (void) WriteBlobByte(image,0x40); (void) WriteBlobByte(image,0x6f); (void) WriteBlobByte(image,0x80); (void) WriteBlobByte(image,1); } (void) WriteBlob(image,sizeof(pdb_image.name),(unsigned char *) pdb_image.name); (void) WriteBlobByte(image,(unsigned char) pdb_image.version); (void) WriteBlobByte(image,pdb_image.type); (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.reserved_1); (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.note); (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.x_last); (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.y_last); (void) WriteBlobMSBLong(image,(unsigned int) pdb_image.reserved_2); (void) WriteBlobMSBShort(image,pdb_image.x_anchor); (void) WriteBlobMSBShort(image,pdb_image.y_anchor); (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.width); (void) WriteBlobMSBShort(image,(unsigned short) pdb_image.height); (void) WriteBlob(image,(size_t) (q-runlength),runlength); runlength=(unsigned char *) RelinquishMagickMemory(runlength); if (pdb_info.number_records > 1) (void) WriteBlobString(image,comment); (void) CloseBlob(image); return(MagickTrue); }
Description: Buffer overflow in the WriteMAPImage function in coders/map.c in ImageMagick before 6.9.5-8 allows remote attackers to cause a denial of service (application crash) or have other unspecified impact via a crafted file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static json_t * check_attestation_fido_u2f(json_t * j_params, unsigned char * credential_id, size_t credential_id_len, unsigned char * cert_x, size_t cert_x_len, unsigned char * cert_y, size_t cert_y_len, cbor_item_t * att_stmt, unsigned char * rpid_hash, size_t rpid_hash_len, const unsigned char * client_data) { json_t * j_error = json_array(), * j_return; cbor_item_t * key = NULL, * x5c = NULL, * sig = NULL, * att_cert = NULL; int i, ret; char * message = NULL; gnutls_pubkey_t pubkey = NULL; gnutls_x509_crt_t cert = NULL; gnutls_datum_t cert_dat, data, signature, cert_issued_by; unsigned char data_signed[200], client_data_hash[32], cert_export[32], cert_export_b64[64]; size_t data_signed_offset = 0, client_data_hash_len = 32, cert_export_len = 32, cert_export_b64_len = 0; if (j_error != NULL) { do { if (gnutls_x509_crt_init(&cert)) { json_array_append_new(j_error, json_string(""check_attestation_fido_u2f - Error gnutls_x509_crt_init"")); break; } if (gnutls_pubkey_init(&pubkey)) { json_array_append_new(j_error, json_string(""check_attestation_fido_u2f - Error gnutls_pubkey_init"")); break; } if (att_stmt == NULL || !cbor_isa_map(att_stmt) || cbor_map_size(att_stmt) != 2) { json_array_append_new(j_error, json_string(""CBOR map value 'attStmt' invalid format"")); break; } for (i=0; i<2; i++) { key = cbor_map_handle(att_stmt)[i].key; if (cbor_isa_string(key)) { if (0 == o_strncmp((const char *)cbor_string_handle(key), ""x5c"", MIN(o_strlen(""x5c""), cbor_string_length(key)))) { x5c = cbor_map_handle(att_stmt)[i].value; } else if (0 == o_strncmp((const char *)cbor_string_handle(key), ""sig"", MIN(o_strlen(""sig""), cbor_string_length(key)))) { sig = cbor_map_handle(att_stmt)[i].value; } else { message = msprintf(""attStmt map element %d key is not valid: '%.*s'"", i, cbor_string_length(key), cbor_string_handle(key)); json_array_append_new(j_error, json_string(message)); o_free(message); break; } } else { message = msprintf(""attStmt map element %d key is not a string"", i); json_array_append_new(j_error, json_string(message)); o_free(message); break; } } if (x5c == NULL || !cbor_isa_array(x5c) || cbor_array_size(x5c) != 1) { json_array_append_new(j_error, json_string(""CBOR map value 'x5c' invalid format"")); break; } att_cert = cbor_array_get(x5c, 0); cert_dat.data = cbor_bytestring_handle(att_cert); cert_dat.size = cbor_bytestring_length(att_cert); if ((ret = gnutls_x509_crt_import(cert, &cert_dat, GNUTLS_X509_FMT_DER)) < 0) { json_array_append_new(j_error, json_string(""Error importing x509 certificate"")); y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Error gnutls_pcert_import_x509_raw: %d"", ret); break; } if (json_object_get(j_params, ""root-ca-list"") != json_null() && validate_certificate_from_root(j_params, cert, x5c) != G_OK) { json_array_append_new(j_error, json_string(""Unrecognized certificate authority"")); if (gnutls_x509_crt_get_issuer_dn2(cert, &cert_issued_by) >= 0) { message = msprintf(""Unrecognized certificate autohority: %.*s"", cert_issued_by.size, cert_issued_by.data); y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - %s"", message); o_free(message); gnutls_free(cert_issued_by.data); } else { y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Unrecognized certificate autohority (unable to get issuer dn)""); } break; } if ((ret = gnutls_pubkey_import_x509(pubkey, cert, 0)) < 0) { json_array_append_new(j_error, json_string(""Error importing x509 certificate"")); y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Error gnutls_pubkey_import_x509: %d"", ret); break; } if ((ret = gnutls_x509_crt_get_key_id(cert, GNUTLS_KEYID_USE_SHA256, cert_export, &cert_export_len)) < 0) { json_array_append_new(j_error, json_string(""Error exporting x509 certificate"")); y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Error gnutls_x509_crt_get_key_id: %d"", ret); break; } if (!o_base64_encode(cert_export, cert_export_len, cert_export_b64, &cert_export_b64_len)) { json_array_append_new(j_error, json_string(""Internal error"")); y_log_message(Y_LOG_LEVEL_DEBUG, ""check_attestation_fido_u2f - Error o_base64_encode cert_export""); break; } if (!generate_digest_raw(digest_SHA256, client_data, o_strlen((char *)client_data), client_data_hash, &client_data_hash_len)) { json_array_append_new(j_error, json_string(""Internal error"")); y_log_message(Y_LOG_LEVEL_ERROR, ""check_attestation_fido_u2f - Error generate_digest_raw client_data""); break; } if (sig == NULL || !cbor_isa_bytestring(sig)) { json_array_append_new(j_error, json_string(""Error sig is not a bytestring"")); break; } data_signed[0] = 0x0; data_signed_offset = 1; memcpy(data_signed+data_signed_offset, rpid_hash, rpid_hash_len); data_signed_offset += rpid_hash_len; memcpy(data_signed+data_signed_offset, client_data_hash, client_data_hash_len); data_signed_offset+=client_data_hash_len; memcpy(data_signed+data_signed_offset, credential_id, credential_id_len); data_signed_offset+=credential_id_len; data_signed[data_signed_offset] = 0x04; data_signed_offset++; memcpy(data_signed+data_signed_offset, cert_x, cert_x_len); data_signed_offset+=cert_x_len; memcpy(data_signed+data_signed_offset, cert_y, cert_y_len); data_signed_offset+=cert_y_len; data.data = data_signed; data.size = data_signed_offset; signature.data = cbor_bytestring_handle(sig); signature.size = cbor_bytestring_length(sig); if (gnutls_pubkey_verify_data2(pubkey, GNUTLS_SIGN_ECDSA_SHA256, 0, &data, &signature)) { json_array_append_new(j_error, json_string(""Invalid signature"")); } } while (0); if (json_array_size(j_error)) { j_return = json_pack(""{sisO}"", ""result"", G_ERROR_PARAM, ""error"", j_error); } else { j_return = json_pack(""{sis{ss%}}"", ""result"", G_OK, ""data"", ""certificate"", cert_export_b64, cert_export_b64_len); } json_decref(j_error); gnutls_pubkey_deinit(pubkey); gnutls_x509_crt_deinit(cert); if (att_cert != NULL) { cbor_decref(&att_cert); } } else { y_log_message(Y_LOG_LEVEL_ERROR, ""check_attestation_fido_u2f - Error allocating resources for j_error""); j_return = json_pack(""{si}"", ""result"", G_ERROR); } return j_return; }
Description: scheme/webauthn.c in Glewlwyd SSO server through 2.5.3 has a buffer overflow during FIDO2 signature validation in webauthn registration.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static PSDP_OPTION getAttributesList(char*urlSafeAddr) { PSDP_OPTION optionHead; char payloadStr[92]; int audioChannelCount; int audioChannelMask; int err; optionHead = NULL; err = 0; sprintf(payloadStr, ""%d"", StreamConfig.width); err |= addAttributeString(&optionHead, ""x-nv-video[0].clientViewportWd"", payloadStr); sprintf(payloadStr, ""%d"", StreamConfig.height); err |= addAttributeString(&optionHead, ""x-nv-video[0].clientViewportHt"", payloadStr); sprintf(payloadStr, ""%d"", StreamConfig.fps); err |= addAttributeString(&optionHead, ""x-nv-video[0].maxFPS"", payloadStr); sprintf(payloadStr, ""%d"", StreamConfig.packetSize); err |= addAttributeString(&optionHead, ""x-nv-video[0].packetSize"", payloadStr); err |= addAttributeString(&optionHead, ""x-nv-video[0].rateControlMode"", ""4""); err |= addAttributeString(&optionHead, ""x-nv-video[0].timeoutLengthMs"", ""7000""); err |= addAttributeString(&optionHead, ""x-nv-video[0].framesWithInvalidRefThreshold"", ""0""); sprintf(payloadStr, ""%d"", StreamConfig.bitrate); if (ServerMajorVersion >= 5) { err |= addAttributeString(&optionHead, ""x-nv-vqos[0].bw.minimumBitrateKbps"", payloadStr); err |= addAttributeString(&optionHead, ""x-nv-vqos[0].bw.maximumBitrateKbps"", payloadStr); } else { if (StreamConfig.streamingRemotely) { err |= addAttributeString(&optionHead, ""x-nv-video[0].averageBitrate"", ""4""); err |= addAttributeString(&optionHead, ""x-nv-video[0].peakBitrate"", ""4""); } err |= addAttributeString(&optionHead, ""x-nv-vqos[0].bw.minimumBitrate"", payloadStr); err |= addAttributeString(&optionHead, ""x-nv-vqos[0].bw.maximumBitrate"", payloadStr); } err |= addAttributeString(&optionHead, ""x-nv-vqos[0].fec.enable"", ""0""); err |= addAttributeString(&optionHead, ""x-nv-vqos[0].videoQualityScoreUpdateTime"", ""5000""); if (StreamConfig.streamingRemotely) { err |= addAttributeString(&optionHead, ""x-nv-vqos[0].qosTrafficType"", ""0""); err |= addAttributeString(&optionHead, ""x-nv-aqos.qosTrafficType"", ""0""); } else { err |= addAttributeString(&optionHead, ""x-nv-vqos[0].qosTrafficType"", ""5""); err |= addAttributeString(&optionHead, ""x-nv-aqos.qosTrafficType"", ""4""); } if (ServerMajorVersion == 3) { err |= addGen3Options(&optionHead, urlSafeAddr); } else if (ServerMajorVersion == 4) { err |= addGen4Options(&optionHead, urlSafeAddr); } else { err |= addGen5Options(&optionHead); } if (ServerMajorVersion >= 4) { if (NegotiatedVideoFormat == VIDEO_FORMAT_H265) { err |= addAttributeString(&optionHead, ""x-nv-clientSupportHevc"", ""1""); err |= addAttributeString(&optionHead, ""x-nv-vqos[0].bitStreamFormat"", ""1""); err |= addAttributeString(&optionHead, ""x-nv-video[0].videoEncoderSlicesPerFrame"", ""1""); } else { unsigned char slicesPerFrame; err |= addAttributeString(&optionHead, ""x-nv-clientSupportHevc"", ""0""); err |= addAttributeString(&optionHead, ""x-nv-vqos[0].bitStreamFormat"", ""0""); slicesPerFrame = (unsigned char)(VideoCallbacks.capabilities >> 24); if (slicesPerFrame == 0) { slicesPerFrame = 1; } sprintf(payloadStr, ""%d"", slicesPerFrame); err |= addAttributeString(&optionHead, ""x-nv-video[0].videoEncoderSlicesPerFrame"", payloadStr); } if (StreamConfig.audioConfiguration == AUDIO_CONFIGURATION_51_SURROUND) { audioChannelCount = CHANNEL_COUNT_51_SURROUND; audioChannelMask = CHANNEL_MASK_51_SURROUND; } else { audioChannelCount = CHANNEL_COUNT_STEREO; audioChannelMask = CHANNEL_MASK_STEREO; } sprintf(payloadStr, ""%d"", audioChannelCount); err |= addAttributeString(&optionHead, ""x-nv-audio.surround.numChannels"", payloadStr); sprintf(payloadStr, ""%d"", audioChannelMask); err |= addAttributeString(&optionHead, ""x-nv-audio.surround.channelMask"", payloadStr); if (audioChannelCount > 2) { err |= addAttributeString(&optionHead, ""x-nv-audio.surround.enable"", ""1""); } else { err |= addAttributeString(&optionHead, ""x-nv-audio.surround.enable"", ""0""); } } if (err == 0) { return optionHead; } freeAttributeList(optionHead); return NULL; }
Description: Moonlight-common-c contains the core GameStream client code shared between Moonlight clients. Moonlight-common-c is vulnerable to buffer overflow starting in commit f57bd745b4cbed577ea654fad4701bea4d38b44c. A malicious game streaming server could exploit a buffer overflow vulnerability to crash a moonlight client. Achieving RCE is possible but unlikely, due to stack canaries in use by modern compiler toolchains. The published binaries for official clients Qt, Android, iOS/tvOS, and Embedded are built with stack canaries, but some unofficial clients may not use stack canaries. This vulnerability takes place after the pairing process, so it requires the client to be tricked into pairing to a malicious host. It is not possible to perform using a man-in-the-middle due to public key pinning that takes place during the pairing process. The bug was addressed in commit b2497a3918a6d79808d9fd0c04734786e70d5954.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: u32 gf_bs_read_ue_log_idx3(GF_BitStream *bs, const char *fname, s32 idx1, s32 idx2, s32 idx3) { u32 val=0, code; s32 nb_lead = -1; u32 bits = 0; for (code=0; !code; nb_lead++) { if (nb_lead>=32) { if (!gf_bs_available(bs)) { GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[Core] exp-golomb read failed, not enough bits in bitstream !\n"")); } else { GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[Core] corrupted exp-golomb code, %d leading zeros, max 31 allowed !\n"", nb_lead)); } return 0; } code = gf_bs_read_int(bs, 1); bits++; } if (nb_lead) { val = gf_bs_read_int(bs, nb_lead); val += (1 << nb_lead) - 1; bits += nb_lead; } if (fname) { gf_bs_log_idx(bs, bits, fname, val, idx1, idx2, idx3); } return val; }
Description: A Segmentation fault caused by null pointer dereference vulnerability eists in Gpac through 1.0.2 via the avc_parse_slice function in av_parsers.c when using mp4box, which causes a denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void Compute(OpKernelContext* context) override { typedef Eigen::Map<const Eigen::Matrix<T, Eigen::Dynamic, Eigen::Dynamic>> ConstEigenMatrixMap; typedef Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, Eigen::Dynamic>> EigenDoubleMatrixMap; const Tensor& orig_input_tensor_shape = context->input(0); OP_REQUIRES(context, orig_input_tensor_shape.dims() == 1 && orig_input_tensor_shape.NumElements() == 4, errors::InvalidArgument(""original input tensor shape must be"" ""1-dimensional and 4 elements"")); const Tensor& out_backprop = context->input(1); const Tensor& row_seq_tensor = context->input(2); const Tensor& col_seq_tensor = context->input(3); const int64_t out_batch = out_backprop.dim_size(0); const int64_t out_rows = out_backprop.dim_size(1); const int64_t out_cols = out_backprop.dim_size(2); const int64_t out_depth = out_backprop.dim_size(3); OP_REQUIRES(context, row_seq_tensor.NumElements() > out_rows, errors::InvalidArgument(""Given out_backprop shape "", out_backprop.shape().DebugString(), "", row_seq_tensor must have at least "", out_rows + 1, "" elements, but got "", row_seq_tensor.NumElements())); OP_REQUIRES(context, col_seq_tensor.NumElements() > out_cols, errors::InvalidArgument(""Given out_backprop shape "", out_backprop.shape().DebugString(), "", col_seq_tensor must have at least "", out_cols + 1, "" elements, but got "", col_seq_tensor.NumElements())); auto row_seq_tensor_flat = row_seq_tensor.flat<int64>(); auto col_seq_tensor_flat = col_seq_tensor.flat<int64>(); auto orig_input_tensor_shape_flat = orig_input_tensor_shape.flat<int64>(); const int64_t in_batch = orig_input_tensor_shape_flat(0); const int64_t in_rows = orig_input_tensor_shape_flat(1); const int64_t in_cols = orig_input_tensor_shape_flat(2); const int64_t in_depth = orig_input_tensor_shape_flat(3); constexpr int tensor_in_and_out_dims = 4; TensorShape in_shape; for (auto i = 0; i < tensor_in_and_out_dims; ++i) { in_shape.AddDim(orig_input_tensor_shape_flat(i)); } Tensor in_backprop_tensor_temp; OP_REQUIRES_OK(context, context->forward_input_or_allocate_temp( {0}, DataTypeToEnum<double>::v(), in_shape, &in_backprop_tensor_temp)); in_backprop_tensor_temp.flat<double>().setZero(); EigenDoubleMatrixMap in_backprop_tensor_temp_mat( in_backprop_tensor_temp.flat<double>().data(), in_depth, in_cols * in_rows * in_batch); ConstEigenMatrixMap out_backprop_mat(out_backprop.flat<T>().data(), out_depth, out_cols * out_rows * out_batch); const int64_t in_max_row_index = in_rows - 1; const int64_t in_max_col_index = in_cols - 1; for (int64_t b = 0; b < out_batch; ++b) { for (int64_t r = 0; r < out_rows; ++r) { const int64_t in_row_start = row_seq_tensor_flat(r); int64_t in_row_end = overlapping_ ? row_seq_tensor_flat(r + 1) : row_seq_tensor_flat(r + 1) - 1; in_row_end = std::min(in_row_end, in_max_row_index); for (int64_t c = 0; c < out_cols; ++c) { const int64_t in_col_start = col_seq_tensor_flat(c); int64_t in_col_end = overlapping_ ? col_seq_tensor_flat(c + 1) : col_seq_tensor_flat(c + 1) - 1; in_col_end = std::min(in_col_end, in_max_col_index); const int64_t num_elements_in_pooling_cell = (in_row_end - in_row_start + 1) * (in_col_end - in_col_start + 1); const int64_t out_index = (b * out_rows + r) * out_cols + c; for (int64_t in_r = in_row_start; in_r <= in_row_end; ++in_r) { for (int64_t in_c = in_col_start; in_c <= in_col_end; ++in_c) { const int64_t in_index = (b * in_rows + in_r) * in_cols + in_c; for (int64_t d = 0; d < out_depth; ++d) { const double out_backprop_element = static_cast<double>( out_backprop_mat.coeffRef(d, out_index)); double& in_backprop_ref = in_backprop_tensor_temp_mat.coeffRef(d, in_index); in_backprop_ref += out_backprop_element / num_elements_in_pooling_cell; } } } } } } Tensor* in_backprop_tensor = nullptr; OP_REQUIRES_OK(context, context->forward_input_or_allocate_output( {0}, 0, in_shape, &in_backprop_tensor)); auto in_backprop_tensor_flat = in_backprop_tensor->flat<T>(); auto in_backprop_tensor_temp_flat = in_backprop_tensor_temp.flat<double>(); for (int64_t i = 0; i < in_backprop_tensor_flat.size(); ++i) { in_backprop_tensor_flat(i) = static_cast<T>(in_backprop_tensor_temp_flat(i)); } }
Description: TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation for `tf.raw_ops.FractionalAvgPoolGrad` can be tricked into accessing data outside of bounds of heap allocated buffers. The [implementation](https://github.com/tensorflow/tensorflow/blob/f24faa153ad31a4b51578f8181d3aaab77a1ddeb/tensorflow/core/kernels/fractional_avg_pool_op.cc#L205) does not validate that the input tensor is non-empty. Thus, code constructs an empty `EigenDoubleMatrixMap` and then accesses this buffer with indices that are outside of the empty area. We have patched the issue in GitHub commit 0f931751fb20f565c4e94aa6df58d54a003cdb30. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: GF_Err gf_isom_box_parse_ex(GF_Box **outBox, GF_BitStream *bs, u32 parent_type, Bool is_root_box) { u32 type, uuid_type, hdr_size; u64 size, start, payload_start, end; char uuid[16]; GF_Err e; GF_Box *newBox; Bool skip_logs = gf_bs_get_cookie(bs) ? GF_TRUE : GF_FALSE; Bool is_special = GF_TRUE; if ((bs == NULL) || (outBox == NULL) ) return GF_BAD_PARAM; *outBox = NULL; if (gf_bs_available(bs) < 8) { return GF_ISOM_INCOMPLETE_FILE; } start = gf_bs_get_position(bs); uuid_type = 0; size = (u64) gf_bs_read_u32(bs); hdr_size = 4; if ((size >= 2) && (size <= 4)) { size = 4; type = GF_ISOM_BOX_TYPE_VOID; } else { type = gf_bs_read_u32(bs); hdr_size += 4; if (type == GF_ISOM_BOX_TYPE_TOTL) size = 12; if (!size) { if (is_root_box) { if (!skip_logs) { GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Warning Read Box type %s (0x%08X) size 0 reading till the end of file\n"", gf_4cc_to_str(type), type)); } size = gf_bs_available(bs) + 8; } else { if (!skip_logs) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box type %s (0x%08X) at position ""LLU"" has size 0 but is not at root/file level, skipping\n"", gf_4cc_to_str(type), type, start)); } return GF_OK; } } } memset(uuid, 0, 16); if (type == GF_ISOM_BOX_TYPE_UUID ) { if (gf_bs_available(bs) < 16) { return GF_ISOM_INCOMPLETE_FILE; } gf_bs_read_data(bs, uuid, 16); hdr_size += 16; uuid_type = gf_isom_solve_uuid_box(uuid); } if (size == 1) { if (gf_bs_available(bs) < 8) { return GF_ISOM_INCOMPLETE_FILE; } size = gf_bs_read_u64(bs); hdr_size += 8; } GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Read Box type %s size ""LLD"" start ""LLD""\n"", gf_4cc_to_str(type), LLD_CAST size, LLD_CAST start)); if ( size < hdr_size ) { GF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (""[iso file] Box size ""LLD"" less than box header size %d\n"", LLD_CAST size, hdr_size)); return GF_ISOM_INVALID_FILE; } if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TREF)) { newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFT); if (!newBox) return GF_OUT_OF_MEM; ((GF_TrackReferenceTypeBox*)newBox)->reference_type = type; } else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_IREF)) { newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_REFI); if (!newBox) return GF_OUT_OF_MEM; ((GF_ItemReferenceTypeBox*)newBox)->reference_type = type; } else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_TRGR)) { newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_TRGT); if (!newBox) return GF_OUT_OF_MEM; ((GF_TrackGroupTypeBox*)newBox)->group_type = type; } else if (parent_type && (parent_type == GF_ISOM_BOX_TYPE_GRPL)) { newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_GRPT); if (!newBox) return GF_OUT_OF_MEM; ((GF_EntityToGroupTypeBox*)newBox)->grouping_type = type; } else { is_special = GF_FALSE; newBox = gf_isom_box_new_ex(uuid_type ? uuid_type : type, parent_type, skip_logs, is_root_box); if (!newBox) return GF_OUT_OF_MEM; } if (type==GF_ISOM_BOX_TYPE_UUID && !is_special) { memcpy(((GF_UUIDBox *)newBox)->uuid, uuid, 16); ((GF_UUIDBox *)newBox)->internal_4cc = uuid_type; } if (!newBox->type) newBox->type = type; payload_start = gf_bs_get_position(bs); retry_unknown_box: end = gf_bs_available(bs); if (size - hdr_size > end ) { newBox->size = size - hdr_size - end; *outBox = newBox; return GF_ISOM_INCOMPLETE_FILE; } newBox->size = size - hdr_size; if (newBox->size) { e = gf_isom_full_box_read(newBox, bs); if (!e) e = gf_isom_box_read(newBox, bs); newBox->size = size; end = gf_bs_get_position(bs); } else { newBox->size = size; e = GF_OK; end = gf_bs_get_position(bs); } if (e && (e != GF_ISOM_INCOMPLETE_FILE)) { gf_isom_box_del(newBox); *outBox = NULL; if (parent_type==GF_ISOM_BOX_TYPE_STSD) { newBox = gf_isom_box_new(GF_ISOM_BOX_TYPE_UNKNOWN); ((GF_UnknownBox *)newBox)->original_4cc = type; newBox->size = size; gf_bs_seek(bs, payload_start); goto retry_unknown_box; } if (!skip_logs) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Read Box \""%s\"" (start ""LLU"") failed (%s) - skipping\n"", gf_4cc_to_str(type), start, gf_error_to_string(e))); } return e; } if (end-start > size) { if (!skip_logs) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box \""%s\"" size ""LLU"" (start ""LLU"") invalid (read ""LLU"")\n"", gf_4cc_to_str(type), LLU_CAST size, start, LLU_CAST (end-start) )); } gf_bs_seek(bs, start+size); } else if (end-start < size) { u32 to_skip = (u32) (size-(end-start)); if (!skip_logs) { if ((to_skip!=4) || gf_bs_peek_bits(bs, 32, 0)) { GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] Box \""%s\"" (start ""LLU"") has %u extra bytes\n"", gf_4cc_to_str(type), start, to_skip)); } } gf_bs_skip_bytes(bs, to_skip); } *outBox = newBox; return e; }
Description: A Null pointer dereference vulnerability exits in MP4Box - GPAC version 0.8.0-rev177-g51a8ef874-master via the gf_isom_get_track_id function, which causes a denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static inline int __mod_timer(struct timer_list *timer, unsigned long expires, bool pending_only) { struct timer_base *base, *new_base; unsigned int idx = UINT_MAX; unsigned long clk = 0, flags; int ret = 0; BUG_ON(!timer->function); if (timer_pending(timer)) { if (timer->expires == expires) return 1; base = lock_timer_base(timer, &flags); clk = base->clk; idx = calc_wheel_index(expires, clk); if (idx == timer_get_idx(timer)) { timer->expires = expires; ret = 1; goto out_unlock; } } else { base = lock_timer_base(timer, &flags); } timer_stats_timer_set_start_info(timer); ret = detach_if_pending(timer, base, false); if (!ret && pending_only) goto out_unlock; debug_activate(timer, expires); new_base = get_target_base(base, timer->flags); if (base != new_base) { if (likely(base->running_timer != timer)) { timer->flags |= TIMER_MIGRATING; spin_unlock(&base->lock); base = new_base; spin_lock(&base->lock); WRITE_ONCE(timer->flags, (timer->flags & ~TIMER_BASEMASK) | base->cpu); } } forward_timer_base(base); timer->expires = expires; if (idx != UINT_MAX && clk == base->clk) { enqueue_timer(base, timer, idx); trigger_dyntick_cpu(base, timer); } else { internal_add_timer(base, timer); } out_unlock: spin_unlock_irqrestore(&base->lock, flags); return ret; }
Description: The time subsystem in the Linux kernel through 4.9.9, when CONFIG_TIMER_STATS is enabled, allows local users to discover real PID values (as distinguished from PID values inside a PID namespace) by reading the /proc/timer_list file, related to the print_timer function in kernel/time/timer_list.c and the __timer_stats_timer_set_start_info function in kernel/time/timer.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static enum TIFFReadDirEntryErr TIFFReadDirEntryArrayWithLimit(TIFF *tif, TIFFDirEntry *direntry, uint32_t *count, uint32_t desttypesize, void **value, uint64_t maxcount) { int typesize; uint32_t datasize; void *data; uint64_t target_count64; int original_datasize_clamped; typesize = TIFFDataWidth(direntry->tdir_type); target_count64 = (direntry->tdir_count > maxcount) ? maxcount : direntry->tdir_count; if ((target_count64 == 0) || (typesize == 0)) { *value = 0; return (TIFFReadDirEntryErrOk); } (void)desttypesize; original_datasize_clamped = ((direntry->tdir_count > 10) ? 10 : (int)direntry->tdir_count) * typesize; if ((uint64_t)(MAX_SIZE_TAG_DATA / typesize) < target_count64) return (TIFFReadDirEntryErrSizesan); if ((uint64_t)(MAX_SIZE_TAG_DATA / desttypesize) < target_count64) return (TIFFReadDirEntryErrSizesan); *count = (uint32_t)target_count64; datasize = (*count) * typesize; assert((tmsize_t)datasize > 0); if (isMapped(tif) && datasize > (uint64_t)tif->tif_size) return TIFFReadDirEntryErrIo; if (!isMapped(tif) && (((tif->tif_flags & TIFF_BIGTIFF) && datasize > 8) || (!(tif->tif_flags & TIFF_BIGTIFF) && datasize > 4))) { data = NULL; } else { data = _TIFFCheckMalloc(tif, *count, typesize, ""ReadDirEntryArray""); if (data == 0) return (TIFFReadDirEntryErrAlloc); } if (!(tif->tif_flags & TIFF_BIGTIFF)) { if (original_datasize_clamped <= 4 && datasize <= 4) _TIFFmemcpy(data, &direntry->tdir_offset, datasize); else { enum TIFFReadDirEntryErr err; uint32_t offset = direntry->tdir_offset.toff_long; if (tif->tif_flags & TIFF_SWAB) TIFFSwabLong(&offset); if (isMapped(tif)) err = TIFFReadDirEntryData(tif, (uint64_t)offset, (tmsize_t)datasize, data); else err = TIFFReadDirEntryDataAndRealloc(tif, (uint64_t)offset, (tmsize_t)datasize, &data); if (err != TIFFReadDirEntryErrOk) { _TIFFfreeExt(tif, data); return (err); } } } else { if (original_datasize_clamped <= 8 && datasize <= 8) _TIFFmemcpy(data, &direntry->tdir_offset, datasize); else { enum TIFFReadDirEntryErr err; uint64_t offset = direntry->tdir_offset.toff_long8; if (tif->tif_flags & TIFF_SWAB) TIFFSwabLong8(&offset); if (isMapped(tif)) err = TIFFReadDirEntryData(tif, (uint64_t)offset, (tmsize_t)datasize, data); else err = TIFFReadDirEntryDataAndRealloc(tif, (uint64_t)offset, (tmsize_t)datasize, &data); if (err != TIFFReadDirEntryErrOk) { _TIFFfreeExt(tif, data); return (err); } } } *value = data; return (TIFFReadDirEntryErrOk); }
Description: An out-of-memory flaw was found in libtiff. Passing a crafted tiff file to TIFFOpen() API may allow a remote attacker to cause a denial of service via a craft input with size smaller than 379 KB.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: R_API RBinJavaAttrInfo *r_bin_java_rti_annotations_attr_new(RBinJavaObj *bin, ut8 *buffer, ut64 sz, ut64 buf_offset) { ut32 i = 0; RBinJavaAttrInfo *attr = NULL; ut64 offset = 0; attr = r_bin_java_default_attr_new (bin, buffer, sz, buf_offset); offset += 6; if (attr) { attr->type = R_BIN_JAVA_ATTR_TYPE_RUNTIME_INVISIBLE_ANNOTATION_ATTR; attr->info.annotation_array.num_annotations = R_BIN_JAVA_USHORT (buffer, offset); offset += 2; attr->info.annotation_array.annotations = r_list_newf (r_bin_java_annotation_free); for (i = 0; i < attr->info.rtv_annotations_attr.num_annotations; i++) { if (offset >= sz) { break; } RBinJavaAnnotation *annotation = r_bin_java_annotation_new (buffer + offset, sz - offset, buf_offset + offset); if (annotation) { offset += annotation->size; } r_list_append (attr->info.annotation_array.annotations, (void *) annotation); } attr->size = offset; } return attr; }
Description: Out-of-bounds Read in r_bin_java_constant_value_attr_new function in GitHub repository radareorg/radare2 prior to 5.7.0. The bug causes the program reads data past the end 2f the intented buffer. Typically, this can allow attackers to read sensitive information from other memory locations or cause a crash. More details see [CWE-125: Out-of-bounds read](https://cwe.mitre.org/data/definitions/125.html).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static bool has_locked_children(struct mount *mnt, struct dentry *dentry) { struct mount *child; list_for_each_entry(child, &mnt->mnt_mounts, mnt_child) { if (!is_subdir(child->mnt_mountpoint, dentry)) continue; if (child->mnt.mnt_flags & MNT_LOCKED) return true; } return false; }
Description: A flaw was found in the Linux kernel's OverlayFS subsystem in the way the user mounts the TmpFS filesystem with OverlayFS. This flaw allows a local user to gain access to hidden files that should not be accessible.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void PackLinuxElf64::PackLinuxElf64help1(InputFile *f) { e_type  = get_te16(&ehdri.e_type); e_phnum = get_te16(&ehdri.e_phnum); e_shnum = get_te16(&ehdri.e_shnum); unsigned const e_phentsize = get_te16(&ehdri.e_phentsize); if (ehdri.e_ident[Elf64_Ehdr::EI_CLASS]!=Elf64_Ehdr::ELFCLASS64 || sizeof(Elf64_Phdr) != e_phentsize || (Elf64_Ehdr::ELFDATA2MSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA] && &N_BELE_RTP::be_policy != bele) || (Elf64_Ehdr::ELFDATA2LSB == ehdri.e_ident[Elf64_Ehdr::EI_DATA] && &N_BELE_RTP::le_policy != bele)) { e_phoff = 0; e_shoff = 0; sz_phdrs = 0; return; } if (0==e_phnum) throwCantUnpack(""0==e_phnum""); e_phoff = get_te64(&ehdri.e_phoff); upx_uint64_t const last_Phdr = e_phoff + e_phnum * sizeof(Elf64_Phdr); if (last_Phdr < e_phoff      ||  e_phoff != sizeof(Elf64_Ehdr)      ||  (unsigned long)file_size < last_Phdr) { throwCantUnpack(""bad e_phoff""); } e_shoff = get_te64(&ehdri.e_shoff); upx_uint64_t const last_Shdr = e_shoff + e_shnum * sizeof(Elf64_Shdr); if (last_Shdr < e_shoff      ||  (e_shnum && e_shoff < last_Phdr) ||  (unsigned long)file_size < last_Shdr) { if (opt->cmd == CMD_COMPRESS) { throwCantUnpack(""bad e_shoff""); } } sz_phdrs = e_phnum * e_phentsize; sz_elf_hdrs = sz_phdrs + sizeof(Elf64_Ehdr); if (f && Elf64_Ehdr::ET_DYN!=e_type) { unsigned const len = sz_phdrs + e_phoff; alloc_file_image(file_image, len); f->seek(0, SEEK_SET); f->readx(file_image, len); phdri= (Elf64_Phdr       *)(e_phoff + file_image);      } if (f && Elf64_Ehdr::ET_DYN==e_type) { alloc_file_image(file_image, file_size); f->seek(0, SEEK_SET); f->readx(file_image, file_size); phdri= (Elf64_Phdr *)(e_phoff + file_image);          shdri= (Elf64_Shdr *)(e_shoff + file_image);          if (opt->cmd != CMD_COMPRESS) { shdri = nullptr; } sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM); if (sec_dynsym) { unsigned t = get_te32(&sec_dynsym->sh_link); if (e_shnum <= t) throwCantPack(""bad dynsym->sh_link""); sec_dynstr = &shdri[t]; } Elf64_Phdr const *phdr= phdri; for (int j = e_phnum; --j>=0; ++phdr) if (Elf64_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) { upx_uint64_t offset = check_pt_dynamic(phdr); dynseg= (Elf64_Dyn const *)(offset + file_image); invert_pt_dynamic(dynseg, umin(get_te64(&phdr->p_filesz), file_size - offset)); } else if (PT_LOAD64==get_te32(&phdr->p_type)) { check_pt_load(phdr); } dynstr =      (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB); dynsym = (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB); gashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_GNU_HASH); hashtab = (unsigned const *)elf_find_dynamic(Elf64_Dyn::DT_HASH); if (3& ((upx_uintptr_t)dynsym | (upx_uintptr_t)gashtab | (upx_uintptr_t)hashtab)) { throwCantPack(""unaligned DT_SYMTAB, DT_GNU_HASH, or DT_HASH/n""); } jni_onload_sym = elf_lookup(""JNI_OnLoad""); if (jni_onload_sym) { jni_onload_va = get_te64(&jni_onload_sym->st_value); jni_onload_va = 0;          } } }
Description: A Segmentation fault was found in UPX in PackLinuxElf64::invert_pt_dynamic() in p_lx_elf.cpp. An attacker with a crafted input file allows invalid memory address access that could lead to a denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int gen_values(codegen_scope *s, node *t, int val, int limit) { int n = 0; int first = 1; int slimit = GEN_VAL_STACK_MAX; if (limit == 0) limit = GEN_LIT_ARY_MAX; if (cursp() >= slimit) slimit = INT16_MAX; if (!val) { while (t) { codegen(s, t->car, NOVAL); n++; t = t->cdr; } return n; } while (t) { int is_splat = nint(t->car->car) == NODE_SPLAT; if (is_splat || n > limit || cursp() >= slimit) {  pop_n(n); if (first) { if (n == 0) { genop_1(s, OP_LOADNIL, cursp()); } else { genop_2(s, OP_ARRAY, cursp(), n); } push(); first = 0; limit = GEN_LIT_ARY_MAX; } else if (n > 0) { pop(); genop_2(s, OP_ARYPUSH, cursp(), n); push(); } n = 0; } codegen(s, t->car, val); if (is_splat) { pop(); pop(); genop_1(s, OP_ARYCAT, cursp()); push(); } else { n++; } t = t->cdr; } if (!first) { pop(); if (n > 0) { pop_n(n); genop_2(s, OP_ARYPUSH, cursp(), n); } return -1;                   } return n; }
Description: Heap-based Buffer Overflow in Homebrew mruby prior to 3.2.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static xfs_failaddr_t xfs_agf_verify( struct xfs_buf*bp) { struct xfs_mount*mp = bp->b_mount; struct xfs_agf*agf = XFS_BUF_TO_AGF(bp); if (xfs_sb_version_hascrc(&mp->m_sb)) { if (!uuid_equal(&agf->agf_uuid, &mp->m_sb.sb_meta_uuid)) return __this_address; if (!xfs_log_check_lsn(mp, be64_to_cpu(XFS_BUF_TO_AGF(bp)->agf_lsn))) return __this_address; } if (!xfs_verify_magic(bp, agf->agf_magicnum)) return __this_address; if (!(XFS_AGF_GOOD_VERSION(be32_to_cpu(agf->agf_versionnum)) && be32_to_cpu(agf->agf_freeblks) <= be32_to_cpu(agf->agf_length) && be32_to_cpu(agf->agf_flfirst) < xfs_agfl_size(mp) && be32_to_cpu(agf->agf_fllast) < xfs_agfl_size(mp) && be32_to_cpu(agf->agf_flcount) <= xfs_agfl_size(mp))) return __this_address; if (be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]) < 1 || be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) < 1 || be32_to_cpu(agf->agf_levels[XFS_BTNUM_BNO]) > XFS_BTREE_MAXLEVELS || be32_to_cpu(agf->agf_levels[XFS_BTNUM_CNT]) > XFS_BTREE_MAXLEVELS) return __this_address; if (xfs_sb_version_hasrmapbt(&mp->m_sb) && (be32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAP]) < 1 || be32_to_cpu(agf->agf_levels[XFS_BTNUM_RMAP]) > XFS_BTREE_MAXLEVELS)) return __this_address; if (bp->b_pag && be32_to_cpu(agf->agf_seqno) != bp->b_pag->pag_agno) return __this_address; if (xfs_sb_version_haslazysbcount(&mp->m_sb) && be32_to_cpu(agf->agf_btreeblks) > be32_to_cpu(agf->agf_length)) return __this_address; if (xfs_sb_version_hasreflink(&mp->m_sb) && (be32_to_cpu(agf->agf_refcount_level) < 1 || be32_to_cpu(agf->agf_refcount_level) > XFS_BTREE_MAXLEVELS)) return __this_address; return NULL; }
Description: An issue was discovered in xfs_agf_verify in fs/xfs/libxfs/xfs_alloc.c in the Linux kernel through 5.6.10. Attackers may trigger a sync of excessive duration via an XFS v5 image with crafted metadata, aka CID-d0c7feaf8767.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files, rpmpsm psm, char ** failedFile) { FD_t payload = rpmtePayload(te); rpmfi fi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE); rpmfs fs = rpmteGetFileStates(te); rpmPlugins plugins = rpmtsPlugins(ts); struct stat sb; int saveerrno = errno; int rc = 0; int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0; int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0; int firsthardlink = -1; int skip; rpmFileAction action; char *tid = NULL; const char *suffix; char *fpath = NULL; if (fi == NULL) { rc = RPMERR_BAD_MAGIC; goto exit; } rasprintf(&tid, "";%08x"", (unsigned)rpmtsGetTid(ts)); rc = fsmMkdirs(files, fs, plugins); while (!rc) { rc = rpmfiNext(fi); if (rc < 0) { if (rc == RPMERR_ITER_END) rc = 0; break; } action = rpmfsGetAction(fs, rpmfiFX(fi)); skip = XFA_SKIPPING(action); suffix = S_ISDIR(rpmfiFMode(fi)) ? NULL : tid; if (action != FA_TOUCH) { fpath = fsmFsPath(fi, suffix); } else { fpath = fsmFsPath(fi, """"); } rc = rpmfiStat(fi, 1, &sb); fsmDebug(fpath, action, &sb); if (rc) break; rc = rpmpluginsCallFsmFilePre(plugins, fi, fpath, sb.st_mode, action); if (rc) { skip = 1; } else { setFileState(fs, rpmfiFX(fi)); } if (!skip) { int setmeta = 1; if (!suffix) { rc = fsmBackup(fi, action); } if (!suffix) { rc = fsmVerify(fpath, fi); } else { rc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT; } if (S_ISREG(sb.st_mode)) { if (rc == RPMERR_ENOENT) { rc = fsmMkfile(fi, fpath, files, psm, nodigest, &setmeta, &firsthardlink); } } else if (S_ISDIR(sb.st_mode)) { if (rc == RPMERR_ENOENT) { mode_t mode = sb.st_mode; mode &= ~07777; mode |=  00700; rc = fsmMkdir(fpath, mode); } } else if (S_ISLNK(sb.st_mode)) { if (rc == RPMERR_ENOENT) { rc = fsmSymlink(rpmfiFLink(fi), fpath); } } else if (S_ISFIFO(sb.st_mode)) { if (rc == RPMERR_ENOENT) { rc = fsmMkfifo(fpath, 0000); } } else if (S_ISCHR(sb.st_mode) || S_ISBLK(sb.st_mode) || S_ISSOCK(sb.st_mode)) { if (rc == RPMERR_ENOENT) { rc = fsmMknod(fpath, sb.st_mode, sb.st_rdev); } } else { if (!IS_DEV_LOG(fpath)) rc = RPMERR_UNKNOWN_FILETYPE; } if (!rc && setmeta) { rc = fsmSetmeta(fpath, fi, plugins, action, &sb, nofcaps); } } else if (firsthardlink >= 0 && rpmfiArchiveHasContent(fi)) { char *fn = rpmfilesFN(files, firsthardlink); rc = expandRegular(fi, fn, psm, nodigest, 0); firsthardlink = -1; free(fn); } if (rc) { if (!skip) { if (suffix && (action != FA_TOUCH)) { (void) fsmRemove(fpath, sb.st_mode); } errno = saveerrno; } } else { rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi)); if (!skip) { if (suffix) rc = fsmBackup(fi, action); if (!rc) rc = fsmCommit(&fpath, fi, action, suffix); } } if (rc) *failedFile = xstrdup(fpath); rpmpluginsCallFsmFilePost(plugins, fi, fpath, sb.st_mode, action, rc); fpath = _free(fpath); } rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ)); rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST)); exit: rpmfiArchiveClose(fi); rpmfiFree(fi); Fclose(payload); free(tid); free(fpath); return rc; }
Description: It was found that versions of rpm before 4.13.0.2 use temporary files with predictable names when installing an RPM. An attacker with ability to write in a directory where files will be installed could create symbolic links to an arbitrary location and modify content, and possibly permissions to arbitrary files, which could be used for denial of service or possibly privilege escalation.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void close_all_sockets(atransport* t) { asocket* s; adb_mutex_lock(&socket_list_lock); restart: for (s = local_socket_list.next; s != &local_socket_list; s = s->next) { if (s->transport == t || (s->peer && s->peer->transport == t)) { local_socket_close_locked(s); goto restart; } } adb_mutex_unlock(&socket_list_lock); }
Description: The Java Debug Wire Protocol (JDWP) implementation in adb/sockets.cpp in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-09-01 mishandles socket close operations, which allows attackers to gain privileges via a crafted application, aka internal bug 28347842.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static njs_ret_t njs_string_prototype_to_upper_case(njs_vm_t *vm, njs_value_t *args, nxt_uint_t nargs, njs_index_t unused) { size_t             size; u_char             *p, *start; const u_char       *s, *end; njs_string_prop_t  string; (void) njs_string_prop(&string, &args[0]); start = njs_string_alloc(vm, &vm->retval, string.size, string.length); if (nxt_slow_path(start == NULL)) { return NXT_ERROR; } p = start; s = string.start; size = string.size; if (string.length == 0 || string.length == size) { while (size != 0) { *p++ = nxt_upper_case(*s++); size--; } } else { end = s + size; while (size != 0) { p = nxt_utf8_encode(p, nxt_utf8_upper_case(&s, end)); size--; } } return NXT_OK; }
Description: njs through 0.3.1, used in NGINX, has a heap-based buffer overflow in nxt_utf8_encode in nxt_utf8.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void nhmldump_send_frame(GF_NHMLDumpCtx *ctx, char *data, u32 data_size, GF_FilterPacket *pck) { GF_FilterPacket *dst_pck; char nhml[1024]; const GF_PropertyValue *p; u32 size; u8 *output; GF_FilterSAPType sap = gf_filter_pck_get_sap(pck); u64 dts = gf_filter_pck_get_dts(pck); u64 cts = gf_filter_pck_get_cts(pck); if (dts==GF_FILTER_NO_TS) dts = cts; if (cts==GF_FILTER_NO_TS) cts = dts; ctx->pck_num++; sprintf(nhml, ""<NHNTSample number=\""%d\"" DTS=\""""LLU""\"" dataLength=\""%d\"" "", ctx->pck_num, dts, data_size); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); if (ctx->pckp || (cts != dts) ) { sprintf(nhml, ""CTSOffset=\""%d\"" "", (s32) ((s64)cts - (s64)dts)); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } if (sap==GF_FILTER_SAP_1) { sprintf(nhml, ""isRAP=\""yes\"" ""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } else if (sap) { sprintf(nhml, ""SAPType=\""%d\"" "", sap); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } else if (ctx->pckp) { sprintf(nhml, ""isRAP=\""no\"" ""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); if ((sap==GF_FILTER_SAP_4) || (sap==GF_FILTER_SAP_4_PROL)) { s32 roll = gf_filter_pck_get_roll_info(pck); sprintf(nhml, ""SAPType=\""4\"" %s=\""%d\"" "", (sap==GF_FILTER_SAP_4_PROL) ? ""prol"" : ""roll"", roll); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } } if (ctx->pckp) { u64 bo; u32 duration, idx; sprintf(nhml, ""mediaOffset=\""""LLU""\"" "", ctx->mdia_pos); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); bo = gf_filter_pck_get_byte_offset(pck); if (bo!=GF_FILTER_NO_BO) { sprintf(nhml, ""sourceByteOffset=\""""LLU""\"" "", bo); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } duration = gf_filter_pck_get_duration(pck); if (duration) { sprintf(nhml, ""duration=\""%d\"" "", duration); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } idx = gf_filter_pck_get_carousel_version(pck); if (idx) { sprintf(nhml, ""carouselVersion=\""%d\"" "", idx); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } idx = 0; while (1) { u32 prop_4cc; const char *prop_name; p = gf_filter_pck_enum_properties(pck, &idx, &prop_4cc, &prop_name); if (!p) break; if (prop_4cc == GF_PROP_PCK_SUBS) continue; nhmldump_pck_property(ctx, prop_4cc, prop_name, p); } } if (ctx->chksum) { if (ctx->chksum==1) { u32 crc = gf_crc_32(data, data_size); sprintf(nhml, ""crc=\""%08X\"" "", crc); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } else { u32 j; u8 hash[GF_SHA1_DIGEST_SIZE]; gf_sha1_csum(data, data_size, hash); sprintf(nhml, ""sha1=\""""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); for (j=0; j<20; j++) { sprintf(nhml, ""%02X"", hash[j]); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } sprintf(nhml, ""\"" ""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } } sprintf(nhml, "">\n""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); p = gf_filter_pck_get_property(pck, GF_PROP_PCK_SUBS); if (p) { u32 offset_in_sample = 0; Bool first_subs = GF_TRUE; if (!ctx->bs_r) ctx->bs_r = gf_bs_new(p->value.data.ptr, p->value.data.size, GF_BITSTREAM_READ); else gf_bs_reassign_buffer(ctx->bs_r, p->value.data.ptr, p->value.data.size); while (gf_bs_available(ctx->bs_r)) { u32 s_flags = gf_bs_read_u32(ctx->bs_r); u32 s_size = gf_bs_read_u32(ctx->bs_r); u32 s_res = gf_bs_read_u32(ctx->bs_r); u8 s_prio = gf_bs_read_u8(ctx->bs_r); u8 s_discard = gf_bs_read_u8(ctx->bs_r); if (offset_in_sample + s_size > data_size) { GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (""Wrong subsample info: sample size %d vs subsample offset+size %dn"", data_size, offset_in_sample + s_size)); break; } if (ctx->is_stpp && ctx->nhmlonly) { if (first_subs) { sprintf(nhml, ""<NHNTSubSample>\n""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); gf_bs_write_data(ctx->bs_w, data, s_size); sprintf(nhml, ""</NHNTSubSample>\n""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } else { u32 d_size; if (ctx->b64_buffer_size<2*s_size) { ctx->b64_buffer_size = 2 * s_size; ctx->b64_buffer = gf_realloc(ctx->b64_buffer, ctx->b64_buffer_size); } d_size = gf_base64_encode(data + offset_in_sample, s_size, ctx->b64_buffer, ctx->b64_buffer_size); ctx->b64_buffer[d_size] = 0; sprintf(nhml, ""<NHNTSubSample data=\""data:application/octet-string;base64,""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); gf_bs_write_data(ctx->bs_w, ctx->b64_buffer, d_size); sprintf(nhml, ""\"">\n""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } } else { sprintf(nhml, ""<NHNTSubSample size=\""%d\"" flags=\""%d\"" reserved=\""%d\"" priority=\""%d\"" discard=\""%d\"" />\n"", s_size, s_flags, s_res, s_prio, s_discard); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } first_subs = GF_FALSE; } } else if (ctx->is_stpp && ctx->nhmlonly) { sprintf(nhml, ""<NHNTSubSample><![CDATA[\n""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); gf_bs_write_data(ctx->bs_w, data, data_size); sprintf(nhml, ""]]></NHNTSubSample>\n""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); } sprintf(nhml, ""</NHNTSample>\n""); gf_bs_write_data(ctx->bs_w, nhml, (u32) strlen(nhml)); gf_bs_get_content_no_truncate(ctx->bs_w, &ctx->nhml_buffer, &size, &ctx->nhml_buffer_size); if (ctx->filep) { gf_fwrite(ctx->nhml_buffer, size, ctx->filep); return; } dst_pck = gf_filter_pck_new_alloc(ctx->opid_nhml, size, &output); if (dst_pck) { memcpy(output, ctx->nhml_buffer, size); gf_filter_pck_set_framing(dst_pck, GF_FALSE, GF_FALSE); gf_filter_pck_send(dst_pck); } ctx->mdia_pos += data_size; if (ctx->opid_mdia) { dst_pck = gf_filter_pck_new_ref(ctx->opid_mdia, 0, data_size, pck); if (!dst_pck) return; gf_filter_pck_merge_properties(pck, dst_pck); gf_filter_pck_set_framing(dst_pck, ctx->first, GF_FALSE); gf_filter_pck_send(dst_pck); } }
Description: GPAC 2.0 allows a heap-based buffer overflow in gf_base64_encode. It can be triggered via MP4Box.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: TEE_Result TEE_MACComputeFinal(TEE_OperationHandle operation, const void *message, uint32_t messageLen, void *mac, uint32_t *macLen) { TEE_Result res; uint64_t ml; if (operation == TEE_HANDLE_NULL || (message == NULL && messageLen != 0) || mac == NULL || macLen == NULL) { res = TEE_ERROR_BAD_PARAMETERS; goto out; } if (operation->info.operationClass != TEE_OPERATION_MAC) { res = TEE_ERROR_BAD_PARAMETERS; goto out; } if ((operation->info.handleState & TEE_HANDLE_FLAG_INITIALIZED) == 0) { res = TEE_ERROR_BAD_PARAMETERS; goto out; } if (operation->operationState != TEE_OPERATION_STATE_ACTIVE) { res = TEE_ERROR_BAD_PARAMETERS; goto out; } ml = *macLen; res = utee_hash_final(operation->state, message, messageLen, mac, &ml); *macLen = ml; if (res != TEE_SUCCESS) goto out; operation->info.handleState &= ~TEE_HANDLE_FLAG_INITIALIZED; operation->operationState = TEE_OPERATION_STATE_INITIAL; out: if (res != TEE_SUCCESS && res != TEE_ERROR_SHORT_BUFFER) TEE_Panic(res); return res; }
Description: A Buffer Access with Incorrect Length Value vulnerablity in the TEE_MACComputeFinal function in Samsung mTower through 0.3.0 allows a trusted application to trigger a Denial of Service (DoS) by invoking the function TEE_MACComputeFinal with an excessive size value of messageLen.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int gnttab_map_frame(struct domain *d, unsigned long idx, gfn_t gfn, mfn_t *mfn) { int rc = 0; struct grant_table *gt = d->grant_table; grant_write_lock(gt); if ( gt->gt_version == 0 ) gt->gt_version = 1; if ( gt->gt_version == 2 && (idx & XENMAPIDX_grant_table_status) ) { idx &= ~XENMAPIDX_grant_table_status; if ( idx < nr_status_frames(gt) ) *mfn = _mfn(virt_to_mfn(gt->status[idx])); else rc = -EINVAL; } else { if ( (idx >= nr_grant_frames(gt)) && (idx < gt->max_grant_frames) ) gnttab_grow_table(d, idx + 1); if ( idx < nr_grant_frames(gt) ) *mfn = _mfn(virt_to_mfn(gt->shared_raw[idx])); else rc = -EINVAL; } if ( !rc ) gnttab_set_frame_gfn(gt, idx, gfn); grant_write_unlock(gt); return rc; }
Description: An issue was discovered in Xen through 4.10.x allowing guest OS users to cause a denial of service (hypervisor crash) or gain privileges by triggering a grant-table transition from v2 to v1.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int renameUnmapSelectCb(Walker *pWalker, Select *p){ Parse *pParse = pWalker->pParse; int i; if( pParse->nErr ) return WRC_Abort; if( ALWAYS(p->pEList) ){ ExprList *pList = p->pEList; for(i=0; i<pList->nExpr; i++){ if( pList->a[i].zName ){ sqlite3RenameTokenRemap(pParse, 0, (void*)pList->a[i].zName); } } } if( ALWAYS(p->pSrc) ){   SrcList *pSrc = p->pSrc; for(i=0; i<pSrc->nSrc; i++){ sqlite3RenameTokenRemap(pParse, 0, (void*)pSrc->a[i].zName); } } renameWalkWith(pWalker, p); return WRC_Continue; }
Description: alter.c in SQLite through 3.30.1 allows attackers to trigger infinite recursion via certain types of self-referential views in conjunction with ALTER TABLE statements.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: unsigned  PackLinuxElf32::check_pt_dynamic(Elf32_Phdr const *const phdr) { unsigned t = get_te32(&phdr->p_offset), s = sizeof(Elf32_Dyn) + t; unsigned vaddr = get_te32(&phdr->p_vaddr); unsigned filesz = get_te32(&phdr->p_filesz), memsz = get_te32(&phdr->p_memsz); unsigned align = get_te32(&phdr->p_align); if (s < t || (u32_t)file_size < s ||  (3 & t) || (7 & (filesz | memsz))      ||  (-1+ align) & (t ^ vaddr) ||  (unsigned long)file_size <= memsz ||  filesz < sizeof(Elf32_Dyn) ||  memsz  < sizeof(Elf32_Dyn) ||  filesz < memsz) { char msg[50]; snprintf(msg, sizeof(msg), ""bad PT_DYNAMIC phdr[%u]"", (unsigned)(phdr - phdri)); throwCantPack(msg); } sz_dynseg = memsz; return t; }
Description: An invalid memory address reference was discovered in the elf_lookup function in p_lx_elf.cpp in UPX 4.0.0 via a crafted Mach-O file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int msOGRFileNextShape(layerObj *layer, shapeObj *shape, msOGRFileInfo *psInfo ) { OGRFeatureH hFeature = NULL; if (psInfo == NULL || psInfo->hLayer == NULL) { msSetError(MS_MISCERR, ""Assertion failed: OGR layer not opened!!!"", ""msOGRFileNextShape()""); return(MS_FAILURE); } msFreeShape(shape); shape->type = MS_SHAPE_NULL; ACQUIRE_OGR_LOCK; while (shape->type == MS_SHAPE_NULL) { if( hFeature ) OGR_F_Destroy( hFeature ); if( (hFeature = OGR_L_GetNextFeature( psInfo->hLayer )) == NULL ) { psInfo->last_record_index_read = -1; if( CPLGetLastErrorType() == CE_Failure ) { msSetError(MS_OGRERR, ""%s"", ""msOGRFileNextShape()"", CPLGetLastErrorMsg() ); RELEASE_OGR_LOCK; return MS_FAILURE; } else { RELEASE_OGR_LOCK; if (layer->debug >= MS_DEBUGLEVEL_VV) msDebug(""msOGRFileNextShape: Returning MS_DONE (no more shapes)\n"" ); return MS_DONE;        } } psInfo->last_record_index_read++; if(layer->numitems > 0) { shape->values = msOGRGetValues(layer, hFeature); shape->numvalues = layer->numitems; if(!shape->values) { OGR_F_Destroy( hFeature ); RELEASE_OGR_LOCK; return(MS_FAILURE); } } if (ogrConvertGeometry(ogrGetLinearGeometry( hFeature ), shape, layer->type) == MS_SUCCESS) { if (shape->type != MS_SHAPE_NULL) break;  if (layer->debug >= MS_DEBUGLEVEL_VVV) msDebug(""msOGRFileNextShape: Rejecting feature (shapeid = "" CPL_FRMT_GIB "", tileid=%d) of incompatible type for this layer (feature wkbType %d, layer type %d)\n"", (GIntBig)OGR_F_GetFID( hFeature ), psInfo->nTileId, OGR_F_GetGeometryRef( hFeature )==NULL ? wkbFlatten(wkbUnknown):wkbFlatten( OGR_G_GetGeometryType( OGR_F_GetGeometryRef( hFeature ) ) ), layer->type); } else { msFreeShape(shape); OGR_F_Destroy( hFeature ); RELEASE_OGR_LOCK; return MS_FAILURE;     } msFreeShape(shape); shape->type = MS_SHAPE_NULL; } shape->index =  (int)OGR_F_GetFID( hFeature );   shape->resultindex = psInfo->last_record_index_read; shape->tileindex = psInfo->nTileId; if (layer->debug >= MS_DEBUGLEVEL_VVV) msDebug(""msOGRFileNextShape: Returning shape=%ld, tile=%d\n"", shape->index, shape->tileindex ); if (psInfo->hLastFeature) OGR_F_Destroy( psInfo->hLastFeature ); psInfo->hLastFeature = hFeature; RELEASE_OGR_LOCK; return MS_SUCCESS; }
Description: In MapServer before 7.0.3, OGR driver error messages are too verbose and may leak sensitive information if data connection fails.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int main(int argc, char *argv[]) { GooString *fileName; UnicodeMap *uMap; GooString *ownerPW, *userPW; PDFDoc *doc; char uBuf[8]; char path[1024]; char *p; bool ok; int exitCode; GooList *embeddedFiles = nullptr; int nFiles, nPages, n, i, j; FileSpec *fileSpec; Page *page; Annots *annots; Annot *annot; const GooString *s1; Unicode u; bool isUnicode; Win32Console win32Console(&argc, &argv); exitCode = 99; ok = parseArgs(argDesc, &argc, argv); if ((doList ? 1 : 0) + ((saveNum != 0) ? 1 : 0) + (saveAll ? 1 : 0) != 1) { ok = false; } if (!ok || argc != 2 || printVersion || printHelp) { fprintf(stderr, ""pdfdetach version %s\n"", PACKAGE_VERSION); fprintf(stderr, ""%s\n"", popplerCopyright); fprintf(stderr, ""%s\n"", xpdfCopyright); if (!printVersion) { printUsage(""pdfdetach"", ""<PDF-file>"", argDesc); } goto err0; } fileName = new GooString(argv[1]); globalParams = new GlobalParams(); if (textEncName[0]) { globalParams->setTextEncoding(textEncName); } if (!(uMap = globalParams->getTextEncoding())) { error(errConfig, -1, ""Couldn't get text encoding""); delete fileName; goto err1; } if (ownerPassword[0] != '\001') { ownerPW = new GooString(ownerPassword); } else { ownerPW = nullptr; } if (userPassword[0] != '\001') { userPW = new GooString(userPassword); } else { userPW = nullptr; } doc = PDFDocFactory().createPDFDoc(*fileName, ownerPW, userPW); if (userPW) { delete userPW; } if (ownerPW) { delete ownerPW; } if (!doc->isOk()) { exitCode = 1; goto err2; } embeddedFiles = new GooList(); for (i = 0; i < doc->getCatalog()->numEmbeddedFiles(); ++i) embeddedFiles->push_back(doc->getCatalog()->embeddedFile(i)); nPages = doc->getCatalog()->getNumPages(); for (i = 0; i < nPages; ++i) { page = doc->getCatalog()->getPage(i + 1); if (!page) continue; annots = page->getAnnots(); if (!annots) break; for (j = 0; j < annots->getNumAnnots(); ++j) { annot = annots->getAnnot(j); if (annot->getType() != Annot::typeFileAttachment) continue; embeddedFiles->push_back(new FileSpec(static_cast<AnnotFileAttachment *>(annot)->getFile())); } } nFiles = embeddedFiles->getLength(); if (doList) { printf(""%d embedded files\n"", nFiles); for (i = 0; i < nFiles; ++i) { fileSpec = static_cast<FileSpec *>(embeddedFiles->get(i)); printf(""%d: "", i+1); s1 = fileSpec->getFileName(); if ((s1->getChar(0) & 0xff) == 0xfe && (s1->getChar(1) & 0xff) == 0xff) { isUnicode = true; j = 2; } else { isUnicode = false; j = 0; } while (j < fileSpec->getFileName()->getLength()) { if (isUnicode) { u = ((s1->getChar(j) & 0xff) << 8) | (s1->getChar(j+1) & 0xff); j += 2; } else { u = pdfDocEncoding[s1->getChar(j) & 0xff]; ++j; } n = uMap->mapUnicode(u, uBuf, sizeof(uBuf)); fwrite(uBuf, 1, n, stdout); } fputc('\n', stdout); } } else if (saveAll) { for (i = 0; i < nFiles; ++i) { fileSpec = static_cast<FileSpec *>(embeddedFiles->get(i)); if (savePath[0]) { n = strlen(savePath); if (n > (int)sizeof(path) - 2) { n = sizeof(path) - 2; } memcpy(path, savePath, n); path[n] = '/'; p = path + n + 1; } else { p = path; } s1 = fileSpec->getFileName(); if ((s1->getChar(0) & 0xff) == 0xfe && (s1->getChar(1) & 0xff) == 0xff) { isUnicode = true; j = 2; } else { isUnicode = false; j = 0; } while (j < fileSpec->getFileName()->getLength()) { if (isUnicode) { u = ((s1->getChar(j) & 0xff) << 8) | (s1->getChar(j+1) & 0xff); j += 2; } else { u = pdfDocEncoding[s1->getChar(j) & 0xff]; ++j; } n = uMap->mapUnicode(u, uBuf, sizeof(uBuf)); if (p + n >= path + sizeof(path)) break; memcpy(p, uBuf, n); p += n; } *p = '\0'; auto *embFile = fileSpec->getEmbeddedFile(); if (!embFile || !embFile->isOk()) { exitCode = 3; goto err2; } if (!embFile->save(path)) { error(errIO, -1, ""Error saving embedded file as '{0:s}'"", p); exitCode = 2; goto err2; } } } else { if (saveNum < 1 || saveNum > nFiles) { error(errCommandLine, -1, ""Invalid file number""); goto err2; } fileSpec = static_cast<FileSpec *>(embeddedFiles->get(saveNum - 1)); if (savePath[0]) { p = savePath; } else { p = path; s1 = fileSpec->getFileName(); if ((s1->getChar(0) & 0xff) == 0xfe && (s1->getChar(1) & 0xff) == 0xff) { isUnicode = true; j = 2; } else { isUnicode = false; j = 0; } while (j < fileSpec->getFileName()->getLength()) { if (isUnicode) { u = ((s1->getChar(j) & 0xff) << 8) | (s1->getChar(j+1) & 0xff); j += 2; } else { u = pdfDocEncoding[s1->getChar(j) & 0xff]; ++j; } n = uMap->mapUnicode(u, uBuf, sizeof(uBuf)); if (p + n >= path + sizeof(path)) break; memcpy(p, uBuf, n); p += n; } *p = '\0'; p = path; } auto *embFile = fileSpec->getEmbeddedFile(); if (!embFile || !embFile->isOk()) { exitCode = 3; goto err2; } if (!embFile->save(p)) { error(errIO, -1, ""Error saving embedded file as '{0:s}'"", p); exitCode = 2; goto err2; } } exitCode = 0; err2: if (embeddedFiles) deleteGooList<FileSpec>(embeddedFiles); uMap->decRefCnt(); delete doc; err1: delete globalParams; err0: return exitCode; }
Description: An issue was discovered in Poppler 0.71.0. There is a NULL pointer dereference in goo/GooString.h, will lead to denial of service, as demonstrated by utils/pdfdetach.cc not validating a filename of an embedded file before constructing a save path.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int update_prepare_order_info(rdpContext* context, ORDER_INFO* orderInfo, UINT32 orderType) { int length = 1; orderInfo->fieldFlags = 0; orderInfo->orderType = orderType; orderInfo->controlFlags = ORDER_STANDARD; orderInfo->controlFlags |= ORDER_TYPE_CHANGE; length += 1; length += PRIMARY_DRAWING_ORDER_FIELD_BYTES[orderInfo->orderType]; length += update_prepare_bounds(context, orderInfo); return length; }
Description: In FreeRDP before version 2.1.2, an out of bound reads occurs resulting in accessing a memory location that is outside of the boundaries of the static array PRIMARY_DRAWING_ORDER_FIELD_BYTES. This is fixed in version 2.1.2.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void ov511_mode_init_regs(struct sd *sd) { struct gspca_dev *gspca_dev = (struct gspca_dev *)sd; int hsegs, vsegs, packet_size, fps, needed; int interlaced = 0; struct usb_host_interface *alt; struct usb_interface *intf; intf = usb_ifnum_to_if(sd->gspca_dev.dev, sd->gspca_dev.iface); alt = usb_altnum_to_altsetting(intf, sd->gspca_dev.alt); if (!alt) { gspca_err(gspca_dev, ""Couldn't get altsetting\n""); sd->gspca_dev.usb_err = -EIO; return; } packet_size = le16_to_cpu(alt->endpoint[0].desc.wMaxPacketSize); reg_w(sd, R51x_FIFO_PSIZE, packet_size >> 5); reg_w(sd, R511_CAM_UV_EN, 0x01); reg_w(sd, R511_SNAP_UV_EN, 0x01); reg_w(sd, R511_SNAP_OPTS, 0x03); hsegs = (sd->gspca_dev.pixfmt.width >> 3) - 1; vsegs = (sd->gspca_dev.pixfmt.height >> 3) - 1; reg_w(sd, R511_CAM_PXCNT, hsegs); reg_w(sd, R511_CAM_LNCNT, vsegs); reg_w(sd, R511_CAM_PXDIV, 0x00); reg_w(sd, R511_CAM_LNDIV, 0x00); reg_w(sd, R511_CAM_OPTS, 0x03); reg_w(sd, R511_SNAP_PXCNT, hsegs); reg_w(sd, R511_SNAP_LNCNT, vsegs); reg_w(sd, R511_SNAP_PXDIV, 0x00); reg_w(sd, R511_SNAP_LNDIV, 0x00); if (frame_rate > 0) sd->frame_rate = frame_rate; switch (sd->sensor) { case SEN_OV6620: sd->clockdiv = 3; break; case SEN_OV7620: case SEN_OV7620AE: case SEN_OV7640: case SEN_OV7648: case SEN_OV76BE: if (sd->gspca_dev.pixfmt.width == 320) interlaced = 1; case SEN_OV6630: case SEN_OV7610: case SEN_OV7670: switch (sd->frame_rate) { case 30: case 25: if (sd->gspca_dev.pixfmt.width != 640) { sd->clockdiv = 0; break; } default: sd->clockdiv = 1; break; case 10: sd->clockdiv = 2; break; case 5: sd->clockdiv = 5; break; } if (interlaced) { sd->clockdiv = (sd->clockdiv + 1) * 2 - 1; if (sd->clockdiv > 10) sd->clockdiv = 10; } break; case SEN_OV8610: sd->clockdiv = 0; break; } fps = (interlaced ? 60 : 30) / (sd->clockdiv + 1) + 1; needed = fps * sd->gspca_dev.pixfmt.width * sd->gspca_dev.pixfmt.height * 3 / 2; if (needed > 1000 * packet_size) { reg_w(sd, R511_COMP_EN, 0x07); reg_w(sd, R511_COMP_LUT_EN, 0x03); } else { reg_w(sd, R511_COMP_EN, 0x06); reg_w(sd, R511_COMP_LUT_EN, 0x00); } reg_w(sd, R51x_SYS_RESET, OV511_RESET_OMNICE); reg_w(sd, R51x_SYS_RESET, 0); }
Description: An issue was discovered in the Linux kernel before 5.6.1. drivers/media/usb/gspca/ov519.c allows NULL pointer dereferences in ov511_mode_init_regs and ov518_mode_init_regs when there are zero endpoints, aka CID-998912346c0d.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static struct page *follow_page_pte(struct vm_area_struct *vma, unsigned long address, pmd_t *pmd, unsigned int flags) { struct mm_struct *mm = vma->vm_mm; struct dev_pagemap *pgmap = NULL; struct page *page; spinlock_t *ptl; pte_t *ptep, pte; retry: if (unlikely(pmd_bad(*pmd))) return no_page_table(vma, flags); ptep = pte_offset_map_lock(mm, pmd, address, &ptl); pte = *ptep; if (!pte_present(pte)) { swp_entry_t entry; if (likely(!(flags & FOLL_MIGRATION))) goto no_page; if (pte_none(pte)) goto no_page; entry = pte_to_swp_entry(pte); if (!is_migration_entry(entry)) goto no_page; pte_unmap_unlock(ptep, ptl); migration_entry_wait(mm, pmd, address); goto retry; } if ((flags & FOLL_NUMA) && pte_protnone(pte)) goto no_page; if ((flags & FOLL_WRITE) && !pte_write(pte)) { pte_unmap_unlock(ptep, ptl); return NULL; } page = vm_normal_page(vma, address, pte); if (!page && pte_devmap(pte) && (flags & FOLL_GET)) { pgmap = get_dev_pagemap(pte_pfn(pte), NULL); if (pgmap) page = pte_page(pte); else goto no_page; } else if (unlikely(!page)) { if (flags & FOLL_DUMP) { page = ERR_PTR(-EFAULT); goto out; } if (is_zero_pfn(pte_pfn(pte))) { page = pte_page(pte); } else { int ret; ret = follow_pfn_pte(vma, address, ptep, flags); page = ERR_PTR(ret); goto out; } } if (flags & FOLL_SPLIT && PageTransCompound(page)) { int ret; get_page(page); pte_unmap_unlock(ptep, ptl); lock_page(page); ret = split_huge_page(page); unlock_page(page); put_page(page); if (ret) return ERR_PTR(ret); goto retry; } if (flags & FOLL_GET) { get_page(page); if (pgmap) { put_dev_pagemap(pgmap); pgmap = NULL; } } if (flags & FOLL_TOUCH) { if ((flags & FOLL_WRITE) && !pte_dirty(pte) && !PageDirty(page)) set_page_dirty(page); mark_page_accessed(page); } if ((flags & FOLL_MLOCK) && (vma->vm_flags & VM_LOCKED)) { if (PageTransCompound(page)) goto out; if (page->mapping && trylock_page(page)) { lru_add_drain();   mlock_vma_page(page); unlock_page(page); } } out: pte_unmap_unlock(ptep, ptl); return page; no_page: pte_unmap_unlock(ptep, ptl); if (!pte_none(pte)) return NULL; return no_page_table(vma, flags); }
Description: Race condition in mm/gup.c in the Linux kernel 2.x through 4.x before 4.8.3 allows local users to gain privileges by leveraging incorrect handling of a copy-on-write (COW) feature to write to a read-only memory mapping, as exploited in the wild in October 2016, aka ""Dirty COW.""
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static long sg_ioctl(struct file *filp, unsigned int cmd_in, unsigned long arg) { void __user *p = (void __user *)arg; int __user *ip = p; int result, val, read_only; Sg_device *sdp; Sg_fd *sfp; Sg_request *srp; unsigned long iflags; if ((!(sfp = (Sg_fd *) filp->private_data)) || (!(sdp = sfp->parentdp))) return -ENXIO; SCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sdp, ""sg_ioctl: cmd=0x%x\n"", (int) cmd_in)); read_only = (O_RDWR != (filp->f_flags & O_ACCMODE)); switch (cmd_in) { case SG_IO: if (atomic_read(&sdp->detaching)) return -ENODEV; if (!scsi_block_when_processing_errors(sdp->device)) return -ENXIO; if (!access_ok(VERIFY_WRITE, p, SZ_SG_IO_HDR)) return -EFAULT; result = sg_new_write(sfp, filp, p, SZ_SG_IO_HDR, 1, read_only, 1, &srp); if (result < 0) return result; result = wait_event_interruptible(sfp->read_wait, (srp_done(sfp, srp) || atomic_read(&sdp->detaching))); if (atomic_read(&sdp->detaching)) return -ENODEV; write_lock_irq(&sfp->rq_list_lock); if (srp->done) { srp->done = 2; write_unlock_irq(&sfp->rq_list_lock); result = sg_new_read(sfp, p, SZ_SG_IO_HDR, srp); return (result < 0) ? result : 0; } srp->orphan = 1; write_unlock_irq(&sfp->rq_list_lock); return result; case SG_SET_TIMEOUT: result = get_user(val, ip); if (result) return result; if (val < 0) return -EIO; if (val >= mult_frac((s64)INT_MAX, USER_HZ, HZ)) val = min_t(s64, mult_frac((s64)INT_MAX, USER_HZ, HZ), INT_MAX); sfp->timeout_user = val; sfp->timeout = mult_frac(val, HZ, USER_HZ); return 0; case SG_GET_TIMEOUT: return sfp->timeout_user; case SG_SET_FORCE_LOW_DMA: result = get_user(val, ip); if (result) return result; if (val) { sfp->low_dma = 1; if ((0 == sfp->low_dma) && (0 == sg_res_in_use(sfp))) { val = (int) sfp->reserve.bufflen; sg_remove_scat(sfp, &sfp->reserve); sg_build_reserve(sfp, val); } } else { if (atomic_read(&sdp->detaching)) return -ENODEV; sfp->low_dma = sdp->device->host->unchecked_isa_dma; } return 0; case SG_GET_LOW_DMA: return put_user((int) sfp->low_dma, ip); case SG_GET_SCSI_ID: if (!access_ok(VERIFY_WRITE, p, sizeof (sg_scsi_id_t))) return -EFAULT; else { sg_scsi_id_t __user *sg_idp = p; if (atomic_read(&sdp->detaching)) return -ENODEV; __put_user((int) sdp->device->host->host_no, &sg_idp->host_no); __put_user((int) sdp->device->channel, &sg_idp->channel); __put_user((int) sdp->device->id, &sg_idp->scsi_id); __put_user((int) sdp->device->lun, &sg_idp->lun); __put_user((int) sdp->device->type, &sg_idp->scsi_type); __put_user((short) sdp->device->host->cmd_per_lun, &sg_idp->h_cmd_per_lun); __put_user((short) sdp->device->queue_depth, &sg_idp->d_queue_depth); __put_user(0, &sg_idp->unused[0]); __put_user(0, &sg_idp->unused[1]); return 0; } case SG_SET_FORCE_PACK_ID: result = get_user(val, ip); if (result) return result; sfp->force_packid = val ? 1 : 0; return 0; case SG_GET_PACK_ID: if (!access_ok(VERIFY_WRITE, ip, sizeof (int))) return -EFAULT; read_lock_irqsave(&sfp->rq_list_lock, iflags); for (srp = sfp->headrp; srp; srp = srp->nextrp) { if ((1 == srp->done) && (!srp->sg_io_owned)) { read_unlock_irqrestore(&sfp->rq_list_lock, iflags); __put_user(srp->header.pack_id, ip); return 0; } } read_unlock_irqrestore(&sfp->rq_list_lock, iflags); __put_user(-1, ip); return 0; case SG_GET_NUM_WAITING: read_lock_irqsave(&sfp->rq_list_lock, iflags); for (val = 0, srp = sfp->headrp; srp; srp = srp->nextrp) { if ((1 == srp->done) && (!srp->sg_io_owned)) ++val; } read_unlock_irqrestore(&sfp->rq_list_lock, iflags); return put_user(val, ip); case SG_GET_SG_TABLESIZE: return put_user(sdp->sg_tablesize, ip); case SG_SET_RESERVED_SIZE: result = get_user(val, ip); if (result) return result; if (val < 0) return -EINVAL; val = min_t(int, val, max_sectors_bytes(sdp->device->request_queue)); if (val != sfp->reserve.bufflen) { if (sg_res_in_use(sfp) || sfp->mmap_called) return -EBUSY; sg_remove_scat(sfp, &sfp->reserve); sg_build_reserve(sfp, val); } return 0; case SG_GET_RESERVED_SIZE: val = min_t(int, sfp->reserve.bufflen, max_sectors_bytes(sdp->device->request_queue)); return put_user(val, ip); case SG_SET_COMMAND_Q: result = get_user(val, ip); if (result) return result; sfp->cmd_q = val ? 1 : 0; return 0; case SG_GET_COMMAND_Q: return put_user((int) sfp->cmd_q, ip); case SG_SET_KEEP_ORPHAN: result = get_user(val, ip); if (result) return result; sfp->keep_orphan = val; return 0; case SG_GET_KEEP_ORPHAN: return put_user((int) sfp->keep_orphan, ip); case SG_NEXT_CMD_LEN: result = get_user(val, ip); if (result) return result; sfp->next_cmd_len = (val > 0) ? val : 0; return 0; case SG_GET_VERSION_NUM: return put_user(sg_version_num, ip); case SG_GET_ACCESS_COUNT: val = (sdp->device ? 1 : 0); return put_user(val, ip); case SG_GET_REQUEST_TABLE: if (!access_ok(VERIFY_WRITE, p, SZ_SG_REQ_INFO * SG_MAX_QUEUE)) return -EFAULT; else { sg_req_info_t *rinfo; unsigned int ms; rinfo = kmalloc(SZ_SG_REQ_INFO * SG_MAX_QUEUE, GFP_KERNEL); if (!rinfo) return -ENOMEM; read_lock_irqsave(&sfp->rq_list_lock, iflags); for (srp = sfp->headrp, val = 0; val < SG_MAX_QUEUE; ++val, srp = srp ? srp->nextrp : srp) { memset(&rinfo[val], 0, SZ_SG_REQ_INFO); if (srp) { rinfo[val].req_state = srp->done + 1; rinfo[val].problem = srp->header.masked_status &  srp->header.host_status &  srp->header.driver_status; if (srp->done) rinfo[val].duration = srp->header.duration; else { ms = jiffies_to_msecs(jiffies); rinfo[val].duration = (ms > srp->header.duration) ? (ms - srp->header.duration) : 0; } rinfo[val].orphan = srp->orphan; rinfo[val].sg_io_owned = srp->sg_io_owned; rinfo[val].pack_id = srp->header.pack_id; rinfo[val].usr_ptr = srp->header.usr_ptr; } } read_unlock_irqrestore(&sfp->rq_list_lock, iflags); result = __copy_to_user(p, rinfo,  SZ_SG_REQ_INFO * SG_MAX_QUEUE); result = result ? -EFAULT : 0; kfree(rinfo); return result; } case SG_EMULATED_HOST: if (atomic_read(&sdp->detaching)) return -ENODEV; return put_user(sdp->device->host->hostt->emulated, ip); case SCSI_IOCTL_SEND_COMMAND: if (atomic_read(&sdp->detaching)) return -ENODEV; if (read_only) { unsigned char opcode = WRITE_6; Scsi_Ioctl_Command __user *siocp = p; if (copy_from_user(&opcode, siocp->data, 1)) return -EFAULT; if (sg_allow_access(filp, &opcode)) return -EPERM; } return sg_scsi_ioctl(sdp->device->request_queue, NULL, filp->f_mode, p); case SG_SET_DEBUG: result = get_user(val, ip); if (result) return result; sdp->sgdebug = (char) val; return 0; case BLKSECTGET: return put_user(max_sectors_bytes(sdp->device->request_queue), ip); case BLKTRACESETUP: return blk_trace_setup(sdp->device->request_queue, sdp->disk->disk_name, MKDEV(SCSI_GENERIC_MAJOR, sdp->index), NULL, (char *)arg); case BLKTRACESTART: return blk_trace_startstop(sdp->device->request_queue, 1); case BLKTRACESTOP: return blk_trace_startstop(sdp->device->request_queue, 0); case BLKTRACETEARDOWN: return blk_trace_remove(sdp->device->request_queue); case SCSI_IOCTL_GET_IDLUN: case SCSI_IOCTL_GET_BUS_NUMBER: case SCSI_IOCTL_PROBE_HOST: case SG_GET_TRANSFORM: case SG_SCSI_RESET: if (atomic_read(&sdp->detaching)) return -ENODEV; break; default: if (read_only) return -EPERM; break; } result = scsi_ioctl_block_when_processing_errors(sdp->device, cmd_in, filp->f_flags & O_NDELAY); if (result) return result; return scsi_ioctl(sdp->device, cmd_in, p); }
Description: The sg_ioctl function in drivers/scsi/sg.c in the Linux kernel through 4.10.4 allows local users to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact via a large command size in an SG_NEXT_CMD_LEN ioctl call, leading to out-of-bounds write access in the sg_write function.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int ff_htmlmarkup_to_ass(void *log_ctx, AVBPrint *dst, const char *in) { char *param, buffer[128], tmp[128]; int len, tag_close, sptr = 1, line_start = 1, an = 0, end = 0; SrtStack stack[16]; int closing_brace_missing = 0; stack[0].tag[0] = 0; strcpy(stack[0].param[PARAM_SIZE],  ""{\\fs}""); strcpy(stack[0].param[PARAM_COLOR], ""{\\c}""); strcpy(stack[0].param[PARAM_FACE],  ""{\\fn}""); for (; !end && *in; in++) { switch (*in) { case '\r': break; case '\n': if (line_start) { end = 1; break; } rstrip_spaces_buf(dst); av_bprintf(dst, ""\\N""); line_start = 1; break; case ' ': if (!line_start) av_bprint_chars(dst, *in, 1); break; case '{':     len = 0; an += sscanf(in, ""{\\an%*1u}%n"", &len) >= 0 && len > 0; if (!closing_brace_missing) { if (   (an != 1 && in[1] == '\\') || (in[1] && strchr(""CcFfoPSsYy"", in[1]) && in[2] == ':')) { char *bracep = strchr(in+2, '}'); if (bracep) { in = bracep; break; } else closing_brace_missing = 1; } } av_bprint_chars(dst, *in, 1); break; case '<': tag_close = in[1] == '/'; len = 0; if (sscanf(in+tag_close+1, ""%127[^<>]>%n"", buffer, &len) >= 1 && len > 0) { const char *tagname = buffer; while (*tagname == ' ') tagname++; if ((param = strchr(tagname, ' '))) *param++ = 0; if ((!tag_close && sptr < FF_ARRAY_ELEMS(stack) && *tagname) || ( tag_close && sptr > 0 && !strcmp(stack[sptr-1].tag, tagname))) { int i, j, unknown = 0; in += len + tag_close; if (!tag_close) memset(stack+sptr, 0, sizeof(*stack)); if (!strcmp(tagname, ""font"")) { if (tag_close) { for (i=PARAM_NUMBER-1; i>=0; i--) if (stack[sptr-1].param[i][0]) for (j=sptr-2; j>=0; j--) if (stack[j].param[i][0]) { av_bprintf(dst, ""%s"", stack[j].param[i]); break; } } else { while (param) { if (!strncmp(param, ""size="", 5)) { unsigned font_size; param += 5 + (param[5] == '""'); if (sscanf(param, ""%u"", &font_size) == 1) { snprintf(stack[sptr].param[PARAM_SIZE], sizeof(stack[0].param[PARAM_SIZE]), ""{\\fs%u}"", font_size); } } else if (!strncmp(param, ""color="", 6)) { param += 6 + (param[6] == '""'); snprintf(stack[sptr].param[PARAM_COLOR], sizeof(stack[0].param[PARAM_COLOR]), ""{\\c&H%X&}"", html_color_parse(log_ctx, param)); } else if (!strncmp(param, ""face="", 5)) { param += 5 + (param[5] == '""'); len = strcspn(param, param[-1] == '""' ? ""\"""" :"" ""); av_strlcpy(tmp, param, FFMIN(sizeof(tmp), len+1)); param += len; snprintf(stack[sptr].param[PARAM_FACE], sizeof(stack[0].param[PARAM_FACE]), ""{\\fn%s}"", tmp); } if ((param = strchr(param, ' '))) param++; } for (i=0; i<PARAM_NUMBER; i++) if (stack[sptr].param[i][0]) av_bprintf(dst, ""%s"", stack[sptr].param[i]); } } else if (tagname[0] && !tagname[1] && strspn(tagname, ""bisu"") == 1) { av_bprintf(dst, ""{\\%c%d}"", tagname[0], !tag_close); } else { unknown = 1; snprintf(tmp, sizeof(tmp), ""</%s>"", tagname); } if (tag_close) { sptr--; } else if (unknown && !strstr(in, tmp)) { in -= len + tag_close; av_bprint_chars(dst, *in, 1); } else av_strlcpy(stack[sptr++].tag, tagname, sizeof(stack[0].tag)); break; } } default: av_bprint_chars(dst, *in, 1); break; } if (*in != ' ' && *in != '\r' && *in != '\n') line_start = 0; } if (!av_bprint_is_complete(dst)) return AVERROR(ENOMEM); while (dst->len >= 2 && !strncmp(&dst->str[dst->len - 2], ""\\N"", 2)) dst->len -= 2; dst->str[dst->len] = 0; rstrip_spaces_buf(dst); return 0; }
Description: In FFmpeg 3.2 and 4.1, a denial of service in the subtitle decoder allows attackers to hog the CPU via a crafted video file in Matroska format, because ff_htmlmarkup_to_ass in libavcodec/htmlsubtitles.c has a complex format argument to sscanf.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void cfile_dump_open_failure_message(const char *progname, const char *filename, int err, int file_type_subtype) { char *file_description; file_description = output_file_description(filename); if (err < 0) { switch (err) { case WTAP_ERR_NOT_REGULAR_FILE: cmdarg_err(""The %s is a \""special file\"" or socket or other non-regular file."", file_description); break; case WTAP_ERR_CANT_WRITE_TO_PIPE: cmdarg_err(""The %s is a pipe, and \""%s\"" capture files can't be written to a pipe."", file_description, wtap_file_type_subtype_short_string(file_type_subtype)); break; case WTAP_ERR_UNWRITABLE_FILE_TYPE: cmdarg_err(""%s doesn't support writing capture files in that format."", progname); break; case WTAP_ERR_UNWRITABLE_ENCAP: cmdarg_err(""The capture file being read can't be written as a \""%s\"" file."", wtap_file_type_subtype_short_string(file_type_subtype)); break; case WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED: cmdarg_err(""The capture file being read can't be written as a \""%s\"" file."", wtap_file_type_subtype_short_string(file_type_subtype)); break; case WTAP_ERR_CANT_OPEN: cmdarg_err(""The %s could not be created for some unknown reason."", file_description); break; case WTAP_ERR_SHORT_WRITE: cmdarg_err(""A full header couldn't be written to the %s."", file_description); break; case WTAP_ERR_COMPRESSION_NOT_SUPPORTED: cmdarg_err(""This file type cannot be written as a compressed file.""); break; default: cmdarg_err(""The %s could not be created: %s."", file_description, wtap_strerror(err)); break; } g_free(file_description); } else cmdarg_err(file_open_error_message(err, TRUE), filename); }
Description: In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, ui/failure_message.c has a memory leak.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int ntfs_attr_find(const ATTR_TYPE type, const ntfschar *name, const u32 name_len, const IGNORE_CASE_BOOL ic, const u8 *val, const u32 val_len, ntfs_attr_search_ctx *ctx) { ATTR_RECORD *a; ntfs_volume *vol = ctx->ntfs_ino->vol; ntfschar *upcase = vol->upcase; u32 upcase_len = vol->upcase_len; if (ctx->is_first) { a = ctx->attr; ctx->is_first = false; } else a = (ATTR_RECORD*)((u8*)ctx->attr + le32_to_cpu(ctx->attr->length)); for (;;a = (ATTR_RECORD*)((u8*)a + le32_to_cpu(a->length))) { u8 *mrec_end = (u8 *)ctx->mrec + le32_to_cpu(ctx->mrec->bytes_allocated); u8 *name_end = (u8 *)a + le16_to_cpu(a->name_offset) + a->name_length * sizeof(ntfschar); if ((u8*)a < (u8*)ctx->mrec || (u8*)a > mrec_end || name_end > mrec_end) break; ctx->attr = a; if (unlikely(le32_to_cpu(a->type) > le32_to_cpu(type) || a->type == AT_END)) return -ENOENT; if (unlikely(!a->length)) break; if (a->type != type) continue; if (!name) { if (a->name_length) return -ENOENT; } else if (!ntfs_are_names_equal(name, name_len, (ntfschar*)((u8*)a + le16_to_cpu(a->name_offset)), a->name_length, ic, upcase, upcase_len)) { register int rc; rc = ntfs_collate_names(name, name_len, (ntfschar*)((u8*)a + le16_to_cpu(a->name_offset)), a->name_length, 1, IGNORE_CASE, upcase, upcase_len); if (rc == -1) return -ENOENT; if (rc) continue; rc = ntfs_collate_names(name, name_len, (ntfschar*)((u8*)a + le16_to_cpu(a->name_offset)), a->name_length, 1, CASE_SENSITIVE, upcase, upcase_len); if (rc == -1) return -ENOENT; if (rc) continue; } if (!val) return 0; else { register int rc; rc = memcmp(val, (u8*)a + le16_to_cpu( a->data.resident.value_offset), min_t(u32, val_len, le32_to_cpu( a->data.resident.value_length))); if (!rc) { register u32 avl; avl = le32_to_cpu( a->data.resident.value_length); if (val_len == avl) return 0; if (val_len < avl) return -ENOENT; } else if (rc < 0) return -ENOENT; } } ntfs_error(vol->sb, ""Inode is corrupt.  Run chkdsk.""); NVolSetErrors(vol); return -EIO; }
Description: In the Linux kernel 6.0.8, there is an out-of-bounds read in ntfs_attr_find in fs/ntfs/attrib.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void Curl_detach_connnection(struct Curl_easy *data) { struct connectdata *conn = data->conn; if(conn) Curl_llist_remove(&conn->easyq, &data->conn_queue, NULL); data->conn = NULL; }
Description: curl 7.75.0 through 7.76.1 suffers from a use-after-free vulnerability resulting in already freed memory being used when a TLS 1.3 session ticket arrives over a connection. A malicious server can use this in rare unfortunate circumstances to potentially reach remote code execution in the client. When libcurl at run-time sets up support for TLS 1.3 session tickets on a connection using OpenSSL, it stores pointers to the transfer in-memory object for later retrieval when a session ticket arrives. If the connection is used by multiple transfers (like with a reused HTTP/1.1 connection or multiplexed HTTP/2 connection) that first transfer object might be freed before the new session is established on that connection and then the function will access a memory buffer that might be freed. When using that memory, libcurl might even call a function pointer in the object, making it possible for a remote code execution if the server could somehow manage to get crafted memory content into the correct place in memory.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static Image *ReadWPGImage(const ImageInfo *image_info, ExceptionInfo *exception) { typedef struct { size_t FileId; MagickOffsetType DataOffset; unsigned int ProductType; unsigned int FileType; unsigned char MajorVersion; unsigned char MinorVersion; unsigned int EncryptKey; unsigned int Reserved; } WPGHeader; typedef struct { unsigned char RecType; size_t RecordLength; } WPGRecord; typedef struct { unsigned char Class; unsigned char RecType; size_t Extension; size_t RecordLength; } WPG2Record; typedef struct { unsigned  HorizontalUnits; unsigned  VerticalUnits; unsigned char PosSizePrecision; } WPG2Start; typedef struct { unsigned int Width; unsigned int Height; unsigned int Depth; unsigned int HorzRes; unsigned int VertRes; } WPGBitmapType1; typedef struct { unsigned int Width; unsigned int Height; unsigned char Depth; unsigned char Compression; } WPG2BitmapType1; typedef struct { unsigned int RotAngle; unsigned int LowLeftX; unsigned int LowLeftY; unsigned int UpRightX; unsigned int UpRightY; unsigned int Width; unsigned int Height; unsigned int Depth; unsigned int HorzRes; unsigned int VertRes; } WPGBitmapType2; typedef struct { unsigned int StartIndex; unsigned int NumOfEntries; } WPGColorMapRec; Image *image; unsigned int status; WPGHeader Header; WPGRecord Rec; WPG2Record Rec2; WPG2Start StartWPG; WPGBitmapType1 BitmapHeader1; WPG2BitmapType1 Bitmap2Header1; WPGBitmapType2 BitmapHeader2; WPGColorMapRec WPG_Palette; int i, bpp, WPG2Flags; ssize_t ldblk; size_t one; unsigned char *BImgBuff; tCTM CTM;          assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); one=1; image=AcquireImage(image_info,exception); image->depth=8; status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } Header.FileId=ReadBlobLSBLong(image); Header.DataOffset=(MagickOffsetType) ReadBlobLSBLong(image); Header.ProductType=ReadBlobLSBShort(image); Header.FileType=ReadBlobLSBShort(image); Header.MajorVersion=ReadBlobByte(image); Header.MinorVersion=ReadBlobByte(image); Header.EncryptKey=ReadBlobLSBShort(image); Header.Reserved=ReadBlobLSBShort(image); if (Header.FileId!=0x435057FF || (Header.ProductType>>8)!=0x16) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); if (Header.EncryptKey!=0) ThrowReaderException(CoderError,""EncryptedWPGImageFileNotSupported""); image->columns = 1; image->rows = 1; image->colors = 0; bpp=0; BitmapHeader2.RotAngle=0; Rec2.RecordLength=0; switch(Header.FileType) { case 1:      while(!EOFBlob(image))  { (void) SeekBlob(image,Header.DataOffset,SEEK_SET); if(EOFBlob(image)) break; Rec.RecType=(i=ReadBlobByte(image)); if(i==EOF) break; Rd_WP_DWORD(image,&Rec.RecordLength); if(EOFBlob(image)) break; Header.DataOffset=TellBlob(image)+Rec.RecordLength; switch(Rec.RecType) { case 0x0B:  BitmapHeader1.Width=ReadBlobLSBShort(image); BitmapHeader1.Height=ReadBlobLSBShort(image); if ((BitmapHeader1.Width == 0) || (BitmapHeader1.Height == 0)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); BitmapHeader1.Depth=ReadBlobLSBShort(image); BitmapHeader1.HorzRes=ReadBlobLSBShort(image); BitmapHeader1.VertRes=ReadBlobLSBShort(image); if(BitmapHeader1.HorzRes && BitmapHeader1.VertRes) { image->units=PixelsPerCentimeterResolution; image->resolution.x=BitmapHeader1.HorzRes/470.0; image->resolution.y=BitmapHeader1.VertRes/470.0; } image->columns=BitmapHeader1.Width; image->rows=BitmapHeader1.Height; bpp=BitmapHeader1.Depth; goto UnpackRaster; case 0x0E:   WPG_Palette.StartIndex=ReadBlobLSBShort(image); WPG_Palette.NumOfEntries=ReadBlobLSBShort(image); if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) > (Rec2.RecordLength-2-2) / 3) ThrowReaderException(CorruptImageError,""InvalidColormapIndex""); image->colors=WPG_Palette.NumOfEntries; if (!AcquireImageColormap(image,image->colors,exception)) goto NoMemory; for (i=WPG_Palette.StartIndex; i < (int)WPG_Palette.NumOfEntries; i++) { image->colormap[i].red=ScaleCharToQuantum((unsigned char) ReadBlobByte(image)); image->colormap[i].green=ScaleCharToQuantum((unsigned char) ReadBlobByte(image)); image->colormap[i].blue=ScaleCharToQuantum((unsigned char) ReadBlobByte(image)); } break; case 0x11:   if(Rec.RecordLength > 8) image=ExtractPostscript(image,image_info, TellBlob(image)+8,    (ssize_t) Rec.RecordLength-8,exception); break;      case 0x14:   BitmapHeader2.RotAngle=ReadBlobLSBShort(image); BitmapHeader2.LowLeftX=ReadBlobLSBShort(image); BitmapHeader2.LowLeftY=ReadBlobLSBShort(image); BitmapHeader2.UpRightX=ReadBlobLSBShort(image); BitmapHeader2.UpRightY=ReadBlobLSBShort(image); BitmapHeader2.Width=ReadBlobLSBShort(image); BitmapHeader2.Height=ReadBlobLSBShort(image); if ((BitmapHeader2.Width == 0) || (BitmapHeader2.Height == 0)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); BitmapHeader2.Depth=ReadBlobLSBShort(image); BitmapHeader2.HorzRes=ReadBlobLSBShort(image); BitmapHeader2.VertRes=ReadBlobLSBShort(image); image->units=PixelsPerCentimeterResolution; image->page.width=(unsigned int) ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightX)/470.0); image->page.height=(unsigned int) ((BitmapHeader2.LowLeftX-BitmapHeader2.UpRightY)/470.0); image->page.x=(int) (BitmapHeader2.LowLeftX/470.0); image->page.y=(int) (BitmapHeader2.LowLeftX/470.0); if(BitmapHeader2.HorzRes && BitmapHeader2.VertRes) { image->resolution.x=BitmapHeader2.HorzRes/470.0; image->resolution.y=BitmapHeader2.VertRes/470.0; } image->columns=BitmapHeader2.Width; image->rows=BitmapHeader2.Height; bpp=BitmapHeader2.Depth; UnpackRaster:       status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) break; if ((image->colors == 0) && (bpp != 24)) { image->colors=one << bpp; if (!AcquireImageColormap(image,image->colors,exception)) { NoMemory: ThrowReaderException(ResourceLimitError, ""MemoryAllocationFailed""); } for (i=0; (i < (int) image->colors) && (i < 256); i++) {                image->colormap[i].red=ScaleCharToQuantum(WPG1_Palette[i].Red); image->colormap[i].green=ScaleCharToQuantum(WPG1_Palette[i].Green); image->colormap[i].blue=ScaleCharToQuantum(WPG1_Palette[i].Blue); } } else { if (bpp < 24) if ( (image->colors < (one << bpp)) && (bpp != 24) ) image->colormap=(PixelInfo *) ResizeQuantumMemory( image->colormap,(size_t) (one << bpp), sizeof(*image->colormap)); } if (bpp == 1) { if(image->colormap[0].red==0 && image->colormap[0].green==0 && image->colormap[0].blue==0 && image->colormap[1].red==0 && image->colormap[1].green==0 && image->colormap[1].blue==0) {   image->colormap[1].red = image->colormap[1].green = image->colormap[1].blue = QuantumRange; } }       if(UnpackWPGRaster(image,bpp,exception) < 0) { DecompressionFailed: ThrowReaderException(CoderError,""UnableToDecompressImage""); } if(Rec.RecType==0x14 && BitmapHeader2.RotAngle!=0 && !image_info->ping) {   if(BitmapHeader2.RotAngle & 0x8000) { Image *flop_image; flop_image = FlopImage(image, exception); if (flop_image != (Image *) NULL) { DuplicateBlob(flop_image,image); ReplaceImageInList(&image,flop_image); } } if(BitmapHeader2.RotAngle & 0x2000) { Image *flip_image; flip_image = FlipImage(image, exception); if (flip_image != (Image *) NULL) { DuplicateBlob(flip_image,image); ReplaceImageInList(&image,flip_image); } } if(BitmapHeader2.RotAngle & 0x0FFF) { Image *rotate_image; rotate_image=RotateImage(image,(BitmapHeader2.RotAngle & 0x0FFF), exception); if (rotate_image != (Image *) NULL) { DuplicateBlob(rotate_image,image); ReplaceImageInList(&image,rotate_image); } } } AcquireNextImage(image_info,image,exception); image->depth=8; if (image->next == (Image *) NULL) goto Finish; image=SyncNextImageInList(image); image->columns=image->rows=1; image->colors=0; break; case 0x1B:   if(Rec.RecordLength>0x3C) image=ExtractPostscript(image,image_info, TellBlob(image)+0x3C,    (ssize_t) Rec.RecordLength-0x3C,exception); break; } } break; case 2:   (void) memset(CTM,0,sizeof(CTM)); StartWPG.PosSizePrecision = 0; while(!EOFBlob(image))  { (void) SeekBlob(image,Header.DataOffset,SEEK_SET); if(EOFBlob(image)) break; Rec2.Class=(i=ReadBlobByte(image)); if(i==EOF) break; Rec2.RecType=(i=ReadBlobByte(image)); if(i==EOF) break; Rd_WP_DWORD(image,&Rec2.Extension); Rd_WP_DWORD(image,&Rec2.RecordLength); if(EOFBlob(image)) break; Header.DataOffset=TellBlob(image)+Rec2.RecordLength; switch(Rec2.RecType) { case 1: StartWPG.HorizontalUnits=ReadBlobLSBShort(image); StartWPG.VerticalUnits=ReadBlobLSBShort(image); StartWPG.PosSizePrecision=ReadBlobByte(image); break; case 0x0C:     WPG_Palette.StartIndex=ReadBlobLSBShort(image); WPG_Palette.NumOfEntries=ReadBlobLSBShort(image); if ((WPG_Palette.NumOfEntries-WPG_Palette.StartIndex) > (Rec2.RecordLength-2-2) / 3) ThrowReaderException(CorruptImageError,""InvalidColormapIndex""); image->colors=WPG_Palette.NumOfEntries; if (AcquireImageColormap(image,image->colors,exception) == MagickFalse) ThrowReaderException(ResourceLimitError, ""MemoryAllocationFailed""); for (i=WPG_Palette.StartIndex; i < (int)WPG_Palette.NumOfEntries; i++) { image->colormap[i].red=ScaleCharToQuantum((char) ReadBlobByte(image)); image->colormap[i].green=ScaleCharToQuantum((char) ReadBlobByte(image)); image->colormap[i].blue=ScaleCharToQuantum((char) ReadBlobByte(image)); (void) ReadBlobByte(image);    } break; case 0x0E: Bitmap2Header1.Width=ReadBlobLSBShort(image); Bitmap2Header1.Height=ReadBlobLSBShort(image); if ((Bitmap2Header1.Width == 0) || (Bitmap2Header1.Height == 0)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); Bitmap2Header1.Depth=ReadBlobByte(image); Bitmap2Header1.Compression=ReadBlobByte(image); if(Bitmap2Header1.Compression > 1) continue;  switch(Bitmap2Header1.Depth) { case 1: bpp=1; break; case 2: bpp=2; break; case 3: bpp=4; break; case 4: bpp=8; break; case 8: bpp=24; break; default: continue;   } image->columns=Bitmap2Header1.Width; image->rows=Bitmap2Header1.Height; status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) break; if ((image->colors == 0) && (bpp != 24)) { image->colors=one << bpp; if (!AcquireImageColormap(image,image->colors,exception)) goto NoMemory; } else { if(bpp < 24) if( image->colors<(one << bpp) && bpp!=24 ) image->colormap=(PixelInfo *) ResizeQuantumMemory( image->colormap,(size_t) (one << bpp), sizeof(*image->colormap)); } switch(Bitmap2Header1.Compression) { case 0:     { ldblk=(ssize_t) ((bpp*image->columns+7)/8); BImgBuff=(unsigned char *) AcquireQuantumMemory((size_t) ldblk+1,sizeof(*BImgBuff)); if (BImgBuff == (unsigned char *) NULL) goto NoMemory; for(i=0; i< (ssize_t) image->rows; i++) { (void) ReadBlob(image,ldblk,BImgBuff); InsertRow(image,BImgBuff,i,bpp,exception); } if(BImgBuff) BImgBuff=(unsigned char *) RelinquishMagickMemory(BImgBuff); break; } case 1:     { if( UnpackWPG2Raster(image,bpp,exception) < 0) goto DecompressionFailed; break; }    } if(CTM[0][0]<0 && !image_info->ping) {     Image *flop_image; flop_image = FlopImage(image, exception); if (flop_image != (Image *) NULL) { DuplicateBlob(flop_image,image); ReplaceImageInList(&image,flop_image); } } if(CTM[1][1]<0 && !image_info->ping) {     Image *flip_image; flip_image = FlipImage(image, exception); if (flip_image != (Image *) NULL) { DuplicateBlob(flip_image,image); ReplaceImageInList(&image,flip_image); } } AcquireNextImage(image_info,image,exception); image->depth=8; if (image->next == (Image *) NULL) goto Finish; image=SyncNextImageInList(image); image->columns=image->rows=1; image->colors=0; break; case 0x12:   i=ReadBlobLSBShort(image); if(Rec2.RecordLength > (unsigned int) i) image=ExtractPostscript(image,image_info, TellBlob(image)+i,     (ssize_t) (Rec2.RecordLength-i-2),exception); break; case 0x1B:           WPG2Flags = LoadWPG2Flags(image,StartWPG.PosSizePrecision,NULL,&CTM); (void) WPG2Flags; break; } } break; default: { ThrowReaderException(CoderError,""DataEncodingSchemeIsNotSupported""); } } Finish: (void) CloseBlob(image); { Image *p; ssize_t scene=0; p=image; image=NULL; while (p != (Image *) NULL) { Image *tmp=p; if ((p->rows == 0) || (p->columns == 0)) { p=p->previous; DeleteImageFromList(&tmp); } else { image=p; p=p->previous; } } for (p=image; p != (Image *) NULL; p=p->next) p->scene=(size_t) scene++; } if (image == (Image *) NULL) ThrowReaderException(CorruptImageError, ""ImageFileDoesNotContainAnyImageData""); return(image); }
Description: ImageMagick 7.0.6-6 has a large loop vulnerability in ReadWPGImage in coders/wpg.c, causing CPU exhaustion via a crafted wpg image file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void mem_log_init(const char* prog_name, const char *banner) { size_t log_name_len; char *log_name; if (__test_bit(LOG_CONSOLE_BIT, &debug)) { log_op = stderr; return; } if (log_op) fclose(log_op); log_name_len = 5 + strlen(prog_name) + 5 + 7 + 4 + 1; log_name = malloc(log_name_len); if (!log_name) { log_message(LOG_INFO, ""Unable to malloc log file name""); log_op = stderr; return; } snprintf(log_name, log_name_len, ""/tmp/%s_mem.%d.log"", prog_name, getpid()); log_op = fopen(log_name, ""a""); if (log_op == NULL) { log_message(LOG_INFO, ""Unable to open %s for appending"", log_name); log_op = stderr; } else { int fd = fileno(log_op); fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC); setlinebuf(log_op); fprintf(log_op, ""\n""); } free(log_name); terminate_banner = banner; }
Description: keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Error HeifContext::get_id_of_non_virtual_child_image(heif_item_id id, heif_item_id& out) const { std::string image_type = m_heif_file->get_item_type(id); if (image_type==""grid"" || image_type==""iden"" || image_type==""iovl"") { auto iref_box = m_heif_file->get_iref_box(); std::vector<heif_item_id> image_references = iref_box->get_references(id, fourcc(""dimg"")); if (image_references.empty()) { return Error(heif_error_Invalid_input, heif_suberror_No_item_data, ""Derived image does not reference any other image items""); } else { return get_id_of_non_virtual_child_image(image_references[0], out); } } else { out = id; return Error::Ok; } }
Description: An issue was discovered in heif::Box_iref::get_references in libheif 1.4.0, allows attackers to cause a Denial of Service or possibly other unspecified impact due to an invalid memory read.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int writeImageSections(TIFF *in, TIFF *out, struct image_data *image, struct pagedef *page, struct pageseg *sections, struct dump_opts * dump, unsigned char *src_buff, unsigned char **sect_buff_ptr) { double  hres, vres; uint32_t  i, k, width, length, sectsize; unsigned char *sect_buff = *sect_buff_ptr; hres = page->hres; vres = page->vres; k = page->cols * page->rows; if ((k < 1) || (k > MAX_SECTIONS)) { TIFFError(""writeImageSections"", ""%""PRIu32"" Rows and Columns exceed maximum sections\nIncrease resolution or reduce sections"", k); return (-1); } for (i = 0; i < k; i++) { width  = sections[i].x2 - sections[i].x1 + 1; length = sections[i].y2 - sections[i].y1 + 1; sectsize = (uint32_t) ceil((width * image->bps + 7) / (double)8) * image->spp * length; if (createImageSection(sectsize, sect_buff_ptr)) { TIFFError(""writeImageSections"", ""Unable to allocate section buffer""); exit(EXIT_FAILURE); } sect_buff = *sect_buff_ptr; if (extractImageSection (image, &sections[i], src_buff, sect_buff)) { TIFFError(""writeImageSections"", ""Unable to extract image sections""); exit(EXIT_FAILURE); } if (writeSingleSection(in, out, image, dump, width, length, hres, vres, sect_buff)) { TIFFError(""writeImageSections"", ""Unable to write image section""); exit(EXIT_FAILURE); } } return (0); }
Description: A heap buffer overflow in ExtractImageSection function in tiffcrop.c in libtiff library Version 4.3.0 allows attacker to trigger unsafe or out of bounds memory access via crafted TIFF image file which could result into application crash, potential information disclosure or any other context-dependent impact
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool  Jpeg2KDecoder::readData( Mat& img ) { bool result = false; int color = img.channels() > 1; uchar* data = img.ptr(); int step = (int)img.step; jas_stream_t* stream = (jas_stream_t*)m_stream; jas_image_t* image = (jas_image_t*)m_image; #ifndef _WIN32 Mat clr; if (CV_MAT_CN(img.type()) < CV_MAT_CN(this->type())) { clr.create(img.size().height, img.size().width, this->type()); color = true; data = clr.ptr(); step = (int)clr.step; } #endif if( stream && image ) { bool convert; int colorspace; if( color ) { convert = (jas_image_clrspc( image ) != JAS_CLRSPC_SRGB); colorspace = JAS_CLRSPC_SRGB; } else { convert = (jas_clrspc_fam( jas_image_clrspc( image ) ) != JAS_CLRSPC_FAM_GRAY); colorspace = JAS_CLRSPC_SGRAY;         } if( convert ) { jas_cmprof_t *clrprof = jas_cmprof_createfromclrspc( colorspace ); if( clrprof ) { jas_image_t *_img = jas_image_chclrspc( image, clrprof, JAS_CMXFORM_INTENT_RELCLR ); if( _img ) { jas_image_destroy( image ); m_image = image = _img; result = true; } else fprintf(stderr, ""JPEG 2000 LOADER ERROR: cannot convert colorspace\n""); jas_cmprof_destroy( clrprof ); } else fprintf(stderr, ""JPEG 2000 LOADER ERROR: unable to create colorspace\n""); } else result = true; if( result ) { int ncmpts; int cmptlut[3]; if( color ) { cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_B ); cmptlut[1] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_G ); cmptlut[2] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_RGB_R ); if( cmptlut[0] < 0 || cmptlut[1] < 0 || cmptlut[2] < 0 ) result = false; ncmpts = 3; } else { cmptlut[0] = jas_image_getcmptbytype( image, JAS_IMAGE_CT_GRAY_Y ); if( cmptlut[0] < 0 ) result = false; ncmpts = 1; } if( result ) { for( int i = 0; i < ncmpts; i++ ) { int maxval = 1 << jas_image_cmptprec( image, cmptlut[i] ); int offset =  jas_image_cmptsgnd( image, cmptlut[i] ) ? maxval / 2 : 0; int yend = jas_image_cmptbry( image, cmptlut[i] ); int ystep = jas_image_cmptvstep( image, cmptlut[i] ); int xend = jas_image_cmptbrx( image, cmptlut[i] ); int xstep = jas_image_cmpthstep( image, cmptlut[i] ); jas_matrix_t *buffer = jas_matrix_create( yend / ystep, xend / xstep ); if( buffer ) { if( !jas_image_readcmpt( image, cmptlut[i], 0, 0, xend / xstep, yend / ystep, buffer )) { if( img.depth() == CV_8U ) result = readComponent8u( data + i, buffer, step, cmptlut[i], maxval, offset, ncmpts ); else result = readComponent16u( ((unsigned short *)data) + i, buffer, step / 2, cmptlut[i], maxval, offset, ncmpts ); if( !result ) { i = ncmpts; result = false; } } jas_matrix_destroy( buffer ); } } } } else fprintf(stderr, ""JPEG2000 LOADER ERROR: colorspace conversion failed\n"" ); } close(); #ifndef _WIN32 if (!clr.empty()) { cv::cvtColor(clr, img, COLOR_BGR2GRAY); } #endif return result; }
Description: OpenCV (Open Source Computer Vision Library) 3.3 has an out-of-bounds write error in the function FillColorRow1 in utils.cpp when reading an image file by using cv::imread. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-12597.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void ppp_cp_parse_cr(struct net_device *dev, u16 pid, u8 id, unsigned int req_len, const u8 *data) { static u8 const valid_accm[6] = { LCP_OPTION_ACCM, 6, 0, 0, 0, 0 }; const u8 *opt; u8 *out; unsigned int len = req_len, nak_len = 0, rej_len = 0; if (!(out = kmalloc(len, GFP_ATOMIC))) { dev->stats.rx_dropped++; return; } for (opt = data; len; len -= opt[1], opt += opt[1]) { if (len < 2 || len < opt[1]) { dev->stats.rx_errors++; kfree(out); return;  } if (pid == PID_LCP) switch (opt[0]) { case LCP_OPTION_MRU: continue;  case LCP_OPTION_ACCM:  if (!memcmp(opt, valid_accm, sizeof(valid_accm))) continue; if (!rej_len) {  memcpy(out + nak_len, valid_accm, sizeof(valid_accm)); nak_len += sizeof(valid_accm); continue; } break; case LCP_OPTION_MAGIC: if (opt[1] != 6 || (!opt[2] && !opt[3] && !opt[4] && !opt[5])) break;  continue; } memcpy(out + rej_len, opt, opt[1]); rej_len += opt[1]; } if (rej_len) ppp_cp_event(dev, pid, RCR_BAD, CP_CONF_REJ, id, rej_len, out); else if (nak_len) ppp_cp_event(dev, pid, RCR_BAD, CP_CONF_NAK, id, nak_len, out); else ppp_cp_event(dev, pid, RCR_GOOD, CP_CONF_ACK, id, req_len, data); kfree(out); }
Description: A flaw was found in the HDLC_PPP module of the Linux kernel in versions before 5.9-rc7. Memory corruption and a read overflow is caused by improper input validation in the ppp_cp_parse_cr function which can cause the system to crash or cause a denial of service. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int ethertype_print(netdissect_options *ndo, u_short ether_type, const u_char *p, u_int length, u_int caplen, const struct lladdr_info *src, const struct lladdr_info *dst) { switch (ether_type) { case ETHERTYPE_IP: ip_print(ndo, p, length); return (1); case ETHERTYPE_IPV6: ip6_print(ndo, p, length); return (1); case ETHERTYPE_ARP: case ETHERTYPE_REVARP: arp_print(ndo, p, length, caplen); return (1); case ETHERTYPE_DN: decnet_print(ndo, p, length, caplen); return (1); case ETHERTYPE_ATALK: if (ndo->ndo_vflag) ND_PRINT((ndo, ""et1 "")); atalk_print(ndo, p, length); return (1); case ETHERTYPE_AARP: aarp_print(ndo, p, length); return (1); case ETHERTYPE_IPX: ND_PRINT((ndo, ""(NOV-ETHII) "")); ipx_print(ndo, p, length); return (1); case ETHERTYPE_ISO: if (length == 0 || caplen == 0) { ND_PRINT((ndo, "" [|osi]"")); return (1); } isoclns_print(ndo, p + 1, length - 1, caplen - 1); return(1); case ETHERTYPE_PPPOED: case ETHERTYPE_PPPOES: case ETHERTYPE_PPPOED2: case ETHERTYPE_PPPOES2: pppoe_print(ndo, p, length); return (1); case ETHERTYPE_EAPOL: eap_print(ndo, p, length); return (1); case ETHERTYPE_RRCP: rrcp_print(ndo, p, length, src, dst); return (1); case ETHERTYPE_PPP: if (length) { ND_PRINT((ndo, "": "")); ppp_print(ndo, p, length); } return (1); case ETHERTYPE_MPCP: mpcp_print(ndo, p, length); return (1); case ETHERTYPE_SLOW: slow_print(ndo, p, length); return (1); case ETHERTYPE_CFM: case ETHERTYPE_CFM_OLD: cfm_print(ndo, p, length); return (1); case ETHERTYPE_LLDP: lldp_print(ndo, p, length); return (1); case ETHERTYPE_NSH: nsh_print(ndo, p, length); return (1); case ETHERTYPE_LOOPBACK: loopback_print(ndo, p, length); return (1); case ETHERTYPE_MPLS: case ETHERTYPE_MPLS_MULTI: mpls_print(ndo, p, length); return (1); case ETHERTYPE_TIPC: tipc_print(ndo, p, length, caplen); return (1); case ETHERTYPE_MS_NLB_HB: msnlb_print(ndo, p); return (1); case ETHERTYPE_GEONET_OLD: case ETHERTYPE_GEONET: geonet_print(ndo, p, length, src); return (1); case ETHERTYPE_CALM_FAST: calm_fast_print(ndo, p, length, src); return (1); case ETHERTYPE_AOE: aoe_print(ndo, p, length); return (1); case ETHERTYPE_MEDSA: medsa_print(ndo, p, length, caplen, src, dst); return (1); case ETHERTYPE_LAT: case ETHERTYPE_SCA: case ETHERTYPE_MOPRC: case ETHERTYPE_MOPDL: case ETHERTYPE_IEEE1905_1: default: return (0); } }
Description: The ISO CLNS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isoclns_print().
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int ProcXChangeFeedbackControl(ClientPtr client) { unsigned len; DeviceIntPtr dev; KbdFeedbackPtr k; PtrFeedbackPtr p; IntegerFeedbackPtr i; StringFeedbackPtr s; BellFeedbackPtr b; LedFeedbackPtr l; int rc; REQUEST(xChangeFeedbackControlReq); REQUEST_AT_LEAST_SIZE(xChangeFeedbackControlReq); len = stuff->length - bytes_to_int32(sizeof(xChangeFeedbackControlReq)); rc = dixLookupDevice(&dev, stuff->deviceid, client, DixManageAccess); if (rc != Success) return rc; switch (stuff->feedbackid) { case KbdFeedbackClass: if (len != bytes_to_int32(sizeof(xKbdFeedbackCtl))) return BadLength; for (k = dev->kbdfeed; k; k = k->next) if (k->ctrl.id == ((xKbdFeedbackCtl *) &stuff[1])->id) return ChangeKbdFeedback(client, dev, stuff->mask, k, (xKbdFeedbackCtl *) &stuff[1]); break; case PtrFeedbackClass: if (len != bytes_to_int32(sizeof(xPtrFeedbackCtl))) return BadLength; for (p = dev->ptrfeed; p; p = p->next) if (p->ctrl.id == ((xPtrFeedbackCtl *) &stuff[1])->id) return ChangePtrFeedback(client, dev, stuff->mask, p, (xPtrFeedbackCtl *) &stuff[1]); break; case StringFeedbackClass: { xStringFeedbackCtl *f = ((xStringFeedbackCtl *) &stuff[1]); if (client->swapped) { if (len < bytes_to_int32(sizeof(xStringFeedbackCtl))) return BadLength; swaps(&f->num_keysyms); } if (len != (bytes_to_int32(sizeof(xStringFeedbackCtl)) + f->num_keysyms)) return BadLength; for (s = dev->stringfeed; s; s = s->next) if (s->ctrl.id == ((xStringFeedbackCtl *) &stuff[1])->id) return ChangeStringFeedback(client, dev, stuff->mask, s, (xStringFeedbackCtl *) &stuff[1]); break; } case IntegerFeedbackClass: if (len != bytes_to_int32(sizeof(xIntegerFeedbackCtl))) return BadLength; for (i = dev->intfeed; i; i = i->next) if (i->ctrl.id == ((xIntegerFeedbackCtl *) &stuff[1])->id) return ChangeIntegerFeedback(client, dev, stuff->mask, i, (xIntegerFeedbackCtl *) & stuff[1]); break; case LedFeedbackClass: if (len != bytes_to_int32(sizeof(xLedFeedbackCtl))) return BadLength; for (l = dev->leds; l; l = l->next) if (l->ctrl.id == ((xLedFeedbackCtl *) &stuff[1])->id) return ChangeLedFeedback(client, dev, stuff->mask, l, (xLedFeedbackCtl *) &stuff[1]); break; case BellFeedbackClass: if (len != bytes_to_int32(sizeof(xBellFeedbackCtl))) return BadLength; for (b = dev->bell; b; b = b->next) if (b->ctrl.id == ((xBellFeedbackCtl *) &stuff[1])->id) return ChangeBellFeedback(client, dev, stuff->mask, b, (xBellFeedbackCtl *) &stuff[1]); break; default: break; } return BadMatch; }
Description: A flaw was found in xorg-x11-server in versions before 1.20.11. An integer underflow can occur in xserver which can lead to a local privilege escalation. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void BD_CheckSFTimeOffset(GF_BifsDecoder *codec, GF_Node *node, GF_FieldInfo *inf) { if (gf_node_get_tag(node) != TAG_ProtoNode) { if (!stricmp(inf->name, ""startTime"") || !stricmp(inf->name, ""stopTime"")) BD_OffsetSFTime(codec,  (Double *)inf->far_ptr); } else if (gf_sg_proto_field_is_sftime_offset(node, inf)) { BD_OffsetSFTime(codec,  (Double *)inf->far_ptr); } }
Description: GPAC 2.1-DEV-rev368-gfd054169b-master was discovered to contain a segmentation violation via the function BD_CheckSFTimeOffset at /bifs/field_decode.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static inline int add_post_vars(zval *arr, post_var_data_t *vars, zend_bool eof TSRMLS_DC) { uint64_t max_vars = PG(max_input_vars); vars->ptr = vars->str.c; vars->end = vars->str.c + vars->str.len; while (add_post_var(arr, vars, eof TSRMLS_CC)) { if (++vars->cnt > max_vars) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Input variables exceeded %"" PRIu64 "". "" ""To increase the limit change max_input_vars in php.ini."", max_vars); return FAILURE; } } if (!eof) { memmove(vars->str.c, vars->ptr, vars->str.len = vars->end - vars->ptr); } return SUCCESS; }
Description: In PHP before 5.6.31, 7.x before 7.0.17, and 7.1.x before 7.1.3, remote attackers could cause a CPU consumption denial of service attack by injecting long form variables, related to main/php_variables.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int array_list_del_idx(struct array_list *arr, size_t idx, size_t count) { size_t i, stop; stop = idx + count; if (idx >= arr->length || stop > arr->length) return -1; for (i = idx; i < stop; ++i) { if (arr->array[i]) arr->free_fn(arr->array[i]); } memmove(arr->array + idx, arr->array + stop, (arr->length - stop) * sizeof(void *)); arr->length -= count; return 0; }
Description: json-c through 0.14 has an integer overflow and out-of-bounds write via a large JSON file, as demonstrated by printbuf_memappend.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void lcPiecesLibrary::ReleaseBuffers(lcContext* Context) { Context->DestroyVertexBuffer(mVertexBuffer); Context->DestroyIndexBuffer(mIndexBuffer); mBuffersDirty = true; }
Description: LeoCAD before 21.03 sometimes allows a use-after-free during the opening of a new document.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static BOOL nsc_stream_initialize(NSC_CONTEXT* context, wStream* s) { WINPR_ASSERT(context); WINPR_ASSERT(context->priv); if (!Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, 20)) return FALSE; size_t total = 0; for (size_t i = 0; i < 4; i++) { Stream_Read_UINT32(s, context->PlaneByteCount[i]); total += context->PlaneByteCount[i]; } Stream_Read_UINT8(s, context->ColorLossLevel);          Stream_Read_UINT8(s, context->ChromaSubsamplingLevel);  Stream_Seek(s, 2);                                      context->Planes = Stream_Pointer(s); return Stream_CheckAndLogRequiredLengthWLog(context->priv->log, s, total); }
Description: FreeRDP is a free implementation of the Remote Desktop Protocol (RDP), released under the Apache license. Affected versions are subject to an Out-Of-Bounds Read in the `nsc_rle_decompress_data` function. The Out-Of-Bounds Read occurs because it processes `context->Planes` without  checking if it contains data of sufficient length. Should an attacker be able to leverage this vulnerability they may be able to cause a crash. This issue has been addressed in versions 2.11.0 and 3.0.0-beta3. Users are advised to upgrade. There are no known workarounds for this vulnerability.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int nfc_activate_target(struct nfc_dev *dev, u32 target_idx, u32 protocol) { int rc; struct nfc_target *target; pr_debug(""dev_name=%s target_idx=%u protocol=%u\n"", dev_name(&dev->dev), target_idx, protocol); device_lock(&dev->dev); if (!device_is_registered(&dev->dev)) { rc = -ENODEV; goto error; } if (dev->active_target) { rc = -EBUSY; goto error; } target = nfc_find_target(dev, target_idx); if (target == NULL) { rc = -ENOTCONN; goto error; } rc = dev->ops->activate_target(dev, target, protocol); if (!rc) { dev->active_target = target; dev->rf_mode = NFC_RF_INITIATOR; if (dev->ops->check_presence && !dev->shutting_down) mod_timer(&dev->check_pres_timer, jiffies + msecs_to_jiffies(NFC_CHECK_PRES_FREQ_MS)); } error: device_unlock(&dev->dev); return rc; }
Description: A use-after-free flaw was found in the Linux kernel's NFC core functionality due to a race condition between kobject creation and delete. This vulnerability allows a local attacker with CAP_NET_ADMIN privilege to leak kernel information.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static gint dissect_mutable_member(proto_tree *tree , tvbuff_t * tvb, gint offset, guint encoding, guint encoding_version, dissection_info * info, gboolean * is_end, gboolean show) { proto_tree * member; guint32 member_id, member_length; mutable_member_mapping * mapping; gint64 key; rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length); if ((member_id & PID_LIST_END) == PID_LIST_END){ offset += 0; *is_end = TRUE; return offset; } if (member_length == 0){ return offset; } member = proto_tree_add_subtree_format(tree, tvb, offset, member_length, ett_rtps_dissection_tree, NULL, ""ID: %d, Length: %d"", member_id, member_length); { if (info->base_type_id > 0) { key = (info->base_type_id + info->base_type_id * member_id); mapping = (mutable_member_mapping *) wmem_map_lookup(mutable_member_mappings, &(key)); if (mapping) {  proto_item_append_text(member, ""(base found 0x%016"" PRIx64 "")"", key); dissect_user_defined(tree, tvb, offset, encoding, encoding_version, NULL, mapping->member_type_id, mapping->member_name, EXTENSIBILITY_INVALID, offset, 0, mapping->member_id, show); proto_item_set_hidden(member); return offset + member_length; } else proto_item_append_text(member, ""(base not found 0x%016"" PRIx64 "" from 0x%016"" PRIx64 "")"", key, info->base_type_id); } } key = (info->type_id + info->type_id * member_id); mapping = (mutable_member_mapping *) wmem_map_lookup(mutable_member_mappings, &(key)); if (mapping) {  proto_item_append_text(member, ""(found 0x%016"" PRIx64 "")"", key); dissect_user_defined(tree, tvb, offset, encoding, encoding_version, NULL, mapping->member_type_id, mapping->member_name, EXTENSIBILITY_INVALID, offset, 0, mapping->member_id, show); } else proto_item_append_text(member, ""(not found 0x%016"" PRIx64 "" from 0x%016"" PRIx64 "")"", key, info->type_id); proto_item_set_hidden(member); return offset + member_length; }
Description: Excessive loops in multiple dissectors in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static GF_XMTParser *xmt_new_parser(GF_SceneLoader *load) { GF_XMTParser *parser; if ((load->type==GF_SM_LOAD_XSR) && !load->ctx) return NULL; GF_SAFEALLOC(parser, GF_XMTParser); if (!parser) return NULL; parser->nodes = gf_list_new(); parser->descriptors = gf_list_new(); parser->od_links = gf_list_new(); parser->esd_links = gf_list_new(); parser->def_nodes = gf_list_new(); parser->peeked_nodes = gf_list_new(); parser->inserted_routes = gf_list_new(); parser->unresolved_routes = gf_list_new(); parser->sax_parser = gf_xml_sax_new(xmt_node_start, xmt_node_end, xmt_text_content, parser); parser->load = load; load->loader_priv = parser; if (load->ctx) load->ctx->is_pixel_metrics = 1; return parser; }
Description: GPAC 0.7.1 has a buffer overflow issue in gf_import_message() in media_import.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static njs_ret_t njs_string_replace_regexp(njs_vm_t *vm, njs_value_t *args, njs_string_replace_t *r) { int                        *captures; u_char                     *p, *start; njs_ret_t                  ret; const u_char               *end; njs_regexp_pattern_t       *pattern; njs_string_replace_part_t  replace; pattern = args[1].data.u.regexp->pattern; end = r->part[0].start + r->part[0].size; replace = r->part[1]; do { ret = njs_regexp_match(vm, &pattern->regex[r->type], r->part[0].start, r->part[0].size, r->match_data); if (ret >= 0) { captures = nxt_regex_captures(r->match_data); if (r->substitutions != NULL) { ret = njs_string_replace_substitute(vm, r, captures); if (nxt_slow_path(ret != NXT_OK)) { return ret; } if (!pattern->global) { return njs_string_replace_regexp_join(vm, r); } } else { if (r->part != r->parts.start) { r->part = nxt_array_add(&r->parts, &njs_array_mem_proto, vm->mem_pool); if (nxt_slow_path(r->part == NULL)) { return NXT_ERROR; } r->part = nxt_array_add(&r->parts, &njs_array_mem_proto, vm->mem_pool); if (nxt_slow_path(r->part == NULL)) { return NXT_ERROR; } r->part -= 2; } if (captures[1] == 0) { start = r->part[0].start; if (start < end) { p = (u_char *) nxt_utf8_next(start, end); r->part[1].start = start; r->part[1].size = p - start; r->part[2].start = p; r->part[2].size = end - p; } else { r->part[1].size = 0; r->part[2].size = 0; r->part[2].start = start + 1; } r->part[0] = replace; } else { r->part[2].start = r->part[0].start + captures[1]; r->part[2].size = r->part[0].size - captures[1]; njs_set_invalid(&r->part[2].value); if (r->function != NULL) { return njs_string_replace_regexp_function(vm, args, r, captures, ret); } r->part[0].size = captures[0]; r->part[1] = replace; } if (!pattern->global) { return njs_string_replace_regexp_join(vm, r); } r->part += 2; } } else if (ret == NXT_REGEX_NOMATCH) { break; } else { return NXT_ERROR; } } while (r->part[0].start <= end); if (r->part != r->parts.start) { return njs_string_replace_regexp_join(vm, r); } nxt_regex_match_data_free(r->match_data, vm->regex_context); nxt_array_destroy(&r->parts, &njs_array_mem_proto, vm->mem_pool); njs_string_copy(&vm->retval, &args[0]); return NXT_OK; }
Description: njs through 0.3.3, used in NGINX, has a buffer over-read in nxt_utf8_decode in nxt/nxt_utf8.c. This issue occurs after the fix for CVE-2019-12207 is in place.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: BatchBlock::BatchBlock(int32_t device_id, size_t avail_mem, int32_t max_sequences_per_poa, int8_t output_mask, bool banded_alignment) : max_sequences_per_poa_(throw_on_negative(max_sequences_per_poa, ""Maximum sequences per POA has to be non-negative"")) , banded_alignment_(banded_alignment) , device_id_(throw_on_negative(device_id, ""Device ID has to be non-negative"")) , output_mask_(output_mask) { matrix_sequence_dimension_ = banded_alignment_ ? CUDAPOA_BANDED_MAX_MATRIX_SEQUENCE_DIMENSION : CUDAPOA_MAX_MATRIX_SEQUENCE_DIMENSION; max_graph_dimension_       = banded_alignment_ ? CUDAPOA_MAX_MATRIX_GRAPH_DIMENSION_BANDED : CUDAPOA_MAX_MATRIX_GRAPH_DIMENSION; max_nodes_per_window_      = banded_alignment_ ? CUDAPOA_MAX_NODES_PER_WINDOW_BANDED : CUDAPOA_MAX_NODES_PER_WINDOW; size_t host_size_fixed, device_size_fixed; size_t host_size_per_poa, device_size_per_poa; std::tie(host_size_fixed, device_size_fixed, host_size_per_poa, device_size_per_poa) = calculate_space_per_poa(); size_t minimum_device_mem = 2 * (device_size_fixed + device_size_per_poa); if (avail_mem < minimum_device_mem) { std::string msg = std::string(""Require at least "") .append(std::to_string(minimum_device_mem)) .append("" bytes of device memory per CUDAPOA batch to process correctly.""); throw std::runtime_error(msg); } const float fraction_for_metadata = 0.4f; max_poas_                         = (avail_mem * fraction_for_metadata) / device_size_per_poa; output_size_ = max_poas_ * CUDAPOA_MAX_CONSENSUS_SIZE; input_size_  = max_poas_ * max_sequences_per_poa_ * CUDAPOA_MAX_SEQUENCE_SIZE; total_h_     = max_poas_ * host_size_per_poa + host_size_fixed; total_d_     = avail_mem; CGA_CU_CHECK_ERR(cudaSetDevice(device_id_)); CGA_CU_CHECK_ERR(cudaHostAlloc((void**)&block_data_h_, total_h_, cudaHostAllocDefault)); CGA_CU_CHECK_ERR(cudaMalloc((void**)&block_data_d_, total_d_)); }
Description: Clara Genomics Analysis before 0.2.0 has an integer overflow for cudapoa memory management in allocate_block.cpp.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int parse(RParse *p, const char *data, char *str) { int i, len = strlen (data); char w0[WSZ]; char w1[WSZ]; char w2[WSZ]; char w3[WSZ]; char w4[WSZ]; char *buf, *ptr, *optr; if (!(buf = malloc (len + 1))) { return false; } memcpy (buf, data, len + 1); r_str_trim (buf); if (*buf) { w0[0] = '\0'; w1[0] = '\0'; w2[0] = '\0'; w3[0] = '\0'; w4[0] = '\0'; ptr = strchr (buf, ' '); if (!ptr) { ptr = strchr (buf, '\t'); } if (ptr) { *ptr = '\0'; for (++ptr; *ptr == ' '; ptr++) { } strncpy (w0, buf, WSZ - 1); strncpy (w1, ptr, WSZ - 1); optr = ptr; ptr = strchr (ptr, ','); if (ptr) { *ptr = '\0'; for (++ptr; *ptr == ' '; ptr++) { } strncpy (w1, optr, WSZ - 1); strncpy (w2, ptr, WSZ - 1); optr = ptr; ptr = strchr (ptr, ','); if (ptr) { *ptr = '\0'; for (++ptr; *ptr == ' '; ptr++) { } strncpy (w2, optr, WSZ - 1); strncpy (w3, ptr, WSZ - 1); optr = ptr; ptr = strchr (ptr, ','); if (ptr) { *ptr = '\0'; for (++ptr; *ptr == ' '; ptr++) { } strncpy (w3, optr, WSZ - 1); strncpy (w4, ptr, WSZ - 1); } } } } else { strncpy (w0, buf, WSZ - 1); } { const char *wa[] = { w0, w1, w2, w3, w4 }; int nw = 0; for (i = 0; i < 5; i++) { if (wa[i][0] != '\0') { nw++; } } replace (nw, wa, str); } } free (buf); return true; }
Description: radare2 through 3.5.1 mishandles the RParse API, which allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact, as demonstrated by newstr buffer overflows during replace operations. This affects libr/asm/asm.c and libr/parse/parse.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void fz_append_display_node( fz_context *ctx, fz_device *dev, fz_display_command cmd, int flags, const fz_rect *rect, const fz_path *path, const float *color, fz_colorspace *colorspace, const float *alpha, const fz_matrix *ctm, const fz_stroke_state *stroke, const void *private_data, int private_data_len) { fz_display_node node = { 0 }; fz_display_node *node_ptr; fz_list_device *writer = (fz_list_device *)dev; fz_display_list *list = writer->list; int size; int rect_off = 0; int path_off = 0; int color_off = 0; int colorspace_off = 0; int alpha_off = 0; int ctm_off = 0; int stroke_off = 0; int rect_for_updates = 0; int private_off = 0; fz_path *my_path = NULL; fz_stroke_state *my_stroke = NULL; fz_rect local_rect; int path_size = 0; switch (cmd) { case FZ_CMD_CLIP_PATH: case FZ_CMD_CLIP_STROKE_PATH: case FZ_CMD_CLIP_TEXT: case FZ_CMD_CLIP_STROKE_TEXT: case FZ_CMD_CLIP_IMAGE_MASK: if (writer->top < STACK_SIZE) { rect_for_updates = 1; writer->stack[writer->top].rect = fz_empty_rect; } writer->top++; break; case FZ_CMD_END_MASK: if (writer->top < STACK_SIZE) { writer->stack[writer->top].update = NULL; writer->stack[writer->top].rect = fz_empty_rect; } writer->top++; break; case FZ_CMD_BEGIN_TILE: writer->tiled++; if (writer->top > 0 && writer->top <= STACK_SIZE) { writer->stack[writer->top-1].rect = fz_infinite_rect; } break; case FZ_CMD_END_TILE: writer->tiled--; break; case FZ_CMD_END_GROUP: break; case FZ_CMD_POP_CLIP: if (writer->top > STACK_SIZE) { writer->top--; rect = &fz_infinite_rect; } else if (writer->top > 0) { fz_rect *update; writer->top--; update = writer->stack[writer->top].update; if (writer->tiled == 0) { if (update) { *update = fz_intersect_rect(*update, writer->stack[writer->top].rect); local_rect = *update; rect = &local_rect; } else rect = &writer->stack[writer->top].rect; } else rect = &fz_infinite_rect; } default: if (writer->top > 0 && writer->tiled == 0 && writer->top <= STACK_SIZE && rect) writer->stack[writer->top-1].rect = fz_union_rect(writer->stack[writer->top-1].rect, *rect); break; } size = 1;  node.cmd = cmd; if (rect_for_updates || (rect != NULL && (writer->rect.x0 != rect->x0 || writer->rect.y0 != rect->y0 || writer->rect.x1 != rect->x1 || writer->rect.y1 != rect->y1))) { node.rect = 1; rect_off = size; size += SIZE_IN_NODES(sizeof(fz_rect)); } if (color || colorspace) { if (colorspace != writer->colorspace) { assert(color); if (colorspace == fz_device_gray(ctx)) { if (color[0] == 0.0f) node.cs = CS_GRAY_0, color = NULL; else { node.cs = CS_GRAY_1; if (color[0] == 1.0f) color = NULL; } } else if (colorspace == fz_device_rgb(ctx)) { if (color[0] == 0.0f && color[1] == 0.0f && color[2] == 0.0f) node.cs = CS_RGB_0, color = NULL; else { node.cs = CS_RGB_1; if (color[0] == 1.0f && color[1] == 1.0f && color[2] == 1.0f) color = NULL; } } else if (colorspace == fz_device_cmyk(ctx)) { node.cs = CS_CMYK_0; if (color[0] == 0.0f && color[1] == 0.0f && color[2] == 0.0f) { if (color[3] == 0.0f) color = NULL; else { node.cs = CS_CMYK_1; if (color[3] == 1.0f) color = NULL; } } } else { int i; int n = fz_colorspace_n(ctx, colorspace); colorspace_off = size; size += SIZE_IN_NODES(sizeof(fz_colorspace *)); node.cs = CS_OTHER_0; for (i = 0; i < n; i++) if (color[i] != 0.0f) break; if (i == n) color = NULL; memset(writer->color, 0, sizeof(float)*n); } } else { if (colorspace == fz_device_gray(ctx)) { if (writer->color[0] != color[0]) { if (color[0] == 0.0f) { node.cs = CS_GRAY_0; color = NULL; } else if (color[0] == 1.0f) { node.cs = CS_GRAY_1; color = NULL; } } } else if (colorspace == fz_device_rgb(ctx)) { if (writer->color[0] != color[0] || writer->color[1] != color[1] || writer->color[2] != color[2]) { if (color[0] == 0.0f && color[1] == 0.0f && color[2] == 0.0f) { node.cs = CS_RGB_0; color = NULL; } else if (color[0] == 1.0f && color[1] == 1.0f && color[2] == 1.0f) { node.cs = CS_RGB_1; color = NULL; } } } else if (colorspace == fz_device_cmyk(ctx)) { if (writer->color[0] != color[0] || writer->color[1] != color[1] || writer->color[2] != color[2] || writer->color[3] != color[3]) { if (color[0] == 0.0f && color[1] == 0.0f && color[2] == 0.0f) { if (color[3] == 0.0f) { node.cs = CS_CMYK_0; color = NULL; } else if (color[3] == 1.0f) { node.cs = CS_CMYK_1; color = NULL; } } } } else { int i; int n = fz_colorspace_n(ctx, colorspace); for (i=0; i < n; i++) if (color[i] != 0.0f) break; if (i == n) { node.cs = CS_OTHER_0; colorspace_off = size; size += SIZE_IN_NODES(sizeof(fz_colorspace *)); color = NULL; } } } } if (color) { int i, n; const float *wc = &writer->color[0]; assert(colorspace != NULL); n = fz_colorspace_n(ctx, colorspace); i = 0; if (colorspace == writer->colorspace) for (; i < n; i++) if (color[i] != wc[i]) break; if (i != n) { node.color = 1; color_off = size; size += n * SIZE_IN_NODES(sizeof(float)); } } if (alpha && (*alpha != writer->alpha)) { if (*alpha >= 1.0f) node.alpha = ALPHA_1; else if (*alpha <= 0.0f) node.alpha = ALPHA_0; else { alpha_off = size; size += SIZE_IN_NODES(sizeof(float)); node.alpha = ALPHA_PRESENT; } } if (ctm && (ctm->a != writer->ctm.a || ctm->b != writer->ctm.b || ctm->c != writer->ctm.c || ctm->d != writer->ctm.d || ctm->e != writer->ctm.e || ctm->f != writer->ctm.f)) { int ctm_flags; ctm_off = size; ctm_flags = CTM_UNCHANGED; if (ctm->a != writer->ctm.a || ctm->d != writer->ctm.d) ctm_flags = CTM_CHANGE_AD, size += SIZE_IN_NODES(2*sizeof(float)); if (ctm->b != writer->ctm.b || ctm->c != writer->ctm.c) ctm_flags |= CTM_CHANGE_BC, size += SIZE_IN_NODES(2*sizeof(float)); if (ctm->e != writer->ctm.e || ctm->f != writer->ctm.f) ctm_flags |= CTM_CHANGE_EF, size += SIZE_IN_NODES(2*sizeof(float)); node.ctm = ctm_flags; } if (stroke && (writer->stroke == NULL || stroke != writer->stroke)) { stroke_off = size; size += SIZE_IN_NODES(sizeof(fz_stroke_state *)); node.stroke = 1; } if (path && (writer->path == NULL || path != writer->path)) { int max = SIZE_IN_NODES(MAX_NODE_SIZE) - size - SIZE_IN_NODES(private_data_len); path_size = SIZE_IN_NODES(fz_pack_path(ctx, NULL, max, path)); node.path = 1; path_off = size; size += path_size; } if (private_data != NULL) { private_off = size; size += SIZE_IN_NODES(private_data_len); } while (list->len + size > list->max) { int newsize = list->max * 2; fz_display_node *old = list->list; ptrdiff_t diff; int i, n; if (newsize < 256) newsize = 256; list->list = fz_realloc_array(ctx, list->list, newsize, fz_display_node); list->max = newsize; diff = (char *)(list->list) - (char *)old; n = (writer->top < STACK_SIZE ? writer->top : STACK_SIZE); for (i = 0; i < n; i++) { if (writer->stack[i].update != NULL) writer->stack[i].update = (fz_rect *)(((char *)writer->stack[i].update) + diff); } if (writer->path) writer->path = (fz_path *)(((char *)writer->path) + diff); } node.size = size; node.flags = flags; assert(size < (1<<9)); node_ptr = &list->list[list->len]; *node_ptr = node; if (path_off) { my_path = (void *)(&node_ptr[path_off]); (void)fz_pack_path(ctx, (void *)my_path, path_size * sizeof(fz_display_node), path); } if (stroke_off) { fz_try(ctx) { my_stroke = fz_keep_stroke_state(ctx, stroke); } fz_catch(ctx) { fz_drop_path(ctx, my_path); fz_rethrow(ctx); } } if (rect_off) { fz_rect *out_rect = (fz_rect *)(void *)(&node_ptr[rect_off]); writer->rect = *rect; *out_rect = *rect; if (rect_for_updates) writer->stack[writer->top-1].update = out_rect; } if (path_off) { fz_drop_path(ctx, writer->path); writer->path = fz_keep_path(ctx, my_path);  } if (node.cs) { fz_drop_colorspace(ctx, writer->colorspace); switch(node.cs) { case CS_GRAY_0: writer->colorspace = fz_keep_colorspace(ctx, fz_device_gray(ctx)); writer->color[0] = 0; break; case CS_GRAY_1: writer->colorspace = fz_keep_colorspace(ctx, fz_device_gray(ctx)); writer->color[0] = 1; break; case CS_RGB_0: writer->color[0] = 0; writer->color[1] = 0; writer->color[2] = 0; writer->colorspace = fz_keep_colorspace(ctx, fz_device_rgb(ctx)); break; case CS_RGB_1: writer->color[0] = 1; writer->color[1] = 1; writer->color[2] = 1; writer->colorspace = fz_keep_colorspace(ctx, fz_device_rgb(ctx)); break; case CS_CMYK_0: writer->color[0] = 0; writer->color[1] = 0; writer->color[2] = 0; writer->color[3] = 0; writer->colorspace = fz_keep_colorspace(ctx, fz_device_cmyk(ctx)); break; case CS_CMYK_1: writer->color[0] = 0; writer->color[1] = 0; writer->color[2] = 0; writer->color[3] = 1; writer->colorspace = fz_keep_colorspace(ctx, fz_device_cmyk(ctx)); break; default: { fz_colorspace **out_colorspace = (fz_colorspace **)(void *)(&node_ptr[colorspace_off]); int i, n; n = fz_colorspace_n(ctx, colorspace); *out_colorspace = fz_keep_colorspace(ctx, colorspace); writer->colorspace = fz_keep_colorspace(ctx, colorspace); for (i = 0; i < n; i++) writer->color[i] = 0; break; } } } if (color_off) { int n = fz_colorspace_n(ctx, colorspace); float *out_color = (float *)(void *)(&node_ptr[color_off]); memcpy(writer->color, color, n * sizeof(float)); memcpy(out_color, color, n * sizeof(float)); } if (node.alpha) { writer->alpha = *alpha; if (alpha_off) { float *out_alpha = (float *)(void *)(&node_ptr[alpha_off]); *out_alpha = *alpha; } } if (ctm_off) { float *out_ctm = (float *)(void *)(&node_ptr[ctm_off]); if (node.ctm & CTM_CHANGE_AD) { writer->ctm.a = *out_ctm++ = ctm->a; writer->ctm.d = *out_ctm++ = ctm->d; } if (node.ctm & CTM_CHANGE_BC) { writer->ctm.b = *out_ctm++ = ctm->b; writer->ctm.c = *out_ctm++ = ctm->c; } if (node.ctm & CTM_CHANGE_EF) { writer->ctm.e = *out_ctm++ = ctm->e; writer->ctm.f = *out_ctm = ctm->f; } } if (stroke_off) { fz_stroke_state **out_stroke = (fz_stroke_state **)(void *)(&node_ptr[stroke_off]); *out_stroke = my_stroke; fz_drop_stroke_state(ctx, writer->stroke); writer->stroke = fz_keep_stroke_state(ctx, my_stroke); } if (private_off) { char *out_private = (char *)(void *)(&node_ptr[private_off]); memcpy(out_private, private_data, private_data_len); } list->len += size; }
Description: Artifex MuPDF 1.15.0 has a heap-based buffer overflow in fz_append_display_node located at fitz/list-device.c, allowing remote attackers to execute arbitrary code via a crafted PDF file. This occurs with a large BDC property name that overflows the allocated size of a display list node.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void QPaintEngineEx::stroke(const QVectorPath &path, const QPen &inPen) { #ifdef QT_DEBUG_DRAW qDebug() << ""QPaintEngineEx::stroke()"" << pen; #endif Q_D(QPaintEngineEx); if (path.isEmpty()) return; if (!d->strokeHandler) { d->strokeHandler = new StrokeHandler(path.elementCount()+4); d->stroker.setMoveToHook(qpaintengineex_moveTo); d->stroker.setLineToHook(qpaintengineex_lineTo); d->stroker.setCubicToHook(qpaintengineex_cubicTo); } QRectF clipRect; QPen pen = inPen; if (pen.style() > Qt::SolidLine) { QRectF cpRect = path.controlPointRect(); const QTransform &xf = state()->matrix; if (pen.isCosmetic()) { clipRect = d->exDeviceRect; cpRect.translate(xf.dx(), xf.dy()); } else { clipRect = xf.inverted().mapRect(QRectF(d->exDeviceRect)); } QRectF extentRect = cpRect & clipRect; qreal extent = qMax(extentRect.width(), extentRect.height()); qreal patternLength = 0; const QList<qreal> pattern = pen.dashPattern(); const int patternSize = qMin(pattern.size(), 32); for (int i = 0; i < patternSize; i++) patternLength += qMax(pattern.at(i), qreal(0)); if (pen.widthF()) patternLength *= pen.widthF(); if (qFuzzyIsNull(patternLength)) { pen.setStyle(Qt::NoPen); } else if (extent / patternLength > 10000) { pen.setStyle(Qt::SolidLine); QColor color(pen.color()); color.setAlpha(color.alpha() / 2); pen.setColor(color); } } if (!qpen_fast_equals(pen, d->strokerPen)) { d->strokerPen = pen; d->stroker.setJoinStyle(pen.joinStyle()); d->stroker.setCapStyle(pen.capStyle()); d->stroker.setMiterLimit(pen.miterLimit()); qreal penWidth = pen.widthF(); if (penWidth == 0) d->stroker.setStrokeWidth(1); else d->stroker.setStrokeWidth(penWidth); Qt::PenStyle style = pen.style(); if (style == Qt::SolidLine) { d->activeStroker = &d->stroker; } else if (style == Qt::NoPen) { d->activeStroker = nullptr; } else { d->dasher.setDashPattern(pen.dashPattern()); d->dasher.setDashOffset(pen.dashOffset()); d->activeStroker = &d->dasher; } } if (!d->activeStroker) { return; } if (!clipRect.isNull()) d->activeStroker->setClipRect(clipRect); if (d->activeStroker == &d->stroker) d->stroker.setForceOpen(path.hasExplicitOpen()); const QPainterPath::ElementType *types = path.elements(); const qreal *points = path.points(); int pointCount = path.elementCount(); const qreal *lastPoint = points + (pointCount<<1); d->strokeHandler->types.reset(); d->strokeHandler->pts.reset(); uint flags = QVectorPath::WindingFill; if (path.elementCount() > 2) flags |= QVectorPath::NonConvexShapeMask; if (d->stroker.capStyle() == Qt::RoundCap || d->stroker.joinStyle() == Qt::RoundJoin) flags |= QVectorPath::CurvedShapeMask; if (!pen.isCosmetic()) { d->activeStroker->setCurveThresholdFromTransform(state()->matrix); d->activeStroker->begin(d->strokeHandler); if (types) { while (points < lastPoint) { switch (*types) { case QPainterPath::MoveToElement: d->activeStroker->moveTo(points[0], points[1]); points += 2; ++types; break; case QPainterPath::LineToElement: d->activeStroker->lineTo(points[0], points[1]); points += 2; ++types; break; case QPainterPath::CurveToElement: d->activeStroker->cubicTo(points[0], points[1], points[2], points[3], points[4], points[5]); points += 6; types += 3; flags |= QVectorPath::CurvedShapeMask; break; default: break; } } if (path.hasImplicitClose()) d->activeStroker->lineTo(path.points()[0], path.points()[1]); } else { d->activeStroker->moveTo(points[0], points[1]); points += 2; while (points < lastPoint) { d->activeStroker->lineTo(points[0], points[1]); points += 2; } if (path.hasImplicitClose()) d->activeStroker->lineTo(path.points()[0], path.points()[1]); } d->activeStroker->end(); if (!d->strokeHandler->types.size())             return; QVectorPath strokePath(d->strokeHandler->pts.data(), d->strokeHandler->types.size(), d->strokeHandler->types.data(), flags); fill(strokePath, pen.brush()); } else { if (state()->matrix.type() >= QTransform::TxProject) { QPainterPath painterPath = state()->matrix.map(path.convertToPainterPath()); d->activeStroker->strokePath(painterPath, d->strokeHandler, QTransform()); } else { d->activeStroker->setCurveThresholdFromTransform(QTransform()); d->activeStroker->begin(d->strokeHandler); if (types) { while (points < lastPoint) { switch (*types) { case QPainterPath::MoveToElement: { QPointF pt = (*(const QPointF *) points) * state()->matrix; d->activeStroker->moveTo(pt.x(), pt.y()); points += 2; ++types; break; } case QPainterPath::LineToElement: { QPointF pt = (*(const QPointF *) points) * state()->matrix; d->activeStroker->lineTo(pt.x(), pt.y()); points += 2; ++types; break; } case QPainterPath::CurveToElement: { QPointF c1 = ((const QPointF *) points)[0] * state()->matrix; QPointF c2 = ((const QPointF *) points)[1] * state()->matrix; QPointF e =  ((const QPointF *) points)[2] * state()->matrix; d->activeStroker->cubicTo(c1.x(), c1.y(), c2.x(), c2.y(), e.x(), e.y()); points += 6; types += 3; flags |= QVectorPath::CurvedShapeMask; break; } default: break; } } if (path.hasImplicitClose()) { QPointF pt = * ((const QPointF *) path.points()) * state()->matrix; d->activeStroker->lineTo(pt.x(), pt.y()); } } else { QPointF p = ((const QPointF *)points)[0] * state()->matrix; d->activeStroker->moveTo(p.x(), p.y()); points += 2; while (points < lastPoint) { QPointF p = ((const QPointF *)points)[0] * state()->matrix; d->activeStroker->lineTo(p.x(), p.y()); points += 2; } if (path.hasImplicitClose()) d->activeStroker->lineTo(p.x(), p.y()); } d->activeStroker->end(); } QVectorPath strokePath(d->strokeHandler->pts.data(), d->strokeHandler->types.size(), d->strokeHandler->types.data(), flags); QTransform xform = state()->matrix; state()->matrix = QTransform(); transformChanged(); QBrush brush = pen.brush(); if (qbrush_style(brush) != Qt::SolidPattern) brush.setTransform(brush.transform() * xform); fill(strokePath, brush); state()->matrix = xform; transformChanged(); } }
Description: Qt 5.x before 5.15.6 and 6.x through 6.1.2 has an out-of-bounds write in QOutlineMapper::convertPath (called from QRasterPaintEngine::fill and QPaintEngineEx::stroke).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: struct bio *bio_map_user_iov(struct request_queue *q, const struct iov_iter *iter, gfp_t gfp_mask) { int j; int nr_pages = 0; struct page **pages; struct bio *bio; int cur_page = 0; int ret, offset; struct iov_iter i; struct iovec iov; iov_for_each(iov, i, *iter) { unsigned long uaddr = (unsigned long) iov.iov_base; unsigned long len = iov.iov_len; unsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT; unsigned long start = uaddr >> PAGE_SHIFT; if (end < start) return ERR_PTR(-EINVAL); nr_pages += end - start; if (uaddr & queue_dma_alignment(q)) return ERR_PTR(-EINVAL); } if (!nr_pages) return ERR_PTR(-EINVAL); bio = bio_kmalloc(gfp_mask, nr_pages); if (!bio) return ERR_PTR(-ENOMEM); ret = -ENOMEM; pages = kcalloc(nr_pages, sizeof(struct page *), gfp_mask); if (!pages) goto out; iov_for_each(iov, i, *iter) { unsigned long uaddr = (unsigned long) iov.iov_base; unsigned long len = iov.iov_len; unsigned long end = (uaddr + len + PAGE_SIZE - 1) >> PAGE_SHIFT; unsigned long start = uaddr >> PAGE_SHIFT; const int local_nr_pages = end - start; const int page_limit = cur_page + local_nr_pages; ret = get_user_pages_fast(uaddr, local_nr_pages, (iter->type & WRITE) != WRITE, &pages[cur_page]); if (ret < local_nr_pages) { ret = -EFAULT; goto out_unmap; } offset = offset_in_page(uaddr); for (j = cur_page; j < page_limit; j++) { unsigned int bytes = PAGE_SIZE - offset; unsigned short prev_bi_vcnt = bio->bi_vcnt; if (len <= 0) break; if (bytes > len) bytes = len; if (bio_add_pc_page(q, bio, pages[j], bytes, offset) < bytes) break; if (bio->bi_vcnt == prev_bi_vcnt) put_page(pages[j]); len -= bytes; offset = 0; } cur_page = j; while (j < page_limit) put_page(pages[j++]); } kfree(pages); bio_set_flag(bio, BIO_USER_MAPPED); bio_get(bio); return bio; out_unmap: for (j = 0; j < nr_pages; j++) { if (!pages[j]) break; put_page(pages[j]); } out: kfree(pages); bio_put(bio); return ERR_PTR(ret); }
Description: The bio_map_user_iov and bio_unmap_user functions in block/bio.c in the Linux kernel before 4.13.8 do unbalanced refcounting when a SCSI I/O vector has small consecutive buffers belonging to the same page. The bio_add_pc_page function merges them into one, but the page reference is never dropped. This causes a memory leak and possible system lockup (exploitable against the host OS by a guest OS user, if a SCSI disk is passed through to a virtual machine) due to an out-of-memory condition.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int cp2112_probe(struct hid_device *hdev, const struct hid_device_id *id) { struct cp2112_device *dev; u8 buf[3]; struct cp2112_smbus_config_report config; int ret; dev = devm_kzalloc(&hdev->dev, sizeof(*dev), GFP_KERNEL); if (!dev) return -ENOMEM; dev->in_out_buffer = devm_kzalloc(&hdev->dev, CP2112_REPORT_MAX_LENGTH, GFP_KERNEL); if (!dev->in_out_buffer) return -ENOMEM; spin_lock_init(&dev->lock); ret = hid_parse(hdev); if (ret) { hid_err(hdev, ""parse failed\n""); return ret; } ret = hid_hw_start(hdev, HID_CONNECT_HIDRAW); if (ret) { hid_err(hdev, ""hw start failed\n""); return ret; } ret = hid_hw_open(hdev); if (ret) { hid_err(hdev, ""hw open failed\n""); goto err_hid_stop; } ret = hid_hw_power(hdev, PM_HINT_FULLON); if (ret < 0) { hid_err(hdev, ""power management error: %d\n"", ret); goto err_hid_close; } ret = cp2112_hid_get(hdev, CP2112_GET_VERSION_INFO, buf, sizeof(buf), HID_FEATURE_REPORT); if (ret != sizeof(buf)) { hid_err(hdev, ""error requesting version\n""); if (ret >= 0) ret = -EIO; goto err_power_normal; } hid_info(hdev, ""Part Number: 0x%02X Device Version: 0x%02X\n"", buf[1], buf[2]); ret = cp2112_hid_get(hdev, CP2112_SMBUS_CONFIG, (u8 *)&config, sizeof(config), HID_FEATURE_REPORT); if (ret != sizeof(config)) { hid_err(hdev, ""error requesting SMBus config\n""); if (ret >= 0) ret = -EIO; goto err_power_normal; } config.retry_time = cpu_to_be16(1); ret = cp2112_hid_output(hdev, (u8 *)&config, sizeof(config), HID_FEATURE_REPORT); if (ret != sizeof(config)) { hid_err(hdev, ""error setting SMBus config\n""); if (ret >= 0) ret = -EIO; goto err_power_normal; } hid_set_drvdata(hdev, (void *)dev); dev->hdev= hdev; dev->adap.owner= THIS_MODULE; dev->adap.class= I2C_CLASS_HWMON; dev->adap.algo= &smbus_algorithm; dev->adap.algo_data= dev; dev->adap.dev.parent= &hdev->dev; snprintf(dev->adap.name, sizeof(dev->adap.name), ""CP2112 SMBus Bridge on hiddev%d"", hdev->minor); dev->hwversion = buf[2]; init_waitqueue_head(&dev->wait); hid_device_io_start(hdev); ret = i2c_add_adapter(&dev->adap); hid_device_io_stop(hdev); if (ret) { hid_err(hdev, ""error registering i2c adapter\n""); goto err_power_normal; } hid_dbg(hdev, ""adapter registered\n""); dev->gc.label= ""cp2112_gpio""; dev->gc.direction_input= cp2112_gpio_direction_input; dev->gc.direction_output= cp2112_gpio_direction_output; dev->gc.set= cp2112_gpio_set; dev->gc.get= cp2112_gpio_get; dev->gc.base= -1; dev->gc.ngpio= 8; dev->gc.can_sleep= 1; dev->gc.parent= &hdev->dev; ret = gpiochip_add_data(&dev->gc, dev); if (ret < 0) { hid_err(hdev, ""error registering gpio chip\n""); goto err_free_i2c; } ret = sysfs_create_group(&hdev->dev.kobj, &cp2112_attr_group); if (ret < 0) { hid_err(hdev, ""error creating sysfs attrs\n""); goto err_gpiochip_remove; } chmod_sysfs_attrs(hdev); hid_hw_power(hdev, PM_HINT_NORMAL); ret = gpiochip_irqchip_add(&dev->gc, &cp2112_gpio_irqchip, 0, handle_simple_irq, IRQ_TYPE_NONE); if (ret) { dev_err(dev->gc.parent, ""failed to add IRQ chip\n""); goto err_sysfs_remove; } return ret; err_sysfs_remove: sysfs_remove_group(&hdev->dev.kobj, &cp2112_attr_group); err_gpiochip_remove: gpiochip_remove(&dev->gc); err_free_i2c: i2c_del_adapter(&dev->adap); err_power_normal: hid_hw_power(hdev, PM_HINT_NORMAL); err_hid_close: hid_hw_close(hdev); err_hid_stop: hid_hw_stop(hdev); return ret; }
Description: drivers/hid/hid-cp2112.c in the Linux kernel 4.9.x before 4.9.9 uses a spinlock without considering that sleeping is possible in a USB HID request callback, which allows local users to cause a denial of service (deadlock) via unspecified vectors.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void rose_stop_heartbeat(struct sock *sk) { del_timer(&sk->sk_timer); }
Description: There are use-after-free vulnerabilities caused by timer handler in net/rose/rose_timer.c of linux that allow attackers to crash linux kernel without any privileges.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void DBusBridge::handlePolicyMethodCall(const std::string& method_name, GVariant* parameters, GDBusMethodInvocation* invocation) { if (method_name == ""listRules"") { const char* label_cstr = nullptr; g_variant_get(parameters, ""(&s)"", &label_cstr); std::string label(label_cstr); auto rules = listRules(label); if (rules.size() > 0) { auto gvbuilder = g_variant_builder_new(G_VARIANT_TYPE_ARRAY); try { for (auto rule : rules) { g_variant_builder_add(gvbuilder, ""(us)"", rule.getRuleID(), rule.toString().c_str()); } g_dbus_method_invocation_return_value(invocation, g_variant_new(""(a(us))"", gvbuilder)); } catch (...) { g_variant_builder_unref(gvbuilder); throw; } g_variant_builder_unref(gvbuilder); } else { g_dbus_method_invocation_return_value(invocation, g_variant_new(""(a(us))"", nullptr)); } return; } if (method_name == ""appendRule"") { const char* rule_spec_cstr = nullptr; uint32_t parent_id = 0; gboolean temporary = false; g_variant_get(parameters, ""(&sub)"", &rule_spec_cstr, &parent_id, &temporary); std::string rule_spec(rule_spec_cstr); const uint32_t rule_id = appendRule(rule_spec, parent_id, !temporary); g_dbus_method_invocation_return_value(invocation, g_variant_new(""(u)"", rule_id)); return; } if (method_name == ""removeRule"") { uint32_t rule_id = 0; g_variant_get(parameters, ""(u)"", &rule_id); removeRule(rule_id); g_dbus_method_invocation_return_value(invocation, nullptr); return; } g_dbus_method_invocation_return_error(invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, ""Unknown method interface""); return; }
Description: An issue was discovered in USBGuard before 1.1.0. On systems with the usbguard-dbus daemon running, an unprivileged user could make USBGuard allow all USB devices to be connected in the future.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void  openscript ( char_u *name, int directly                    ) { if (curscript + 1 == NSCRIPT) { EMSG(_(e_nesting)); return; } if (ignore_script) return; if (scriptin[curscript] != NULL)       ++curscript; expand_env(name, NameBuff, MAXPATHL); int error; if ((scriptin[curscript] = file_open_new(&error, (char *)NameBuff, kFileReadOnly, 0)) == NULL) { emsgf(_(e_notopen_2), name, os_strerror(error)); if (curscript) { curscript--; } return; } save_typebuf(); if (directly) { oparg_T oa; int oldcurscript; int save_State = State; int save_restart_edit = restart_edit; int save_insertmode = p_im; int save_finish_op = finish_op; int save_msg_scroll = msg_scroll; State = NORMAL; msg_scroll = FALSE;          restart_edit = 0;            p_im = FALSE;                clear_oparg(&oa); finish_op = FALSE; oldcurscript = curscript; do { update_topline_cursor();           normal_cmd(&oa, FALSE);            vpeekc();                          } while (scriptin[oldcurscript] != NULL); State = save_State; msg_scroll = save_msg_scroll; restart_edit = save_restart_edit; p_im = save_insertmode; finish_op = save_finish_op; } }
Description: getchar.c in Vim before 8.1.1365 and Neovim before 0.3.6 allows remote attackers to execute arbitrary OS commands via the :source! command in a modeline, as demonstrated by execute in Vim, and assert_fails or nvim_input in Neovim.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int io_uring_flush(struct file *file, void *data) { struct io_ring_ctx *ctx = file->private_data; io_uring_cancel_files(ctx, data); if (fatal_signal_pending(current) || (current->flags & PF_EXITING)) io_wq_cancel_cb(ctx->io_wq, io_cancel_task_cb, current, true); return 0; }
Description: An issue was discovered in the Linux kernel before 5.9.3. io_uring takes a non-refcounted reference to the files_struct of the process that submitted a request, causing execve() to incorrectly optimize unshare_fd(), aka CID-0f2122045b94.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void Ethernet_getInterfaceMACAddress(const char* interfaceId, uint8_t* addr) { struct ifreq buffer; int sock = socket(PF_INET, SOCK_DGRAM, 0); memset(&buffer, 0x00, sizeof(buffer)); strcpy(buffer.ifr_name, interfaceId); ioctl(sock, SIOCGIFHWADDR, &buffer); close(sock); int i; for(i = 0; i < 6; i++ ) { addr[i] = (unsigned char)buffer.ifr_hwaddr.sa_data[i]; } }
Description: An issue has been found in libIEC61850 v1.3. It is a stack-based buffer overflow in prepareGooseBuffer in goose/goose_publisher.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void ConnPoolImplBase::checkForIdleAndCloseIdleConnsIfDraining() { if (is_draining_for_deletion_) { closeIdleConnectionsForDrainingPool(); } if (isIdleImpl()) { ENVOY_LOG(debug, ""invoking idle callbacks - is_draining_for_deletion_={}"", is_draining_for_deletion_); for (const Instance::IdleCb& cb : idle_callbacks_) { cb(); } } }
Description: Envoy is an open source edge and service proxy, designed for cloud-native applications. When a cluster is deleted via Cluster Discovery Service (CDS) all idle connections established to endpoints in that cluster are disconnected. A recursion was introduced in the procedure of disconnecting idle connections that can lead to stack exhaustion and abnormal process termination when a cluster has a large number of idle connections. This infinite recursion causes Envoy to crash. Users are advised to upgrade.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void print_bpf_insn(struct bpf_insn *insn) { u8 class = BPF_CLASS(insn->code); if (class == BPF_ALU || class == BPF_ALU64) { if (BPF_SRC(insn->code) == BPF_X) verbose(""(%02x) %sr%d %s %sr%d\n"", insn->code, class == BPF_ALU ? ""(u32) "" : """", insn->dst_reg, bpf_alu_string[BPF_OP(insn->code) >> 4], class == BPF_ALU ? ""(u32) "" : """", insn->src_reg); else verbose(""(%02x) %sr%d %s %s%d\n"", insn->code, class == BPF_ALU ? ""(u32) "" : """", insn->dst_reg, bpf_alu_string[BPF_OP(insn->code) >> 4], class == BPF_ALU ? ""(u32) "" : """", insn->imm); } else if (class == BPF_STX) { if (BPF_MODE(insn->code) == BPF_MEM) verbose(""(%02x) *(%s *)(r%d %+d) = r%d\n"", insn->code, bpf_ldst_string[BPF_SIZE(insn->code) >> 3], insn->dst_reg, insn->off, insn->src_reg); else if (BPF_MODE(insn->code) == BPF_XADD) verbose(""(%02x) lock *(%s *)(r%d %+d) += r%d\n"", insn->code, bpf_ldst_string[BPF_SIZE(insn->code) >> 3], insn->dst_reg, insn->off, insn->src_reg); else verbose(""BUG_%02x\n"", insn->code); } else if (class == BPF_ST) { if (BPF_MODE(insn->code) != BPF_MEM) { verbose(""BUG_st_%02x\n"", insn->code); return; } verbose(""(%02x) *(%s *)(r%d %+d) = %d\n"", insn->code, bpf_ldst_string[BPF_SIZE(insn->code) >> 3], insn->dst_reg, insn->off, insn->imm); } else if (class == BPF_LDX) { if (BPF_MODE(insn->code) != BPF_MEM) { verbose(""BUG_ldx_%02x\n"", insn->code); return; } verbose(""(%02x) r%d = *(%s *)(r%d %+d)\n"", insn->code, insn->dst_reg, bpf_ldst_string[BPF_SIZE(insn->code) >> 3], insn->src_reg, insn->off); } else if (class == BPF_LD) { if (BPF_MODE(insn->code) == BPF_ABS) { verbose(""(%02x) r0 = *(%s *)skb[%d]\n"", insn->code, bpf_ldst_string[BPF_SIZE(insn->code) >> 3], insn->imm); } else if (BPF_MODE(insn->code) == BPF_IND) { verbose(""(%02x) r0 = *(%s *)skb[r%d + %d]\n"", insn->code, bpf_ldst_string[BPF_SIZE(insn->code) >> 3], insn->src_reg, insn->imm); } else if (BPF_MODE(insn->code) == BPF_IMM) { verbose(""(%02x) r%d = 0x%x\n"", insn->code, insn->dst_reg, insn->imm); } else { verbose(""BUG_ld_%02x\n"", insn->code); return; } } else if (class == BPF_JMP) { u8 opcode = BPF_OP(insn->code); if (opcode == BPF_CALL) { verbose(""(%02x) call %s#%d\n"", insn->code, func_id_name(insn->imm), insn->imm); } else if (insn->code == (BPF_JMP | BPF_JA)) { verbose(""(%02x) goto pc%+d\n"", insn->code, insn->off); } else if (insn->code == (BPF_JMP | BPF_EXIT)) { verbose(""(%02x) exit\n"", insn->code); } else if (BPF_SRC(insn->code) == BPF_X) { verbose(""(%02x) if r%d %s r%d goto pc%+d\n"", insn->code, insn->dst_reg, bpf_jmp_string[BPF_OP(insn->code) >> 4], insn->src_reg, insn->off); } else { verbose(""(%02x) if r%d %s 0x%x goto pc%+d\n"", insn->code, insn->dst_reg, bpf_jmp_string[BPF_OP(insn->code) >> 4], insn->imm, insn->off); } } else { verbose(""(%02x) %s\n"", insn->code, bpf_class_string[class]); } }
Description: The do_check function in kernel/bpf/verifier.c in the Linux kernel before 4.11.1 does not make the allow_ptr_leaks value available for restricting the output of the print_bpf_insn function, which allows local users to obtain sensitive address information via crafted bpf system calls.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void ubik_print(netdissect_options *ndo, register const u_char *bp) { int ubik_op; int32_t temp; ubik_op = EXTRACT_32BITS(bp + sizeof(struct rx_header)); ND_PRINT((ndo, "" ubik call %s"", tok2str(ubik_req, ""op#%d"", ubik_op))); bp += sizeof(struct rx_header) + 4; switch (ubik_op) { case 10000: ND_TCHECK2(bp[0], 4); temp = EXTRACT_32BITS(bp); bp += sizeof(int32_t); ND_PRINT((ndo, "" syncsite %s"", temp ? ""yes"" : ""no"")); ND_PRINT((ndo, "" votestart"")); DATEOUT(); ND_PRINT((ndo, "" dbversion"")); UBIK_VERSIONOUT(); ND_PRINT((ndo, "" tid"")); UBIK_VERSIONOUT(); break; case 10003: ND_PRINT((ndo, "" site"")); UINTOUT(); break; case 20000: case 20001: case 20007: case 20008: case 20010: ND_PRINT((ndo, "" tid"")); UBIK_VERSIONOUT(); break; case 20002: ND_PRINT((ndo, "" tid"")); UBIK_VERSIONOUT(); ND_PRINT((ndo, "" file"")); INTOUT(); ND_PRINT((ndo, "" pos"")); INTOUT(); ND_PRINT((ndo, "" length"")); INTOUT(); temp = EXTRACT_32BITS(bp); bp += sizeof(int32_t); tok2str(ubik_lock_types, ""type %d"", temp); break; case 20003: ND_PRINT((ndo, "" tid"")); UBIK_VERSIONOUT(); ND_PRINT((ndo, "" file"")); INTOUT(); ND_PRINT((ndo, "" pos"")); INTOUT(); break; case 20005: ND_PRINT((ndo, "" file"")); INTOUT(); break; case 20006: ND_PRINT((ndo, "" file"")); INTOUT(); ND_PRINT((ndo, "" length"")); INTOUT(); ND_PRINT((ndo, "" dbversion"")); UBIK_VERSIONOUT(); break; case 20009: ND_PRINT((ndo, "" tid"")); UBIK_VERSIONOUT(); ND_PRINT((ndo, "" file"")); INTOUT(); ND_PRINT((ndo, "" length"")); INTOUT(); break; case 20012: ND_PRINT((ndo, "" tid"")); UBIK_VERSIONOUT(); ND_PRINT((ndo, "" oldversion"")); UBIK_VERSIONOUT(); ND_PRINT((ndo, "" newversion"")); UBIK_VERSIONOUT(); break; default: ; } return; trunc: ND_PRINT((ndo, "" [|ubik]"")); }
Description: The Rx protocol parser in tcpdump before 4.9.2 has a buffer over-read in print-rx.c:ubik_print().
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void exif_iif_add_value(image_info_type *image_info, int section_index, char *name, int tag, int format, int length, void* value, int motorola_intel) { size_t idex; void *vptr; image_info_value *info_value; image_info_data  *info_data; image_info_data  *list; if (length < 0) { return; } list = safe_erealloc(image_info->info_list[section_index].list, (image_info->info_list[section_index].count+1), sizeof(image_info_data), 0); image_info->info_list[section_index].list = list; info_data  = &image_info->info_list[section_index].list[image_info->info_list[section_index].count]; memset(info_data, 0, sizeof(image_info_data)); info_data->tag    = tag; info_data->format = format; info_data->length = length; info_data->name   = estrdup(name); info_value        = &info_data->value; switch (format) { case TAG_FMT_STRING: if (value) { length = php_strnlen(value, length); info_value->s = estrndup(value, length); info_data->length = length; } else { info_data->length = 0; info_value->s = estrdup(""""); } break; default: info_data->tag = TAG_FMT_UNDEFINED; case TAG_FMT_SBYTE: case TAG_FMT_BYTE: if (!length) break; case TAG_FMT_UNDEFINED: if (value) { if (tag == TAG_MAKER_NOTE) { length = (int) php_strnlen(value, length); } info_value->s = estrndup(value, length); info_data->length = length; } else { info_data->length = 0; info_value->s = estrdup(""""); } break; case TAG_FMT_USHORT: case TAG_FMT_ULONG: case TAG_FMT_URATIONAL: case TAG_FMT_SSHORT: case TAG_FMT_SLONG: case TAG_FMT_SRATIONAL: case TAG_FMT_SINGLE: case TAG_FMT_DOUBLE: if (length==0) { break; } else if (length>1) { info_value->list = safe_emalloc(length, sizeof(image_info_value), 0); } else { info_value = &info_data->value; } for (idex=0,vptr=value; idex<(size_t)length; idex++,vptr=(char *) vptr + php_tiff_bytes_per_format[format]) { if (length>1) { info_value = &info_data->value.list[idex]; } switch (format) { case TAG_FMT_USHORT: info_value->u = php_ifd_get16u(vptr, motorola_intel); break; case TAG_FMT_ULONG: info_value->u = php_ifd_get32u(vptr, motorola_intel); break; case TAG_FMT_URATIONAL: info_value->ur.num = php_ifd_get32u(vptr, motorola_intel); info_value->ur.den = php_ifd_get32u(4+(char *)vptr, motorola_intel); break; case TAG_FMT_SSHORT: info_value->i = php_ifd_get16s(vptr, motorola_intel); break; case TAG_FMT_SLONG: info_value->i = php_ifd_get32s(vptr, motorola_intel); break; case TAG_FMT_SRATIONAL: info_value->sr.num = php_ifd_get32u(vptr, motorola_intel); info_value->sr.den = php_ifd_get32u(4+(char *)vptr, motorola_intel); break; case TAG_FMT_SINGLE: #ifdef EXIF_DEBUG php_error_docref(NULL, E_WARNING, ""Found value of type single""); #endif info_value->f = *(float *)value; case TAG_FMT_DOUBLE: #ifdef EXIF_DEBUG php_error_docref(NULL, E_WARNING, ""Found value of type double""); #endif info_value->d = *(double *)value; break; } } } image_info->sections_found |= 1<<section_index; image_info->info_list[section_index].count++; }
Description: When processing certain files, PHP EXIF extension in versions 7.1.x below 7.1.28, 7.2.x below 7.2.17 and 7.3.x below 7.3.4 can be caused to read past allocated buffer in exif_iif_add_value function. This may lead to information disclosure or crash.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int  dlt_jnpr_ether_cleanup(tcpeditdlt_t *ctx) { tcpeditdlt_plugin_t *plugin; assert(ctx); if ((plugin = tcpedit_dlt_getplugin(ctx, dlt_value)) == NULL) { tcpedit_seterr(ctx->tcpedit, ""Unable to cleanup unregistered plugin %s"", dlt_name); return TCPEDIT_ERROR; } safe_free(plugin->name); plugin->name = NULL; if (plugin->config != NULL) { jnpr_ether_config_t *config; config = (jnpr_ether_config_t *)ctx->encoder->config; tcpedit_dlt_cleanup(config->subctx); safe_free(plugin->config); plugin->config = NULL; plugin->config_size = 0; } return TCPEDIT_OK;  }
Description: An issue found in TCPreplay tcprewrite v.4.4.3 allows a remote attacker to cause a denial of service via the tcpedit_dlt_cleanup function at plugins/dlt_plugins.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int chk_domain_generation(unsigned int domid, uint64_t gen) { struct domain *d; xc_dominfo_t dominfo; if (!xc_handle && domid == 0) return 1; d = find_domain_struct(domid); if (d) return (d->generation <= gen) ? 1 : 0; if (!get_domain_info(domid, &dominfo)) return 0; d = alloc_domain(NULL, domid); return d ? 1 : -1; }
Description: Xenstore: Guests can get access to Xenstore nodes of deleted domains Access rights of Xenstore nodes are per domid. When a domain is gone, there might be Xenstore nodes left with access rights containing the domid of the removed domain. This is normally no problem, as those access right entries will be corrected when such a node is written later. There is a small time window when a new domain is created, where the access rights of a past domain with the same domid as the new one will be regarded to be still valid, leading to the new domain being able to get access to a node which was meant to be accessible by the removed domain. For this to happen another domain needs to write the node before the newly created domain is being introduced to Xenstore by dom0.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: char *path_name(const struct name_path *path, const char *name) { const struct name_path *p; char *n, *m; int nlen = strlen(name); int len = nlen + 1; for (p = path; p; p = p->up) { if (p->elem_len) len += p->elem_len + 1; } n = xmalloc(len); m = n + len - (nlen + 1); strcpy(m, name); for (p = path; p; p = p->up) { if (p->elem_len) { m -= p->elem_len + 1; memcpy(m, p->elem, p->elem_len); m[p->elem_len] = '/'; } } return n; }
Description: revision.c in git before 2.7.4 uses an incorrect integer data type, which allows remote attackers to execute arbitrary code via a (1) long filename or (2) many nested trees, leading to a heap-based buffer overflow.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len) { struct inet_sock *inet = inet_sk(sk); struct net *net = sock_net(sk); struct ipcm_cookie ipc; struct rtable *rt = NULL; struct flowi4 fl4; int free = 0; __be32 daddr; __be32 saddr; u8  tos; int err; struct ip_options_data opt_copy; struct raw_frag_vec rfv; err = -EMSGSIZE; if (len > 0xFFFF) goto out; err = -EOPNOTSUPP; if (msg->msg_flags & MSG_OOB) goto out;                if (msg->msg_namelen) { DECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name); err = -EINVAL; if (msg->msg_namelen < sizeof(*usin)) goto out; if (usin->sin_family != AF_INET) { pr_info_once(""%s: %s forgot to set AF_INET. Fix it!\n"", __func__, current->comm); err = -EAFNOSUPPORT; if (usin->sin_family) goto out; } daddr = usin->sin_addr.s_addr; } else { err = -EDESTADDRREQ; if (sk->sk_state != TCP_ESTABLISHED) goto out; daddr = inet->inet_daddr; } ipc.sockc.tsflags = sk->sk_tsflags; ipc.addr = inet->inet_saddr; ipc.opt = NULL; ipc.tx_flags = 0; ipc.ttl = 0; ipc.tos = -1; ipc.oif = sk->sk_bound_dev_if; if (msg->msg_controllen) { err = ip_cmsg_send(sk, msg, &ipc, false); if (unlikely(err)) { kfree(ipc.opt); goto out; } if (ipc.opt) free = 1; } saddr = ipc.addr; ipc.addr = daddr; if (!ipc.opt) { struct ip_options_rcu *inet_opt; rcu_read_lock(); inet_opt = rcu_dereference(inet->inet_opt); if (inet_opt) { memcpy(&opt_copy, inet_opt, sizeof(*inet_opt) + inet_opt->opt.optlen); ipc.opt = &opt_copy.opt; } rcu_read_unlock(); } if (ipc.opt) { err = -EINVAL; if (inet->hdrincl) goto done; if (ipc.opt->opt.srr) { if (!daddr) goto done; daddr = ipc.opt->opt.faddr; } } tos = get_rtconn_flags(&ipc, sk); if (msg->msg_flags & MSG_DONTROUTE) tos |= RTO_ONLINK; if (ipv4_is_multicast(daddr)) { if (!ipc.oif) ipc.oif = inet->mc_index; if (!saddr) saddr = inet->mc_addr; } else if (!ipc.oif) ipc.oif = inet->uc_index; flowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos, RT_SCOPE_UNIVERSE, inet->hdrincl ? IPPROTO_RAW : sk->sk_protocol, inet_sk_flowi_flags(sk) | (inet->hdrincl ? FLOWI_FLAG_KNOWN_NH : 0), daddr, saddr, 0, 0, sk->sk_uid); if (!inet->hdrincl) { rfv.msg = msg; rfv.hlen = 0; err = raw_probe_proto_opt(&rfv, &fl4); if (err) goto done; } security_sk_classify_flow(sk, flowi4_to_flowi(&fl4)); rt = ip_route_output_flow(net, &fl4, sk); if (IS_ERR(rt)) { err = PTR_ERR(rt); rt = NULL; goto done; } err = -EACCES; if (rt->rt_flags & RTCF_BROADCAST && !sock_flag(sk, SOCK_BROADCAST)) goto done; if (msg->msg_flags & MSG_CONFIRM) goto do_confirm; back_from_confirm: if (inet->hdrincl) err = raw_send_hdrinc(sk, &fl4, msg, len, &rt, msg->msg_flags, &ipc.sockc); else { sock_tx_timestamp(sk, ipc.sockc.tsflags, &ipc.tx_flags); if (!ipc.addr) ipc.addr = fl4.daddr; lock_sock(sk); err = ip_append_data(sk, &fl4, raw_getfrag, &rfv, len, 0, &ipc, &rt, msg->msg_flags); if (err) ip_flush_pending_frames(sk); else if (!(msg->msg_flags & MSG_MORE)) { err = ip_push_pending_frames(sk, &fl4); if (err == -ENOBUFS && !inet->recverr) err = 0; } release_sock(sk); } done: if (free) kfree(ipc.opt); ip_rt_put(rt); out: if (err < 0) return err; return len; do_confirm: if (msg->msg_flags & MSG_PROBE) dst_confirm_neigh(&rt->dst, &fl4.daddr); if (!(msg->msg_flags & MSG_PROBE) || len) goto back_from_confirm; err = 0; goto done; }
Description: The raw_sendmsg() function in net/ipv4/raw.c in the Linux kernel through 4.14.6 has a race condition in inet->hdrincl that leads to uninitialized stack pointer usage; this allows a local user to execute code and gain privileges.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int crxFreeImageData(CrxImage *img) { CrxTile *tile = img->tiles; int nTiles = img->tileRows * img->tileCols; if (img->tiles) { for (int32_t curTile = 0; curTile < nTiles; curTile++, tile++) if (tile[curTile].comps) for (int32_t curPlane = 0; curPlane < img->nPlanes; curPlane++) crxFreeSubbandData(img, tile[curTile].comps + curPlane); free(img->tiles); img->tiles = 0; } if (img->planeBuf) { free(img->planeBuf); img->planeBuf = 0; } return 0; }
Description: In LibRaw, there is a memory corruption vulnerability within the ""crxFreeSubbandData()"" function (libraw\src\decoders\crx.cpp) when processing cr3 files.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void ImageDocumentParser::finish() { if (!isStopped() && document()->imageElement() && document()->cachedImage()) { ImageResource* cachedImage = document()->cachedImage(); DocumentLoader* loader = document()->loader(); cachedImage->setResponse(loader->response()); cachedImage->setLoadFinishTime(loader->timing().responseEnd()); cachedImage->finish(); IntSize size = flooredIntSize(cachedImage->imageSize(LayoutObject::shouldRespectImageOrientation(document()->imageElement()->layoutObject()), 1.0f)); if (size.width()) { String fileName = decodeURLEscapeSequences(document()->url().lastPathComponent()); if (fileName.isEmpty()) fileName = document()->url().host(); document()->setTitle(imageTitle(fileName, size)); } document()->imageUpdated(); } if (document()) document()->finishedParsing(); }
Description: Google Chrome before 50.0.2661.75 does not properly consider that frame removal may occur during callback execution, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted extension.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void const * PackLinuxElf32::elf_find_dynamic(unsigned int key) const { Elf32_Dyn const *dynp= dynseg; if (dynp) for (; (unsigned)((char const *)dynp - (char const *)dynseg) < sz_dynseg && Elf32_Dyn::DT_NULL!=dynp->d_tag; ++dynp) if (get_te32(&dynp->d_tag)==key) { unsigned const t= elf_get_offset_from_address(get_te32(&dynp->d_val)); if (t) { return t + file_image; } break; } return 0; }
Description: p_lx_elf.cpp in UPX before 3.96 has an integer overflow during unpacking via crafted values in a PT_DYNAMIC segment.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: njs_int_t njs_array_convert_to_slow_array(njs_vm_t *vm, njs_array_t *array) { uint32_t           i, length; njs_value_t        index, value; njs_object_prop_t  *prop; njs_set_array(&value, array); array->object.fast_array = 0; length = array->length; for (i = 0; i < length; i++) { if (njs_is_valid(&array->start[i])) { njs_uint32_to_string(&index, i); prop = njs_object_property_add(vm, &value, &index, 0); if (njs_slow_path(prop == NULL)) { return NJS_ERROR; } prop->value = array->start[i]; } } njs_mp_free(vm->mem_pool, array->start); array->start = NULL; return NJS_OK; }
Description: Nginx NJS v0.7.2 was discovered to contain a segmentation violation in the function njs_array_convert_to_slow_array at src/njs_array.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static u32 UpdateRuns(GF_ISOFile *movie, GF_TrackFragmentBox *traf) { u32 sampleCount, i, j, RunSize, RunDur, RunFlags, NeedFlags, UseCTS; u32 UseDefaultSize, UseDefaultDur, UseDefaultFlag; GF_TrackFragmentRunBox *trun; GF_TrunEntry *ent; sampleCount = 0; #ifndef USE_BASE_DATA_OFFSET if (movie->use_segments) { traf->tfhd->flags = GF_ISOM_MOOF_BASE_OFFSET; } else #endif { if (movie->force_moof_base_offset) { traf->tfhd->flags = GF_ISOM_MOOF_BASE_OFFSET; } else { traf->tfhd->flags = GF_ISOM_TRAF_BASE_OFFSET; } } if (traf->tfhd->EmptyDuration) { while (gf_list_count(traf->TrackRuns)) { trun = (GF_TrackFragmentRunBox *)gf_list_get(traf->TrackRuns, 0); gf_list_rem(traf->TrackRuns, 0); gf_isom_box_del_parent(&traf->child_boxes, (GF_Box *)trun); } traf->tfhd->flags |= GF_ISOM_TRAF_DUR_EMPTY; if (traf->tfhd->EmptyDuration != traf->trex->def_sample_duration) { traf->tfhd->def_sample_duration = traf->tfhd->EmptyDuration; traf->tfhd->flags |= GF_ISOM_TRAF_SAMPLE_DUR; } return 0; } UseDefaultSize = 0; UseDefaultDur = 0; UseDefaultFlag = 0; i=0; while ((trun = (GF_TrackFragmentRunBox *)gf_list_enum(traf->TrackRuns, &i))) { GF_TrunEntry *first_ent = NULL; RunSize = 0; RunDur = 0; RunFlags = 0; UseCTS = 0; NeedFlags = 0; for (j=0; j<trun->nb_samples; j++) { ent = &trun->samples[j]; if (!j) { first_ent = ent; RunSize = ent->size; if (ent->nb_pack) RunSize /= ent->nb_pack; RunDur = ent->Duration; } if (j || (trun->nb_samples==1)) { u32 ssize = ent->size; if (ent->nb_pack) ssize /= ent->nb_pack; if (j==1 || (trun->nb_samples==1) ) RunFlags = ent->flags; if (ssize != RunSize) RunSize = 0; if (RunDur && (ent->Duration != RunDur)) RunDur = 0; if (j && (RunFlags != ent->flags)) NeedFlags = 1; } if (ent->CTS_Offset) UseCTS = 1; } if (!first_ent) { i--; gf_list_rem(traf->TrackRuns, i); continue; } trun->flags = 0; if (RunSize && (traf->trex->def_sample_size == RunSize) && !traf->trex->cannot_use_default) { if (!UseDefaultSize) UseDefaultSize = 2; else if (UseDefaultSize==1) RunSize = 0; } else if (RunSize && (traf->tfhd->def_sample_size == RunSize)) { if (!UseDefaultSize) UseDefaultSize = 1; else if (UseDefaultSize==2) RunSize = 0; } else { RunSize=0; } if (!RunSize) trun->flags |= GF_ISOM_TRUN_SIZE; if (RunDur && (traf->trex->def_sample_duration == RunDur) && !traf->trex->cannot_use_default) { if (!UseDefaultDur) UseDefaultDur = 2; else if (UseDefaultDur==1) RunDur = 0; } else if (RunDur && (traf->tfhd->def_sample_duration == RunDur)) { if (!UseDefaultDur) UseDefaultDur = 1; else if (UseDefaultDur==2) RunDur = 0; } if (!RunDur) trun->flags |= GF_ISOM_TRUN_DURATION; if (!NeedFlags) { if (RunFlags == traf->trex->def_sample_flags && !traf->trex->cannot_use_default) { if (!UseDefaultFlag) { UseDefaultFlag = 2; } else if (UseDefaultFlag==1) { NeedFlags = GF_TRUE; } } else if (RunFlags == traf->tfhd->def_sample_flags) { if (!UseDefaultFlag) { UseDefaultFlag = 1; } else if(UseDefaultFlag==2) { NeedFlags = GF_TRUE; } } else { NeedFlags = GF_TRUE; } } if (NeedFlags) { trun->flags |= GF_ISOM_TRUN_FLAGS; } else { if (first_ent->flags != RunFlags) { trun->flags |= GF_ISOM_TRUN_FIRST_FLAG; if (!traf->no_sdtp_first_flags) trun->first_sample_flags = first_ent->flags; } } if (UseCTS) trun->flags |= GF_ISOM_TRUN_CTS_OFFSET; if (trun->data_offset) trun->flags |= GF_ISOM_TRUN_DATA_OFFSET; sampleCount += trun->sample_count; } if (UseDefaultSize==1) traf->tfhd->flags |= GF_ISOM_TRAF_SAMPLE_SIZE; if (UseDefaultDur==1) traf->tfhd->flags |= GF_ISOM_TRAF_SAMPLE_DUR; if (UseDefaultFlag==1) traf->tfhd->flags |= GF_ISOM_TRAF_SAMPLE_FLAGS; if (traf->trex->cannot_use_default || (traf->tfhd->sample_desc_index != traf->trex->def_sample_desc_index)) traf->tfhd->flags |= GF_ISOM_TRAF_SAMPLE_DESC; return sampleCount; }
Description: GPAC v2.3-DEV-rev566-g50c2ab06f-master was discovered to contain a heap-use-after-free via the flush_ref_samples function at /gpac/src/isomedia/movie_fragments.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static js_Ast *bitor(js_State *J, int notin) { js_Ast *a = bitxor(J, notin); while (jsP_accept(J, '|')) a = EXP2(BITOR, a, bitxor(J, notin)); return a; }
Description: jsparse.c in Artifex MuJS through 1.0.2 does not properly maintain the AST depth for binary expressions, which allows remote attackers to cause a denial of service (excessive recursion) via a crafted file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Result BinaryReaderIR::TopLabelExpr(LabelNode** label, Expr** expr) { CHECK_RESULT(TopLabel(label)); LabelNode* parent_label; CHECK_RESULT(GetLabelAt(&parent_label, 1)); *expr = &parent_label->exprs->back(); return Result::Ok; }
Description: An issue in wasm2c 1.0.32, wasm2wat 1.0.32, wasm-decompile 1.0.32, and wasm-validate 1.0.32 allows attackers to cause a Denial of Service (DoS) via running a crafted binary.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static fz_page * svg_load_page(fz_context *ctx, fz_document *doc_, int number) { svg_document *doc = (svg_document*)doc_; svg_page *page; if (number != 0) return NULL; page = fz_new_derived_page(ctx, svg_page); page->super.bound_page = svg_bound_page; page->super.run_page_contents = svg_run_page; page->super.drop_page = svg_drop_page; page->doc = doc; return (fz_page*)page; }
Description: Artifex MuPDF 1.14.0 has a SEGV in the function fz_load_page of the fitz/document.c file, as demonstrated by mutool. This is related to page-number mishandling in cbz/mucbz.c, cbz/muimg.c, and svg/svg-doc.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int asn1_ex_c2i(ASN1_VALUE **pval, const unsigned char *cont, int len, int utype, char *free_cont, const ASN1_ITEM *it) { ASN1_VALUE **opval = NULL; ASN1_STRING *stmp; ASN1_TYPE *typ = NULL; int ret = 0; const ASN1_PRIMITIVE_FUNCS *pf; ASN1_INTEGER **tint; pf = it->funcs; if (pf && pf->prim_c2i) return pf->prim_c2i(pval, cont, len, utype, free_cont, it); if (it->utype == V_ASN1_ANY) { if (!*pval) { typ = ASN1_TYPE_new(); if (typ == NULL) goto err; *pval = (ASN1_VALUE *)typ; } else typ = (ASN1_TYPE *)*pval; if (utype != typ->type) ASN1_TYPE_set(typ, utype, NULL); opval = pval; pval = &typ->value.asn1_value; } switch (utype) { case V_ASN1_OBJECT: if (!c2i_ASN1_OBJECT((ASN1_OBJECT **)pval, &cont, len)) goto err; break; case V_ASN1_NULL: if (len) { ASN1err(ASN1_F_ASN1_EX_C2I, ASN1_R_NULL_IS_WRONG_LENGTH); goto err; } *pval = (ASN1_VALUE *)1; break; case V_ASN1_BOOLEAN: if (len != 1) { ASN1err(ASN1_F_ASN1_EX_C2I, ASN1_R_BOOLEAN_IS_WRONG_LENGTH); goto err; } else { ASN1_BOOLEAN *tbool; tbool = (ASN1_BOOLEAN *)pval; *tbool = *cont; } break; case V_ASN1_BIT_STRING: if (!c2i_ASN1_BIT_STRING((ASN1_BIT_STRING **)pval, &cont, len)) goto err; break; case V_ASN1_INTEGER: case V_ASN1_NEG_INTEGER: case V_ASN1_ENUMERATED: case V_ASN1_NEG_ENUMERATED: tint = (ASN1_INTEGER **)pval; if (!c2i_ASN1_INTEGER(tint, &cont, len)) goto err; (*tint)->type = utype | ((*tint)->type & V_ASN1_NEG); break; case V_ASN1_OCTET_STRING: case V_ASN1_NUMERICSTRING: case V_ASN1_PRINTABLESTRING: case V_ASN1_T61STRING: case V_ASN1_VIDEOTEXSTRING: case V_ASN1_IA5STRING: case V_ASN1_UTCTIME: case V_ASN1_GENERALIZEDTIME: case V_ASN1_GRAPHICSTRING: case V_ASN1_VISIBLESTRING: case V_ASN1_GENERALSTRING: case V_ASN1_UNIVERSALSTRING: case V_ASN1_BMPSTRING: case V_ASN1_UTF8STRING: case V_ASN1_OTHER: case V_ASN1_SET: case V_ASN1_SEQUENCE: default: if (utype == V_ASN1_BMPSTRING && (len & 1)) { ASN1err(ASN1_F_ASN1_EX_C2I, ASN1_R_BMPSTRING_IS_WRONG_LENGTH); goto err; } if (utype == V_ASN1_UNIVERSALSTRING && (len & 3)) { ASN1err(ASN1_F_ASN1_EX_C2I, ASN1_R_UNIVERSALSTRING_IS_WRONG_LENGTH); goto err; } if (!*pval) { stmp = ASN1_STRING_type_new(utype); if (!stmp) { ASN1err(ASN1_F_ASN1_EX_C2I, ERR_R_MALLOC_FAILURE); goto err; } *pval = (ASN1_VALUE *)stmp; } else { stmp = (ASN1_STRING *)*pval; stmp->type = utype; } if (*free_cont) { if (stmp->data) OPENSSL_free(stmp->data); stmp->data = (unsigned char *)cont;  stmp->length = len; *free_cont = 0; } else { if (!ASN1_STRING_set(stmp, cont, len)) { ASN1err(ASN1_F_ASN1_EX_C2I, ERR_R_MALLOC_FAILURE); ASN1_STRING_free(stmp); *pval = NULL; goto err; } } break; } if (typ && (utype == V_ASN1_NULL)) typ->value.ptr = NULL; ret = 1; err: if (!ret) { ASN1_TYPE_free(typ); if (opval) *opval = NULL; } return ret; }
Description: The ASN.1 implementation in OpenSSL before 1.0.1o and 1.0.2 before 1.0.2c allows remote attackers to execute arbitrary code or cause a denial of service (buffer underflow and memory corruption) via an ANY field in crafted serialized data, aka the ""negative zero"" issue.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Reprog *regcompx(void *(*alloc)(void *ctx, void *p, int n), void *ctx, const char *pattern, int cflags, const char **errorp) { struct cstate g; Renode *node; Reinst *split, *jump; int i, n; g.pstart = NULL; g.prog = NULL; if (setjmp(g.kaboom)) { if (errorp) *errorp = g.error; alloc(ctx, g.pstart, 0); alloc(ctx, g.prog, 0); return NULL; } g.prog = alloc(ctx, NULL, sizeof (Reprog)); if (!g.prog) die(&g, ""cannot allocate regular expression""); n = strlen(pattern) * 2; if (n > 0) { g.pstart = g.pend = alloc(ctx, NULL, sizeof (Renode) * n); if (!g.pstart) die(&g, ""cannot allocate regular expression parse list""); } g.source = pattern; g.ncclass = 0; g.nsub = 1; for (i = 0; i < MAXSUB; ++i) g.sub[i] = 0; g.prog->flags = cflags; next(&g); node = parsealt(&g); if (g.lookahead == ')') die(&g, ""unmatched ')'""); if (g.lookahead != 0) die(&g, ""syntax error""); #ifdef TEST dumpnode(node); putchar('\n'); #endif n = 6 + count(&g, node); if (n < 0 || n > MAXPROG) die(&g, ""program too large""); g.prog->nsub = g.nsub; g.prog->start = g.prog->end = alloc(ctx, NULL, n * sizeof (Reinst)); if (!g.prog->start) die(&g, ""cannot allocate regular expression instruction list""); split = emit(g.prog, I_SPLIT); split->x = split + 3; split->y = split + 1; emit(g.prog, I_ANYNL); jump = emit(g.prog, I_JUMP); jump->x = split; emit(g.prog, I_LPAR); compile(g.prog, node); emit(g.prog, I_RPAR); emit(g.prog, I_END); #ifdef TEST dumpprog(g.prog); #endif alloc(ctx, g.pstart, 0); if (errorp) *errorp = NULL; return g.prog; }
Description: An issue was discovered in Artifex MuJS 1.0.5. regcompx in regexp.c does not restrict regular expression program size, leading to an overflow of the parsed syntax list size.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: GF_Err gp_rtp_builder_do_vvc(GP_RTPPacketizer *builder, u8 *nalu, u32 nalu_size, u8 IsAUEnd, u32 FullAUSize) { u32 do_flush, bytesLeft, size; do_flush = 0; if (!nalu) do_flush = 1; else if (builder->sl_header.accessUnitStartFlag) do_flush = 1; else if (builder->bytesInPacket + nalu_size + 4 >= builder->Path_MTU) do_flush = 2;  else if (! (builder->flags & GP_RTP_PCK_USE_MULTI) ) do_flush = 2; if (builder->bytesInPacket && do_flush) { builder->rtp_header.Marker = (do_flush==1) ? 1 : 0; if (strlen(builder->hevc_payload_hdr)) { builder->OnData(builder->cbk_obj, (char *)builder->hevc_payload_hdr, 2, GF_TRUE); memset(builder->hevc_payload_hdr, 0, 2); } builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header); builder->bytesInPacket = 0; } if (!nalu) return GF_OK; if (!builder->bytesInPacket) { builder->rtp_header.PayloadType = builder->PayloadType; builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp; builder->rtp_header.SequenceNumber += 1; builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header); } if (builder->bytesInPacket+nalu_size+4 < builder->Path_MTU) { Bool use_AP = (builder->flags & GP_RTP_PCK_USE_MULTI) ? GF_TRUE : GF_FALSE; if (IsAUEnd && !builder->bytesInPacket) use_AP = GF_FALSE; if (use_AP) { char nal_s[2]; if (!builder->bytesInPacket) { builder->hevc_payload_hdr[0] = nalu[0]; builder->hevc_payload_hdr[1] = (RTP_VVC_AGG_NAL << 3) | (nalu[1] & 0x7); } else { u8 cur_LayerId, cur_TID, new_LayerId, new_TID; builder->hevc_payload_hdr[0] |= (nalu[0] & 0x80); cur_LayerId = (builder->hevc_payload_hdr[0] & 0x3F); new_LayerId = (nalu[0] & 0x3F); if (cur_LayerId > new_LayerId) { builder->hevc_payload_hdr[0] = (builder->hevc_payload_hdr[0] & 0xC0) | new_LayerId; } cur_TID = builder->hevc_payload_hdr[1] & 0x3; new_TID = nalu[1] & 0x3; if (cur_TID > new_TID) { builder->hevc_payload_hdr[1] = (builder->hevc_payload_hdr[1] & 0xF8) | new_TID; } } nal_s[0] = nalu_size>>8; nal_s[1] = nalu_size&0x00ff; builder->OnData(builder->cbk_obj, (char *)nal_s, 2, GF_FALSE); builder->bytesInPacket += 2; } if (builder->OnDataReference) builder->OnDataReference(builder->cbk_obj, nalu_size, 0); else builder->OnData(builder->cbk_obj, nalu, nalu_size, GF_FALSE); builder->bytesInPacket += nalu_size; if (IsAUEnd) { builder->rtp_header.Marker = 1; if (strlen(builder->hevc_payload_hdr)) { builder->OnData(builder->cbk_obj, (char *)builder->hevc_payload_hdr, 2, GF_TRUE); memset(builder->hevc_payload_hdr, 0, 2); } builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header); builder->bytesInPacket = 0; } } else { u32 offset; u8 payload_hdr[2]; u8 shdr; assert(nalu_size + 4 >=builder->Path_MTU); assert(!builder->bytesInPacket); bytesLeft = nalu_size - 2; offset = 2; while (bytesLeft) { u8 nut; if (3 + bytesLeft > builder->Path_MTU) { size = builder->Path_MTU - 3; } else { size = bytesLeft; } memset(payload_hdr, 0, 2); payload_hdr[0] = nalu[0]; payload_hdr[1] = (((u32) RTP_VVC_FRAG_NAL) << 3) | (nalu[1] & 0x7); builder->OnData(builder->cbk_obj, (char *)payload_hdr, 2, GF_FALSE); nut = nalu[1] >> 3; shdr = 0; shdr |= nut; if (offset==2) shdr |= 0x80; else if (size == bytesLeft) { shdr |= 0x40; if (nut <= GF_VVC_NALU_SLICE_GDR) { shdr |= 0x20; } } builder->OnData(builder->cbk_obj, &shdr, 1, GF_FALSE); if (builder->OnDataReference) builder->OnDataReference(builder->cbk_obj, size, offset); else builder->OnData(builder->cbk_obj, nalu+offset, size, GF_FALSE); offset += size; bytesLeft -= size; builder->rtp_header.Marker = (IsAUEnd && !bytesLeft) ? 1 : 0; builder->OnPacketDone(builder->cbk_obj, &builder->rtp_header); builder->bytesInPacket = 0; if (bytesLeft) { builder->rtp_header.PayloadType = builder->PayloadType; builder->rtp_header.TimeStamp = (u32) builder->sl_header.compositionTimeStamp; builder->rtp_header.SequenceNumber += 1; builder->OnNewPacket(builder->cbk_obj, &builder->rtp_header); } } } return GF_OK; }
Description: gp_rtp_builder_do_hevc in ietf/rtp_pck_mpeg4.c in GPAC 2.0.0 has a heap-based buffer over-read, as demonstrated by MP4Box.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: TEE_Result tee_ta_init_pseudo_ta_session(const TEE_UUID *uuid, struct tee_ta_session *s) { struct pseudo_ta_ctx *stc = NULL; struct tee_ta_ctx *ctx; const struct pseudo_ta_head *ta; DMSG(""Lookup pseudo TA %pUl"", (void *)uuid); ta = &__start_ta_head_section; while (true) { if (ta >= &__stop_ta_head_section) return TEE_ERROR_ITEM_NOT_FOUND; if (memcmp(&ta->uuid, uuid, sizeof(TEE_UUID)) == 0) break; ta++; } DMSG(""Open %s"", ta->name); stc = calloc(1, sizeof(struct pseudo_ta_ctx)); if (!stc) return TEE_ERROR_OUT_OF_MEMORY; ctx = &stc->ctx; s->ctx = ctx; ctx->flags = ta->flags; stc->pseudo_ta = ta; ctx->uuid = ta->uuid; ctx->ops = &pseudo_ta_ops; TAILQ_INSERT_TAIL(&tee_ctxes, ctx, link); DMSG(""%s : %pUl"", stc->pseudo_ta->name, (void *)&ctx->uuid); return TEE_SUCCESS; }
Description: The function tee_obj_free in Samsung mTower through 0.3.0 allows a trusted application to trigger a Denial of Service (DoS) by invoking the function TEE_AllocateOperation with a disturbed heap layout, related to utee_cryp_obj_alloc.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int DecodeBasicOcspResponse(byte* source, word32* ioIndex, OcspResponse* resp, word32 size, void* cm, void* heap, int noVerify) { int    length; word32 idx = *ioIndex; word32 end_index; int    ret; int    sigLength; WOLFSSL_ENTER(""DecodeBasicOcspResponse""); (void)heap; if (GetSequence(source, &idx, &length, size) < 0) return ASN_PARSE_E; if (idx + length > size) return ASN_INPUT_E; end_index = idx + length; if ((ret = DecodeResponseData(source, &idx, resp, size)) < 0) return ret;  if (GetAlgoId(source, &idx, &resp->sigOID, oidSigType, size) < 0) return ASN_PARSE_E; ret = CheckBitString(source, &idx, &sigLength, size, 1, NULL); if (ret != 0) return ret; resp->sigSz = sigLength; resp->sig = source + idx; idx += sigLength; #ifndef WOLFSSL_NO_OCSP_OPTIONAL_CERTS if (idx < end_index) { DecodedCert cert; if (DecodeCerts(source, &idx, resp, size) < 0) return ASN_PARSE_E; InitDecodedCert(&cert, resp->cert, resp->certSz, heap); ret = ParseCertRelative(&cert, CERT_TYPE, noVerify ? NO_VERIFY : VERIFY_OCSP, cm); if (ret < 0) { WOLFSSL_MSG(""\tOCSP Responder certificate parsing failed""); FreeDecodedCert(&cert); return ret; } #ifndef WOLFSSL_NO_OCSP_ISSUER_CHECK if ((cert.extExtKeyUsage & EXTKEYUSE_OCSP_SIGN) == 0) { if (XMEMCMP(cert.subjectHash, resp->single->issuerHash, OCSP_DIGEST_SIZE) == 0) { WOLFSSL_MSG(""\tOCSP Response signed by issuer""); } else { WOLFSSL_MSG(""\tOCSP Responder key usage check failed""); #ifdef OPENSSL_EXTRA resp->verifyError = OCSP_BAD_ISSUER; #else FreeDecodedCert(&cert); return BAD_OCSP_RESPONDER; #endif } } #endif ret = ConfirmSignature(&cert.sigCtx, resp->response, resp->responseSz, cert.publicKey, cert.pubKeySize, cert.keyOID, resp->sig, resp->sigSz, resp->sigOID, NULL); FreeDecodedCert(&cert); if (ret != 0) { WOLFSSL_MSG(""\tOCSP Confirm signature failed""); return ASN_OCSP_CONFIRM_E; } } else #endif  { Signer* ca; int sigValid = -1; #ifndef NO_SKID ca = GetCA(cm, resp->single->issuerKeyHash); #else ca = GetCA(cm, resp->single->issuerHash); #endif if (ca) { SignatureCtx sigCtx; InitSignatureCtx(&sigCtx, heap, INVALID_DEVID); sigValid = ConfirmSignature(&sigCtx, resp->response, resp->responseSz, ca->publicKey, ca->pubKeySize, ca->keyOID, resp->sig, resp->sigSz, resp->sigOID, NULL); } if (ca == NULL || sigValid != 0) { WOLFSSL_MSG(""\tOCSP Confirm signature failed""); return ASN_OCSP_CONFIRM_E; } (void)noVerify; } *ioIndex = idx; return 0; }
Description: wolfSSL before 4.8.1 incorrectly skips OCSP verification in certain situations of irrelevant response data that contains the NoCheck extension.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int nntp_hcache_namer(const char *path, char *dest, size_t destlen) { return snprintf(dest, destlen, ""%s.hcache"", path); }
Description: An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. pop.c does not forbid characters that may have unsafe interaction with message-cache pathnames, as demonstrated by a '/' character.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void zend_throw_or_error(int fetch_type, zend_class_entry *exception_ce, const char *format, ...)  { va_list va; char *message = NULL; va_start(va, format); zend_vspprintf(&message, 0, format, va); if (fetch_type & ZEND_FETCH_CLASS_EXCEPTION) { zend_throw_error(exception_ce, message); } else { zend_error(E_ERROR, ""%s"", message); } efree(message); va_end(va); }
Description: Format string vulnerability in the zend_throw_or_error function in Zend/zend_execute_API.c in PHP 7.x before 7.0.1 allows remote attackers to execute arbitrary code via format string specifiers in a string that is misused as a class name, leading to incorrect error handling.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int main(int argc, char *argv[]) { int objectsCount = 0; unsigned int numOffset = 0; std::vector<Object> pages; std::vector<unsigned int> offsets; XRef *yRef, *countRef; FILE *f; OutStream *outStr; int i; int j, rootNum; std::vector<PDFDoc *> docs; int majorVersion = 0; int minorVersion = 0; char *fileName = argv[argc - 1]; const bool ok = parseArgs(argDesc, &argc, argv); if (!ok || argc < 3 || printVersion || printHelp) { fprintf(stderr, ""pdfunite version %s\n"", PACKAGE_VERSION); fprintf(stderr, ""%s\n"", popplerCopyright); fprintf(stderr, ""%s\n"", xpdfCopyright); if (!printVersion) { printUsage(""pdfunite"", ""<PDF-sourcefile-1>..<PDF-sourcefile-n> <PDF-destfile>"", argDesc); } if (printVersion || printHelp) { return 0; } return 99; } globalParams = std::make_unique<GlobalParams>(); for (i = 1; i < argc - 1; i++) { PDFDoc *doc = new PDFDoc(std::make_unique<GooString>(argv[i])); if (doc->isOk() && !doc->isEncrypted() && doc->getXRef()->getCatalog().isDict()) { docs.push_back(doc); if (doc->getPDFMajorVersion() > majorVersion) { majorVersion = doc->getPDFMajorVersion(); minorVersion = doc->getPDFMinorVersion(); } else if (doc->getPDFMajorVersion() == majorVersion) { if (doc->getPDFMinorVersion() > minorVersion) { minorVersion = doc->getPDFMinorVersion(); } } } else if (doc->isOk()) { if (doc->isEncrypted()) { error(errUnimplemented, -1, ""Could not merge encrypted files ('{0:s}')"", argv[i]); return -1; } else if (!doc->getXRef()->getCatalog().isDict()) { error(errSyntaxError, -1, ""XRef's Catalog is not a dictionary ('{0:s}')"", argv[i]); return -1; } } else { error(errSyntaxError, -1, ""Could not merge damaged documents ('{0:s}')"", argv[i]); return -1; } } if (!(f = fopen(fileName, ""wb""))) { error(errIO, -1, ""Could not open file '{0:s}'"", fileName); return -1; } outStr = new FileOutStream(f, 0); yRef = new XRef(); countRef = new XRef(); yRef->add(0, 65535, 0, false); PDFDoc::writeHeader(outStr, majorVersion, minorVersion); Object intents; Object names; Object afObj; Object ocObj; if (docs.size() >= 1) { Object catObj = docs[0]->getXRef()->getCatalog(); if (!catObj.isDict()) { fclose(f); delete yRef; delete countRef; delete outStr; error(errSyntaxError, -1, ""XRef's Catalog is not a dictionary.""); return -1; } Dict *catDict = catObj.getDict(); intents = catDict->lookup(""OutputIntents""); afObj = catDict->lookupNF(""AcroForm"").copy(); Ref *refPage = docs[0]->getCatalog()->getPageRef(1); if (!afObj.isNull() && refPage) { docs[0]->markAcroForm(&afObj, yRef, countRef, 0, refPage->num, refPage->num); } ocObj = catDict->lookupNF(""OCProperties"").copy(); if (!ocObj.isNull() && ocObj.isDict() && refPage) { docs[0]->markPageObjects(ocObj.getDict(), yRef, countRef, 0, refPage->num, refPage->num); } names = catDict->lookup(""Names""); if (!names.isNull() && names.isDict() && refPage) { docs[0]->markPageObjects(names.getDict(), yRef, countRef, 0, refPage->num, refPage->num); } if (intents.isArray() && intents.arrayGetLength() > 0) { for (i = 1; i < (int)docs.size(); i++) { Object pagecatObj = docs[i]->getXRef()->getCatalog(); Dict *pagecatDict = pagecatObj.getDict(); Object pageintents = pagecatDict->lookup(""OutputIntents""); if (pageintents.isArray() && pageintents.arrayGetLength() > 0) { for (j = intents.arrayGetLength() - 1; j >= 0; j--) { Object intent = intents.arrayGet(j, 0); if (intent.isDict()) { Object idf = intent.dictLookup(""OutputConditionIdentifier""); if (idf.isString()) { const GooString *gidf = idf.getString(); bool removeIntent = true; for (int k = 0; k < pageintents.arrayGetLength(); k++) { Object pgintent = pageintents.arrayGet(k, 0); if (pgintent.isDict()) { Object pgidf = pgintent.dictLookup(""OutputConditionIdentifier""); if (pgidf.isString()) { const GooString *gpgidf = pgidf.getString(); if (gpgidf->cmp(gidf) == 0) { removeIntent = false; break; } } } } if (removeIntent) { intents.arrayRemove(j); error(errSyntaxWarning, -1, ""Output intent {0:s} missing in pdf {1:s}, removed"", gidf->c_str(), docs[i]->getFileName()->c_str()); } } else { intents.arrayRemove(j); error(errSyntaxWarning, -1, ""Invalid output intent dict, missing required OutputConditionIdentifier""); } } else { intents.arrayRemove(j); } } } else { error(errSyntaxWarning, -1, ""Output intents differs, remove them all""); break; } } } if (intents.isArray() && intents.arrayGetLength() > 0) { for (j = intents.arrayGetLength() - 1; j >= 0; j--) { Object intent = intents.arrayGet(j, 0); if (intent.isDict()) { docs[0]->markPageObjects(intent.getDict(), yRef, countRef, numOffset, 0, 0); } else { intents.arrayRemove(j); } } } } for (i = 0; i < (int)docs.size(); i++) { for (j = 1; j <= docs[i]->getNumPages(); j++) { if (!docs[i]->getCatalog()->getPage(j)) { continue; } const PDFRectangle *cropBox = nullptr; if (docs[i]->getCatalog()->getPage(j)->isCropped()) { cropBox = docs[i]->getCatalog()->getPage(j)->getCropBox(); } docs[i]->replacePageDict(j, docs[i]->getCatalog()->getPage(j)->getRotate(), docs[i]->getCatalog()->getPage(j)->getMediaBox(), cropBox); Ref *refPage = docs[i]->getCatalog()->getPageRef(j); Object page = docs[i]->getXRef()->fetch(*refPage); Dict *pageDict = page.getDict(); Object *resDict = docs[i]->getCatalog()->getPage(j)->getResourceDictObject(); if (resDict->isDict()) { pageDict->set(""Resources"", resDict->copy()); } pages.push_back(std::move(page)); offsets.push_back(numOffset); docs[i]->markPageObjects(pageDict, yRef, countRef, numOffset, refPage->num, refPage->num); Object annotsObj = pageDict->lookupNF(""Annots"").copy(); if (!annotsObj.isNull()) { docs[i]->markAnnotations(&annotsObj, yRef, countRef, numOffset, refPage->num, refPage->num); } } Object pageCatObj = docs[i]->getXRef()->getCatalog(); if (!pageCatObj.isDict()) { fclose(f); delete yRef; delete countRef; delete outStr; error(errSyntaxError, -1, ""XRef's Catalog is not a dictionary.""); return -1; } Dict *pageCatDict = pageCatObj.getDict(); Object pageNames = pageCatDict->lookup(""Names""); if (!pageNames.isNull() && pageNames.isDict()) { if (!names.isDict()) { names = Object(new Dict(yRef)); } doMergeNameDict(docs[i], yRef, countRef, 0, 0, names.getDict(), pageNames.getDict(), numOffset); } Object pageForm = pageCatDict->lookup(""AcroForm""); if (i > 0 && !pageForm.isNull() && pageForm.isDict()) { if (afObj.isNull()) { afObj = pageCatDict->lookupNF(""AcroForm"").copy(); } else if (afObj.isDict()) { doMergeFormDict(afObj.getDict(), pageForm.getDict(), numOffset); } } objectsCount += docs[i]->writePageObjects(outStr, yRef, numOffset, true); numOffset = yRef->getNumObjects() + 1; } rootNum = yRef->getNumObjects() + 1; yRef->add(rootNum, 0, outStr->getPos(), true); outStr->printf(""%d 0 obj\n"", rootNum); outStr->printf(""<< /Type /Catalog /Pages %d 0 R"", rootNum + 1); if (intents.isArray() && intents.arrayGetLength() > 0) { outStr->printf("" /OutputIntents [""); for (j = 0; j < intents.arrayGetLength(); j++) { Object intent = intents.arrayGet(j, 0); if (intent.isDict()) { PDFDoc::writeObject(&intent, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0); } } outStr->printf(""]""); } if (!afObj.isNull()) { outStr->printf("" /AcroForm ""); PDFDoc::writeObject(&afObj, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0); } if (!ocObj.isNull() && ocObj.isDict()) { outStr->printf("" /OCProperties ""); PDFDoc::writeObject(&ocObj, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0); } if (!names.isNull() && names.isDict()) { outStr->printf("" /Names ""); PDFDoc::writeObject(&names, outStr, yRef, 0, nullptr, cryptRC4, 0, 0, 0); } outStr->printf("">>\nendobj\n""); objectsCount++; yRef->add(rootNum + 1, 0, outStr->getPos(), true); outStr->printf(""%d 0 obj\n"", rootNum + 1); outStr->printf(""<< /Type /Pages /Kids [""); for (j = 0; j < (int)pages.size(); j++) { outStr->printf("" %d 0 R"", rootNum + j + 2); } outStr->printf("" ] /Count %zd >>\nendobj\n"", pages.size()); objectsCount++; for (i = 0; i < (int)pages.size(); i++) { yRef->add(rootNum + i + 2, 0, outStr->getPos(), true); outStr->printf(""%d 0 obj\n"", rootNum + i + 2); outStr->printf(""<< ""); Dict *pageDict = pages[i].getDict(); for (j = 0; j < pageDict->getLength(); j++) { if (j > 0) { outStr->printf("" ""); } const char *key = pageDict->getKey(j); Object value = pageDict->getValNF(j).copy(); if (strcmp(key, ""Parent"") == 0) { outStr->printf(""/Parent %d 0 R"", rootNum + 1); } else { outStr->printf(""/%s "", key); PDFDoc::writeObject(&value, outStr, yRef, offsets[i], nullptr, cryptRC4, 0, 0, 0); } } outStr->printf("" >>\nendobj\n""); objectsCount++; } Goffset uxrefOffset = outStr->getPos(); Ref ref; ref.num = rootNum; ref.gen = 0; Object trailerDict = PDFDoc::createTrailerDict(objectsCount, false, 0, &ref, yRef, fileName, outStr->getPos()); PDFDoc::writeXRefTableTrailer(std::move(trailerDict), yRef, true,                                                                                                         uxrefOffset, outStr, yRef); outStr->close(); delete outStr; fclose(f); delete yRef; delete countRef; for (i = 0; i < (int)docs.size(); i++) { delete docs[i]; } return 0; }
Description: An issue was discovered in Poppler 22.08.0. There is a reachable assertion in Object.h, will lead to denial of service because PDFDoc::replacePageDict in PDFDoc.cc lacks a stream check before saving an embedded file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int main(int argc, char *argv[]) { int i, fd, swapped, pkthdrlen, ret, optct, backwards, caplentoobig; struct pcap_file_header pcap_fh; struct pcap_pkthdr pcap_ph; struct pcap_sf_patched_pkthdr pcap_patched_ph;  char buf[10000]; struct stat statinfo; uint64_t pktcnt; uint32_t readword; int32_t last_sec, last_usec, caplen; optct = optionProcess(&tcpcapinfoOptions, argc, argv); argc -= optct; argv += optct; #ifdef DEBUG if (HAVE_OPT(DBUG)) debug = OPT_VALUE_DBUG; #endif for (i = 0; i < argc; i++) { dbgx(1, ""processing:  %s\n"", argv[i]); if ((fd = open(argv[i], O_RDONLY)) < 0) errx(-1, ""Error opening file %s: %s"", argv[i], strerror(errno)); if (fstat(fd, &statinfo) < 0) errx(-1, ""Error getting file stat info %s: %s"", argv[i], strerror(errno)); printf(""file size   = %""PRIu64"" bytes\n"", (uint64_t)statinfo.st_size); if ((ret = read(fd, &buf, sizeof(pcap_fh))) != sizeof(pcap_fh)) errx(-1, ""File too small.  Unable to read pcap_file_header from %s"", argv[i]); dbgx(3, ""Read %d bytes for file header"", ret); swapped = 0; memcpy(&pcap_fh, &buf, sizeof(pcap_fh)); pkthdrlen = 16;  switch (pcap_fh.magic) { case TCPDUMP_MAGIC: printf(""magic       = 0x%08""PRIx32"" (tcpdump) (%s)\n"", pcap_fh.magic, is_not_swapped); break; case SWAPLONG(TCPDUMP_MAGIC): printf(""magic       = 0x%08""PRIx32"" (tcpdump/swapped) (%s)\n"", pcap_fh.magic, is_swapped); swapped = 1; break; case KUZNETZOV_TCPDUMP_MAGIC: pkthdrlen = sizeof(pcap_patched_ph); printf(""magic       = 0x%08""PRIx32"" (Kuznetzov) (%s)\n"", pcap_fh.magic, is_not_swapped); break; case SWAPLONG(KUZNETZOV_TCPDUMP_MAGIC): pkthdrlen = sizeof(pcap_patched_ph); printf(""magic       = 0x%08""PRIx32"" (Kuznetzov/swapped) (%s)\n"", pcap_fh.magic, is_swapped); swapped = 1; break; case FMESQUITA_TCPDUMP_MAGIC: printf(""magic       = 0x%08""PRIx32"" (Fmesquita) (%s)\n"", pcap_fh.magic, is_not_swapped); break; case SWAPLONG(FMESQUITA_TCPDUMP_MAGIC): printf(""magic       = 0x%08""PRIx32"" (Fmesquita) (%s)\n"", pcap_fh.magic, is_swapped); swapped = 1; break; case NAVTEL_TCPDUMP_MAGIC: printf(""magic       = 0x%08""PRIx32"" (Navtel) (%s)\n"", pcap_fh.magic, is_not_swapped); break; case SWAPLONG(NAVTEL_TCPDUMP_MAGIC): printf(""magic       = 0x%08""PRIx32"" (Navtel/swapped) (%s)\n"", pcap_fh.magic, is_swapped); swapped = 1; break; case NSEC_TCPDUMP_MAGIC: printf(""magic       = 0x%08""PRIx32"" (Nsec) (%s)\n"", pcap_fh.magic, is_not_swapped); break; case SWAPLONG(NSEC_TCPDUMP_MAGIC): printf(""magic       = 0x%08""PRIx32"" (Nsec/swapped) (%s)\n"", pcap_fh.magic, is_swapped); swapped = 1; break; default: printf(""magic       = 0x%08""PRIx32"" (unknown)\n"", pcap_fh.magic); } if (swapped == 1) { pcap_fh.version_major = SWAPSHORT(pcap_fh.version_major); pcap_fh.version_minor = SWAPSHORT(pcap_fh.version_minor); pcap_fh.thiszone = SWAPLONG(pcap_fh.thiszone); pcap_fh.sigfigs = SWAPLONG(pcap_fh.sigfigs); pcap_fh.snaplen = SWAPLONG(pcap_fh.snaplen); pcap_fh.linktype = SWAPLONG(pcap_fh.linktype); } printf(""version     = %hu.%hu\n"", pcap_fh.version_major, pcap_fh.version_minor); printf(""thiszone    = 0x%08""PRIx32""\n"", pcap_fh.thiszone); printf(""sigfigs     = 0x%08""PRIx32""\n"", pcap_fh.sigfigs); printf(""snaplen     = %""PRIu32""\n"", pcap_fh.snaplen); printf(""linktype    = 0x%08""PRIx32""\n"", pcap_fh.linktype); if (pcap_fh.version_major != 2 && pcap_fh.version_minor != 4) { printf(""Sorry, we only support file format version 2.4\n""); close(fd); continue; } dbgx(5, ""Packet header len: %d"", pkthdrlen); if (pkthdrlen == 24) { printf(""Packet\tOrigLen\t\tCaplen\t\tTimestamp\t\tIndex\tProto\tPktType\tPktCsum\tNote\n""); } else { printf(""Packet\tOrigLen\t\tCaplen\t\tTimestamp\tCsum\tNote\n""); } pktcnt = 0; last_sec = 0; last_usec = 0; while ((ret = read(fd, &buf, pkthdrlen)) == pkthdrlen) { pktcnt ++; backwards = 0; caplentoobig = 0; dbgx(3, ""Read %d bytes for packet %""PRIu64"" header"", ret, pktcnt); memset(&pcap_ph, 0, sizeof(pcap_ph)); if (pkthdrlen == sizeof(pcap_patched_ph)) { memcpy(&pcap_patched_ph, &buf, sizeof(pcap_patched_ph)); if (swapped == 1) { dbg(3, ""Swapping packet header bytes...""); pcap_patched_ph.caplen = SWAPLONG(pcap_patched_ph.caplen); pcap_patched_ph.len = SWAPLONG(pcap_patched_ph.len); pcap_patched_ph.ts.tv_sec = SWAPLONG(pcap_patched_ph.ts.tv_sec); pcap_patched_ph.ts.tv_usec = SWAPLONG(pcap_patched_ph.ts.tv_usec); pcap_patched_ph.index = SWAPLONG(pcap_patched_ph.index); pcap_patched_ph.protocol = SWAPSHORT(pcap_patched_ph.protocol); } printf(""%""PRIu64""\t%4""PRIu32""\t\t%4""PRIu32""\t\t%"" PRIx32"".%""PRIx32""\t\t%4""PRIu32""\t%4hu\t%4hhu"",  pktcnt, pcap_patched_ph.len, pcap_patched_ph.caplen,  pcap_patched_ph.ts.tv_sec, pcap_patched_ph.ts.tv_usec, pcap_patched_ph.index, pcap_patched_ph.protocol, pcap_patched_ph.pkt_type); if (pcap_fh.snaplen < pcap_patched_ph.caplen) { caplentoobig = 1; } caplen = pcap_patched_ph.caplen; } else { memcpy(&readword, buf, 4); pcap_ph.ts.tv_sec = readword; memcpy(&readword, &buf[4], 4); pcap_ph.ts.tv_usec = readword; memcpy(&pcap_ph.caplen, &buf[8], 4); memcpy(&pcap_ph.len, &buf[12], 4); if (swapped == 1) { dbg(3, ""Swapping packet header bytes...""); pcap_ph.caplen = SWAPLONG(pcap_ph.caplen); pcap_ph.len = SWAPLONG(pcap_ph.len); pcap_ph.ts.tv_sec = SWAPLONG(pcap_ph.ts.tv_sec); pcap_ph.ts.tv_usec = SWAPLONG(pcap_ph.ts.tv_usec); } printf(""%""PRIu64""\t%4""PRIu32""\t\t%4""PRIu32""\t\t%"" PRIx32"".%""PRIx32, pktcnt, pcap_ph.len, pcap_ph.caplen,  (unsigned int)pcap_ph.ts.tv_sec, (unsigned int)pcap_ph.ts.tv_usec); if (pcap_fh.snaplen < pcap_ph.caplen) { caplentoobig = 1; } caplen = pcap_ph.caplen; } if (last_sec > 0 && last_usec > 0) { if ((pcap_ph.ts.tv_sec == last_sec) ?  (pcap_ph.ts.tv_usec < last_usec) :  (pcap_ph.ts.tv_sec < last_sec)) { backwards = 1; } } if (pkthdrlen == sizeof(pcap_patched_ph)) { last_sec = pcap_patched_ph.ts.tv_sec; last_usec = pcap_patched_ph.ts.tv_usec; } else { last_sec = pcap_ph.ts.tv_sec; last_usec = pcap_ph.ts.tv_usec; } if ((ret = read(fd, &buf, caplen)) != caplen) { if (ret < 0) { printf(""Error reading file: %s: %s\n"", argv[i], strerror(errno)); } else { printf(""File truncated!  Unable to jump to next packet.\n""); } close(fd); continue; } printf(""\t%x\t"", do_checksum_math((u_int16_t *)buf, caplen)); if (! backwards && ! caplentoobig) { printf(""OK\n""); } else if (backwards && ! caplentoobig) { printf(""BAD_TS\n""); } else if (caplentoobig && ! backwards) { printf(""TOOBIG\n""); } else if (backwards && caplentoobig) { printf(""BAD_TS|TOOBIG""); }  } } exit(0); }
Description: Buffer overflow in the tcpcapinfo utility in Tcpreplay before 4.2.0 Beta 1 allows remote attackers to have unspecified impact via a pcap file with an over-size packet.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static njs_int_t njs_iterator_to_array_handler(njs_vm_t *vm, njs_iterator_args_t *args, njs_value_t *value, int64_t index) { njs_array_t  *array; array = args->data; array->start[index] = *value; return NJS_OK; }
Description: Nginx NJS v0.7.5 was discovered to contain a segmentation violation in the function njs_value_own_enumerate at src/njs_value.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static njs_int_t njs_promise_perform_any_handler(njs_vm_t *vm, njs_iterator_args_t *args, njs_value_t *value, int64_t index) { njs_int_t                    ret; njs_array_t                  *array; njs_value_t                  arguments[2], next; njs_function_t               *on_rejected; njs_promise_capability_t     *capability; njs_promise_all_context_t    *context; njs_promise_iterator_args_t  *pargs; pargs = (njs_promise_iterator_args_t *) args; capability = pargs->capability; array = pargs->args.data; njs_set_undefined(&array->start[index]); ret = njs_function_call(vm, pargs->function, pargs->constructor, value, 1, &next); if (njs_slow_path(ret == NJS_ERROR)) { return ret; } on_rejected = njs_promise_create_function(vm, sizeof(njs_promise_all_context_t)); if (njs_slow_path(on_rejected == NULL)) { return NJS_ERROR; } on_rejected->u.native = njs_promise_any_reject_element_functions; on_rejected->args_count = 1; context = on_rejected->context; context->already_called = 0; context->index = (uint32_t) index; context->values = pargs->args.data; context->capability = capability; context->remaining_elements = pargs->remaining; (*pargs->remaining)++; arguments[0] = capability->resolve; njs_set_function(&arguments[1], on_rejected); ret = njs_promise_invoke_then(vm, &next, arguments, 2); if (njs_slow_path(ret == NJS_ERROR)) { return ret; } return NJS_OK; }
Description: Nginx NJS v0.7.2 was discovered to contain a segmentation violation in the function njs_vmcode_interpreter at src/njs_vmcode.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Compound_Selector_Obj get_arg_sel(const std::string& argname, Env& env, Signature sig, ParserState pstate, Backtraces traces, Context& ctx) { Expression_Obj exp = ARG(argname, Expression); if (exp->concrete_type() == Expression::NULL_VAL) { std::stringstream msg; msg << argname << "": null is not a string for `"" << function_name(sig) << ""'""; error(msg.str(), exp->pstate(), traces); } if (String_Constant_Ptr str = Cast<String_Constant>(exp)) { str->quote_mark(0); } std::string exp_src = exp->to_string(ctx.c_options); Selector_List_Obj sel_list = Parser::parse_selector(exp_src.c_str(), ctx, traces, exp->pstate(), pstate.src); if (sel_list->length() == 0) return {}; Complex_Selector_Obj first = sel_list->first(); if (!first->tail()) return first->head(); return first->tail()->head(); }
Description: In LibSass 3.5.5, a NULL Pointer Dereference in the function Sass::Selector_List::populate_extends in SharedPtr.hpp (used by ast.cpp and ast_selectors.cpp) may cause a Denial of Service (application crash) via a crafted sass input file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void on_display_status_changed (GdmDisplay *display, GParamSpec *arg1, GdmManager *manager) { int         status; int         display_number = -1; #ifdef WITH_PLYMOUTH gboolean    display_is_local = FALSE; gboolean    quit_plymouth = FALSE; g_object_get (display, ""is-local"", &display_is_local, NULL); quit_plymouth = display_is_local && manager->priv->plymouth_is_running; #endif g_object_get (display, ""x11-display-number"", &display_number, NULL); status = gdm_display_get_status (display); switch (status) { case GDM_DISPLAY_PREPARED: case GDM_DISPLAY_MANAGED: if ((display_number == -1 && status == GDM_DISPLAY_PREPARED) || (display_number != -1 && status == GDM_DISPLAY_MANAGED)) { char *session_class; g_object_get (display, ""session-class"", &session_class, NULL); if (g_strcmp0 (session_class, ""greeter"") == 0) set_up_session (manager, display); g_free (session_class); } if (status == GDM_DISPLAY_MANAGED) { greeter_display_started (manager, display); } break; case GDM_DISPLAY_FAILED: case GDM_DISPLAY_UNMANAGED: case GDM_DISPLAY_FINISHED: #ifdef WITH_PLYMOUTH if (quit_plymouth) { plymouth_quit_without_transition (); manager->priv->plymouth_is_running = FALSE; } #endif maybe_start_pending_initial_login (manager, display); break; default: break; } }
Description: A flaw was discovered in gdm 3.24.1 where gdm greeter was no longer setting the ran_once boolean during autologin. If autologin was enabled for a victim, an attacker could simply select 'login as another user' to unlock their screen.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void update_max_tr(struct trace_array *tr, struct task_struct *tsk, int cpu) { struct ring_buffer *buf; if (tr->stop_count) return; WARN_ON_ONCE(!irqs_disabled()); if (!tr->allocated_snapshot) { WARN_ON_ONCE(tr->current_trace != &nop_trace); return; } arch_spin_lock(&tr->max_lock); buf = tr->trace_buffer.buffer; tr->trace_buffer.buffer = tr->max_buffer.buffer; tr->max_buffer.buffer = buf; __update_max_tr(tr, tsk, cpu); arch_spin_unlock(&tr->max_lock); }
Description: An issue was discovered in the Linux kernel through 4.17.2. The filter parsing in kernel/trace/trace_events_filter.c could be called with no filter, which is an N=0 case when it expected at least one line to have been read, thus making the N-1 index invalid. This allows attackers to cause a denial of service (slab out-of-bounds write) or possibly have unspecified other impact via crafted perf_event_open and mmap system calls.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int blk_mq_init_sched(struct request_queue *q, struct elevator_type *e) { struct blk_mq_hw_ctx *hctx; struct elevator_queue *eq; unsigned int i; int ret; if (!e) { q->elevator = NULL; q->nr_requests = q->tag_set->queue_depth; return 0; } q->nr_requests = 2 * min_t(unsigned int, q->tag_set->queue_depth, BLKDEV_MAX_RQ); queue_for_each_hw_ctx(q, hctx, i) { ret = blk_mq_sched_alloc_tags(q, hctx, i); if (ret) goto err; } ret = e->ops.init_sched(q, e); if (ret) goto err; blk_mq_debugfs_register_sched(q); queue_for_each_hw_ctx(q, hctx, i) { if (e->ops.init_hctx) { ret = e->ops.init_hctx(hctx, i); if (ret) { eq = q->elevator; blk_mq_exit_sched(q, eq); kobject_put(&eq->kobj); return ret; } } blk_mq_debugfs_register_sched_hctx(q, hctx); } return 0; err: blk_mq_sched_tags_teardown(q); q->elevator = NULL; return ret; }
Description: The block subsystem in the Linux kernel before 5.2 has a use-after-free that can lead to arbitrary code execution in the kernel context and privilege escalation, aka CID-c3e2219216c9. This is related to blk_mq_free_rqs and blk_cleanup_queue.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int _yr_scan_match_callback( uint8_t* match_data, int32_t match_length, int flags, void* args) { CALLBACK_ARGS* callback_args = (CALLBACK_ARGS*) args; YR_STRING* string = callback_args->string; YR_MATCH* new_match; int result = ERROR_SUCCESS; int tidx = callback_args->context->tidx; size_t match_offset = match_data - callback_args->data; match_length += callback_args->forward_matches; if (callback_args->full_word) { if (flags & RE_FLAGS_WIDE) { if (match_offset >= 2 && *(match_data - 1) == 0 && isalnum(*(match_data - 2))) return ERROR_SUCCESS; if (match_offset + match_length + 1 < callback_args->data_size && *(match_data + match_length + 1) == 0 && isalnum(*(match_data + match_length))) return ERROR_SUCCESS; } else { if (match_offset >= 1 && isalnum(*(match_data - 1))) return ERROR_SUCCESS; if (match_offset + match_length < callback_args->data_size && isalnum(*(match_data + match_length))) return ERROR_SUCCESS; } } if (STRING_IS_CHAIN_PART(string)) { result = _yr_scan_verify_chained_string_match( string, callback_args->context, match_data, callback_args->data_base, match_offset, match_length); } else { if (string->matches[tidx].count == 0) { FAIL_ON_ERROR(yr_arena_write_data( callback_args->context->matching_strings_arena, &string, sizeof(string), NULL)); } FAIL_ON_ERROR(yr_arena_allocate_memory( callback_args->context->matches_arena, sizeof(YR_MATCH), (void**) &new_match)); new_match->data_length = yr_min(match_length, MAX_MATCH_DATA); FAIL_ON_ERROR(yr_arena_write_data( callback_args->context->matches_arena, match_data, new_match->data_length, (void**) &new_match->data)); if (result == ERROR_SUCCESS) { new_match->base = callback_args->data_base; new_match->offset = match_offset; new_match->match_length = match_length; new_match->prev = NULL; new_match->next = NULL; FAIL_ON_ERROR(_yr_scan_add_match_to_list( new_match, &string->matches[tidx], STRING_IS_GREEDY_REGEXP(string))); } } return result; }
Description: The yr_arena_write_data function in YARA 3.6.1 allows remote attackers to cause a denial of service (buffer over-read and application crash) or obtain sensitive information from process memory via a crafted file that is mishandled in the yr_re_fast_exec function in libyara/re.c and the _yr_scan_match_callback function in libyara/scan.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static gint rtps_util_add_type_member(proto_tree *tree, tvbuff_t * tvb, gint offset, const guint encoding, dissection_info * info, dissection_element * member_object) { proto_tree * member_property, *annotation_tree; guint32 member_id = 0, member_length = 0; guint32 long_number, i; guint16 short_number; guint64 member_type_id; gint offset_tmp; gchar * name = NULL; member_property = proto_tree_add_subtree(tree, tvb, offset, 0, ett_rtps_type_element, NULL, ""Member Property""); rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length); offset_tmp = offset; short_number = tvb_get_guint16(tvb, offset_tmp, encoding); proto_tree_add_bitmask_value(member_property, tvb, offset_tmp, hf_rtps_type_object_flags, ett_rtps_flags, MEMBER_FLAGS, short_number); if (member_object) member_object->flags = short_number; offset_tmp += 2; ALIGN_ZERO(offset_tmp, 4, offset); proto_tree_add_item(member_property, hf_rtps_type_object_member_id, tvb, offset_tmp, 4, encoding); member_id = tvb_get_guint32(tvb, offset_tmp, encoding); offset_tmp += 4; offset_tmp = rtps_util_add_type_id(member_property, tvb, offset_tmp, encoding, offset, -1, tree, &member_type_id); rtps_util_add_string(member_property, tvb, offset_tmp, hf_rtps_type_object_name, encoding); long_number = tvb_get_guint32(tvb, offset_tmp, encoding); name = tvb_get_string_enc(wmem_packet_scope(), tvb, offset_tmp+4, long_number, ENC_ASCII); proto_item_append_text(tree, "" %s (ID: %d)"", name, member_id); if (member_object) { member_object->member_id = member_id; (void) g_strlcpy(member_object->member_name, name, long_number < 256 ? long_number : 256); member_object->type_id = member_type_id; } if (info && info->extensibility == EXTENSIBILITY_MUTABLE) { mutable_member_mapping * mutable_mapping = NULL; mutable_mapping = wmem_new(wmem_file_scope(), mutable_member_mapping); (void) g_strlcpy(mutable_mapping->member_name, name, long_number < 256 ? long_number : 256); mutable_mapping->struct_type_id = info->type_id; mutable_mapping->member_type_id = member_type_id; mutable_mapping->member_id = member_id; mutable_mapping->key = (mutable_mapping->struct_type_id + mutable_mapping->struct_type_id * mutable_mapping->member_id); proto_item_append_text(tree, ""(Inserted 0x%016"" PRIx64 "" from 0x%016"" PRIx64 "")"", mutable_mapping->key, mutable_mapping->struct_type_id); wmem_map_insert(mutable_member_mappings, &(mutable_mapping->key), (void *) mutable_mapping); } offset = check_offset_addition(offset, member_length, tree, NULL, tvb); rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length); offset_tmp = offset; long_number = tvb_get_guint32(tvb, offset_tmp, encoding); annotation_tree = proto_tree_add_subtree_format(tree, tvb, offset_tmp, member_length, ett_rtps_type_annotation_usage_list, NULL, ""Annotation Usage Member List (%d elements)"", long_number); offset_tmp += 4; for (i = 0; i < long_number ; i++) { offset_tmp = rtps_util_add_type_annotation_usage(annotation_tree, tvb, offset_tmp, encoding, offset); } offset = check_offset_addition(offset, member_length, tree, NULL, tvb); long_number = tvb_get_guint32(tvb, offset, encoding); if ((long_number & PID_LIST_END) == PID_LIST_END) { offset += 4; } return offset; }
Description: Due to failure in validating the length provided by an attacker-crafted RTPS packet, Wireshark version 4.0.5 and prior, by default, is susceptible to a heap-based buffer overflow, and possibly code execution in the context of the process running Wireshark.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static gboolean dissect_eap_identity_wlan(tvbuff_t *tvb, packet_info* pinfo, proto_tree* tree, int offset, gint size) { guint       mnc = 0; guint       mcc = 0; guint       mcc_mnc = 0; proto_tree* eap_identity_tree = NULL; guint8      eap_identity_prefix = 0; guint8*     identity = NULL; gchar**     tokens = NULL; guint       ntokens = 0; gboolean    ret = TRUE; int         hf_eap_identity_wlan_mcc_mnc; proto_item* item; identity = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, size, ENC_ASCII); tokens = g_strsplit_set(identity, ""@."", -1); while(tokens[ntokens]) ntokens++; if (ntokens != 6 || g_ascii_strncasecmp(tokens[1], ""wlan"", 4) || g_ascii_strncasecmp(tokens[4], ""3gppnetwork"", 11) || g_ascii_strncasecmp(tokens[5], ""org"", 3)) { ret = FALSE; goto end; } eap_identity_tree = proto_item_add_subtree(tree, ett_identity); eap_identity_prefix = tokens[0][0]; item = proto_tree_add_uint(eap_identity_tree, hf_eap_identity_wlan_prefix, tvb, offset, 1, eap_identity_prefix); switch(eap_identity_prefix) { case '0': case '1': case '6': dissect_e212_utf8_imsi(tvb, pinfo, eap_identity_tree, offset + 1, (guint)strlen(tokens[0]) - 1); break; case '2': case '3': case '7': proto_tree_add_item(eap_identity_tree, hf_eap_identity_pseudo, tvb, offset + 1, (guint)strlen(tokens[0]) - 1, ENC_ASCII|ENC_NA); break; case '4': case '5': case '8': proto_tree_add_item(eap_identity_tree, hf_eap_identity_reauth, tvb, offset + 1, (guint)strlen(tokens[0]) - 1, ENC_ASCII|ENC_NA); break; default: expert_add_info(pinfo, item, &ei_eap_identity_invalid); } if (!sscanf(tokens[2] + 3, ""%u"", &mnc) || !sscanf(tokens[3] + 3, ""%u"", &mcc)) { ret = FALSE; goto end; } if (!g_ascii_strncasecmp(tokens[0], tokens[2] + 3, 3)) { mcc_mnc = 1000 * mcc + mnc; hf_eap_identity_wlan_mcc_mnc = hf_eap_identity_wlan_mcc_mnc_3digits; } else { mcc_mnc = 100 * mcc + mnc; hf_eap_identity_wlan_mcc_mnc = hf_eap_identity_wlan_mcc_mnc_2digits; } proto_tree_add_uint(eap_identity_tree, hf_eap_identity_wlan_mcc_mnc, tvb, offset + (guint)strlen(tokens[0]) + (guint)strlen(""@wlan."") + (guint)strlen(""mnc""), (guint)strlen(tokens[2]) - (guint)strlen(""mnc""), mcc_mnc); proto_tree_add_uint(eap_identity_tree, hf_eap_identity_wlan_mcc, tvb, offset + (guint)(strlen(tokens[0]) + strlen(""@wlan."") + strlen(tokens[2]) + 1 + strlen(""mcc"")), (guint)(strlen(tokens[3]) - strlen(""mcc"")), mcc); end: g_strfreev(tokens); return ret; }
Description: In Wireshark 3.2.0 to 3.2.1, 3.0.0 to 3.0.8, and 2.6.0 to 2.6.14, the EAP dissector could crash. This was addressed in epan/dissectors/packet-eap.c by using more careful sscanf parsing.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void null_asynch_write (struct rw *rw, struct command *command, nbd_completion_callback cb) { int dummy = 0; if (cb.callback (cb.user_data, &dummy) == -1) { perror (rw->name); exit (EXIT_FAILURE); } }
Description: A flaw was found in the copying tool `nbdcopy` of libnbd. When performing multi-threaded copies using asynchronous nbd calls, nbdcopy was blindly treating the completion of an asynchronous command as successful, rather than checking the *error parameter. This could result in the silent creation of a corrupted destination image.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: char *uwsgi_expand_path(char *dir, int dir_len, char *ptr) { char src[PATH_MAX + 1]; memcpy(src, dir, dir_len); src[dir_len] = 0; char *dst = ptr; if (!dst) dst = uwsgi_malloc(PATH_MAX + 1); if (!realpath(src, dst)) { uwsgi_error_realpath(src); if (!ptr) free(dst); return NULL; } return dst; }
Description: The uwsgi_expand_path function in core/utils.c in Unbit uWSGI through 2.0.15 has a stack-based buffer overflow via a large directory length.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant) { int diff,dc,k; int t; if (j->code_bits < 16) stbi__grow_buffer_unsafe(j); t = stbi__jpeg_huff_decode(j, hdc); if (t < 0) return stbi__err(""bad huffman code"",""Corrupt JPEG""); memset(data,0,64*sizeof(data[0])); diff = t ? stbi__extend_receive(j, t) : 0; dc = j->img_comp[b].dc_pred + diff; j->img_comp[b].dc_pred = dc; data[0] = (short) (dc * dequant[0]); k = 1; do { unsigned int zig; int c,r,s; if (j->code_bits < 16) stbi__grow_buffer_unsafe(j); c = (j->code_buffer >> (32 - FAST_BITS)) & ((1 << FAST_BITS)-1); r = fac[c]; if (r) {          k += (r >> 4) & 15;          s = r & 15;          j->code_buffer <<= s; j->code_bits -= s; zig = stbi__jpeg_dezigzag[k++]; data[zig] = (short) ((r >> 8) * dequant[zig]); } else { int rs = stbi__jpeg_huff_decode(j, hac); if (rs < 0) return stbi__err(""bad huffman code"",""Corrupt JPEG""); s = rs & 15; r = rs >> 4; if (s == 0) { if (rs != 0xf0) break;             k += 16; } else { k += r; zig = stbi__jpeg_dezigzag[k++]; data[zig] = (short) (stbi__extend_receive(j,s) * dequant[zig]); } } } while (k < 64); return 1; }
Description: Buffer overflow vulnerability in function stbi__extend_receive in stb_image.h in stb 2.26 via a crafted JPEG file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static const u_char * ikev2_auth_print(netdissect_options *ndo, u_char tpay, const struct isakmp_gen *ext, u_int item_len _U_, const u_char *ep, uint32_t phase _U_, uint32_t doi _U_, uint32_t proto _U_, int depth _U_) { struct ikev2_auth a; const char *v2_auth[]={ ""invalid"", ""rsasig"", ""shared-secret"", ""dsssig"" }; const u_char *authdata = (const u_char*)ext + sizeof(a); unsigned int len; ND_TCHECK(*ext); UNALIGNED_MEMCPY(&a, ext, sizeof(a)); ikev2_pay_print(ndo, NPSTR(tpay), a.h.critical); len = ntohs(a.h.len); ND_PRINT((ndo,"" len=%u method=%s"", len-4, STR_OR_ID(a.auth_method, v2_auth))); if (len > 4) { if (ndo->ndo_vflag > 1) { ND_PRINT((ndo, "" authdata=("")); if (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a))) goto trunc; ND_PRINT((ndo, "") "")); } else if (ndo->ndo_vflag) { if (!ike_show_somedata(ndo, authdata, ep)) goto trunc; } } return (const u_char *)ext + len; trunc: ND_PRINT((ndo,"" [|%s]"", NPSTR(tpay))); return NULL; }
Description: The IKEv2 parser in tcpdump before 4.9.2 has a buffer over-read in print-isakmp.c, several functions.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static bool nested_vmx_exit_handled_io(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12) { unsigned long exit_qualification; unsigned int port; int size; if (!nested_cpu_has(vmcs12, CPU_BASED_USE_IO_BITMAPS)) return nested_cpu_has(vmcs12, CPU_BASED_UNCOND_IO_EXITING); exit_qualification = vmcs_readl(EXIT_QUALIFICATION); port = exit_qualification >> 16; size = (exit_qualification & 7) + 1; return nested_vmx_check_io_bitmaps(vcpu, port, size); }
Description: A flaw was discovered in the way that the KVM hypervisor handled instruction emulation for an L2 guest when nested virtualisation is enabled. Under some circumstances, an L2 guest may trick the L0 guest into accessing sensitive L1 resources that should be inaccessible to the L2 guest.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void vrend_launch_grid(struct vrend_context *ctx, UNUSED uint32_t *block, uint32_t *grid, uint32_t indirect_handle, uint32_t indirect_offset) { bool new_program = false; struct vrend_resource *indirect_res = NULL; if (!has_feature(feat_compute_shader)) return; if (ctx->sub->cs_shader_dirty) { struct vrend_linked_shader_program *prog; bool cs_dirty; ctx->sub->cs_shader_dirty = false; if (!ctx->sub->shaders[PIPE_SHADER_COMPUTE]) { vrend_printf(""dropping rendering due to missing shaders: %s\n"", ctx->debug_name); return; } vrend_shader_select(ctx, ctx->sub->shaders[PIPE_SHADER_COMPUTE], &cs_dirty); if (!ctx->sub->shaders[PIPE_SHADER_COMPUTE]->current) { vrend_printf( ""failure to compile shader variants: %s\n"", ctx->debug_name); return; } if (ctx->sub->shaders[PIPE_SHADER_COMPUTE]->current->id != (GLuint)ctx->sub->prog_ids[PIPE_SHADER_COMPUTE]) { prog = lookup_cs_shader_program(ctx, ctx->sub->shaders[PIPE_SHADER_COMPUTE]->current->id); if (!prog) { prog = add_cs_shader_program(ctx, ctx->sub->shaders[PIPE_SHADER_COMPUTE]->current); if (!prog) return; } } else prog = ctx->sub->prog; if (ctx->sub->prog != prog) { new_program = true; ctx->sub->prog_ids[PIPE_SHADER_VERTEX] = -1; ctx->sub->prog_ids[PIPE_SHADER_COMPUTE] = ctx->sub->shaders[PIPE_SHADER_COMPUTE]->current->id; ctx->sub->prog = prog; prog->ref_context = ctx->sub; } ctx->sub->shader_dirty = true; } vrend_use_program(ctx, ctx->sub->prog->id); vrend_draw_bind_ubo_shader(ctx, PIPE_SHADER_COMPUTE, 0); vrend_draw_bind_const_shader(ctx, PIPE_SHADER_COMPUTE, new_program); vrend_draw_bind_samplers_shader(ctx, PIPE_SHADER_COMPUTE, 0); vrend_draw_bind_images_shader(ctx, PIPE_SHADER_COMPUTE); vrend_draw_bind_ssbo_shader(ctx, PIPE_SHADER_COMPUTE); vrend_draw_bind_abo_shader(ctx); if (indirect_handle) { indirect_res = vrend_renderer_ctx_res_lookup(ctx, indirect_handle); if (!indirect_res) { report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_RESOURCE, indirect_handle); return; } } if (indirect_res) glBindBuffer(GL_DISPATCH_INDIRECT_BUFFER, indirect_res->id); else glBindBuffer(GL_DISPATCH_INDIRECT_BUFFER, 0); if (indirect_res) { glDispatchComputeIndirect(indirect_offset); } else { glDispatchCompute(grid[0], grid[1], grid[2]); } }
Description: A NULL pointer dereference in vrend_renderer.c in virglrenderer through 0.8.1 allows attackers to cause a denial of service via commands that attempt to launch a grid without previously providing a Compute Shader (CS).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void ax25_kill_by_device(struct net_device *dev) { ax25_dev *ax25_dev; ax25_cb *s; struct sock *sk; if ((ax25_dev = ax25_dev_ax25dev(dev)) == NULL) return; spin_lock_bh(&ax25_list_lock); again: ax25_for_each(s, &ax25_list) { if (s->ax25_dev == ax25_dev) { sk = s->sk; sock_hold(sk); spin_unlock_bh(&ax25_list_lock); lock_sock(sk); s->ax25_dev = NULL; dev_put_track(ax25_dev->dev, &ax25_dev->dev_tracker); ax25_dev_put(ax25_dev); ax25_disconnect(s, ENETUNREACH); release_sock(sk); spin_lock_bh(&ax25_list_lock); sock_put(sk); goto again; } } spin_unlock_bh(&ax25_list_lock); }
Description: A flaw was found in the Linux kernel. This flaw allows an attacker to crash the Linux kernel by simulating amateur radio from the user space, resulting in a null-ptr-deref vulnerability and a use-after-free vulnerability.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static inline u32 ___skb_get_hash(const struct sk_buff *skb, struct flow_keys *keys, u32 keyval) { skb_flow_dissect_flow_keys(skb, keys, FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL); return __flow_hash_from_keys(keys, keyval); }
Description: The flow_dissector feature in the Linux kernel 4.3 through 5.x before 5.3.10 has a device tracking vulnerability, aka CID-55667441c84f. This occurs because the auto flowlabel of a UDP IPv6 packet relies on a 32-bit hashrnd value as a secret, and because jhash (instead of siphash) is used. The hashrnd value remains the same starting from boot time, and can be inferred by an attacker. This affects net/core/flow_dissector.c and related code.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void g_vfs_daemon_init (GVfsDaemon *daemon) { GError *error; gint max_threads = 1;  daemon->thread_pool = g_thread_pool_new (job_handler_callback, daemon, max_threads, FALSE, NULL); g_assert (daemon->thread_pool != NULL); g_mutex_init (&daemon->lock); daemon->mount_counter = 0; daemon->jobs = NULL; daemon->registered_paths = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, (GDestroyNotify)registered_path_free); daemon->client_connections = g_hash_table_new_full (g_direct_hash, g_direct_equal, g_object_unref, NULL); daemon->conn = g_bus_get_sync (G_BUS_TYPE_SESSION, NULL, NULL); g_assert (daemon->conn != NULL); daemon->daemon_skeleton = gvfs_dbus_daemon_skeleton_new (); g_signal_connect (daemon->daemon_skeleton, ""handle-get-connection"", G_CALLBACK (handle_get_connection), daemon); g_signal_connect (daemon->daemon_skeleton, ""handle-cancel"", G_CALLBACK (handle_cancel), daemon); g_signal_connect (daemon->daemon_skeleton, ""handle-list-monitor-implementations"", G_CALLBACK (handle_list_monitor_implementations), daemon); error = NULL; if (!g_dbus_interface_skeleton_export (G_DBUS_INTERFACE_SKELETON (daemon->daemon_skeleton), daemon->conn, G_VFS_DBUS_DAEMON_PATH, &error)) { g_warning (""Error exporting daemon interface: %s (%s, %d)\n"", error->message, g_quark_to_string (error->domain), error->code); g_error_free (error); } daemon->mountable_skeleton = gvfs_dbus_mountable_skeleton_new (); g_signal_connect (daemon->mountable_skeleton, ""handle-mount"", G_CALLBACK (daemon_handle_mount), daemon); error = NULL; if (!g_dbus_interface_skeleton_export (G_DBUS_INTERFACE_SKELETON (daemon->mountable_skeleton), daemon->conn, G_VFS_DBUS_MOUNTABLE_PATH, &error)) { g_warning (""Error exporting mountable interface: %s (%s, %d)\n"", error->message, g_quark_to_string (error->domain), error->code); g_error_free (error); } }
Description: daemon/gvfsdaemon.c in gvfsd from GNOME gvfs before 1.38.3, 1.40.x before 1.40.2, and 1.41.x before 1.41.3 opened a private D-Bus server socket without configuring an authorization rule. A local attacker could connect to this server socket and issue D-Bus method calls. (Note that the server socket only accepts a single connection, so the attacker would have to discover the server and connect to the socket before its owner does.)
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void PackLinuxElf64::pack1(OutputFile *fo, Filter & ) { fi->seek(0, SEEK_SET); fi->readx(&ehdri, sizeof(ehdri)); assert(e_phoff == sizeof(Elf64_Ehdr));      sz_phdrs = e_phnum * get_te16(&ehdri.e_phentsize); Elf64_Phdr *phdr = phdri; note_size = 0; for (unsigned j=0; j < e_phnum; ++phdr, ++j) { if (PT_NOTE64 == get_te32(&phdr->p_type)) { note_size += up4(get_te64(&phdr->p_filesz)); } } if (note_size) { note_body = New(unsigned char, note_size); note_size = 0; } phdr = phdri; for (unsigned j=0; j < e_phnum; ++phdr, ++j) { unsigned const type = get_te32(&phdr->p_type); if (PT_NOTE64 == type) { unsigned const len = get_te64(&phdr->p_filesz); fi->seek(get_te64(&phdr->p_offset), SEEK_SET); fi->readx(&note_body[note_size], len); note_size += up4(len); } if (PT_LOAD64 == type) { unsigned x = get_te64(&phdr->p_align) >> lg2_page; while (x>>=1) { ++lg2_page; } } if (PT_GNU_STACK64 == type) { gnu_stack = phdr; } } page_size =  1u  <<lg2_page; page_mask = ~0ull<<lg2_page; progid = 0;      sz_elf_hdrs = sizeof(ehdri) + sz_phdrs; if (0!=xct_off) {          sz_elf_hdrs = xct_off; lowmem.alloc(xct_off + (!opt->o_unix.android_shlib ? 0 : e_shnum * sizeof(Elf64_Shdr))); memcpy(lowmem, file_image, xct_off);          fo->write(lowmem, xct_off);          if (opt->o_unix.android_shlib) { xct_va  += asl_delta; Elf64_Dyn *dyn = const_cast<Elf64_Dyn *>(dynseg); for (; dyn->d_tag; ++dyn) { upx_uint64_t d_tag = get_te64(&dyn->d_tag); if (Elf64_Dyn::DT_FINI       == d_tag ||  Elf64_Dyn::DT_FINI_ARRAY == d_tag ||  Elf64_Dyn::DT_INIT_ARRAY == d_tag ||  Elf64_Dyn::DT_PREINIT_ARRAY == d_tag ||  Elf64_Dyn::DT_PLTGOT      == d_tag) { upx_uint64_t d_val = get_te64(&dyn->d_val); set_te64(&dyn->d_val, asl_delta + d_val); } } upx_uint64_t const off_dynsym = get_te64(&sec_dynsym->sh_offset); upx_uint64_t const sz_dynsym  = get_te64(&sec_dynsym->sh_size); Elf64_Sym *dyntym = (Elf64_Sym *)lowmem.subref( ""bad dynsym"", off_dynsym, sz_dynsym); Elf64_Sym *sym = dyntym; for (int j = sz_dynsym / sizeof(Elf64_Sym); --j>=0; ++sym) { upx_uint64_t symval = get_te64(&sym->st_value); unsigned symsec = get_te16(&sym->st_shndx); if (Elf64_Sym::SHN_UNDEF != symsec &&  Elf64_Sym::SHN_ABS   != symsec &&  xct_off <= symval) { set_te64(&sym->st_value, asl_delta + symval); } if (Elf64_Sym::SHN_ABS == symsec && xct_off <= symval) { adjABS(sym, asl_delta); } } unsigned char buf_notes[512]; memset(buf_notes, 0, sizeof(buf_notes)); unsigned len_notes = 0; phdr = (Elf64_Phdr *)lowmem.subref( ""bad e_phoff"", e_phoff, e_phnum * sizeof(Elf64_Phdr)); for (unsigned j = 0; j < e_phnum; ++j, ++phdr) { upx_uint64_t offset = get_te64(&phdr->p_offset); if (xct_off <= offset) {                     if (PT_NOTE64 == get_te32(&phdr->p_type)) { upx_uint64_t memsz = get_te64(&phdr->p_memsz); if (sizeof(buf_notes) < (memsz + len_notes)) { throwCantPack(""PT_NOTES too big""); } set_te64(&phdr->p_vaddr, len_notes + (e_shnum * sizeof(Elf64_Shdr)) + xct_off); phdr->p_offset = phdr->p_paddr = phdr->p_vaddr; memcpy(&buf_notes[len_notes], &file_image[offset], memsz); len_notes += memsz; } else { upx_uint64_t addr = get_te64(&phdr->p_paddr); set_te64(&phdr->p_paddr, asl_delta + addr); addr = get_te64(&phdr->p_vaddr); set_te64(&phdr->p_vaddr, asl_delta + addr); } } } Elf64_Ehdr *const ehdr = (Elf64_Ehdr *)&lowmem[0]; upx_uint64_t e_entry = get_te64(&ehdr->e_entry); if (xct_off < e_entry) { set_te64(&ehdr->e_entry, asl_delta + e_entry); } set_te64(&ehdr->e_shoff, xct_off); memcpy(&lowmem[xct_off], shdri, e_shnum * sizeof(Elf64_Shdr)); Elf64_Shdr *const shdro = (Elf64_Shdr *)&lowmem[xct_off]; Elf64_Shdr *shdr = shdro; upx_uint64_t sz_shstrtab  = get_te64(&sec_strndx->sh_size); for (unsigned j = 0; j < e_shnum; ++j, ++shdr) { unsigned sh_type = get_te32(&shdr->sh_type); upx_uint64_t sh_size = get_te64(&shdr->sh_size); upx_uint64_t sh_offset = get_te64(&shdr->sh_offset); upx_uint64_t sh_entsize = get_te64(&shdr->sh_entsize); if (xct_off <= sh_offset) { upx_uint64_t addr = get_te64(&shdr->sh_addr); set_te64(&shdr->sh_addr, asl_delta + addr); } if (Elf64_Shdr::SHT_RELA == sh_type) { if (sizeof(Elf64_Rela) != sh_entsize) { char msg[50]; snprintf(msg, sizeof(msg), ""bad Rela.sh_entsize %lu"", (long)sh_entsize); throwCantPack(msg); } n_jmp_slot = 0; plt_off = ~0ull; Elf64_Rela *const relb = (Elf64_Rela *)lowmem.subref( ""bad Rela offset"", sh_offset, sh_size); Elf64_Rela *rela = relb; for (int k = sh_size / sh_entsize; --k >= 0; ++rela) { upx_uint64_t r_addend = get_te64(&rela->r_addend); upx_uint64_t r_offset = get_te64(&rela->r_offset); upx_uint64_t r_info   = get_te64(&rela->r_info); unsigned r_type = ELF64_R_TYPE(r_info); if (xct_off <= r_offset) { set_te64(&rela->r_offset, asl_delta + r_offset); } if (Elf64_Ehdr::EM_AARCH64 == e_machine) switch (r_type) { default: { char msg[90]; snprintf(msg, sizeof(msg), ""unexpected relocation %#x [%#x]"", r_type, -1 + (unsigned)(sh_size / sh_entsize) - k); throwCantPack(msg); } break; case R_AARCH64_ABS64:                             case R_AARCH64_GLOB_DAT:                             case R_AARCH64_RELATIVE: { if (xct_off <= r_addend) { set_te64(&rela->r_addend, asl_delta + r_addend); } } break; case R_AARCH64_JUMP_SLOT: { if (plt_off > r_offset) { plt_off = r_offset; } upx_uint64_t d = elf_get_offset_from_address(r_offset); upx_uint64_t w = get_te64(&file_image[d]); if (xct_off <= w) { set_te64(&file_image[d], asl_delta + w); } ++n_jmp_slot; } break; } } fo->seek(sh_offset, SEEK_SET); fo->rewrite(relb, sh_size); } if (Elf64_Shdr::SHT_REL == sh_type) { if (sizeof(Elf64_Rel) != sh_entsize) { char msg[50]; snprintf(msg, sizeof(msg), ""bad Rel.sh_entsize %lu"", (long)sh_entsize); throwCantPack(msg); } Elf64_Rel *rel = (Elf64_Rel *)lowmem.subref( ""bad Rel sh_offset"", sh_offset, sh_size); for (int k = sh_size / sh_entsize; --k >= 0; ++rel) { upx_uint64_t r_offset = get_te64(&rel->r_offset); if (xct_off <= r_offset) { set_te64(&rel->r_offset, asl_delta + r_offset); } upx_uint64_t d = elf_get_offset_from_address(asl_delta + r_offset); upx_uint64_t w = get_te64(&file_image[d]); upx_uint64_t r_info = get_te64(&rel->r_info); unsigned r_type = ELF64_R_TYPE(r_info); if (xct_off <= w &&  Elf64_Ehdr::EM_AARCH64 == e_machine &&  (  R_AARCH64_RELATIVE  == r_type || R_AARCH64_JUMP_SLOT == r_type)) { set_te64(&file_image[d], asl_delta + w); } } } if (Elf64_Shdr::SHT_NOTE == sh_type) { if (!(Elf64_Shdr::SHF_ALLOC & get_te64(&shdr->sh_flags))) { if (sizeof(buf_notes) < (sh_size + len_notes)) { throwCantPack(""SHT_NOTEs too big""); } set_te64(&shdro[j].sh_offset, len_notes + (e_shnum * sizeof(Elf64_Shdr)) + xct_off); memcpy(&buf_notes[len_notes], &file_image[sh_offset], sh_size); len_notes += sh_size; } else {                                                                         if (xct_off <= sh_offset) { upx_uint64_t pos = xct_off + e_shnum * sizeof(Elf64_Shdr); set_te64(&shdr->sh_addr,   pos); set_te64(&shdr->sh_offset, pos); } } } } set_te64(&shdro[get_te16(&ehdri.e_shstrndx)].sh_offset, len_notes + e_shnum * sizeof(Elf64_Shdr) + xct_off); fo->seek(0, SEEK_SET); fo->rewrite(lowmem, xct_off); Elf64_Shdr blank; memset(&blank, 0, sizeof(blank)); set_te64(&blank.sh_offset, xct_off);              fo->write(&blank, sizeof(blank)); fo->write(&shdro[1], (-1+ e_shnum) * sizeof(Elf64_Shdr)); if (len_notes) { fo->write(buf_notes, len_notes); } fo->write(shstrtab,  sz_shstrtab); sz_elf_hdrs = fpad8(fo); } memset(&linfo, 0, sizeof(linfo)); fo->write(&linfo, sizeof(linfo)); } if (opt->o_unix.preserve_build_id) { e_shnum = get_te16(&ehdri.e_shnum); MemBuffer mb_shdri; if (!shdri) { mb_shdri.alloc(e_shnum * sizeof(Elf64_Shdr)); shdri = (Elf64_Shdr *)mb_shdri.getVoidPtr(); e_shoff = get_te64(&ehdri.e_shoff); fi->seek(e_shoff, SEEK_SET); fi->readx(shdri, e_shnum * sizeof(Elf64_Shdr)); } sec_strndx = &shdri[get_te16(&ehdri.e_shstrndx)]; upx_uint64_t sh_size = get_te64(&sec_strndx->sh_size); char *strtab = New(char, sh_size); fi->seek(0,SEEK_SET); fi->seek(sec_strndx->sh_offset,SEEK_SET); fi->readx(strtab, sh_size); shstrtab = (const char*)strtab; Elf64_Shdr const *buildid = elf_find_section_name("".note.gnu.build-id""); if (buildid) { unsigned bid_sh_size = get_te32(&buildid->sh_size); unsigned char *data = New(unsigned char, bid_sh_size); memset(data,0,bid_sh_size); fi->seek(0,SEEK_SET); fi->seek(buildid->sh_offset,SEEK_SET); fi->readx(data,bid_sh_size); buildid_data  = data; o_elf_shnum = 3; memset(&shdrout,0,sizeof(shdrout)); memcpy(&shdrout.shdr[1], buildid, sizeof(shdrout.shdr[1])); set_te32(&shdrout.shdr[1].sh_name, 1); memcpy(&shdrout.shdr[2], sec_strndx, sizeof(shdrout.shdr[2])); set_te32(&shdrout.shdr[2].sh_name, 20); set_te32(&shdrout.shdr[2].sh_size, 29);         } } }
Description: A heap-based buffer over-read was discovered in the get_le64 function in bele.h in UPX 4.0.0 via a crafted Mach-O file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void dissect_q931_IEs(tvbuff_t *tvb, packet_info *pinfo, proto_tree *root_tree, proto_tree *q931_tree, gboolean is_over_ip, int offset, int initial_codeset) { proto_item  *ti; proto_tree  *ie_tree = NULL; guint8      info_element; guint8      dummy; guint16     info_element_len; int         codeset, locked_codeset; gboolean    non_locking_shift, first_segment; tvbuff_t    *h225_tvb, *next_tvb; e164_info_t e164_info; e164_info.e164_number_type = NONE; e164_info.nature_of_address = NONE; e164_info.E164_number_str = """"; e164_info.E164_number_length = NONE; codeset = locked_codeset = initial_codeset; first_segment = FALSE; while (tvb_reported_length_remaining(tvb, offset) > 0) { info_element = tvb_get_guint8(tvb, offset); if ((info_element & Q931_IE_SO_MASK) && ((info_element & Q931_IE_SO_IDENTIFIER_MASK) == Q931_IE_SHIFT)) { non_locking_shift = info_element & Q931_IE_SHIFT_NON_LOCKING; codeset = info_element & Q931_IE_SHIFT_CODESET; if (!non_locking_shift) locked_codeset = codeset; if (q931_tree != NULL) { proto_tree_add_uint_format(q931_tree, hf_q931_locking_codeset, tvb, offset, 1, codeset, ""%s shift to codeset %u: %s"", (non_locking_shift ? ""Non-locking"" : ""Locking""), codeset, val_to_str(codeset, q931_codeset_vals, ""Unknown (0x%02X)"")); } offset += 1; continue; } if (info_element & Q931_IE_SO_MASK) { if (dissector_get_uint_handle(codeset_dissector_table, codeset) || dissector_get_uint_handle(ie_dissector_table, (codeset << 8) | (info_element & Q931_IE_SO_IDENTIFIER_MASK))) { next_tvb = tvb_new_subset_length (tvb, offset, 1); if (dissector_try_uint(ie_dissector_table, (codeset << 8) | (info_element & Q931_IE_SO_IDENTIFIER_MASK), next_tvb, pinfo, q931_tree) || dissector_try_uint(codeset_dissector_table, codeset, next_tvb, pinfo, q931_tree)) { offset += 1; codeset = locked_codeset; continue; } } switch ((codeset << 8) | (info_element & Q931_IE_SO_IDENTIFIER_MASK)) { case CS0 | Q931_IE_MORE_DATA_OR_SEND_COMP: switch (info_element) { case Q931_IE_MORE_DATA: proto_tree_add_item(q931_tree, hf_q931_more_data, tvb, offset, 1, ENC_NA); break; case Q931_IE_SENDING_COMPLETE: proto_tree_add_item(q931_tree, hf_q931_sending_complete, tvb, offset, 1, ENC_NA); break; default: proto_tree_add_expert_format(q931_tree, pinfo, &ei_q931_information_element, tvb, offset, 1, ""Unknown information element (0x%02X)"", info_element); break; } break; case CS0 | Q931_IE_CONGESTION_LEVEL: proto_tree_add_item(q931_tree, hf_q931_congestion_level, tvb, offset, 1, ENC_BIG_ENDIAN); break; case CS0 | Q931_IE_REPEAT_INDICATOR: proto_tree_add_item(q931_tree, hf_q931_repeat_indicator, tvb, offset, 1, ENC_BIG_ENDIAN); break; default: proto_tree_add_expert_format(q931_tree, pinfo, &ei_q931_information_element, tvb, offset, 1, ""Unknown information element (0x%02X)"", info_element); break; } offset += 1; codeset = locked_codeset; continue; } if (is_over_ip && tvb_bytes_exist(tvb, offset, 4) && codeset == 0 && tvb_get_guint8(tvb, offset) == Q931_IE_USER_USER && tvb_get_guint8(tvb, offset + 3) == Q931_PROTOCOL_DISCRIMINATOR_ASN1)  { info_element_len = tvb_get_ntohs(tvb, offset + 1); if (q931_tree != NULL) { ie_tree = proto_tree_add_subtree(q931_tree, tvb, offset, 1+2+info_element_len, ett_q931_ie[info_element], NULL, val_to_str(info_element, q931_info_element_vals[codeset], ""Unknown information element (0x%02X)"")); proto_tree_add_uint_format_value(ie_tree, hf_q931_information_element, tvb, offset, 1, info_element, ""%s"", val_to_str(info_element, q931_info_element_vals[codeset], ""Unknown (0x%02X)"")); proto_tree_add_item(ie_tree, hf_q931_information_element_len, tvb, offset + 1, 2, ENC_BIG_ENDIAN); proto_tree_add_item(ie_tree, hf_q931_user_protocol_discriminator, tvb, offset + 3, 1, ENC_NA); } if (info_element_len > 1) { if (!pinfo->can_desegment) { info_element_len = MIN(info_element_len, tvb_captured_length_remaining(tvb, offset + 3)); } if (h225_handle != NULL) { h225_tvb = tvb_new_subset_length(tvb, offset + 4, info_element_len - 1); call_dissector(h225_handle, h225_tvb, pinfo, root_tree); } else { proto_tree_add_item(ie_tree, hf_q931_user_information_bytes, tvb, offset + 4, info_element_len - 1, ENC_NA); } } offset += 1 + 2 + info_element_len; } else { info_element_len = tvb_get_guint8(tvb, offset + 1); if (first_segment && (tvb_reported_length_remaining(tvb, offset + 2) < info_element_len)) {   proto_tree_add_expert(q931_tree, pinfo, &ei_q931_incomplete_ie, tvb, offset, -1); break; } if (dissector_get_uint_handle(codeset_dissector_table, codeset) || dissector_get_uint_handle(ie_dissector_table, (codeset << 8) | info_element)) { next_tvb = tvb_new_subset_length (tvb, offset, info_element_len + 2); if (dissector_try_uint(ie_dissector_table, (codeset << 8) | info_element, next_tvb, pinfo, q931_tree) || dissector_try_uint(codeset_dissector_table, codeset, next_tvb, pinfo, q931_tree)) { offset += 2 + info_element_len; codeset = locked_codeset; continue; } } ie_tree = proto_tree_add_subtree(q931_tree, tvb, offset, 1+1+info_element_len, ett_q931_ie[info_element], &ti, val_to_str(info_element, q931_info_element_vals[codeset], ""Unknown information element (0x%02X)"")); proto_tree_add_uint_format_value(ie_tree, hf_q931_information_element, tvb, offset, 1, info_element, ""%s"", val_to_str(info_element, q931_info_element_vals[codeset], ""Unknown (0x%02X)"")); proto_tree_add_uint(ie_tree, hf_q931_information_element_len, tvb, offset + 1, 1, info_element_len); if (((codeset << 8) | info_element) == (CS0 | Q931_IE_SEGMENTED_MESSAGE)) { dissect_q931_segmented_message_ie(tvb, pinfo, offset + 2, info_element_len, ie_tree, ti); col_append_fstr(pinfo->cinfo, COL_INFO, "" of %s"", val_to_str_ext(tvb_get_guint8(tvb, offset + 3), &q931_message_type_vals_ext, ""Unknown message type (0x%02X)"")); if (tvb_get_guint8(tvb, offset + 2) & 0x80) {   first_segment = TRUE; } else {   proto_tree_add_item(q931_tree, hf_q931_message_segment, tvb, offset + 4, -1, ENC_NA); info_element_len += tvb_reported_length_remaining(tvb, offset + 4); } } else { switch ((codeset << 8) | info_element) { case CS0 | Q931_IE_BEARER_CAPABILITY: case CS0 | Q931_IE_LOW_LAYER_COMPAT: if (q931_tree != NULL) { dissect_q931_bearer_capability_ie(tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_CAUSE: dissect_q931_cause_ie_unsafe(tvb, offset + 2, info_element_len, ie_tree, hf_q931_cause_value, &dummy, q931_info_element_vals0); break; case CS0 | Q931_IE_CHANGE_STATUS: if (q931_tree != NULL) { dissect_q931_change_status_ie(tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_CALL_STATE: if (q931_tree != NULL) { dissect_q931_call_state_ie(tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_CHANNEL_IDENTIFICATION: if (q931_tree != NULL) { dissect_q931_channel_identification_ie( tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_PROGRESS_INDICATOR: if (q931_tree != NULL) { dissect_q931_progress_indicator_ie(tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_NETWORK_SPECIFIC_FACIL: case CS0 | Q931_IE_TRANSIT_NETWORK_SEL: if (q931_tree != NULL) { dissect_q931_ns_facilities_ie(tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_NOTIFICATION_INDICATOR: if (q931_tree != NULL) { dissect_q931_notification_indicator_ie( tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_DISPLAY: if (q931_tree != NULL) { dissect_q931_ia5_ie(tvb, offset + 2, info_element_len, ie_tree, hf_q931_display_information); } break; case CS0 | Q931_IE_DATE_TIME: dissect_q931_date_time_ie(tvb, pinfo, offset + 2, info_element_len, ie_tree); break; case CS0 | Q931_IE_KEYPAD_FACILITY: if (q931_tree != NULL) { dissect_q931_ia5_ie(tvb, offset + 2, info_element_len, ie_tree, hf_q931_keypad_facility); } break; case CS0 | Q931_IE_SIGNAL: dissect_q931_signal_ie(tvb, pinfo, offset + 2, info_element_len, ie_tree, ti); break; case CS0 | Q931_IE_INFORMATION_RATE: dissect_q931_information_rate_ie(tvb, pinfo, offset + 2, info_element_len, ie_tree, ti); break; case CS0 | Q931_IE_E2E_TRANSIT_DELAY: dissect_q931_e2e_transit_delay_ie(tvb, pinfo, offset + 2, info_element_len, ie_tree, ti); break; case CS0 | Q931_IE_TD_SELECTION_AND_INT: dissect_q931_td_selection_and_int_ie( tvb, pinfo, offset + 2, info_element_len, ie_tree, ti); break; case CS0 | Q931_IE_PL_BINARY_PARAMETERS: if (q931_tree != NULL) { dissect_q931_pl_binary_parameters_ie( tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_PL_WINDOW_SIZE: if (q931_tree != NULL) { dissect_q931_pl_window_size_ie(tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_PACKET_SIZE: if (q931_tree != NULL) { dissect_q931_packet_size_ie(tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_CUG: if (q931_tree != NULL) { dissect_q931_cug_ie(tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_REVERSE_CHARGE_IND: if (q931_tree != NULL) { dissect_q931_reverse_charge_ind_ie(tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_CONNECTED_NUMBER_DEFAULT: if (q931_tree != NULL) { dissect_q931_number_ie(tvb, offset + 2, info_element_len, ie_tree, hf_q931_connected_number, e164_info); } break; case CS0 | Q931_IE_CALLING_PARTY_NUMBER: e164_info.e164_number_type = CALLING_PARTY_NUMBER; dissect_q931_number_ie(tvb, offset + 2, info_element_len, ie_tree, hf_q931_calling_party_number, e164_info); break; case CS0 | Q931_IE_CALLED_PARTY_NUMBER: e164_info.e164_number_type = CALLED_PARTY_NUMBER; dissect_q931_number_ie(tvb, offset + 2, info_element_len, ie_tree, hf_q931_called_party_number, e164_info); break; case CS0 | Q931_IE_CALLING_PARTY_SUBADDR: case CS0 | Q931_IE_CALLED_PARTY_SUBADDR: if (q931_tree != NULL) { dissect_q931_party_subaddr_ie(tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_REDIRECTING_NUMBER: if (q931_tree != NULL) { dissect_q931_number_ie(tvb, offset + 2, info_element_len, ie_tree, hf_q931_redirecting_number, e164_info); } break; case CS0 | Q931_IE_RESTART_INDICATOR: dissect_q931_restart_indicator_ie(tvb, pinfo, offset + 2, info_element_len, ie_tree, ti); break; case CS0 | Q931_IE_HIGH_LAYER_COMPAT: if (q931_tree != NULL) { dissect_q931_high_layer_compat_ie(tvb, offset + 2, info_element_len, ie_tree); } break; case CS0 | Q931_IE_USER_USER: if (q931_tree != NULL) { dissect_q931_user_user_ie(tvb, pinfo, offset + 2, info_element_len, ie_tree); } break; case CS5 | Q931_IE_PARTY_CATEGORY: if (q931_tree != NULL) { dissect_q931_party_category_ie(tvb, offset + 2, info_element_len, ie_tree); } break; case CS6 | Q931_IE_DISPLAY: if (q931_tree != NULL) { dissect_q931_ia5_ie(tvb, offset + 2, info_element_len, ie_tree, hf_q931_avaya_display); } break; default: if (q931_tree != NULL) { proto_tree_add_item(ie_tree, hf_q931_data, tvb, offset + 2, info_element_len, ENC_NA); } break; } } offset += 1 + 1 + info_element_len; } codeset = locked_codeset; } if(have_valid_q931_pi) { tap_queue_packet(q931_tap, pinfo, q931_pi); } have_valid_q931_pi=FALSE; }
Description: In Wireshark 2.6.0, 2.4.0 to 2.4.6, and 2.2.0 to 2.2.14, the Q.931 dissector could crash. This was addressed in epan/dissectors/packet-q931.c by avoiding a use-after-free after a malformed packet prevented certain cleanup.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic) { ioapic->rtc_status.pending_eoi = 0; bitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPUS); }
Description: KVM in the Linux kernel before 4.8.12, when I/O APIC is enabled, does not properly restrict the VCPU index, which allows guest OS users to gain host OS privileges or cause a denial of service (out-of-bounds array access and host OS crash) via a crafted interrupt request, related to arch/x86/kvm/ioapic.c and arch/x86/kvm/ioapic.h.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static guint32 dissect_dcm_tag_value(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, dcm_state_pdv_t *pdv, guint32 offset, guint16 grp, guint16 elm, guint32 vl, guint32 vl_max, const gchar* vr, gchar **tag_value) { proto_item *pitem = NULL; gboolean is_little_endian; if (pdv->syntax == DCM_EBE) is_little_endian = FALSE; else                        is_little_endian = TRUE; if ((strncmp(vr, ""AE"", 2) == 0) || (strncmp(vr, ""AS"", 2) == 0) || (strncmp(vr, ""CS"", 2) == 0) || (strncmp(vr, ""DA"", 2) == 0) || (strncmp(vr, ""DS"", 2) == 0) || (strncmp(vr, ""DT"", 2) == 0) || (strncmp(vr, ""IS"", 2) == 0) || (strncmp(vr, ""LO"", 2) == 0) || (strncmp(vr, ""LT"", 2) == 0) || (strncmp(vr, ""PN"", 2) == 0) || (strncmp(vr, ""SH"", 2) == 0) || (strncmp(vr, ""ST"", 2) == 0) || (strncmp(vr, ""TM"", 2) == 0) || (strncmp(vr, ""UI"", 2) == 0) || (strncmp(vr, ""UT"", 2) == 0) ) { gchar   *vals; dcm_uid_t *uid = NULL; guint8 val8; val8 = tvb_get_guint8(tvb, offset + vl_max - 1); if (val8 == 0x00) { vals = tvb_format_text(tvb, offset, vl_max - 1); } else { vals = tvb_format_text(tvb, offset, vl_max); } if ((strncmp(vr, ""UI"", 2) == 0)) { uid = (dcm_uid_t *)g_hash_table_lookup(dcm_uid_table, (gpointer) vals); if (uid) { g_snprintf(*tag_value, MAX_BUF_LEN, ""%s (%s)"", vals, uid->name); } else { g_snprintf(*tag_value, MAX_BUF_LEN, ""%s"", vals); } } else { if (strlen(vals) > 50) { g_snprintf(*tag_value, MAX_BUF_LEN, ""%-50.50s..."", vals); } else { g_snprintf(*tag_value, MAX_BUF_LEN, ""%s"", vals); } } proto_tree_add_string_format(tree, hf_dcm_tag_value_str, tvb, offset, vl_max, *tag_value, ""%-8.8s%s"", ""Value:"", *tag_value); if (grp == 0x0000 && elm == 0x0902) { pdv->comment = wmem_strdup(wmem_file_scope(), g_strstrip(vals)); } } else if ((strncmp(vr, ""OB"", 2) == 0) || (strncmp(vr, ""OF"", 2) == 0) || (strncmp(vr, ""OW"", 2) == 0)) { proto_tree_add_bytes_format(tree, hf_dcm_tag_value_byte, tvb, offset, vl_max, NULL, ""%-8.8s%s"", ""Value:"", ""(binary)""); g_snprintf(*tag_value, MAX_BUF_LEN, ""(binary)""); } else if (strncmp(vr, ""UN"", 2) == 0) { guint8    val8; gchar    *vals; guint32  i; gboolean        is_string = TRUE; gboolean        is_padded = FALSE; for (i = 0; i < vl_max ; i++) { val8 = tvb_get_guint8(tvb, offset + i); if ((val8 == 0x09) || (val8 == 0x0A) || (val8 == 0x0D)) { } else if ((val8 >= 0x20) && (val8 <= 0x7E)) { } else if ((i == vl_max -1) && (val8 == 0x00)) { is_padded = TRUE; } else { is_string = FALSE; } } if (is_string) { vals = tvb_format_text(tvb, offset, (is_padded ? vl_max - 1 : vl_max)); proto_tree_add_string_format(tree, hf_dcm_tag_value_str, tvb, offset, vl_max, vals, ""%-8.8s%s"", ""Value:"", vals); g_snprintf(*tag_value, MAX_BUF_LEN, ""%s"", vals); } else { proto_tree_add_bytes_format(tree, hf_dcm_tag_value_byte, tvb, offset, vl_max, NULL, ""%-8.8s%s"", ""Value:"", ""(binary)""); g_snprintf(*tag_value, MAX_BUF_LEN, ""(binary)""); } } else if (strncmp(vr, ""AT"", 2) == 0)  {       guint16 at_grp; guint16 at_elm; guint32 at_offset = 0; const gchar *at_value = """"; while(at_offset < vl_max-3) { if (is_little_endian)   at_grp = tvb_get_letohs(tvb, offset+at_offset); else                    at_grp = tvb_get_ntohs(tvb, offset+at_offset); if (is_little_endian)   at_elm = tvb_get_letohs(tvb, offset+at_offset+2); else                    at_elm = tvb_get_ntohs(tvb, offset+at_offset+2); proto_tree_add_uint_format(tree, hf_dcm_tag_value_32u, tvb, offset+at_offset, 4, (at_grp << 16) | at_elm, ""%-8.8s%04x,%04x"", ""Value:"", at_grp, at_elm); at_value = wmem_strdup_printf(wmem_packet_scope(),""%s(%04x,%04x)"", at_value, at_grp, at_elm); at_offset += 4; } g_snprintf(*tag_value, MAX_BUF_LEN, ""%s"", at_value); } else if (strncmp(vr, ""FL"", 2) == 0)  {       gfloat valf; if (is_little_endian) valf = tvb_get_letohieee_float(tvb, offset); else                  valf = tvb_get_ntohieee_float(tvb, offset); proto_tree_add_bytes_format(tree, hf_dcm_tag_value_byte, tvb, offset, 4, NULL, ""%-8.8s%f"", ""Value:"", valf); g_snprintf(*tag_value, MAX_BUF_LEN, ""%f"", valf); } else if (strncmp(vr, ""FD"", 2) == 0)  {       gdouble vald; if (is_little_endian) vald = tvb_get_letohieee_double(tvb, offset); else                  vald = tvb_get_ntohieee_double(tvb, offset); proto_tree_add_bytes_format(tree, hf_dcm_tag_value_byte, tvb, offset, 8, NULL, ""%-8.8s%f"", ""Value:"", vald); g_snprintf(*tag_value, MAX_BUF_LEN, ""%f"", vald); } else if (strncmp(vr, ""SL"", 2) == 0)  {           gint32  val32; if (is_little_endian)   val32 = tvb_get_letohl(tvb, offset); else                    val32 = tvb_get_ntohl(tvb, offset); proto_tree_add_int_format(tree, hf_dcm_tag_value_32s, tvb, offset, 4, val32, ""%-8.8s%d"", ""Value:"", val32); g_snprintf(*tag_value, MAX_BUF_LEN, ""%d"", val32); } else if (strncmp(vr, ""SS"", 2) == 0)  {           gint16  val16; if (is_little_endian)   val16 = tvb_get_letohs(tvb, offset); else                    val16 = tvb_get_ntohs(tvb, offset); proto_tree_add_int_format(tree, hf_dcm_tag_value_16s, tvb, offset, 2, val16, ""%-8.8s%d"", ""Value:"", val16); g_snprintf(*tag_value, MAX_BUF_LEN, ""%d"", val16); } else if (strncmp(vr, ""UL"", 2) == 0)  {           guint32  val32; if (is_little_endian)   val32 = tvb_get_letohl(tvb, offset); else                    val32 = tvb_get_ntohl(tvb, offset); proto_tree_add_uint_format(tree, hf_dcm_tag_value_32u, tvb, offset, 4, val32, ""%-8.8s%u"", ""Value:"", val32); g_snprintf(*tag_value, MAX_BUF_LEN, ""%u"", val32); } else if (strncmp(vr, ""US"", 2) == 0)  {           const gchar *status_message = NULL; guint16     val16; if (is_little_endian)   val16 = tvb_get_letohs(tvb, offset); else                    val16 = tvb_get_ntohs(tvb, offset); if (grp == 0x0000 && elm == 0x0100) { g_snprintf(*tag_value, MAX_BUF_LEN, ""%s"", dcm_cmd2str(val16)); pdv->command = wmem_strdup(wmem_file_scope(), *tag_value); } else if (grp == 0x0000 && elm == 0x0900) { status_message = dcm_rsp2str(val16); g_snprintf(*tag_value, MAX_BUF_LEN, ""%s (0x%02x)"", status_message, val16); if (val16 != 0x0000 && ((val16 & 0xFF00) != 0xFF00)) { pdv->is_warning = TRUE; } pdv->status = wmem_strdup(wmem_file_scope(), status_message); } else { g_snprintf(*tag_value, MAX_BUF_LEN, ""%u"", val16); } if (grp == 0x0000) { if (elm == 0x0110) {                 pdv->message_id = val16; } else if (elm == 0x0120) {            pdv->message_id_resp = val16; } else if (elm == 0x1020) {            pdv->no_remaining = val16; } else if (elm == 0x1021) {            pdv->no_completed = val16; } else if (elm == 0x1022) {            pdv->no_failed = val16; } else if (elm == 0x1023) {            pdv->no_warning = val16; } } pitem = proto_tree_add_uint_format(tree, hf_dcm_tag_value_16u, tvb, offset, 2, val16, ""%-8.8s%s"", ""Value:"", *tag_value); if (pdv->is_warning && status_message) { expert_add_info(pinfo, pitem, &ei_dcm_status_msg); } } else { proto_tree_add_bytes_format(tree, hf_dcm_tag_value_byte, tvb, offset, vl_max, NULL, ""%-8.8s%s"", ""Value:"", (vl > vl_max ? """" : ""(unknown VR)"")); g_snprintf(*tag_value, MAX_BUF_LEN, ""(unknown VR)""); } offset += vl_max; return offset; }
Description: In Wireshark 2.6.0 to 2.6.1, 2.4.0 to 2.4.7, and 2.2.0 to 2.2.15, the DICOM dissector could go into a large or infinite loop. This was addressed in epan/dissectors/packet-dcm.c by preventing an offset overflow.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: status_t BnGraphicBufferProducer::onTransact( uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags) { switch(code) { case REQUEST_BUFFER: { CHECK_INTERFACE(IGraphicBufferProducer, data, reply); int bufferIdx   = data.readInt32(); sp<GraphicBuffer> buffer; int result = requestBuffer(bufferIdx, &buffer); reply->writeInt32(buffer != 0); if (buffer != 0) { reply->write(*buffer); } reply->writeInt32(result); return NO_ERROR; } case SET_BUFFER_COUNT: { CHECK_INTERFACE(IGraphicBufferProducer, data, reply); int bufferCount = data.readInt32(); int result = setBufferCount(bufferCount); reply->writeInt32(result); return NO_ERROR; } case DEQUEUE_BUFFER: { CHECK_INTERFACE(IGraphicBufferProducer, data, reply); bool async = static_cast<bool>(data.readInt32()); uint32_t width = data.readUint32(); uint32_t height = data.readUint32(); PixelFormat format = static_cast<PixelFormat>(data.readInt32()); uint32_t usage = data.readUint32(); int buf = 0; sp<Fence> fence; int result = dequeueBuffer(&buf, &fence, async, width, height, format, usage); reply->writeInt32(buf); reply->writeInt32(fence != NULL); if (fence != NULL) { reply->write(*fence); } reply->writeInt32(result); return NO_ERROR; } case DETACH_BUFFER: { CHECK_INTERFACE(IGraphicBufferProducer, data, reply); int slot = data.readInt32(); int result = detachBuffer(slot); reply->writeInt32(result); return NO_ERROR; } case DETACH_NEXT_BUFFER: { CHECK_INTERFACE(IGraphicBufferProducer, data, reply); sp<GraphicBuffer> buffer; sp<Fence> fence; int32_t result = detachNextBuffer(&buffer, &fence); reply->writeInt32(result); if (result == NO_ERROR) { reply->writeInt32(buffer != NULL); if (buffer != NULL) { reply->write(*buffer); } reply->writeInt32(fence != NULL); if (fence != NULL) { reply->write(*fence); } } return NO_ERROR; } case ATTACH_BUFFER: { CHECK_INTERFACE(IGraphicBufferProducer, data, reply); sp<GraphicBuffer> buffer = new GraphicBuffer(); data.read(*buffer.get()); int slot = 0; int result = attachBuffer(&slot, buffer); reply->writeInt32(slot); reply->writeInt32(result); return NO_ERROR; } case QUEUE_BUFFER: { CHECK_INTERFACE(IGraphicBufferProducer, data, reply); int buf = data.readInt32(); QueueBufferInput input(data); QueueBufferOutput* const output = reinterpret_cast<QueueBufferOutput *>( reply->writeInplace(sizeof(QueueBufferOutput))); memset(output, 0, sizeof(QueueBufferOutput)); status_t result = queueBuffer(buf, input, output); reply->writeInt32(result); return NO_ERROR; } case CANCEL_BUFFER: { CHECK_INTERFACE(IGraphicBufferProducer, data, reply); int buf = data.readInt32(); sp<Fence> fence = new Fence(); data.read(*fence.get()); cancelBuffer(buf, fence); return NO_ERROR; } case QUERY: { CHECK_INTERFACE(IGraphicBufferProducer, data, reply); int value = 0; int what = data.readInt32(); int res = query(what, &value); reply->writeInt32(value); reply->writeInt32(res); return NO_ERROR; } case CONNECT: { CHECK_INTERFACE(IGraphicBufferProducer, data, reply); sp<IProducerListener> listener; if (data.readInt32() == 1) { listener = IProducerListener::asInterface(data.readStrongBinder()); } int api = data.readInt32(); bool producerControlledByApp = data.readInt32(); QueueBufferOutput* const output = reinterpret_cast<QueueBufferOutput *>( reply->writeInplace(sizeof(QueueBufferOutput))); status_t res = connect(listener, api, producerControlledByApp, output); reply->writeInt32(res); return NO_ERROR; } case DISCONNECT: { CHECK_INTERFACE(IGraphicBufferProducer, data, reply); int api = data.readInt32(); status_t res = disconnect(api); reply->writeInt32(res); return NO_ERROR; } case SET_SIDEBAND_STREAM: { CHECK_INTERFACE(IGraphicBufferProducer, data, reply); sp<NativeHandle> stream; if (data.readInt32()) { stream = NativeHandle::create(data.readNativeHandle(), true); } status_t result = setSidebandStream(stream); reply->writeInt32(result); return NO_ERROR; } case ALLOCATE_BUFFERS: { CHECK_INTERFACE(IGraphicBufferProducer, data, reply); bool async = static_cast<bool>(data.readInt32()); uint32_t width = data.readUint32(); uint32_t height = data.readUint32(); PixelFormat format = static_cast<PixelFormat>(data.readInt32()); uint32_t usage = data.readUint32(); allocateBuffers(async, width, height, format, usage); return NO_ERROR; } case ALLOW_ALLOCATION: { CHECK_INTERFACE(IGraphicBufferProducer, data, reply); bool allow = static_cast<bool>(data.readInt32()); status_t result = allowAllocation(allow); reply->writeInt32(result); return NO_ERROR; } case SET_GENERATION_NUMBER: { CHECK_INTERFACE(IGraphicBufferProducer, data, reply); uint32_t generationNumber = data.readUint32(); status_t result = setGenerationNumber(generationNumber); reply->writeInt32(result); return NO_ERROR; } case GET_CONSUMER_NAME: { CHECK_INTERFACE(IGraphicBufferProducer, data, reply); reply->writeString8(getConsumerName()); return NO_ERROR; } } return BBinder::onTransact(code, data, reply, flags); }
Description: mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 does not initialize certain data structures, which allows attackers to obtain sensitive information via a crafted application, related to IGraphicBufferConsumer.cpp and IGraphicBufferProducer.cpp, aka internal bug 27556038.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: double asn1_get_real(const guint8 *real_ptr, gint len) { guint8 octet; const guint8 *p; guint8 *buf; double val = 0; if (len < 1) return val; octet = real_ptr[0]; p = real_ptr + 1; len -= 1; if (octet & 0x80) {   int i; gboolean Eneg; gint8 S;  guint8 B;  guint8 F;  gint32 E = 0;  guint64 N = 0;  guint8 lenE, lenN; if(octet & 0x40) S = -1; else S = 1; switch(octet & 0x30) { case 0x00: B = 2; break; case 0x10: B = 8; break; case 0x20: B = 16; break; case 0x30:  default: return 0; } F = (octet & 0x0c) >> 2; lenE = (octet & 0x3) + 1; if(lenE == 4) { DISSECTOR_ASSERT_NOT_REACHED(); } Eneg = (*p) & 0x80 ? TRUE : FALSE; for (i = 0; i < lenE; i++) { if(Eneg) { E = (E<<8) | ((guint8) ~(*p)); } else { E = (E<<8) | *p; } p++; } if(Eneg) { E = -(E + 1); } lenN = len - lenE; if(lenN > 8) { DISSECTOR_ASSERT_NOT_REACHED(); } for (i=0; i<lenN; i++) { N = (N<<8) | *p; p++; } val = (double) S * N * pow(2, F) * pow(B, E); #ifdef DEBUG ws_debug_printf(""S = %d, N = %lu, F = %u, B = %u, E = %d -> %f\n"", S, N, F, B, E, val); #endif } else if (octet & 0x40) {   switch (octet & 0x3F) { case 0x00: val = HUGE_VAL; break; case 0x01: val = -HUGE_VAL; break; } } else {   buf = g_strndup(p, len); val = g_ascii_strtod(buf, NULL); g_free(buf); } return val; }
Description: In Wireshark 3.0.0 to 3.0.2, 2.6.0 to 2.6.9, and 2.4.0 to 2.4.15, the ASN.1 BER dissector and related dissectors could crash. This was addressed in epan/asn1.c by properly restricting buffer increments.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int ismt_access(struct i2c_adapter *adap, u16 addr, unsigned short flags, char read_write, u8 command, int size, union i2c_smbus_data *data) { int ret; unsigned long time_left; dma_addr_t dma_addr = 0;  u8 dma_size = 0; enum dma_data_direction dma_direction = 0; struct ismt_desc *desc; struct ismt_priv *priv = i2c_get_adapdata(adap); struct device *dev = &priv->pci_dev->dev; u8 *dma_buffer = PTR_ALIGN(&priv->buffer[0], 16); desc = &priv->hw[priv->head]; memset(priv->buffer, 0, sizeof(priv->buffer)); memset(desc, 0, sizeof(struct ismt_desc)); desc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, read_write); memset(priv->log, 0, ISMT_LOG_ENTRIES * sizeof(u32)); if (likely(pci_dev_msi_enabled(priv->pci_dev))) desc->control = ISMT_DESC_INT | ISMT_DESC_FAIR; else desc->control = ISMT_DESC_FAIR; if ((flags & I2C_CLIENT_PEC) && (size != I2C_SMBUS_QUICK) && (size != I2C_SMBUS_I2C_BLOCK_DATA)) desc->control |= ISMT_DESC_PEC; switch (size) { case I2C_SMBUS_QUICK: dev_dbg(dev, ""I2C_SMBUS_QUICK\n""); break; case I2C_SMBUS_BYTE: if (read_write == I2C_SMBUS_WRITE) { dev_dbg(dev, ""I2C_SMBUS_BYTE:  WRITE\n""); desc->control |= ISMT_DESC_CWRL; desc->wr_len_cmd = command; } else { dev_dbg(dev, ""I2C_SMBUS_BYTE:  READ\n""); dma_size = 1; dma_direction = DMA_FROM_DEVICE; desc->rd_len = 1; } break; case I2C_SMBUS_BYTE_DATA: if (read_write == I2C_SMBUS_WRITE) { dev_dbg(dev, ""I2C_SMBUS_BYTE_DATA:  WRITE\n""); desc->wr_len_cmd = 2; dma_size = 2; dma_direction = DMA_TO_DEVICE; dma_buffer[0] = command; dma_buffer[1] = data->byte; } else { dev_dbg(dev, ""I2C_SMBUS_BYTE_DATA:  READ\n""); desc->control |= ISMT_DESC_CWRL; desc->wr_len_cmd = command; desc->rd_len = 1; dma_size = 1; dma_direction = DMA_FROM_DEVICE; } break; case I2C_SMBUS_WORD_DATA: if (read_write == I2C_SMBUS_WRITE) { dev_dbg(dev, ""I2C_SMBUS_WORD_DATA:  WRITE\n""); desc->wr_len_cmd = 3; dma_size = 3; dma_direction = DMA_TO_DEVICE; dma_buffer[0] = command; dma_buffer[1] = data->word & 0xff; dma_buffer[2] = data->word >> 8; } else { dev_dbg(dev, ""I2C_SMBUS_WORD_DATA:  READ\n""); desc->wr_len_cmd = command; desc->control |= ISMT_DESC_CWRL; desc->rd_len = 2; dma_size = 2; dma_direction = DMA_FROM_DEVICE; } break; case I2C_SMBUS_PROC_CALL: dev_dbg(dev, ""I2C_SMBUS_PROC_CALL\n""); desc->wr_len_cmd = 3; desc->rd_len = 2; dma_size = 3; dma_direction = DMA_BIDIRECTIONAL; dma_buffer[0] = command; dma_buffer[1] = data->word & 0xff; dma_buffer[2] = data->word >> 8; break; case I2C_SMBUS_BLOCK_DATA: if (read_write == I2C_SMBUS_WRITE) { dev_dbg(dev, ""I2C_SMBUS_BLOCK_DATA:  WRITE\n""); dma_size = data->block[0] + 1; dma_direction = DMA_TO_DEVICE; desc->wr_len_cmd = dma_size; desc->control |= ISMT_DESC_BLK; dma_buffer[0] = command; memcpy(&dma_buffer[1], &data->block[1], dma_size - 1); } else { dev_dbg(dev, ""I2C_SMBUS_BLOCK_DATA:  READ\n""); dma_size = I2C_SMBUS_BLOCK_MAX; dma_direction = DMA_FROM_DEVICE; desc->rd_len = dma_size; desc->wr_len_cmd = command; desc->control |= (ISMT_DESC_BLK | ISMT_DESC_CWRL); } break; case I2C_SMBUS_BLOCK_PROC_CALL: dev_dbg(dev, ""I2C_SMBUS_BLOCK_PROC_CALL\n""); dma_size = I2C_SMBUS_BLOCK_MAX; desc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 1); desc->wr_len_cmd = data->block[0] + 1; desc->rd_len = dma_size; desc->control |= ISMT_DESC_BLK; dma_direction = DMA_BIDIRECTIONAL; dma_buffer[0] = command; memcpy(&dma_buffer[1], &data->block[1], data->block[0]); break; case I2C_SMBUS_I2C_BLOCK_DATA: if (data->block[0] < 1) data->block[0] = 1; if (data->block[0] > I2C_SMBUS_BLOCK_MAX) data->block[0] = I2C_SMBUS_BLOCK_MAX; if (read_write == I2C_SMBUS_WRITE) { dev_dbg(dev, ""I2C_SMBUS_I2C_BLOCK_DATA:  WRITE\n""); dma_size = data->block[0] + 1; dma_direction = DMA_TO_DEVICE; desc->wr_len_cmd = dma_size; desc->control |= ISMT_DESC_I2C; dma_buffer[0] = command; memcpy(&dma_buffer[1], &data->block[1], dma_size - 1); } else { dev_dbg(dev, ""I2C_SMBUS_I2C_BLOCK_DATA:  READ\n""); dma_size = data->block[0]; dma_direction = DMA_FROM_DEVICE; desc->rd_len = dma_size; desc->wr_len_cmd = command; desc->control |= (ISMT_DESC_I2C | ISMT_DESC_CWRL); desc->tgtaddr_rw = ISMT_DESC_ADDR_RW(addr, 0); } break; default: dev_err(dev, ""Unsupported transaction %d\n"", size); return -EOPNOTSUPP; } if (dma_size != 0) { dev_dbg(dev, "" dev=%p\n"", dev); dev_dbg(dev, "" data=%p\n"", data); dev_dbg(dev, "" dma_buffer=%p\n"", dma_buffer); dev_dbg(dev, "" dma_size=%d\n"", dma_size); dev_dbg(dev, "" dma_direction=%d\n"", dma_direction); dma_addr = dma_map_single(dev, dma_buffer, dma_size, dma_direction); if (dma_mapping_error(dev, dma_addr)) { dev_err(dev, ""Error in mapping dma buffer %p\n"", dma_buffer); return -EIO; } dev_dbg(dev, "" dma_addr = %pad\n"", &dma_addr); desc->dptr_low = lower_32_bits(dma_addr); desc->dptr_high = upper_32_bits(dma_addr); } reinit_completion(&priv->cmp); ismt_submit_desc(priv); time_left = wait_for_completion_timeout(&priv->cmp, HZ*1); if (dma_size != 0) dma_unmap_single(dev, dma_addr, dma_size, dma_direction); if (unlikely(!time_left)) { dev_err(dev, ""completion wait timed out\n""); ret = -ETIMEDOUT; goto out; } ret = ismt_process_desc(desc, data, priv, size, read_write); out: priv->head++; priv->head %= ISMT_DESC_ENTRIES; return ret; }
Description: A buffer overflow vulnerability was found in the Linux kernel Intel’s iSMT SMBus host controller driver in the way it handled the I2C_SMBUS_BLOCK_PROC_CALL case (via the ioctl I2C_SMBUS) with malicious input data. This flaw could allow a local user to crash the system.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static ssize_t cgroup_pressure_write(struct kernfs_open_file *of, char *buf, size_t nbytes, enum psi_res res) { struct cgroup_file_ctx *ctx = of->priv; struct psi_trigger *new; struct cgroup *cgrp; struct psi_group *psi; cgrp = cgroup_kn_lock_live(of->kn, false); if (!cgrp) return -ENODEV; cgroup_get(cgrp); cgroup_kn_unlock(of->kn); psi = cgroup_ino(cgrp) == 1 ? &psi_system : &cgrp->psi; new = psi_trigger_create(psi, buf, nbytes, res); if (IS_ERR(new)) { cgroup_put(cgrp); return PTR_ERR(new); } psi_trigger_replace(&ctx->psi.trigger, new); cgroup_put(cgrp); return nbytes; }
Description: A flaw was found in the Linux kernel's implementation of Pressure Stall Information. While the feature is disabled by default, it could allow an attacker to crash the system or have other memory-corruption side effects.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: J9Method *    resolveStaticSplitMethodRef(J9VMThread *vmStruct, J9ConstantPool *ramCP, UDATA splitTableIndex, UDATA resolveFlags) { J9RAMStaticMethodRef *ramStaticMethodRef = (J9RAMStaticMethodRef *)&vmStruct->floatTemp1; U_16 cpIndex = *(J9ROMCLASS_STATICSPLITMETHODREFINDEXES(ramCP->ramClass->romClass) + splitTableIndex); J9Method *method = ramCP->ramClass->staticSplitMethodTable[splitTableIndex]; if (method == (J9Method*)vmStruct->javaVM->initialMethods.initialStaticMethod) { method = resolveStaticMethodRefInto(vmStruct, ramCP, cpIndex, resolveFlags, ramStaticMethodRef); if (NULL != method) { if (((resolveFlags & J9_RESOLVE_FLAG_CHECK_CLINIT) == J9_RESOLVE_FLAG_CHECK_CLINIT) && (J9_CLASS_FROM_METHOD(method)->initializeStatus == (UDATA)vmStruct) ) { return (J9Method *) -1; } else { ramCP->ramClass->staticSplitMethodTable[splitTableIndex] = method; } } } return method; }
Description: In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool PBFTEngine::handleViewChangeMsg(ViewChangeMsgInterface::Ptr _viewChangeMsg) { if (!isValidViewChangeMsg(_viewChangeMsg->from(), _viewChangeMsg)) { return false; } m_cacheProcessor->addViewChangeReq(_viewChangeMsg); if (_viewChangeMsg->generatedFrom() == m_config->getLeader()) { auto view = m_cacheProcessor->tryToTriggerFastViewChange(); if (view > 0) { triggerTimeout(); } } auto newViewMsg = m_cacheProcessor->checkAndTryIntoNewView(); if (newViewMsg) { reHandlePrePrepareProposals(newViewMsg); return true; } return true; }
Description: FISCO-BCOS release-3.0.0-rc2 contains a denial of service vulnerability. Some transactions may not be committed successfully, and malicious users may use this to achieve double-spending attacks.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int nc_match(GENERAL_NAME *gen, NAME_CONSTRAINTS *nc) { GENERAL_SUBTREE *sub; int i, r, match = 0; int effective_type = ((gen->type == GEN_OTHERNAME) && (OBJ_obj2nid(gen->d.otherName->type_id) == NID_id_on_SmtpUTF8Mailbox)) ? GEN_EMAIL : gen->type; for (i = 0; i < sk_GENERAL_SUBTREE_num(nc->permittedSubtrees); i++) { sub = sk_GENERAL_SUBTREE_value(nc->permittedSubtrees, i); if (effective_type != sub->base->type) continue; if (!nc_minmax_valid(sub)) return X509_V_ERR_SUBTREE_MINMAX; if (match == 2) continue; if (match == 0) match = 1; r = nc_match_single(gen, sub->base); if (r == X509_V_OK) match = 2; else if (r != X509_V_ERR_PERMITTED_VIOLATION) return r; } if (match == 1) return X509_V_ERR_PERMITTED_VIOLATION; for (i = 0; i < sk_GENERAL_SUBTREE_num(nc->excludedSubtrees); i++) { sub = sk_GENERAL_SUBTREE_value(nc->excludedSubtrees, i); if (effective_type != sub->base->type) continue; if (!nc_minmax_valid(sub)) return X509_V_ERR_SUBTREE_MINMAX; r = nc_match_single(gen, sub->base); if (r == X509_V_OK) return X509_V_ERR_EXCLUDED_VIOLATION; else if (r != X509_V_ERR_PERMITTED_VIOLATION) return r; } return X509_V_OK; }
Description: A read buffer overrun can be triggered in X.509 certificate verification,
specifically in name constraint checking. Note that this occurs
after certificate chain signature verification and requires either a
CA to have signed the malicious certificate or for the application to
continue certificate verification despite failure to construct a path
to a trusted issuer.

The read buffer overrun might result in a crash which could lead to
a denial of service attack. In theory it could also result in the disclosure
of private memory contents (such as private keys, or sensitive plaintext)
although we are not aware of any working exploit leading to memory
contents disclosure as of the time of release of this advisory.

In a TLS client, this can be triggered by connecting to a malicious
server. In a TLS server, this can be triggered if the server requests
client authentication and a malicious client connects.


 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: WireToEventCookieType XESetWireToEventCookie( Display *dpy,        int extension,       WireToEventCookieType proc  ) { WireToEventCookieType oldproc; if (proc == NULL) proc = (WireToEventCookieType)_XUnknownWireEventCookie; LockDisplay (dpy); oldproc = dpy->generic_event_vec[extension & 0x7F]; dpy->generic_event_vec[extension & 0x7F] = proc; UnlockDisplay (dpy); return (WireToEventCookieType)oldproc; }
Description: A vulnerability was found in libX11. The security flaw occurs because the functions in src/InitExt.c in libX11 do not check that the values provided for the Request, Event, or Error IDs are within the bounds of the arrays that those functions write to, using those IDs as array indexes. They trust that they were called with values provided by an Xserver adhering to the bounds specified in the X11 protocol, as all X servers provided by X.Org do. As the protocol only specifies a single byte for these values, an out-of-bounds value provided by a malicious server (or a malicious proxy-in-the-middle) can only overwrite other portions of the Display structure and not write outside the bounds of the Display structure itself, possibly causing the client to crash with this memory corruption.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void prekey_handler(const char *userid, const uint8_t *key, size_t key_len, uint16_t id, const char *clientid, bool last, void *arg) { struct session *sess; char lclientid[64]; int err; output(""prekey_handler: %zu bytes, user:%s[%u] -> %s\n"", key_len, userid, id, clientid); err = client_id_load(lclientid, sizeof(lclientid)); if (err) { debug(""my clientid not set -- cannot store prekeys\n""); return; } sess = cryptobox_session_find(g_cryptobox, userid, clientid, lclientid); if (sess) { output(""prekey: session found\n""); } else { info(""conv: adding key to cryptobox for clientid=%s\n"", clientid); err = cryptobox_session_add_send(g_cryptobox, userid, clientid, lclientid, key, key_len); if (err) { warning(""cryptobox_session_add_send failed (%m)\n"", err); } } }
Description: wire-avs is the audio visual signaling (AVS) component of Wire, an open-source messenger. A remote format string vulnerability in versions prior to 7.1.12 allows an attacker to cause a denial of service or possibly execute arbitrary code. The issue has been fixed in wire-avs 7.1.12. There are currently no known workarounds.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int cp2112_gpio_get_all(struct gpio_chip *chip) { struct cp2112_device *dev = gpiochip_get_data(chip); struct hid_device *hdev = dev->hdev; u8 *buf = dev->in_out_buffer; unsigned long flags; int ret; spin_lock_irqsave(&dev->lock, flags); ret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf, CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT, HID_REQ_GET_REPORT); if (ret != CP2112_GPIO_GET_LENGTH) { hid_err(hdev, ""error requesting GPIO values: %d\n"", ret); ret = ret < 0 ? ret : -EIO; goto exit; } ret = buf[1]; exit: spin_unlock_irqrestore(&dev->lock, flags); return ret; }
Description: drivers/hid/hid-cp2112.c in the Linux kernel 4.9.x before 4.9.9 uses a spinlock without considering that sleeping is possible in a USB HID request callback, which allows local users to cause a denial of service (deadlock) via unspecified vectors.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void FixExtensionMap(extension_map_t *map) { int i, extension_size, max_elements; if (( map->size & 0x3 ) != 0 ) { printf(""PANIC! - Verify map id %i: WARNING: map size %i not aligned!\n"", map->map_id, map->size); exit(255); } if ( ((int)map->size - (int)sizeof(extension_map_t)) <= 0 ) { printf(""PANIC! - Verify map id %i: ERROR: map size %i too small!\n"", map->map_id, map->size); exit(255); } max_elements = (map->size - sizeof(extension_map_t)) / sizeof(uint16_t); extension_size = 0; i=0; while (map->ex_id[i] && i <= max_elements) { int id = map->ex_id[i]; if ( id > Max_num_extensions ) { printf(""PANIC! - Verify map id %i: ERROR: element id %i out of range [%i]!\n"", map->map_id, id, Max_num_extensions); } extension_size += extension_descriptor[id].size; i++; } if ( (extension_size != map->extension_size ) ) { #ifdef DEVEL printf(""FixExtension map extension size from %i to %i\n"", map->extension_size, extension_size); #endif map->extension_size = extension_size; } if ( (i != max_elements ) && ((max_elements-i) != 1) ) { printf(""Verify map id %i: ERROR: Expected %i elements in map, but found %i!\n"", map->map_id, max_elements, i); } }
Description: nfdump 1.6.16 and earlier is affected by: Buffer Overflow. The impact is: The impact could range from a denial of service to local code execution. The component is: nfx.c:546, nffile_inline.c:83, minilzo.c (redistributed). The attack vector is: nfdump must read and process a specially crafted file. The fixed version is: after commit 9f0fe9563366f62a71d34c92229da3432ec5cf0e.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: const u_char * smb_fdata(netdissect_options *ndo, const u_char *buf, const char *fmt, const u_char *maxbuf, int unicodestr) { static int depth = 0; char s[128]; char *p; while (*fmt) { switch (*fmt) { case '*': fmt++; while (buf < maxbuf) { const u_char *buf2; depth++; buf2 = smb_fdata(ndo, buf, fmt, maxbuf, unicodestr); depth--; if (buf2 == NULL) return(NULL); if (buf2 == buf) return(buf); buf = buf2; } return(buf); case '|': fmt++; if (buf >= maxbuf) return(buf); break; case '%': fmt++; buf = maxbuf; break; case '#': fmt++; return(buf); break; case '[': fmt++; if (buf >= maxbuf) return(buf); memset(s, 0, sizeof(s)); p = strchr(fmt, ']'); if ((size_t)(p - fmt + 1) > sizeof(s)) { return(buf); } strncpy(s, fmt, p - fmt); s[p - fmt] = '\0'; fmt = p + 1; buf = smb_fdata1(ndo, buf, s, maxbuf, unicodestr); if (buf == NULL) return(NULL); break; default: ND_PRINT((ndo, ""%c"", *fmt)); fmt++; break; } } if (!depth && buf < maxbuf) { size_t len = PTR_DIFF(maxbuf, buf); ND_PRINT((ndo, ""Data: (%lu bytes)\n"", (unsigned long)len)); smb_print_data(ndo, buf, len); return(buf + len); } return(buf); }
Description: The SMB parser in tcpdump before 4.9.3 has stack exhaustion in smbutil.c:smb_fdata() via recursion.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static inline void pud_free_tlb(struct mmu_gather *tlb, pud_t *pud) { #ifdef __s390x__ if (!tlb->fullmm) { tlb->array[--tlb->nr_pxds] = pud; if (tlb->nr_ptes >= tlb->nr_pxds) tlb_flush_mmu(tlb, 0, 0); } else pud_free(tlb->mm, pud); #endif }
Description: The fork implementation in the Linux kernel before 4.5 on s390 platforms mishandles the case of four page-table levels, which allows local users to cause a denial of service (system crash) or possibly have unspecified other impact via a crafted application, related to arch/s390/include/asm/mmu_context.h and arch/s390/include/asm/pgalloc.h.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool BindingSecurity::shouldAllowAccessToFrame(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const Frame* target, SecurityReportingOption reportingOption) { if (!target || !target->securityContext()) return false; return canAccessFrame(isolate, accessingWindow, target->securityContext()->getSecurityOrigin(), target->domWindow(), reportingOption); }
Description: Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux does not properly validate access to the initial document, which allows remote attackers to spoof the address bar via a crafted web site.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: std::unique_ptr<Response> InternalServer::handle_content(const RequestContext& request) { const std::string url = request.get_url(); const std::string pattern = url.substr((url.find_last_of('/'))+1); if (m_verbose.load()) { printf(""** running handle_content\n""); } const std::string bookName = get_book_name(request); if (bookName.empty()) return build_homepage(request); std::shared_ptr<zim::Archive> archive; try { const std::string bookId = mp_nameMapper->getIdForName(bookName); archive = mp_library->getArchiveById(bookId); } catch (const std::out_of_range& e) {} if (archive == nullptr) { std::string searchURL = m_root+""/search?pattern=""+pattern;     const std::string details = searchSuggestionHTML(searchURL, kiwix::urlDecode(pattern)); return Response::build_404(*this, request.get_full_url(), bookName, """", details); } auto urlStr = request.get_url().substr(bookName.size()+1); if (urlStr[0] == '/') { urlStr = urlStr.substr(1); } try { auto entry = getEntryFromPath(*archive, urlStr); if (entry.isRedirect() || urlStr.empty()) { return build_redirect(bookName, getFinalItem(*archive, entry)); } auto response = ItemResponse::build(*this, request, entry.getItem()); try { dynamic_cast<ContentResponse&>(*response).set_taskbar(bookName, getArchiveTitle(*archive)); } catch (std::bad_cast& e) {} if (m_verbose.load()) { printf(""Found %s\n"", entry.getPath().c_str()); printf(""mimeType: %s\n"", entry.getItem(true).getMimetype().c_str()); } return response; } catch(zim::EntryNotFound& e) { if (m_verbose.load()) printf(""Failed to find %s\n"", urlStr.c_str()); std::string searchURL = m_root+""/search?content=""+bookName+""&pattern=""+pattern;     const std::string details = searchSuggestionHTML(searchURL, kiwix::urlDecode(pattern)); return Response::build_404(*this, request.get_full_url(), bookName, getArchiveTitle(*archive), details); } }
Description: libkiwix 10.0.0 and 10.0.1 allows XSS in the built-in webserver functionality via the search suggestions URL parameter. This is fixed in 10.1.0.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int elo_probe(struct hid_device *hdev, const struct hid_device_id *id) { struct elo_priv *priv; int ret; struct usb_device *udev; if (!hid_is_usb(hdev)) return -EINVAL; priv = kzalloc(sizeof(*priv), GFP_KERNEL); if (!priv) return -ENOMEM; INIT_DELAYED_WORK(&priv->work, elo_work); udev = interface_to_usbdev(to_usb_interface(hdev->dev.parent)); priv->usbdev = usb_get_dev(udev); hid_set_drvdata(hdev, priv); ret = hid_parse(hdev); if (ret) { hid_err(hdev, ""parse failed\n""); goto err_free; } ret = hid_hw_start(hdev, HID_CONNECT_DEFAULT); if (ret) { hid_err(hdev, ""hw start failed\n""); goto err_free; } if (elo_broken_firmware(priv->usbdev)) { hid_info(hdev, ""broken firmware found, installing workaround\n""); queue_delayed_work(wq, &priv->work, ELO_PERIODIC_READ_INTERVAL); } return 0; err_free: kfree(priv); return ret; }
Description: In drivers/hid/hid-elo.c in the Linux kernel before 5.16.11, a memory leak exists for a certain hid_parse error condition.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int correct_orientation(struct image_data *image, unsigned char **work_buff_ptr) { uint16_t mirror, rotation; unsigned char *work_buff; work_buff = *work_buff_ptr; if ((image == NULL) || (work_buff == NULL)) { TIFFError(""correct_orientatin"", ""Invalid image or buffer pointer""); return (-1); } if ((image->adjustments & MIRROR_HORIZ) || (image->adjustments & MIRROR_VERT)) { mirror = (uint16_t)(image->adjustments & MIRROR_BOTH); if (mirrorImage(image->spp, image->bps, mirror, image->width, image->length, work_buff)) { TIFFError(""correct_orientation"", ""Unable to mirror image""); return (-1); } } if (image->adjustments & ROTATE_ANY) { if (image->adjustments & ROTATECW_90) rotation = (uint16_t)90; else if (image->adjustments & ROTATECW_180) rotation = (uint16_t)180; else if (image->adjustments & ROTATECW_270) rotation = (uint16_t)270; else { TIFFError(""correct_orientation"", ""Invalid rotation value: %"" PRIu16, (uint16_t)(image->adjustments & ROTATE_ANY)); return (-1); } if (rotateImage(rotation, image, &image->width, &image->length, work_buff_ptr)) { TIFFError(""correct_orientation"", ""Unable to rotate image""); return (-1); } image->orientation = ORIENTATION_TOPLEFT; } return (0); }
Description: libtiff 4.5.0 is vulnerable to Buffer Overflow via /libtiff/tools/tiffcrop.c:8499. Incorrect updating of buffer size after rotateImage() in tiffcrop cause heap-buffer-overflow and SEGV.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int check_compat_entry_size_and_hooks(struct compat_ip6t_entry *e, struct xt_table_info *newinfo, unsigned int *size, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, const char *name) { struct xt_entry_match *ematch; struct xt_entry_target *t; struct xt_target *target; unsigned int entry_offset; unsigned int j; int ret, off, h; duprintf(""check_compat_entry_size_and_hooks %p\n"", e); if ((unsigned long)e % __alignof__(struct compat_ip6t_entry) != 0 || (unsigned char *)e + sizeof(struct compat_ip6t_entry) >= limit) { duprintf(""Bad offset %p, limit = %p\n"", e, limit); return -EINVAL; } if (e->next_offset < sizeof(struct compat_ip6t_entry) + sizeof(struct compat_xt_entry_target)) { duprintf(""checking: element %p size %u\n"", e, e->next_offset); return -EINVAL; } ret = check_entry((struct ip6t_entry *)e); if (ret) return ret; off = sizeof(struct ip6t_entry) - sizeof(struct compat_ip6t_entry); entry_offset = (void *)e - (void *)base; j = 0; xt_ematch_foreach(ematch, e) { ret = compat_find_calc_match(ematch, name, &e->ipv6, &off); if (ret != 0) goto release_matches; ++j; } t = compat_ip6t_get_target(e); target = xt_request_find_target(NFPROTO_IPV6, t->u.user.name, t->u.user.revision); if (IS_ERR(target)) { duprintf(""check_compat_entry_size_and_hooks: `%s' not found\n"", t->u.user.name); ret = PTR_ERR(target); goto release_matches; } t->u.kernel.target = target; off += xt_compat_target_offset(target); *size += off; ret = xt_compat_add_offset(AF_INET6, entry_offset, off); if (ret) goto out; for (h = 0; h < NF_INET_NUMHOOKS; h++) { if ((unsigned char *)e - base == hook_entries[h]) newinfo->hook_entry[h] = hook_entries[h]; if ((unsigned char *)e - base == underflows[h]) newinfo->underflow[h] = underflows[h]; } memset(&e->counters, 0, sizeof(e->counters)); e->comefrom = 0; return 0; out: module_put(t->u.kernel.target->me); release_matches: xt_ematch_foreach(ematch, e) { if (j-- == 0) break; module_put(ematch->u.kernel.match->me); } return ret; }
Description: The IPT_SO_SET_REPLACE setsockopt implementation in the netfilter subsystem in the Linux kernel before 4.6 allows local users to cause a denial of service (out-of-bounds read) or possibly obtain sensitive information from kernel heap memory by leveraging in-container root access to provide a crafted offset value that leads to crossing a ruleset blob boundary.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static s32 naludmx_parse_nal_avc(GF_NALUDmxCtx *ctx, char *data, u32 size, u32 nal_type, Bool *skip_nal, Bool *is_slice, Bool *is_islice) { s32 ps_idx = 0; s32 res = 0; if (!size) return -1; gf_bs_reassign_buffer(ctx->bs_r, data, size); *skip_nal = GF_FALSE; res = gf_avc_parse_nalu(ctx->bs_r, ctx->avc_state); if (res < 0) { if (res == -1) { GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (""[%s] Warning: Error parsing NAL unit\n"", ctx->log_name)); } *skip_nal = GF_TRUE; } ctx->nb_nalus++; switch (nal_type) { case GF_AVC_NALU_SVC_SUBSEQ_PARAM: case GF_AVC_NALU_SEQ_PARAM: ps_idx = ctx->avc_state->last_ps_idx; if (ps_idx<0) { if (ctx->avc_state->sps[0].profile_idc) { GF_LOG(ctx->avc_state->sps[0].profile_idc ? GF_LOG_WARNING : GF_LOG_ERROR, GF_LOG_MEDIA, (""[%s] Error parsing Sequence Param Set\n"", ctx->log_name)); } } else { naludmx_queue_param_set(ctx, data, size, GF_AVC_NALU_SEQ_PARAM, ps_idx, 0, 0); } *skip_nal = GF_TRUE; return 0; case GF_AVC_NALU_PIC_PARAM: ps_idx = ctx->avc_state->last_ps_idx; if (ps_idx<0) { GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (""[%s] Error parsing Picture Param Set\n"", ctx->log_name)); } else { naludmx_queue_param_set(ctx, data, size, GF_AVC_NALU_PIC_PARAM, ps_idx, 0, 0); } *skip_nal = GF_TRUE; return 0; case GF_AVC_NALU_SEQ_PARAM_EXT: ps_idx = ctx->avc_state->last_ps_idx; if (ps_idx<0) { GF_LOG(GF_LOG_ERROR, GF_LOG_MEDIA, (""[%s] Error parsing Sequence Param Set Extension\n"", ctx->log_name)); } else { naludmx_queue_param_set(ctx, data, size, GF_AVC_NALU_SEQ_PARAM_EXT, ps_idx, 0, 0); } *skip_nal = GF_TRUE; return 0; case GF_AVC_NALU_SEI: if (ctx->avc_state->sps_active_idx != -1) { naludmx_push_prefix(ctx, data, size, GF_TRUE); *skip_nal = GF_TRUE; if (ctx->nosei) { ctx->sei_buffer_size = 0; } else { ctx->nb_sei++; } } return 0; case GF_AVC_NALU_ACCESS_UNIT: ctx->nb_aud++; if (!ctx->audelim) { *skip_nal = GF_TRUE; } else if (!ctx->opid) { ctx->has_initial_aud = GF_TRUE; memcpy(ctx->init_aud, data, 2); } return 1; case GF_AVC_NALU_FILLER_DATA: case GF_AVC_NALU_END_OF_SEQ: case GF_AVC_NALU_END_OF_STREAM: *skip_nal = GF_TRUE; return 0; case GF_AVC_NALU_NON_IDR_SLICE: case GF_AVC_NALU_DP_A_SLICE: case GF_AVC_NALU_DP_B_SLICE: case GF_AVC_NALU_DP_C_SLICE: case GF_AVC_NALU_IDR_SLICE: *is_slice = GF_TRUE; switch (ctx->avc_state->s_info.slice_type) { case GF_AVC_TYPE_P: case GF_AVC_TYPE2_P: ctx->nb_p++; break; case GF_AVC_TYPE_I: case GF_AVC_TYPE2_I: ctx->nb_i++; *is_islice = GF_TRUE; break; case GF_AVC_TYPE_B: case GF_AVC_TYPE2_B: ctx->nb_b++; break; case GF_AVC_TYPE_SP: case GF_AVC_TYPE2_SP: ctx->nb_sp++; break; case GF_AVC_TYPE_SI: case GF_AVC_TYPE2_SI: ctx->nb_si++; break; } break; case GF_AVC_NALU_SVC_SLICE: if (!ctx->explicit) { u32 i; for (i = 0; i < gf_list_count(ctx->pps); i ++) { GF_NALUFFParam *slc = (GF_NALUFFParam*)gf_list_get(ctx->pps, i); if (ctx->avc_state->s_info.pps && ctx->avc_state->s_info.pps->id == slc->id) { gf_list_rem(ctx->pps, i); i--; if (!ctx->pps_svc) ctx->pps_svc = gf_list_new(ctx->pps_svc); gf_list_add(ctx->pps_svc, slc); ctx->ps_modified = GF_TRUE; } } } *is_slice = GF_TRUE; if (ctx->is_mvc && (res>=0)) { res=0; ctx->avc_state->s_info.poc = ctx->last_poc; } if (ctx->avc_state->s_info.sps) { switch (ctx->avc_state->s_info.slice_type) { case GF_AVC_TYPE_P: case GF_AVC_TYPE2_P: ctx->avc_state->s_info.sps->nb_ep++; break; case GF_AVC_TYPE_I: case GF_AVC_TYPE2_I: ctx->avc_state->s_info.sps->nb_ei++; break; case GF_AVC_TYPE_B: case GF_AVC_TYPE2_B: ctx->avc_state->s_info.sps->nb_eb++; break; } } break; case GF_AVC_NALU_SLICE_AUX: *is_slice = GF_TRUE; break; case GF_AVC_NALU_DV_RPU: if (ctx->dv_mode==DVMODE_CLEAN) { *skip_nal = GF_TRUE; } else { ctx->nb_dv_rpu ++; if (ctx->nb_dv_rpu==1) naludmx_set_dolby_vision(ctx); } break; case GF_AVC_NALU_DV_EL: if ((ctx->dv_mode==DVMODE_CLEAN) || (ctx->dv_mode==DVMODE_SINGLE)) { *skip_nal = GF_TRUE; } else { ctx->nb_dv_el ++; if (ctx->nb_dv_el==1) naludmx_set_dolby_vision(ctx); } break; } return res; }
Description: GPAC MP4box 2.1-DEV-rev574-g9d5bb184b is vulnerable to Buffer Overflow via gf_vvc_read_sps_bs_internal function of media_tools/av_parsers.c
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void detachThreadLocals() { resetControlMessages_.cancelTimeout(); resetDirectErrors_.cancelTimeout(); timer_ = nullptr; numControlMsgsInCurrentInterval_ = 0; numDirectErrorHandlingInCurrentInterval_ = 0; }
Description: The HTTP/2 protocol allows a denial of service (server resource consumption) because request cancellation can reset many streams quickly, as exploited in the wild in August through October 2023.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void PasswordGenerationAgent::ShowEditingPopup() { Send(new AutofillHostMsg_ShowPasswordEditingPopup( routing_id(), render_frame()->GetRenderView()->ElementBoundsInWindow( generation_element_), *generation_form_data_->form)); editing_popup_shown_ = true; }
Description: The Autofill implementation in Google Chrome before 51.0.2704.63 mishandles the interaction between field updates and JavaScript code that triggers a frame deletion, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted web site, a different vulnerability than CVE-2016-1701.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static float vips_mask_point( VipsPoint *point, int x, int y ) { VipsMask *mask = VIPS_MASK( point );  VipsMaskClass *class = VIPS_MASK_GET_CLASS( point );  int half_width = point->width / 2; int half_height = point->height / 2; double result; if( !mask->optical ) { x = (x + half_width) % point->width; y = (y + half_height) % point->height; } x = x - half_width; y = y - half_height; if( !mask->nodc &&  x == 0 && y == 0 ) result = 1.0; else { double dx, dy; dx = (double) x / half_width; dy = (double) y / half_height; result = class->point( mask, dx, dy ); if( mask->reject ) result = 1.0 - result; } return( result );  }
Description: Division-By-Zero vulnerability in Libvips 8.10.5 in the function vips_eye_point, eye.c#L83, and function vips_mask_point, mask.c#L85.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int mark_source_chains(const struct xt_table_info *newinfo, unsigned int valid_hooks, void *entry0) { unsigned int hook; for (hook = 0; hook < NF_INET_NUMHOOKS; hook++) { unsigned int pos = newinfo->hook_entry[hook]; struct ip6t_entry *e = (struct ip6t_entry *)(entry0 + pos); if (!(valid_hooks & (1 << hook))) continue; e->counters.pcnt = pos; for (;;) { const struct xt_standard_target *t = (void *)ip6t_get_target_c(e); int visited = e->comefrom & (1 << hook); if (e->comefrom & (1 << NF_INET_NUMHOOKS)) { pr_err(""iptables: loop hook %u pos %u %08X.\n"", hook, pos, e->comefrom); return 0; } e->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS)); if ((e->target_offset == sizeof(struct ip6t_entry) && (strcmp(t->target.u.user.name, XT_STANDARD_TARGET) == 0) && t->verdict < 0 && unconditional(&e->ipv6)) || visited) { unsigned int oldpos, size; if ((strcmp(t->target.u.user.name, XT_STANDARD_TARGET) == 0) && t->verdict < -NF_MAX_VERDICT - 1) { duprintf(""mark_source_chains: bad "" ""negative verdict (%i)\n"", t->verdict); return 0; } do { e->comefrom ^= (1<<NF_INET_NUMHOOKS); #ifdef DEBUG_IP_FIREWALL_USER if (e->comefrom & (1 << NF_INET_NUMHOOKS)) { duprintf(""Back unset "" ""on hook %u "" ""rule %u\n"", hook, pos); } #endif oldpos = pos; pos = e->counters.pcnt; e->counters.pcnt = 0; if (pos == oldpos) goto next; e = (struct ip6t_entry *) (entry0 + pos); } while (oldpos == pos + e->next_offset); size = e->next_offset; e = (struct ip6t_entry *) (entry0 + pos + size); e->counters.pcnt = pos; pos += size; } else { int newpos = t->verdict; if (strcmp(t->target.u.user.name, XT_STANDARD_TARGET) == 0 && newpos >= 0) { if (newpos > newinfo->size - sizeof(struct ip6t_entry)) { duprintf(""mark_source_chains: "" ""bad verdict (%i)\n"", newpos); return 0; } duprintf(""Jump rule %u -> %u\n"", pos, newpos); } else { newpos = pos + e->next_offset; } e = (struct ip6t_entry *) (entry0 + newpos); e->counters.pcnt = pos; pos = newpos; } } next: duprintf(""Finished chain %u\n"", hook); } return 1; }
Description: The netfilter subsystem in the Linux kernel through 4.5.2 does not validate certain offset fields, which allows local users to gain privileges or cause a denial of service (heap memory corruption) via an IPT_SO_SET_REPLACE setsockopt call.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int gtStripContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h) { TIFF* tif = img->tif; tileContigRoutine put = img->put.contig; uint32 row, y, nrow, nrowsub, rowstoread; tmsize_t pos; unsigned char* buf = NULL; uint32 rowsperstrip; uint16 subsamplinghor,subsamplingver; uint32 imagewidth = img->width; tmsize_t scanline; int32 fromskew, toskew; int ret = 1, flip; tmsize_t maxstripsize; TIFFGetFieldDefaulted(tif, TIFFTAG_YCBCRSUBSAMPLING, &subsamplinghor, &subsamplingver); if( subsamplingver == 0 ) { TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), ""Invalid vertical YCbCr subsampling""); return (0); } maxstripsize = TIFFStripSize(tif); flip = setorientation(img); if (flip & FLIP_VERTICALLY) { y = h - 1; toskew = -(int32)(w + w); } else { y = 0; toskew = -(int32)(w - w); } TIFFGetFieldDefaulted(tif, TIFFTAG_ROWSPERSTRIP, &rowsperstrip); scanline = TIFFScanlineSize(tif); fromskew = (w < imagewidth ? imagewidth - w : 0); for (row = 0; row < h; row += nrow) { rowstoread = rowsperstrip - (row + img->row_offset) % rowsperstrip; nrow = (row + rowstoread > h ? h - row : rowstoread); nrowsub = nrow; if ((nrowsub%subsamplingver)!=0) nrowsub+=subsamplingver-nrowsub%subsamplingver; if (_TIFFReadEncodedStripAndAllocBuffer(tif, TIFFComputeStrip(tif,row+img->row_offset, 0), (void**)(&buf), maxstripsize, ((row + img->row_offset)%rowsperstrip + nrowsub) * scanline)==(tmsize_t)(-1) && (buf == NULL || img->stoponerr)) { ret = 0; break; } pos = ((row + img->row_offset) % rowsperstrip) * scanline + \ ((tmsize_t) img->col_offset * img->samplesperpixel); (*put)(img, raster+y*w, 0, y, w, nrow, fromskew, toskew, buf + pos); y += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow); } if (flip & FLIP_HORIZONTALLY) { uint32 line; for (line = 0; line < h; line++) { uint32 *left = raster + (line * w); uint32 *right = left + w - 1; while ( left < right ) { uint32 temp = *left; *left = *right; *right = temp; left++; right--; } } } _TIFFfree(buf); return (ret); }
Description: tif_getimage.c in LibTIFF through 4.0.10, as used in GDAL through 3.0.1 and other products, has an integer overflow that potentially causes a heap-based buffer overflow via a crafted RGBA image, related to a ""Negative-size-param"" condition.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void svg_run_use(fz_context *ctx, fz_device *dev, svg_document *doc, fz_xml *root, const svg_state *inherit_state) { svg_state local_state = *inherit_state; char *xlink_href_att = fz_xml_att(root, ""xlink:href""); char *x_att = fz_xml_att(root, ""x""); char *y_att = fz_xml_att(root, ""y""); float x = 0; float y = 0; svg_parse_common(ctx, doc, root, &local_state); if (x_att) x = svg_parse_length(x_att, local_state.viewbox_w, local_state.fontsize); if (y_att) y = svg_parse_length(y_att, local_state.viewbox_h, local_state.fontsize); fz_pre_translate(&local_state.transform, x, y); if (xlink_href_att && xlink_href_att[0] == '#') { fz_xml *linked = fz_tree_lookup(ctx, doc->idmap, xlink_href_att + 1); if (linked) { if (!strcmp(fz_xml_tag(linked), ""symbol"")) svg_run_use_symbol(ctx, dev, doc, root, linked, &local_state); else svg_run_element(ctx, dev, doc, linked, &local_state); return; } } fz_warn(ctx, ""svg: cannot find linked symbol""); }
Description: Artifex MuPDF 1.11 allows attackers to cause a denial of service or possibly have unspecified other impact via a crafted .xps file, related to ""Data from Faulting Address controls Branch Selection starting at mupdf+0x000000000016cb4f"" on Windows. This occurs because of mishandling of XML tag name comparisons.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void mbim_dissect_providers(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint offset) { proto_tree *subtree; gint base_offset; guint32 i, elem_count; wmem_array_t *pair_list; struct mbim_pair_list pair_list_item, *p_pair_list_item; base_offset = offset; proto_tree_add_item_ret_uint(tree, hf_mbim_providers_elem_count, tvb, offset, 4, ENC_LITTLE_ENDIAN, &elem_count); offset += 4; if (elem_count) { pair_list = wmem_array_sized_new(wmem_packet_scope(), sizeof(struct mbim_pair_list), elem_count); subtree = proto_tree_add_subtree(tree, tvb, offset, 8*elem_count, ett_mbim_pair_list, NULL, ""Providers Ref List""); for (i = 0; i < elem_count; i++) { proto_tree_add_item_ret_uint(subtree, hf_mbim_providers_provider_offset, tvb, offset, 4, ENC_LITTLE_ENDIAN, &pair_list_item.offset); offset += 4; proto_tree_add_item_ret_uint(subtree, hf_mbim_providers_provider_size, tvb, offset, 4, ENC_LITTLE_ENDIAN, &pair_list_item.size); offset += 4; wmem_array_append_one(pair_list, pair_list_item); } for (i = 0; i < elem_count; i++) { p_pair_list_item = (struct mbim_pair_list*)wmem_array_index(pair_list, i); if (p_pair_list_item->offset && p_pair_list_item->size) { subtree = proto_tree_add_subtree_format(tree, tvb, base_offset + p_pair_list_item->offset, p_pair_list_item->size, ett_mbim_pair_list, NULL, ""Provider #%u"", i+1); mbim_dissect_provider(tvb, pinfo, subtree, base_offset + p_pair_list_item->offset); } } } }
Description: In Wireshark 2.4.0 to 2.4.1 and 2.2.0 to 2.2.9, the MBIM dissector could crash or exhaust system memory. This was addressed in epan/dissectors/packet-mbim.c by changing the memory-allocation approach.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void j2ku_gray_l(opj_image_t *in, const JPEG2KTILEINFO *tileinfo, const UINT8 *tiledata, Imaging im) { unsigned x0 = tileinfo->x0 - in->x0, y0 = tileinfo->y0 - in->y0; unsigned w = tileinfo->x1 - tileinfo->x0; unsigned h = tileinfo->y1 - tileinfo->y0; int shift = 8 - in->comps[0].prec; int offset = in->comps[0].sgnd ? 1 << (in->comps[0].prec - 1) : 0; int csiz = (in->comps[0].prec + 7) >> 3; unsigned x, y; if (csiz == 3) csiz = 4; if (shift < 0) offset += 1 << (-shift - 1); switch (csiz) { case 1: for (y = 0; y < h; ++y) { const UINT8 *data = &tiledata[y * w]; UINT8 *row = (UINT8 *)im->image[y0 + y] + x0; for (x = 0; x < w; ++x) *row++ = j2ku_shift(offset + *data++, shift); } break; case 2: for (y = 0; y < h; ++y) { const UINT16 *data = (const UINT16 *)&tiledata[2 * y * w]; UINT8 *row = (UINT8 *)im->image[y0 + y] + x0; for (x = 0; x < w; ++x) *row++ = j2ku_shift(offset + *data++, shift); } break; case 4: for (y = 0; y < h; ++y) { const UINT32 *data = (const UINT32 *)&tiledata[4 * y * w]; UINT8 *row = (UINT8 *)im->image[y0 + y] + x0; for (x = 0; x < w; ++x) *row++ = j2ku_shift(offset + *data++, shift); } break; } }
Description: In libImaging/Jpeg2KDecode.c in Pillow before 7.1.0, there are multiple out-of-bounds reads via a crafted JP2 file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int _put_page_type(struct page_info *page, bool preemptible, struct page_info *ptpg) { unsigned long nx, x, y = page->u.inuse.type_info; int rc = 0; for ( ; ; ) { x  = y; nx = x - 1; ASSERT((x & PGT_count_mask) != 0); if ( unlikely((nx & PGT_count_mask) == 0) ) { if ( unlikely((nx & PGT_type_mask) <= PGT_l4_page_table) && likely(nx & (PGT_validated|PGT_partial)) ) { nx = x & ~(PGT_validated|PGT_partial); if ( unlikely((y = cmpxchg(&page->u.inuse.type_info, x, nx)) != x) ) continue; rc = _put_final_page_type(page, x, preemptible, ptpg); ptpg = NULL; if ( x & PGT_partial ) put_page(page); break; } if ( ptpg && PGT_type_equal(x, ptpg->u.inuse.type_info) ) { ASSERT(page_get_owner(page)->is_dying); ASSERT(page->linear_pt_count < 0); ASSERT(ptpg->linear_pt_count > 0); ptpg = NULL; } set_tlbflush_timestamp(page); } if ( likely((y = cmpxchg(&page->u.inuse.type_info, x, nx)) == x) ) break; if ( preemptible && hypercall_preempt_check() ) return -EINTR; } if ( ptpg && PGT_type_equal(x, ptpg->u.inuse.type_info) ) { ASSERT(!rc); dec_linear_uses(page); dec_linear_entries(ptpg); } return rc; }
Description: An issue was discovered in Xen through 4.9.x allowing x86 PV guest OS users to cause a denial of service (memory leak) because reference counts are mishandled.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void ihex_bad_byte (bfd *abfd, unsigned int lineno, int c, bfd_boolean error) { if (c == EOF) { if (! error) bfd_set_error (bfd_error_file_truncated); } else { char buf[10]; if (! ISPRINT (c)) sprintf (buf, ""\\%03o"", (unsigned int) c); else { buf[0] = c; buf[1] = '\0'; } (*_bfd_error_handler) (_(""%B:%d: unexpected character `%s' in Intel Hex file""), abfd, lineno, buf); bfd_set_error (bfd_error_bad_value); } }
Description: ihex.c in GNU Binutils before 2.26 contains a stack buffer overflow when printing bad bytes in Intel Hex objects.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static MagickBooleanType TIFFWritePhotoshopLayers(Image* image, const ImageInfo *image_info,EndianType endian,ExceptionInfo *exception) { BlobInfo *blob; CustomStreamInfo *custom_stream; Image *base_image, *next; ImageInfo *clone_info; MagickBooleanType status; PhotoshopProfile profile; PSDInfo info; StringInfo *layers; base_image=CloneImage(image,0,0,MagickFalse,exception); if (base_image == (Image *) NULL) return(MagickTrue); clone_info=CloneImageInfo(image_info); if (clone_info == (ImageInfo *) NULL) ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"", image->filename); profile.offset=0; profile.quantum=MagickMinBlobExtent; layers=AcquireStringInfo(profile.quantum); if (layers == (StringInfo *) NULL) { clone_info=DestroyImageInfo(clone_info); ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"", image->filename); } profile.data=layers; profile.extent=layers->length; custom_stream=TIFFAcquireCustomStreamForWriting(&profile,exception); if (custom_stream == (CustomStreamInfo *) NULL) { clone_info=DestroyImageInfo(clone_info); layers=DestroyStringInfo(layers); ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"", image->filename); } blob=CloneBlobInfo((BlobInfo *) NULL); if (blob == (BlobInfo *) NULL) { clone_info=DestroyImageInfo(clone_info); layers=DestroyStringInfo(layers); custom_stream=DestroyCustomStreamInfo(custom_stream); ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"", image->filename); } DestroyBlob(base_image); base_image->blob=blob; next=base_image; while (next != (Image *) NULL) next=SyncNextImageInList(next); AttachCustomStream(base_image->blob,custom_stream); InitPSDInfo(image,&info); base_image->endian=endian; WriteBlobString(base_image,""Adobe Photoshop Document Data Block""); WriteBlobByte(base_image,0); WriteBlobString(base_image,base_image->endian == LSBEndian ? ""MIB8ryaL"" : ""8BIMLayr""); status=WritePSDLayers(base_image,clone_info,&info,exception); if (status != MagickFalse) { SetStringInfoLength(layers,(size_t) profile.offset); status=SetImageProfile(image,""tiff:37724"",layers,exception); } next=base_image; while (next != (Image *) NULL) { CloseBlob(next); next=next->next; } layers=DestroyStringInfo(layers); clone_info=DestroyImageInfo(clone_info); custom_stream=DestroyCustomStreamInfo(custom_stream); return(status); }
Description: ImageMagick 7.0.8-6 has a memory leak vulnerability in the TIFFWritePhotoshopLayers function in coders/tiff.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static ssize_t unix_stream_sendpage(struct socket *socket, struct page *page, int offset, size_t size, int flags) { int err; bool send_sigpipe = false; bool init_scm = true; struct scm_cookie scm; struct sock *other, *sk = socket->sk; struct sk_buff *skb, *newskb = NULL, *tail = NULL; if (flags & MSG_OOB) return -EOPNOTSUPP; other = unix_peer(sk); if (!other || sk->sk_state != TCP_ESTABLISHED) return -ENOTCONN; if (false) { alloc_skb: unix_state_unlock(other); mutex_unlock(&unix_sk(other)->iolock); newskb = sock_alloc_send_pskb(sk, 0, 0, flags & MSG_DONTWAIT, &err, 0); if (!newskb) goto err; } err = mutex_lock_interruptible(&unix_sk(other)->iolock); if (err) { err = flags & MSG_DONTWAIT ? -EAGAIN : -ERESTARTSYS; goto err; } if (sk->sk_shutdown & SEND_SHUTDOWN) { err = -EPIPE; send_sigpipe = true; goto err_unlock; } unix_state_lock(other); if (sock_flag(other, SOCK_DEAD) || other->sk_shutdown & RCV_SHUTDOWN) { err = -EPIPE; send_sigpipe = true; goto err_state_unlock; } if (init_scm) { err = maybe_init_creds(&scm, socket, other); if (err) goto err_state_unlock; init_scm = false; } skb = skb_peek_tail(&other->sk_receive_queue); if (tail && tail == skb) { skb = newskb; } else if (!skb || !unix_skb_scm_eq(skb, &scm)) { if (newskb) { skb = newskb; } else { tail = skb; goto alloc_skb; } } else if (newskb) { consume_skb(newskb); newskb = NULL; } if (skb_append_pagefrags(skb, page, offset, size)) { tail = skb; goto alloc_skb; } skb->len += size; skb->data_len += size; skb->truesize += size; refcount_add(size, &sk->sk_wmem_alloc); if (newskb) { err = unix_scm_to_skb(&scm, skb, false); if (err) goto err_state_unlock; spin_lock(&other->sk_receive_queue.lock); __skb_queue_tail(&other->sk_receive_queue, newskb); spin_unlock(&other->sk_receive_queue.lock); } unix_state_unlock(other); mutex_unlock(&unix_sk(other)->iolock); other->sk_data_ready(other); scm_destroy(&scm); return size; err_state_unlock: unix_state_unlock(other); err_unlock: mutex_unlock(&unix_sk(other)->iolock); err: kfree_skb(newskb); if (send_sigpipe && !(flags & MSG_NOSIGNAL)) send_sig(SIGPIPE, current, 0); if (!init_scm) scm_destroy(&scm); return err; }
Description: A use-after-free vulnerability in the Linux kernel's af_unix component can be exploited to achieve local privilege escalation.

The unix_stream_sendpage() function tries to add data to the last skb in the peer's recv queue without locking the queue. Thus there is a race where unix_stream_sendpage() could access an skb locklessly that is being released by garbage collection, resulting in use-after-free.

We recommend upgrading past commit 790c2f9d15b594350ae9bca7b236f2b1859de02c.


 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: auto Phase3() -> Local<Value> final { return Boolean::New(Isolate::GetCurrent(), did_set); }
Description: isolated-vm is a library for nodejs which gives you access to v8's Isolate interface. Versions of isolated-vm before v4.0.0 have API pitfalls which may make it easy for implementers to expose supposed secure isolates to the permissions of the main nodejs isolate. Reference objects allow access to the underlying reference's full prototype chain. In an environment where the implementer has exposed a Reference instance to an attacker they would be able to use it to acquire a Reference to the nodejs context's Function object. Similar application-specific attacks could be possible by modifying the local prototype of other API objects. Access to NativeModule objects could allow an attacker to load and run native code from anywhere on the filesystem. If combined with, for example, a file upload API this would allow for arbitrary code execution. This is addressed in v4.0.0 through a series of related changes.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void __gnttab_unmap_common_complete(struct gnttab_unmap_common *op) { struct domain *ld, *rd = op->rd; struct grant_table *rgt; struct active_grant_entry *act; grant_entry_header_t *sha; struct page_info *pg; uint16_t *status; bool_t put_handle = 0; if ( rd == NULL ) {  return; } ld = current->domain; rcu_lock_domain(rd); rgt = rd->grant_table; grant_read_lock(rgt); if ( rgt->gt_version == 0 ) goto unlock_out; act = active_entry_acquire(rgt, op->map->ref); sha = shared_entry_header(rgt, op->map->ref); if ( rgt->gt_version == 1 ) status = &sha->flags; else status = &status_entry(rgt, op->map->ref); if ( unlikely(op->frame != act->frame) )  { goto act_release_out; } pg = mfn_to_page(op->frame); if ( op->flags & GNTMAP_device_map )  { if ( !is_iomem_page(_mfn(act->frame)) ) { if ( op->flags & GNTMAP_readonly ) put_page(pg); else put_page_and_type(pg); } ASSERT(act->pin & (GNTPIN_devw_mask | GNTPIN_devr_mask)); if ( op->flags & GNTMAP_readonly ) act->pin -= GNTPIN_devr_inc; else act->pin -= GNTPIN_devw_inc; } if ( (op->host_addr != 0) && (op->flags & GNTMAP_host_map) ) { if ( op->status != 0 )  { goto act_release_out; } if ( !is_iomem_page(_mfn(op->frame)) ) { if ( gnttab_host_mapping_get_page_type(op, ld, rd) ) put_page_type(pg); put_page(pg); } ASSERT(act->pin & (GNTPIN_hstw_mask | GNTPIN_hstr_mask)); if ( op->flags & GNTMAP_readonly ) act->pin -= GNTPIN_hstr_inc; else act->pin -= GNTPIN_hstw_inc; } if ( (op->map->flags & (GNTMAP_device_map|GNTMAP_host_map)) == 0 ) put_handle = 1; if ( ((act->pin & (GNTPIN_devw_mask|GNTPIN_hstw_mask)) == 0) && !(op->flags & GNTMAP_readonly) ) gnttab_clear_flag(_GTF_writing, status); if ( act->pin == 0 ) gnttab_clear_flag(_GTF_reading, status); act_release_out: active_entry_release(act); unlock_out: grant_read_unlock(rgt); if ( put_handle ) { op->map->flags = 0; put_maptrack_handle(ld->grant_table, op->handle); } rcu_unlock_domain(rd); }
Description: The grant-table feature in Xen through 4.8.x provides false mapping information in certain cases of concurrent unmap calls, which allows backend attackers to obtain sensitive information or gain privileges, aka XSA-218 bug 1.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static char * expand_dynamic_string_token (struct link_map *l, const char *s) { size_t cnt; size_t total; char *result; cnt = DL_DST_COUNT (s, 1); if (cnt == 0) return local_strdup (s); total = DL_DST_REQUIRED (l, s, strlen (s), cnt); result = (char *) malloc (total + 1); if (result == NULL) return NULL; return DL_DST_SUBSTITUTE (l, s, result, 1); }
Description: manual/search.texi in the GNU C Library (aka glibc) before 2.2 lacks a statement about the unspecified tdelete return value upon deletion of a tree's root, which might allow attackers to access a dangling pointer in an application whose developer was unaware of a documentation update from 1999.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int svm_range_restore_pages(struct amdgpu_device *adev, unsigned int pasid, uint64_t addr, bool write_fault) { struct mm_struct *mm = NULL; struct svm_range_list *svms; struct svm_range *prange; struct kfd_process *p; ktime_t timestamp = ktime_get_boottime(); int32_t best_loc; int32_t gpuidx = MAX_GPU_INSTANCE; bool write_locked = false; struct vm_area_struct *vma; bool migration = false; int r = 0; if (!KFD_IS_SVM_API_SUPPORTED(adev->kfd.dev)) { pr_debug(""device does not support SVM\n""); return -EFAULT; } p = kfd_lookup_process_by_pasid(pasid); if (!p) { pr_debug(""kfd process not founded pasid 0x%x\n"", pasid); return 0; } svms = &p->svms; pr_debug(""restoring svms 0x%p fault address 0x%llx\n"", svms, addr); if (atomic_read(&svms->drain_pagefaults)) { pr_debug(""draining retry fault, drop fault 0x%llx\n"", addr); r = 0; goto out; } if (!p->xnack_enabled) { pr_debug(""XNACK not enabled for pasid 0x%x\n"", pasid); r = -EFAULT; goto out; } mm = get_task_mm(p->lead_thread); if (!mm) { pr_debug(""svms 0x%p failed to get mm\n"", svms); r = 0; goto out; } mmap_read_lock(mm); retry_write_locked: mutex_lock(&svms->lock); prange = svm_range_from_addr(svms, addr, NULL); if (!prange) { pr_debug(""failed to find prange svms 0x%p address [0x%llx]\n"", svms, addr); if (!write_locked) { mutex_unlock(&svms->lock); mmap_read_unlock(mm); mmap_write_lock(mm); write_locked = true; goto retry_write_locked; } prange = svm_range_create_unregistered_range(adev, p, mm, addr); if (!prange) { pr_debug(""failed to create unregistered range svms 0x%p address [0x%llx]\n"", svms, addr); mmap_write_downgrade(mm); r = -EFAULT; goto out_unlock_svms; } } if (write_locked) mmap_write_downgrade(mm); mutex_lock(&prange->migrate_mutex); if (svm_range_skip_recover(prange)) { amdgpu_gmc_filter_faults_remove(adev, addr, pasid); r = 0; goto out_unlock_range; } if (ktime_before(timestamp, ktime_add_ns(prange->validate_timestamp, AMDGPU_SVM_RANGE_RETRY_FAULT_PENDING))) { pr_debug(""svms 0x%p [0x%lx %lx] already restored\n"", svms, prange->start, prange->last); r = 0; goto out_unlock_range; } vma = find_vma(mm, addr << PAGE_SHIFT); if (!vma || (addr << PAGE_SHIFT) < vma->vm_start) { pr_debug(""address 0x%llx VMA is removed\n"", addr); r = 0; goto out_unlock_range; } if (!svm_fault_allowed(vma, write_fault)) { pr_debug(""fault addr 0x%llx no %s permission\n"", addr, write_fault ? ""write"" : ""read""); r = -EPERM; goto out_unlock_range; } best_loc = svm_range_best_restore_location(prange, adev, &gpuidx); if (best_loc == -1) { pr_debug(""svms %p failed get best restore loc [0x%lx 0x%lx]\n"", svms, prange->start, prange->last); r = -EACCES; goto out_unlock_range; } pr_debug(""svms %p [0x%lx 0x%lx] best restore 0x%x, actual loc 0x%x\n"", svms, prange->start, prange->last, best_loc, prange->actual_loc); kfd_smi_event_page_fault_start(adev->kfd.dev, p->lead_thread->pid, addr, write_fault, timestamp); if (prange->actual_loc != best_loc) { migration = true; if (best_loc) { r = svm_migrate_to_vram(prange, best_loc, mm, KFD_MIGRATE_TRIGGER_PAGEFAULT_GPU); if (r) { pr_debug(""svm_migrate_to_vram failed (%d) at %llx, falling back to system memory\n"", r, addr); if (prange->actual_loc) r = svm_migrate_vram_to_ram(prange, mm, KFD_MIGRATE_TRIGGER_PAGEFAULT_GPU); else r = 0; } } else { r = svm_migrate_vram_to_ram(prange, mm, KFD_MIGRATE_TRIGGER_PAGEFAULT_GPU); } if (r) { pr_debug(""failed %d to migrate svms %p [0x%lx 0x%lx]\n"", r, svms, prange->start, prange->last); goto out_unlock_range; } } r = svm_range_validate_and_map(mm, prange, gpuidx, false, false, false); if (r) pr_debug(""failed %d to map svms 0x%p [0x%lx 0x%lx] to gpus\n"", r, svms, prange->start, prange->last); kfd_smi_event_page_fault_end(adev->kfd.dev, p->lead_thread->pid, addr, migration); out_unlock_range: mutex_unlock(&prange->migrate_mutex); out_unlock_svms: mutex_unlock(&svms->lock); mmap_read_unlock(mm); svm_range_count_fault(adev, p, gpuidx); mmput(mm); out: kfd_unref_process(p); if (r == -EAGAIN) { pr_debug(""recover vm fault later\n""); amdgpu_gmc_filter_faults_remove(adev, addr, pasid); r = 0; } return r; }
Description: A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: GF_Err BD_DecMFFieldVec(GF_BifsDecoder * codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field, Bool is_mem_com) { GF_Err e; u32 NbBits, nbFields; u32 i; GF_ChildNodeItem *last; u8 qp_local, qp_on, initial_qp; GF_FieldInfo sffield; memset(&sffield, 0, sizeof(GF_FieldInfo)); sffield.fieldIndex = field->fieldIndex; sffield.fieldType = gf_sg_vrml_get_sf_type(field->fieldType); sffield.NDTtype = field->NDTtype; sffield.name = field->name; initial_qp = qp_local = qp_on = 0; NbBits = gf_bs_read_int(bs, 5); nbFields = gf_bs_read_int(bs, NbBits); if (codec->ActiveQP) { initial_qp = 1; gf_bifs_dec_qp14_set_length(codec, nbFields); } if (field->fieldType != GF_SG_VRML_MFNODE) { e = gf_sg_vrml_mf_alloc(field->far_ptr, field->fieldType, nbFields); if (e) return e; for (i=0; i<nbFields; i++) { e = gf_sg_vrml_mf_get_item(field->far_ptr, field->fieldType, & sffield.far_ptr, i); if (e) return e; e = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_FALSE); if (e) return e; } } else { last = NULL; for (i=0; i<nbFields; i++) { GF_Node *new_node = gf_bifs_dec_node(codec, bs, field->NDTtype); if (new_node) { e = gf_node_register(new_node, is_mem_com ? NULL : node); if (e) return e; if (node) { if (gf_node_get_tag(new_node) == TAG_MPEG4_QuantizationParameter) { qp_local = ((M_QuantizationParameter *)new_node)->isLocal; if (qp_on) gf_bifs_dec_qp_remove(codec, GF_FALSE); e = gf_bifs_dec_qp_set(codec, new_node); if (e) return e; qp_on = 1; if (qp_local) qp_local = 2; if (codec->force_keep_qp) { e = gf_node_list_add_child_last(field->far_ptr, new_node, &last); if (e) return e; } else { gf_node_register(new_node, NULL); gf_node_unregister(new_node, node); } } else { e = gf_node_list_add_child_last(field->far_ptr, new_node, &last); if (e) return e; } } else if (codec->pCurrentProto) { e = gf_node_list_add_child_last( (GF_ChildNodeItem **)field->far_ptr, new_node, &last); if (e) return e; } } else { return codec->LastError ? codec->LastError : GF_NON_COMPLIANT_BITSTREAM; } } if (qp_on && qp_local) { if (qp_local == 2) { } else { gf_bifs_dec_qp_remove(codec, initial_qp); } } } if (qp_on) gf_bifs_dec_qp_remove(codec, GF_TRUE); return GF_OK; }
Description: Use After Free in GitHub repository gpac/gpac prior to 2.1-DEV.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int vq_getchain(struct virtio_vq_info *vq, uint16_t *pidx, struct iovec *iov, int n_iov, uint16_t *flags) { int i; u_int ndesc, n_indir; u_int idx, next; volatile struct vring_desc *vdir, *vindir, *vp; struct vmctx *ctx; struct virtio_base *base; const char *name; base = vq->base; name = base->vops->name; idx = vq->last_avail; ndesc = (uint16_t)((u_int)vq->avail->idx - idx); if (ndesc == 0) return 0; if (ndesc > vq->qsize) { pr_err(""%s: ndesc (%u) out of range, driver confused?\r\n"", name, (u_int)ndesc); return -1; } ctx = base->dev->vmctx; *pidx = next = vq->avail->ring[idx & (vq->qsize - 1)]; vq->last_avail++; for (i = 0; i < VQ_MAX_DESCRIPTORS; next = vdir->next) { if (next >= vq->qsize) { pr_err(""%s: descriptor index %u out of range, "" ""driver confused?\r\n"", name, next); return -1; } vdir = &vq->desc[next]; if ((vdir->flags & VRING_DESC_F_INDIRECT) == 0) { _vq_record(i, vdir, ctx, iov, n_iov, flags); i++; } else if ((base->device_caps & (1 << VIRTIO_RING_F_INDIRECT_DESC)) == 0) { pr_err(""%s: descriptor has forbidden INDIRECT flag, "" ""driver confused?\r\n"", name); return -1; } else { n_indir = vdir->len / 16; if ((vdir->len & 0xf) || n_indir == 0) { pr_err(""%s: invalid indir len 0x%x, "" ""driver confused?\r\n"", name, (u_int)vdir->len); return -1; } vindir = paddr_guest2host(ctx, vdir->addr, vdir->len); next = 0; for (;;) { vp = &vindir[next]; if (vp->flags & VRING_DESC_F_INDIRECT) { pr_err(""%s: indirect desc has INDIR flag,"" "" driver confused?\r\n"", name); return -1; } _vq_record(i, vp, ctx, iov, n_iov, flags); if (++i > VQ_MAX_DESCRIPTORS) goto loopy; if ((vp->flags & VRING_DESC_F_NEXT) == 0) break; next = vp->next; if (next >= n_indir) { pr_err(""%s: invalid next %u > %u, "" ""driver confused?\r\n"", name, (u_int)next, n_indir); return -1; } } } if ((vdir->flags & VRING_DESC_F_NEXT) == 0) return i; } loopy: pr_err(""%s: descriptor loop? count > %d - driver confused?\r\n"", name, i); return -1; }
Description: ACRN through 2.2 has a devicemodel/hw/pci/virtio/virtio.c NULL Pointer Dereference.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void balloon_process(struct work_struct *work) { enum bp_state state = BP_DONE; long credit; do { mutex_lock(&balloon_mutex); credit = current_credit(); if (credit > 0) { if (balloon_is_inflated()) state = increase_reservation(credit); else state = reserve_additional_memory(); } if (credit < 0) state = decrease_reservation(-credit, GFP_BALLOON); state = update_schedule(state); mutex_unlock(&balloon_mutex); cond_resched(); } while (credit && state == BP_DONE); if (state == BP_EAGAIN) schedule_delayed_work(&balloon_worker, balloon_stats.schedule_delay * HZ); }
Description: An issue was discovered in drivers/xen/balloon.c in the Linux kernel before 5.2.3, as used in Xen through 4.12.x, allowing guest OS users to cause a denial of service because of unrestricted resource consumption during the mapping of guest memory, aka CID-6ef36ab967c7.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static XcursorImage * _XcursorReadImage (XcursorFile*file, XcursorFileHeader*fileHeader, inttoc) { XcursorChunkHeaderchunkHeader; XcursorImagehead; XcursorImage*image; intn; XcursorPixel*p; if (!file || !fileHeader) return NULL; if (!_XcursorFileReadChunkHeader (file, fileHeader, toc, &chunkHeader)) return NULL; if (!_XcursorReadUInt (file, &head.width)) return NULL; if (!_XcursorReadUInt (file, &head.height)) return NULL; if (!_XcursorReadUInt (file, &head.xhot)) return NULL; if (!_XcursorReadUInt (file, &head.yhot)) return NULL; if (!_XcursorReadUInt (file, &head.delay)) return NULL; if (head.width >= 0x10000 || head.height > 0x10000) return NULL; if (head.width == 0 || head.height == 0) return NULL; if (head.xhot > head.width || head.yhot > head.height) return NULL; image = XcursorImageCreate (head.width, head.height); if (image == NULL) return NULL; if (chunkHeader.version < image->version) image->version = chunkHeader.version; image->size = chunkHeader.subtype; image->xhot = head.xhot; image->yhot = head.yhot; image->delay = head.delay; n = image->width * image->height; p = image->pixels; while (n--) { if (!_XcursorReadUInt (file, p)) { XcursorImageDestroy (image); return NULL; } p++; } return image; }
Description: libXcursor before 1.1.15 has various integer overflows that could lead to heap buffer overflows when processing malicious cursors, e.g., with programs like GIMP. It is also possible that an attack vector exists against the related code in cursor/xcursor.c in Wayland through 1.14.0.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: uint32_t virtio_config_readw(VirtIODevice *vdev, uint32_t addr) { VirtioDeviceClass *k = VIRTIO_DEVICE_GET_CLASS(vdev); uint16_t val; k->get_config(vdev, vdev->config); if (addr > (vdev->config_len - sizeof(val))) return (uint32_t)-1; val = lduw_p(vdev->config + addr); return val; }
Description: A flaw was found in the way qemu v1.3.0 and later (virtio-rng) validates addresses when guest accesses the config space of a virtio device. If the virtio device has zero/small sized config space, such as virtio-rng, a privileged guest user could use this flaw to access the matching host's qemu address space and thus increase their privileges on the host.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static VALUE rb_xml_reader_attribute_hash(VALUE rb_reader) { VALUE rb_attributes = rb_hash_new(); xmlTextReaderPtr c_reader; xmlNodePtr c_node; xmlAttrPtr c_property; Data_Get_Struct(rb_reader, xmlTextReader, c_reader); if (!has_attributes(c_reader)) { return rb_attributes; } c_node = xmlTextReaderExpand(c_reader); c_property = c_node->properties; while (c_property != NULL) { VALUE rb_name = NOKOGIRI_STR_NEW2(c_property->name); VALUE rb_value = Qnil; xmlChar *c_value = xmlNodeGetContent((xmlNode *)c_property); if (c_value) { rb_value = NOKOGIRI_STR_NEW2(c_value); xmlFree(c_value); } rb_hash_aset(rb_attributes, rb_name, rb_value); c_property = c_property->next; } return rb_attributes; }
Description: Nokogiri is an open source XML and HTML library for the Ruby programming language. Nokogiri `1.13.8` and `1.13.9` fail to check the return value from `xmlTextReaderExpand` in the method `Nokogiri::XML::Reader#attribute_hash`. This can lead to a null pointer exception when invalid markup is being parsed. For applications using `XML::Reader` to parse untrusted inputs, this may potentially be a vector for a denial of service attack. Users are advised to upgrade to Nokogiri `>= 1.13.10`. Users may be able to search their code for calls to either `XML::Reader#attributes` or `XML::Reader#attribute_hash` to determine if they are affected.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int install_thread_keyring(void) { struct cred *new; int ret; new = prepare_creds(); if (!new) return -ENOMEM; BUG_ON(new->thread_keyring); ret = install_thread_keyring_to_cred(new); if (ret < 0) { abort_creds(new); return ret; } return commit_creds(new); }
Description: The KEYS subsystem in the Linux kernel before 4.10.13 allows local users to cause a denial of service (memory consumption) via a series of KEY_REQKEY_DEFL_THREAD_KEYRING keyctl_set_reqkey_keyring calls.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void grant_table_init_vcpu(struct vcpu *v) { v->maptrack_head = MAPTRACK_TAIL; v->maptrack_tail = MAPTRACK_TAIL; }
Description: Race condition in the grant table code in Xen 4.6.x through 4.9.x allows local guest OS administrators to cause a denial of service (free list corruption and host crash) or gain privileges on the host via vectors involving maptrack free list handling.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void destroy_surface(struct swaylock_surface *surface) { wl_list_remove(&surface->link); if (surface->layer_surface != NULL) { zwlr_layer_surface_v1_destroy(surface->layer_surface); } if (surface->surface != NULL) { wl_surface_destroy(surface->surface); } destroy_buffer(&surface->buffers[0]); destroy_buffer(&surface->buffers[1]); destroy_buffer(&surface->indicator_buffers[0]); destroy_buffer(&surface->indicator_buffers[1]); wl_output_destroy(surface->output); free(surface); }
Description: swaylock before 1.6 allows attackers to trigger a crash and achieve unlocked access to a Wayland compositor.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static struct sk_buff *napi_frags_skb(struct napi_struct *napi) { struct sk_buff *skb = napi->skb; const struct ethhdr *eth; unsigned int hlen = sizeof(*eth); napi->skb = NULL; skb_reset_mac_header(skb); skb_gro_reset_offset(skb); eth = skb_gro_header_fast(skb, 0); if (unlikely(skb_gro_header_hard(skb, hlen))) { eth = skb_gro_header_slow(skb, hlen, 0); if (unlikely(!eth)) { net_warn_ratelimited(""%s: dropping impossible skb from %s\n"", __func__, napi->dev->name); napi_reuse_skb(napi, skb); return NULL; } } else { gro_pull_from_frag0(skb, hlen); NAPI_GRO_CB(skb)->frag0 += hlen; NAPI_GRO_CB(skb)->frag0_len -= hlen; } __skb_pull(skb, hlen); skb->protocol = eth->h_proto; return skb; }
Description: A flaw was found in the Linux kernel's implementation of GRO in versions before 5.2. This flaw allows an attacker with local access to crash the system.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: uint32_t njs_string_trim(const njs_value_t *value, njs_string_prop_t *string, unsigned mode) { uint32_t              cp, trim; const u_char          *p, *prev, *start, *end; njs_unicode_decode_t  ctx; trim = 0; njs_string_prop(string, value); start = string->start; end = string->start + string->size; if (njs_is_byte_or_ascii_string(string)) { if (mode & NJS_TRIM_START) { for ( ;; ) { if (start == end) { break; } if (njs_is_whitespace(*start)) { start++; trim++; continue; } break; } } if (mode & NJS_TRIM_END) { for ( ;; ) { if (start == end) { break; } end--; if (njs_is_whitespace(*end)) { trim++; continue; } end++; break; } } } else { if (mode & NJS_TRIM_START) { njs_utf8_decode_init(&ctx); for ( ;; ) { if (start == end) { break; } p = start; cp = njs_utf8_decode(&ctx, &start, end); if (njs_utf8_is_whitespace(cp)) { trim++; continue; } start = p; break; } } if (mode & NJS_TRIM_END) { prev = end; njs_utf8_decode_init(&ctx); for ( ;; ) { if (start == prev) { break; } prev = njs_utf8_prev(prev); p = prev; cp = njs_utf8_decode(&ctx, &p, end); if (njs_utf8_is_whitespace(cp)) { trim++; continue; } end = p; break; } } } if (start == end) { string->length = 0; string->size = 0; return trim; } string->start = (u_char *) start; string->size = end - start; if (string->length != 0) { string->length -= trim; } return trim; }
Description: Nginx NJS v0.7.7 was discovered to contain a segmentation violation via njs_utf8_next at src/njs_utf8.h
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool ASessionDescription::getDimensions( size_t index, unsigned long PT, int32_t *width, int32_t *height) const { *width = 0; *height = 0; char key[20]; sprintf(key, ""a=framesize:%lu"", PT); AString value; if (!findAttribute(index, key, &value)) { return false; } const char *s = value.c_str(); char *end; *width = strtoul(s, &end, 10); CHECK_GT(end, s); CHECK_EQ(*end, '-'); s = end + 1; *height = strtoul(s, &end, 10); CHECK_GT(end, s); CHECK_EQ(*end, '\0'); return true; }
Description: Multiple buffer overflows in rtsp/ASessionDescription.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 allow remote attackers to cause a denial of service (device hang or reboot) via a crafted media file, aka internal bug 25747670.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int opmov(RAsm *a, ut8 *data, const Opcode *op) { int l = 0; st64 offset = 0; int mod = 0; int base = 0; int rex = 0; ut64 immediate = 0; if (op->operands[1].type & OT_CONSTANT) { if (!op->operands[1].is_good_flag) { return -1; } if (op->operands[1].immediate == -1) { return -1; } immediate = op->operands[1].immediate * op->operands[1].sign; if (op->operands[0].type & OT_GPREG && !(op->operands[0].type & OT_MEMORY)) { if (a->bits == 64 && ((op->operands[0].type & OT_QWORD) | (op->operands[1].type & OT_QWORD))) { if (!(op->operands[1].type & OT_CONSTANT) && op->operands[1].extended) { data[l++] = 0x49; } else { data[l++] = 0x48; } } else if (op->operands[0].extended) { data[l++] = 0x41; } if (op->operands[0].type & OT_WORD) { if (a->bits > 16) { data[l++] = 0x66; } } if (op->operands[0].type & OT_BYTE) { data[l++] = 0xb0 | op->operands[0].reg; data[l++] = immediate; } else { if (a->bits == 64 && ((op->operands[0].type & OT_QWORD) | (op->operands[1].type & OT_QWORD)) && immediate < UT32_MAX) { data[l++] = 0xc7; data[l++] = 0xc0 | op->operands[0].reg; } else { data[l++] = 0xb8 | op->operands[0].reg; } data[l++] = immediate; data[l++] = immediate >> 8; if (!(op->operands[0].type & OT_WORD)) { data[l++] = immediate >> 16; data[l++] = immediate >> 24; } if (a->bits == 64 && immediate > UT32_MAX) { data[l++] = immediate >> 32; data[l++] = immediate >> 40; data[l++] = immediate >> 48; data[l++] = immediate >> 56; } } } else if (op->operands[0].type & OT_MEMORY) { if (!op->operands[0].explicit_size) { if (op->operands[0].type & OT_GPREG) { ((Opcode *)op)->operands[0].dest_size = op->operands[0].reg_size; } else { return -1; } } int dest_bits = 8 * ((op->operands[0].dest_size & ALL_SIZE) >> OPSIZE_SHIFT); int reg_bits = 8 * ((op->operands[0].reg_size & ALL_SIZE) >> OPSIZE_SHIFT); int offset = op->operands[0].offset * op->operands[0].offset_sign; bool use_aso = false; if (reg_bits < a->bits) { use_aso = true; } bool use_oso = false; if (dest_bits == 16) { use_oso = true; } bool rip_rel = op->operands[0].regs[0] == X86R_RIP; int rex = 1 << 6; bool use_rex = false; if (dest_bits == 64) {use_rex = true; rex |= 1 << 3; } if (op->operands[0].extended) {use_rex = true; rex |= 1; } int opcode; if (dest_bits == 8) { opcode = 0xc6; } else { opcode = 0xc7; } int modrm = 0; int mod; int reg = 0; int rm; bool use_sib = false; int sib; if (offset == 0) { mod = 0; } else if (offset < 128 && offset > -129) { mod = 1; } else { mod = 2; } if (reg_bits == 16) { if (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == X86R_SI) { rm = B0000; } else if (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == X86R_DI) { rm = B0001; } else if (op->operands[0].regs[0] == X86R_BP && op->operands[0].regs[1] == X86R_SI) { rm = B0010; } else if (op->operands[0].regs[0] == X86R_BP && op->operands[0].regs[1] == X86R_DI) { rm = B0011; } else if (op->operands[0].regs[0] == X86R_SI && op->operands[0].regs[1] == -1) { rm = B0100; } else if (op->operands[0].regs[0] == X86R_DI && op->operands[0].regs[1] == -1) { rm = B0101; } else if (op->operands[0].regs[0] == X86R_BX && op->operands[0].regs[1] == -1) { rm = B0111; } else { return -1; } modrm = (mod << 6) | (reg << 3) | rm; } else { if (op->operands[0].extended) { rm = op->operands[0].reg; } else { rm = op->operands[0].regs[0]; } if (rm == 5 && mod == 0) { mod = 1; } int index = op->operands[0].regs[1]; int scale = getsib(op->operands[0].scale[1]); if (index != -1) { use_sib = true; sib = (scale << 6) | (index << 3) | rm; } else if (rm == 4) { use_sib = true; sib = 0x24; } if (use_sib) { rm = B0100; } if (rip_rel) { modrm = (B0000 << 6) | (reg << 3) | B0101; sib = (scale << 6) | (B0100 << 3) | B0101; } else { modrm = (mod << 6) | (reg << 3) | rm; } } if (use_aso) { data[l++] = 0x67; } if (use_oso) { data[l++] = 0x66; } if (use_rex) { data[l++] = rex; } data[l++] = opcode; data[l++] = modrm; if (use_sib) { data[l++] = sib; } if (mod == 1) { data[l++] = offset; } else if (reg_bits == 16 && mod == 2) { data[l++] = offset; data[l++] = offset >> 8; } else if (mod == 2 || rip_rel) { data[l++] = offset; data[l++] = offset >> 8; data[l++] = offset >> 16; data[l++] = offset >> 24; } int byte; for (byte = 0; byte < dest_bits && byte < 32; byte += 8) { data[l++] = (immediate >> byte); } } } else if (op->operands[1].type & OT_REGALL && !(op->operands[1].type & OT_MEMORY)) { if (op->operands[0].type & OT_CONSTANT) { return -1; } if (op->operands[0].type & OT_REGTYPE & OT_SEGMENTREG && op->operands[1].type & OT_REGTYPE & OT_SEGMENTREG) { return -1; } if (op->operands[0].type & OT_REGTYPE && op->operands[1].type & OT_REGTYPE) { if (!((op->operands[0].type & ALL_SIZE) & (op->operands[1].type & ALL_SIZE))) { return -1; } } if (a->bits == 64) { if (op->operands[0].extended) { rex = 1; } if (op->operands[1].extended) { rex += 4; } if (op->operands[1].type & OT_QWORD) { if (!(op->operands[0].type & OT_QWORD)) { data[l++] = 0x67; data[l++] = 0x48; } } if (op->operands[1].type & OT_QWORD && op->operands[0].type & OT_QWORD) { data[l++] = 0x48 | rex; } if (op->operands[1].type & OT_DWORD && op->operands[0].type & OT_DWORD) { data[l++] = 0x40 | rex; } } else if (op->operands[0].extended && op->operands[1].extended) { data[l++] = 0x45; } offset = op->operands[0].offset * op->operands[0].offset_sign; if (op->operands[1].type & OT_REGTYPE & OT_SEGMENTREG) { data[l++] = 0x8c; } else { if (op->operands[0].type & OT_WORD) { data[l++] = 0x66; } data[l++] = (op->operands[0].type & OT_BYTE) ? 0x88 : 0x89; } if (op->operands[0].scale[0] > 1) { data[l++] = op->operands[1].reg << 3 | 4; data[l++] = getsib (op->operands[0].scale[0]) << 6 | op->operands[0].regs[0] << 3 | 5; data[l++] = offset; data[l++] = offset >> 8; data[l++] = offset >> 16; data[l++] = offset >> 24; return l; } if (!(op->operands[0].type & OT_MEMORY)) { if (op->operands[0].reg == X86R_UNDEFINED || op->operands[1].reg == X86R_UNDEFINED) { return -1; } mod = 0x3; data[l++] = mod << 6 | op->operands[1].reg << 3 | op->operands[0].reg; } else if (op->operands[0].regs[0] == X86R_UNDEFINED) { data[l++] = op->operands[1].reg << 3 | 0x5; data[l++] = offset; data[l++] = offset >> 8; data[l++] = offset >> 16; data[l++] = offset >> 24; } else { if (op->operands[0].type & OT_MEMORY) { if (op->operands[0].regs[1] != X86R_UNDEFINED) { data[l++] = op->operands[1].reg << 3 | 0x4; data[l++] = op->operands[0].regs[1] << 3 | op->operands[0].regs[0]; return l; } if (offset) { mod = (offset > 128 || offset < -129) ? 0x2 : 0x1; } if (op->operands[0].regs[0] == X86R_EBP) { mod = 0x2; } data[l++] = mod << 6 | op->operands[1].reg << 3 | op->operands[0].regs[0]; if (op->operands[0].regs[0] == X86R_ESP) { data[l++] = 0x24; } if (offset) { data[l++] = offset; } if (mod == 2) { data[l++] = offset >> 8; data[l++] = offset >> 16; data[l++] = offset >> 24; } } } } else if (op->operands[1].type & OT_MEMORY) { if (op->operands[0].type & OT_MEMORY) { return -1; } offset = op->operands[1].offset * op->operands[1].offset_sign; if (op->operands[0].reg == X86R_EAX && op->operands[1].regs[0] == X86R_UNDEFINED) { if (a->bits == 64) { data[l++] = 0x48; } if (op->operands[0].type & OT_BYTE) { data[l++] = 0xa0; } else { data[l++] = 0xa1; } data[l++] = offset; data[l++] = offset >> 8; data[l++] = offset >> 16; data[l++] = offset >> 24; if (a->bits == 64) { data[l++] = offset >> 32; data[l++] = offset >> 40; data[l++] = offset >> 48; data[l++] = offset >> 54; } return l; } if (op->operands[0].type & OT_BYTE && a->bits == 64 && op->operands[1].regs[0]) { if (op->operands[1].regs[0] >= X86R_R8 && op->operands[0].reg < 4) { data[l++] = 0x41; data[l++] = 0x8a; data[l++] = op->operands[0].reg << 3 | (op->operands[1].regs[0] - 8); return l; } return -1; } if (op->operands[1].type & OT_REGTYPE & OT_SEGMENTREG) { if (op->operands[1].scale[0] == 0) { return -1; } data[l++] = SEG_REG_PREFIXES[op->operands[1].regs[0]]; data[l++] = 0x8b; data[l++] = op->operands[0].reg << 3 | 0x5; data[l++] = offset; data[l++] = offset >> 8; data[l++] = offset >> 16; data[l++] = offset >> 24; return l; } if (a->bits == 64) { if (op->operands[0].type & OT_QWORD) { if (!(op->operands[1].type & OT_QWORD)) { if (op->operands[1].regs[0] != -1) { data[l++] = 0x67; } data[l++] = 0x48; } } else if (op->operands[1].type & OT_DWORD) { data[l++] = 0x44; } else if (!(op->operands[1].type & OT_QWORD)) { data[l++] = 0x67; } if (op->operands[1].type & OT_QWORD && op->operands[0].type & OT_QWORD) { data[l++] = 0x48; } } if (op->operands[0].type & OT_WORD) { data[l++] = 0x66; data[l++] = op->operands[1].type & OT_BYTE ? 0x8a : 0x8b; } else { data[l++] = (op->operands[1].type & OT_BYTE || op->operands[0].type & OT_BYTE) ? 0x8a : 0x8b; } if (op->operands[1].regs[0] == X86R_UNDEFINED) { if (a->bits == 64) { data[l++] = op->operands[0].reg << 3 | 0x4; data[l++] = 0x25; } else { data[l++] = op->operands[0].reg << 3 | 0x5; } data[l++] = offset; data[l++] = offset >> 8; data[l++] = offset >> 16; data[l++] = offset >> 24; } else { if (op->operands[1].scale[0] > 1) { data[l++] = op->operands[0].reg << 3 | 4; if (op->operands[1].scale[0] >= 2) { base = 5; } if (base) { data[l++] = getsib (op->operands[1].scale[0]) << 6 | op->operands[1].regs[0] << 3 | base; } else { data[l++] = getsib (op->operands[1].scale[0]) << 3 | op->operands[1].regs[0]; } if (offset || base) { data[l++] = offset; data[l++] = offset >> 8; data[l++] = offset >> 16; data[l++] = offset >> 24; } return l; } if (op->operands[1].regs[1] != X86R_UNDEFINED) { data[l++] = op->operands[0].reg << 3 | 0x4; data[l++] = op->operands[1].regs[1] << 3 | op->operands[1].regs[0]; return l; } if (offset || op->operands[1].regs[0] == X86R_EBP) { mod = 0x2; if (op->operands[1].offset > 127) { mod = 0x4; } } if (a->bits == 64 && offset && op->operands[0].type & OT_QWORD) { if (op->operands[1].regs[0] == X86R_RIP) { data[l++] = 0x5; } else { if (op->operands[1].offset > 127) { data[l++] = 0x80 | op->operands[0].reg << 3 | op->operands[1].regs[0]; } else { data[l++] = 0x40 | op->operands[1].regs[0]; } } if (op->operands[1].offset > 127) { mod = 0x1; } } else { if (op->operands[1].regs[0] == X86R_EIP && (op->operands[0].type & OT_DWORD)) { data[l++] = 0x0d; } else if (op->operands[1].regs[0] == X86R_RIP && (op->operands[0].type & OT_QWORD)) { data[l++] = 0x05; } else { data[l++] = mod << 5 | op->operands[0].reg << 3 | op->operands[1].regs[0]; } } if (op->operands[1].regs[0] == X86R_ESP) { data[l++] = 0x24; } if (mod >= 0x2) { data[l++] = offset; if (op->operands[1].offset > 128 || op->operands[1].regs[0] == X86R_EIP) { data[l++] = offset >> 8; data[l++] = offset >> 16; data[l++] = offset >> 24; } } else if (a->bits == 64 && (offset || op->operands[1].regs[0] == X86R_RIP)) { data[l++] = offset; if (op->operands[1].offset > 127 || op->operands[1].regs[0] == X86R_RIP) { data[l++] = offset >> 8; data[l++] = offset >> 16; data[l++] = offset >> 24; } } } } return l; }
Description: opmov in libr/asm/p/asm_x86_nz.c in radare2 before 3.1.0 allows attackers to cause a denial of service (buffer over-read) via crafted x86 assembly data, as demonstrated by rasm2.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int ovl_copy_up_locked(struct dentry *workdir, struct dentry *upperdir, struct dentry *dentry, struct path *lowerpath, struct kstat *stat, struct iattr *attr, const char *link) { struct inode *wdir = workdir->d_inode; struct inode *udir = upperdir->d_inode; struct dentry *newdentry = NULL; struct dentry *upper = NULL; umode_t mode = stat->mode; int err; newdentry = ovl_lookup_temp(workdir, dentry); err = PTR_ERR(newdentry); if (IS_ERR(newdentry)) goto out; upper = lookup_one_len(dentry->d_name.name, upperdir, dentry->d_name.len); err = PTR_ERR(upper); if (IS_ERR(upper)) goto out1; stat->mode &= S_IFMT; err = ovl_create_real(wdir, newdentry, stat, link, NULL, true); stat->mode = mode; if (err) goto out2; if (S_ISREG(stat->mode)) { struct path upperpath; ovl_path_upper(dentry, &upperpath); BUG_ON(upperpath.dentry != NULL); upperpath.dentry = newdentry; err = ovl_copy_up_data(lowerpath, &upperpath, stat->size); if (err) goto out_cleanup; } err = ovl_copy_xattr(lowerpath->dentry, newdentry); if (err) goto out_cleanup; mutex_lock(&newdentry->d_inode->i_mutex); err = ovl_set_attr(newdentry, stat); if (!err && attr) err = notify_change(newdentry, attr, NULL); mutex_unlock(&newdentry->d_inode->i_mutex); if (err) goto out_cleanup; err = ovl_do_rename(wdir, newdentry, udir, upper, 0); if (err) goto out_cleanup; ovl_dentry_update(dentry, newdentry); newdentry = NULL; if (!S_ISDIR(stat->mode)) ovl_dentry_set_opaque(dentry, true); out2: dput(upper); out1: dput(newdentry); out: return err; out_cleanup: ovl_cleanup(wdir, newdentry); goto out; }
Description: fs/overlayfs/copy_up.c in the Linux kernel before 4.2.6 uses an incorrect cleanup code path, which allows local users to cause a denial of service (dentry reference leak) via filesystem operations on a large file in a lower overlayfs layer.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static gatt_connection_t *initialize_gattlib_connection(const gchar *src, const gchar *dst, uint8_t dest_type, BtIOSecLevel sec_level, int psm, int mtu, gatt_connect_cb_t connect_cb, io_connect_arg_t* io_connect_arg) { bdaddr_t sba, dba; GError *err = NULL; if (g_gattlib_thread.ref == 0) { int error = pthread_create(&g_gattlib_thread.thread, NULL, &connection_thread, &g_gattlib_thread); if (error != 0) { fprintf(stderr, ""Cannot create connection thread: %s"", strerror(error)); return NULL; } while (!g_gattlib_thread.loop || !g_main_loop_is_running (g_gattlib_thread.loop)) { usleep(1000); } } else { g_gattlib_thread.ref++; } if (dst == NULL) { fprintf(stderr, ""Remote Bluetooth address required\n""); return NULL; } str2ba(dst, &dba); if (src != NULL) { if (!strncmp(src, ""hci"", 3)) hci_devba(atoi(src + 3), &sba); else str2ba(src, &sba); } else bacpy(&sba, BDADDR_ANY); if ((dest_type != BDADDR_LE_PUBLIC) && (dest_type != BDADDR_LE_RANDOM)) { return NULL; } if ((sec_level != BT_IO_SEC_LOW) && (sec_level != BT_IO_SEC_MEDIUM) && (sec_level != BT_IO_SEC_HIGH)) { return NULL; } gattlib_context_t* conn_context = calloc(sizeof(gattlib_context_t), 1); if (conn_context == NULL) { return NULL; } gatt_connection_t* conn = calloc(sizeof(gatt_connection_t), 1); if (conn == NULL) { return NULL; } conn->context = conn_context; io_connect_arg->conn       = conn; io_connect_arg->connect_cb = connect_cb; io_connect_arg->connected  = FALSE; io_connect_arg->timeout    = FALSE; io_connect_arg->error      = NULL; if (psm == 0) { conn_context->io = bt_io_connect( #if BLUEZ_VERSION_MAJOR == 4 BT_IO_L2CAP, #endif io_connect_cb, io_connect_arg, NULL, &err, BT_IO_OPT_SOURCE_BDADDR, &sba, #if BLUEZ_VERSION_MAJOR == 5 BT_IO_OPT_SOURCE_TYPE, BDADDR_LE_PUBLIC, #endif BT_IO_OPT_DEST_BDADDR, &dba, BT_IO_OPT_DEST_TYPE, dest_type, BT_IO_OPT_CID, ATT_CID, BT_IO_OPT_SEC_LEVEL, sec_level, BT_IO_OPT_TIMEOUT, CONNECTION_TIMEOUT, BT_IO_OPT_INVALID); } else { conn_context->io = bt_io_connect( #if BLUEZ_VERSION_MAJOR == 4 BT_IO_L2CAP, #endif io_connect_cb, io_connect_arg, NULL, &err, BT_IO_OPT_SOURCE_BDADDR, &sba, #if BLUEZ_VERSION_MAJOR == 5 BT_IO_OPT_SOURCE_TYPE, BDADDR_LE_PUBLIC, #endif BT_IO_OPT_DEST_BDADDR, &dba, BT_IO_OPT_PSM, psm, BT_IO_OPT_IMTU, mtu, BT_IO_OPT_SEC_LEVEL, sec_level, BT_IO_OPT_TIMEOUT, CONNECTION_TIMEOUT, BT_IO_OPT_INVALID); } if (err) { fprintf(stderr, ""%s\n"", err->message); g_error_free(err); free(conn_context); free(conn); return NULL; } else { return conn; } }
Description: GattLib 0.2 has a stack-based buffer over-read in gattlib_connect in dbus/gattlib.c because strncpy is misused.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool UserScriptInjector::ShouldInjectCss( UserScript::RunLocation run_location) const { return run_location == UserScript::DOCUMENT_START && !script_->css_scripts().empty(); }
Description: Use-after-free vulnerability in extensions/renderer/user_script_injector.cc in the Extensions subsystem in Google Chrome before 52.0.2743.82 allows remote attackers to cause a denial of service or possibly have unspecified other impact via vectors related to script deletion.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int translate_compat_table(struct net *net, struct xt_table_info **pinfo, void **pentry0, const struct compat_ip6t_replace *compatr) { unsigned int i, j; struct xt_table_info *newinfo, *info; void *pos, *entry0, *entry1; struct compat_ip6t_entry *iter0; struct ip6t_replace repl; unsigned int size; int ret; info = *pinfo; entry0 = *pentry0; size = compatr->size; info->number = compatr->num_entries; j = 0; xt_compat_lock(AF_INET6); ret = xt_compat_init_offsets(AF_INET6, compatr->num_entries); if (ret) goto out_unlock; xt_entry_foreach(iter0, entry0, compatr->size) { ret = check_compat_entry_size_and_hooks(iter0, info, &size, entry0, entry0 + compatr->size); if (ret != 0) goto out_unlock; ++j; } ret = -EINVAL; if (j != compatr->num_entries) goto out_unlock; ret = -ENOMEM; newinfo = xt_alloc_table_info(size); if (!newinfo) goto out_unlock; newinfo->number = compatr->num_entries; for (i = 0; i < NF_INET_NUMHOOKS; i++) { newinfo->hook_entry[i] = compatr->hook_entry[i]; newinfo->underflow[i] = compatr->underflow[i]; } entry1 = newinfo->entries; pos = entry1; size = compatr->size; xt_entry_foreach(iter0, entry0, compatr->size) compat_copy_entry_from_user(iter0, &pos, &size, newinfo, entry1); xt_compat_flush_offsets(AF_INET6); xt_compat_unlock(AF_INET6); memcpy(&repl, compatr, sizeof(*compatr)); for (i = 0; i < NF_INET_NUMHOOKS; i++) { repl.hook_entry[i] = newinfo->hook_entry[i]; repl.underflow[i] = newinfo->underflow[i]; } repl.num_counters = 0; repl.counters = NULL; repl.size = newinfo->size; ret = translate_table(net, newinfo, entry1, &repl); if (ret) goto free_newinfo; *pinfo = newinfo; *pentry0 = entry1; xt_free_table_info(info); return 0; free_newinfo: xt_free_table_info(newinfo); return ret; out_unlock: xt_compat_flush_offsets(AF_INET6); xt_compat_unlock(AF_INET6); xt_entry_foreach(iter0, entry0, compatr->size) { if (j-- == 0) break; compat_release_entry(iter0); } return ret; }
Description: A heap out-of-bounds write affecting Linux since v2.6.19-rc1 was discovered in net/netfilter/x_tables.c. This allows an attacker to gain privileges or cause a DoS (via heap memory corruption) through user name space
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: CallResult<HermesValue> hermesBuiltinCopyDataProperties(void *, Runtime &runtime, NativeArgs args) { GCScope gcScope{runtime}; Handle<JSObject> target = args.dyncastArg<JSObject>(0); if (!target) return HermesValue::encodeUndefinedValue(); Handle<> untypedSource = args.getArgHandle(1); if (untypedSource->isNull() || untypedSource->isUndefined()) return target.getHermesValue(); Handle<JSObject> source = untypedSource->isObject() ? Handle<JSObject>::vmcast(untypedSource) : Handle<JSObject>::vmcast( runtime.makeHandle(*toObject(runtime, untypedSource))); Handle<JSObject> excludedItems = args.dyncastArg<JSObject>(2); assert( (!excludedItems || !excludedItems->isProxyObject()) && ""excludedItems internal List is a Proxy""); if (source->isProxyObject()) { return copyDataPropertiesSlowPath_RJS( runtime, target, source, excludedItems); } MutableHandle<> nameHandle{runtime}; MutableHandle<> valueHandle{runtime}; MutableHandle<SymbolID> tmpSymbolStorage{runtime}; bool success = JSObject::forEachOwnPropertyWhile( source, runtime, [&source, &target, &excludedItems, &nameHandle, &valueHandle, &tmpSymbolStorage]( Runtime &runtime, uint32_t index, ComputedPropertyDescriptor desc) { if (!desc.flags.enumerable) return true; nameHandle = HermesValue::encodeNumberValue(index); if (excludedItems) { assert( !excludedItems->isProxyObject() && ""internal excludedItems object is a proxy""); ComputedPropertyDescriptor xdesc; auto cr = JSObject::getOwnComputedPrimitiveDescriptor( excludedItems, runtime, nameHandle, JSObject::IgnoreProxy::Yes, tmpSymbolStorage, xdesc); if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION)) return false; if (*cr) return true; } valueHandle = JSObject::getOwnIndexed( createPseudoHandle(source.get()), runtime, index); if (LLVM_UNLIKELY( JSObject::defineOwnComputedPrimitive( target, runtime, nameHandle, DefinePropertyFlags::getDefaultNewPropertyFlags(), valueHandle) == ExecutionStatus::EXCEPTION)) { return false; } return true; }, [&source, &target, &excludedItems, &valueHandle]( Runtime &runtime, SymbolID sym, NamedPropertyDescriptor desc) { if (!desc.flags.enumerable) return true; if (InternalProperty::isInternal(sym)) return true; if (excludedItems) { auto cr = JSObject::hasNamedOrIndexed(excludedItems, runtime, sym); assert( cr != ExecutionStatus::EXCEPTION && ""hasNamedOrIndex failed, which can only happen with a proxy, "" ""but excludedItems should never be a proxy""); if (*cr) return true; } auto cr = JSObject::getNamedPropertyValue_RJS(source, runtime, source, desc); if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION)) return false; valueHandle = std::move(*cr); if (LLVM_UNLIKELY( JSObject::defineOwnPropertyInternal( target, runtime, sym, DefinePropertyFlags::getDefaultNewPropertyFlags(), valueHandle) == ExecutionStatus::EXCEPTION)) { return false; } return true; }); if (LLVM_UNLIKELY(!success)) return ExecutionStatus::EXCEPTION; return target.getHermesValue(); }
Description: An error in Hermes' algorithm for copying objects properties prior to commit a00d237346894c6067a594983be6634f4168c9ad could be used by a malicious attacker to execute arbitrary code via type confusion. Note that this is only exploitable in cases where Hermes is used to execute untrusted JavaScript. Hence, most React Native applications are not affected.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static inline void write_s3row_data( const entity_stage3_row *r, unsigned orig_cp, enum entity_charset charset, zval *arr) { char key[9] = """";  char entity[LONGEST_ENTITY_LENGTH + 2] = {'&'}; size_t written_k1; written_k1 = write_octet_sequence(key, charset, orig_cp); if (!r->ambiguous) { size_t l = r->data.ent.entity_len; memcpy(&entity[1], r->data.ent.entity, l); entity[l + 1] = ';'; add_assoc_stringl_ex(arr, key, written_k1 + 1, entity, l + 2, 1); } else { unsigned i, num_entries; const entity_multicodepoint_row *mcpr = r->data.multicodepoint_table; if (mcpr[0].leading_entry.default_entity != NULL) { size_t l = mcpr[0].leading_entry.default_entity_len; memcpy(&entity[1], mcpr[0].leading_entry.default_entity, l); entity[l + 1] = ';'; add_assoc_stringl_ex(arr, key, written_k1 + 1, entity, l + 2, 1); } num_entries = mcpr[0].leading_entry.size; for (i = 1; i <= num_entries; i++) { size_t   l, written_k2; unsigned uni_cp, spe_cp; uni_cp = mcpr[i].normal_entry.second_cp; l = mcpr[i].normal_entry.entity_len; if (!CHARSET_UNICODE_COMPAT(charset)) { if (map_from_unicode(uni_cp, charset, &spe_cp) == FAILURE) continue;  } else { spe_cp = uni_cp; } written_k2 = write_octet_sequence(&key[written_k1], charset, spe_cp); memcpy(&entity[1], mcpr[i].normal_entry.entity, l); entity[l + 1] = ';'; entity[l + 1] = '\0'; add_assoc_stringl_ex(arr, key, written_k1 + written_k2 + 1, entity, l + 1, 1); } } }
Description: Integer overflow in the php_html_entities function in ext/standard/html.c in PHP before 5.5.36 and 5.6.x before 5.6.22 allows remote attackers to cause a denial of service or possibly have unspecified other impact by triggering a large output string from the htmlspecialchars function.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void SparseFillEmptyRowsOpImpl(OpKernelContext* context, AsyncOpKernel::DoneCallback done = nullptr) { if (!done) { done = [] {}; } const int kIndicesInput = 0; const int kValuesInput = 1; const int kDenseShapeInput = 2; const int kDefaultValueInput = 3; const Tensor& indices_t = context->input(kIndicesInput); const Tensor& values_t = context->input(kValuesInput); const Tensor& dense_shape_t = context->input(kDenseShapeInput); const Tensor& default_value_t = context->input(kDefaultValueInput); OP_REQUIRES_ASYNC( context, TensorShapeUtils::IsVector(dense_shape_t.shape()), errors::InvalidArgument(""dense_shape must be a vector, saw: "", dense_shape_t.shape().DebugString()), done); OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsMatrix(indices_t.shape()), errors::InvalidArgument(""indices must be a matrix, saw: "", indices_t.shape().DebugString()), done); OP_REQUIRES_ASYNC(context, TensorShapeUtils::IsVector(values_t.shape()), errors::InvalidArgument(""values must be a vector, saw: "", values_t.shape().DebugString()), done); OP_REQUIRES_ASYNC( context, TensorShapeUtils::IsScalar(default_value_t.shape()), errors::InvalidArgument(""default_value must be a scalar, saw: "", default_value_t.shape().DebugString()), done); using FunctorType = functor::SparseFillEmptyRows<Device, T, Tindex>; OP_REQUIRES_OK_ASYNC(context, FunctorType()(context, default_value_t, indices_t, values_t, dense_shape_t, done), done); }
Description: TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a null pointer dereference in the implementation of `tf.raw_ops.SparseFillEmptyRows`. This is because of missing validation(https://github.com/tensorflow/tensorflow/blob/fdc82089d206e281c628a93771336bf87863d5e8/tensorflow/core/kernels/sparse_fill_empty_rows_op.cc#L230-L231) that was covered under a `TODO`. If the `dense_shape` tensor is empty, then `dense_shape_t.vec<>()` would cause a null pointer dereference in the implementation of the op. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int pci_xhci_complete_commands(struct pci_xhci_vdev *xdev) { struct xhci_trbevtrb; struct xhci_trb*trb; uint64_tcrcr; uint32_tccs; uint32_ttype; uint32_tslot; uint32_tcmderr; xdev->opregs.crcr |= XHCI_CRCR_LO_CRR; trb = xdev->opregs.cr_p; ccs = xdev->opregs.crcr & XHCI_CRCR_LO_RCS; crcr = xdev->opregs.crcr & ~0xF; while (1) { xdev->opregs.cr_p = trb; type = XHCI_TRB_3_TYPE_GET(trb->dwTrb3); if ((trb->dwTrb3 & XHCI_TRB_3_CYCLE_BIT) != (ccs & XHCI_TRB_3_CYCLE_BIT)) break; UPRINTF(LDBG, ""cmd type 0x%x, Trb0 x%016lx dwTrb2 x%08x"" "" dwTrb3 x%08x, TRB_CYCLE %u/ccs %u\r\n"", type, trb->qwTrb0, trb->dwTrb2, trb->dwTrb3, trb->dwTrb3 & XHCI_TRB_3_CYCLE_BIT, ccs); cmderr = XHCI_TRB_ERROR_SUCCESS; evtrb.dwTrb2 = 0; evtrb.dwTrb3 = (ccs & XHCI_TRB_3_CYCLE_BIT) | XHCI_TRB_3_TYPE_SET(XHCI_TRB_EVENT_CMD_COMPLETE); slot = 0; switch (type) { case XHCI_TRB_TYPE_LINK: if (trb->dwTrb3 & XHCI_TRB_3_TC_BIT) ccs ^= XHCI_CRCR_LO_RCS; break; case XHCI_TRB_TYPE_ENABLE_SLOT: cmderr = pci_xhci_cmd_enable_slot(xdev, &slot); break; case XHCI_TRB_TYPE_DISABLE_SLOT: XHCI_GET_SLOT(xdev, trb, slot, cmderr); if (slot) cmderr = pci_xhci_cmd_disable_slot(xdev, slot); break; case XHCI_TRB_TYPE_ADDRESS_DEVICE: XHCI_GET_SLOT(xdev, trb, slot, cmderr); if (slot) cmderr = pci_xhci_cmd_address_device(xdev, slot, trb); break; case XHCI_TRB_TYPE_CONFIGURE_EP: XHCI_GET_SLOT(xdev, trb, slot, cmderr); if (slot) cmderr = pci_xhci_cmd_config_ep(xdev, slot, trb); break; case XHCI_TRB_TYPE_EVALUATE_CTX: XHCI_GET_SLOT(xdev, trb, slot, cmderr); if (slot) cmderr = pci_xhci_cmd_eval_ctx(xdev, slot, trb); break; case XHCI_TRB_TYPE_RESET_EP: UPRINTF(LDBG, ""Reset Endpoint on slot %d\r\n"", slot); XHCI_GET_SLOT(xdev, trb, slot, cmderr); if (slot) cmderr = pci_xhci_cmd_reset_ep(xdev, slot, trb); break; case XHCI_TRB_TYPE_STOP_EP: UPRINTF(LDBG, ""Stop Endpoint on slot %d\r\n"", slot); XHCI_GET_SLOT(xdev, trb, slot, cmderr); if (slot) cmderr = pci_xhci_cmd_reset_ep(xdev, slot, trb); break; case XHCI_TRB_TYPE_SET_TR_DEQUEUE: XHCI_GET_SLOT(xdev, trb, slot, cmderr); if (slot) cmderr = pci_xhci_cmd_set_tr(xdev, slot, trb); break; case XHCI_TRB_TYPE_RESET_DEVICE: XHCI_GET_SLOT(xdev, trb, slot, cmderr); if (slot) cmderr = pci_xhci_cmd_reset_device(xdev, slot); break; case XHCI_TRB_TYPE_FORCE_EVENT: break; case XHCI_TRB_TYPE_NEGOTIATE_BW: break; case XHCI_TRB_TYPE_SET_LATENCY_TOL: break; case XHCI_TRB_TYPE_GET_PORT_BW: break; case XHCI_TRB_TYPE_FORCE_HEADER: break; case XHCI_TRB_TYPE_NOOP_CMD: break; default: UPRINTF(LDBG, ""unsupported cmd %x\r\n"", type); break; } if (type != XHCI_TRB_TYPE_LINK) { evtrb.qwTrb0 = crcr; evtrb.dwTrb2 |= XHCI_TRB_2_ERROR_SET(cmderr); evtrb.dwTrb3 |= XHCI_TRB_3_SLOT_SET(slot); UPRINTF(LDBG, ""command 0x%x result: 0x%x\r\n"", type, cmderr); if (pci_xhci_insert_event(xdev, &evtrb, 1) != 0) { UPRINTF(LFTL, ""Failed to inject command completion event!\r\n""); return -ENAVAIL; } } trb = pci_xhci_trb_next(xdev, trb, &crcr); if (!trb) { UPRINTF(LDBG, ""Get the invalid trb in %s!\r\n"", __func__); break; } } xdev->opregs.crcr = crcr | (xdev->opregs.crcr & XHCI_CRCR_LO_CA) | ccs; xdev->opregs.crcr &= ~XHCI_CRCR_LO_CRR; return 0; }
Description: ACRN before 2.5 has a devicemodel/hw/pci/xhci.c NULL Pointer Dereference for a trb pointer.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void TiledInputFile::initialize () { if(!isMultiPart(_data->version) && !isNonImage(_data->version) &&  isTiled(_data->version) &&  _data->header.hasType() ) { _data->header.setType(TILEDIMAGE); } if (_data->partNumber == -1) { if (!isTiled (_data->version)) throw IEX_NAMESPACE::ArgExc (""Expected a tiled file but the file is not tiled.""); } else { if(_data->header.hasType() && _data->header.type()!=TILEDIMAGE) { throw IEX_NAMESPACE::ArgExc (""TiledInputFile used for non-tiledimage part.""); } } _data->header.sanityCheck (true); _data->tileDesc = _data->header.tileDescription(); _data->lineOrder = _data->header.lineOrder(); const Box2i &dataWindow = _data->header.dataWindow(); _data->minX = dataWindow.min.x; _data->maxX = dataWindow.max.x; _data->minY = dataWindow.min.y; _data->maxY = dataWindow.max.y; precalculateTileInfo (_data->tileDesc, _data->minX, _data->maxX, _data->minY, _data->maxY, _data->numXTiles, _data->numYTiles, _data->numXLevels, _data->numYLevels);     _data->bytesPerPixel = calculateBytesPerPixel (_data->header); _data->maxBytesPerTileLine = _data->bytesPerPixel * _data->tileDesc.xSize; _data->tileBufferSize = _data->maxBytesPerTileLine * _data->tileDesc.ySize; if( _data->tileBufferSize > INT_MAX ) { throw IEX_NAMESPACE::ArgExc (""Tile size too large for OpenEXR format""); } for (size_t i = 0; i < _data->tileBuffers.size(); i++) { _data->tileBuffers[i] = new TileBuffer (newTileCompressor (_data->header.compression(), _data->maxBytesPerTileLine, _data->tileDesc.ySize, _data->header)); if (!_data->_streamData->is->isMemoryMapped ()) _data->tileBuffers[i]->buffer = new char [_data->tileBufferSize]; } _data->tileOffsets = TileOffsets (_data->tileDesc.mode, _data->numXLevels, _data->numYLevels, _data->numXTiles, _data->numYTiles); }
Description: A flaw was found in OpenEXR's TiledInputFile functionality. This flaw allows an attacker who can submit a crafted single-part non-image to be processed by OpenEXR, to trigger a floating-point exception error. The highest threat from this vulnerability is to system availability.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int WebObjects_translate(request_rec *r) { WebObjects_config *wc; WOURLComponents url; WOURLError urlerr; wc = ap_get_module_config(r->server->module_config, &WebObjects_module); WOLog(WO_DBG, ""<WebObjects Apache Module> new translate: %s"", r->uri); if (strncmp(wc->WebObjects_alias, r->uri, strlen(wc->WebObjects_alias)) == 0 || (r->handler != NULL && strcasecmp(r->handler, WEBOBJECTS) == 0)) { #ifndef _MSC_VER         url = WOURLComponents_Initializer; #else memset(&url,0,sizeof(WOURLComponents)); #endif urlerr = WOParseApplicationName(&url, r->uri); if (urlerr != WOURLOK && !((urlerr == WOURLInvalidApplicationName) && ac_authorizeAppListing(&url))) { WOLog(WO_DBG, ""<WebObjects Apache Module> translate - DECLINED: %s"", r->uri); return DECLINED; } if (!adaptorEnabled) { WOLog(WO_ERR, ""WebObjects_translate(): declining request due to initialization failure""); return DECLINED; } r->handler = (char *)apr_pstrdup(r->pool, WEBOBJECTS); r->filename = (char *)apr_pstrdup(r->pool, r->uri); return OK; } WOLog(WO_DBG, ""<WebObjects Apache Module> translate - DECLINED: %s"", r->uri); return DECLINED; }
Description: Project Wonder WebObjects 1.0 through 5.4.3 is vulnerable to Arbitrary HTTP Header injection and URL- or Header-based XSS reflection in all web-server adaptor interfaces.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void xsltNumberFormatRoman(xmlBufferPtr buffer, double number, int is_upper) { while (number >= 1000.0) { xmlBufferCCat(buffer, (is_upper) ? ""M"" : ""m""); number -= 1000.0; } if (number >= 900.0) { xmlBufferCCat(buffer, (is_upper) ? ""CM"" : ""cm""); number -= 900.0; } while (number >= 500.0) { xmlBufferCCat(buffer, (is_upper) ? ""D"" : ""d""); number -= 500.0; } if (number >= 400.0) { xmlBufferCCat(buffer, (is_upper) ? ""CD"" : ""cd""); number -= 400.0; } while (number >= 100.0) { xmlBufferCCat(buffer, (is_upper) ? ""C"" : ""c""); number -= 100.0; } if (number >= 90.0) { xmlBufferCCat(buffer, (is_upper) ? ""XC"" : ""xc""); number -= 90.0; } while (number >= 50.0) { xmlBufferCCat(buffer, (is_upper) ? ""L"" : ""l""); number -= 50.0; } if (number >= 40.0) { xmlBufferCCat(buffer, (is_upper) ? ""XL"" : ""xl""); number -= 40.0; } while (number >= 10.0) { xmlBufferCCat(buffer, (is_upper) ? ""X"" : ""x""); number -= 10.0; } if (number >= 9.0) { xmlBufferCCat(buffer, (is_upper) ? ""IX"" : ""ix""); number -= 9.0; } while (number >= 5.0) { xmlBufferCCat(buffer, (is_upper) ? ""V"" : ""v""); number -= 5.0; } if (number >= 4.0) { xmlBufferCCat(buffer, (is_upper) ? ""IV"" : ""iv""); number -= 4.0; } while (number >= 1.0) { xmlBufferCCat(buffer, (is_upper) ? ""I"" : ""i""); number--; } }
Description: numbers.c in libxslt before 1.1.29, as used in Google Chrome before 51.0.2704.63, mishandles the i format token for xsl:number data, which allows remote attackers to cause a denial of service (integer overflow or resource consumption) or possibly have unspecified other impact via a crafted document.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static inline bool_t port_is_valid(struct domain *d, unsigned int p) { return p < read_atomic(&d->valid_evtchns); }
Description: An issue was discovered in Xen through 4.14.x. There are missing memory barriers when accessing/allocating an event channel. Event channels control structures can be accessed lockless as long as the port is considered to be valid. Such a sequence is missing an appropriate memory barrier (e.g., smp_*mb()) to prevent both the compiler and CPU from re-ordering access. A malicious guest may be able to cause a hypervisor crash resulting in a Denial of Service (DoS). Information leak and privilege escalation cannot be excluded. Systems running all versions of Xen are affected. Whether a system is vulnerable will depend on the CPU and compiler used to build Xen. For all systems, the presence and the scope of the vulnerability depend on the precise re-ordering performed by the compiler used to build Xen. We have not been able to survey compilers; consequently we cannot say which compiler(s) might produce vulnerable code (with which code generation options). GCC documentation clearly suggests that re-ordering is possible. Arm systems will also be vulnerable if the CPU is able to re-order memory access. Please consult your CPU vendor. x86 systems are only vulnerable if a compiler performs re-ordering.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void write_version( FILE       *fp, const char *fname, const char *dirname, xref_t     *xref) { long  start; char *c, *new_fname, data; FILE *new_fp; start = ftell(fp); if ((c = strstr(fname, "".pdf""))) *c = '\0'; new_fname = malloc(strlen(fname) + strlen(dirname) + 16); snprintf(new_fname, strlen(fname) + strlen(dirname) + 16, ""%s/%s-version-%d.pdf"", dirname, fname, xref->version); if (!(new_fp = fopen(new_fname, ""w""))) { ERR(""Could not create file '%s'\n"", new_fname); fseek(fp, start, SEEK_SET); free(new_fname); return; } fseek(fp, 0, SEEK_SET); while (fread(&data, 1, 1, fp)) fwrite(&data, 1, 1, new_fp); fprintf(new_fp, ""\r\nstartxref\r\n%ld\r\n%%%%EOF"", xref->start); fclose(new_fp); free(new_fname); fseek(fp, start, SEEK_SET); }
Description: An issue was discovered in PDFResurrect before 0.18. pdf_load_pages_kids in pdf.c doesn't validate a certain size value, which leads to a malloc failure and out-of-bounds write.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: FrameLoader::FrameLoader(LocalFrame* frame) : m_frame(frame) , m_progressTracker(ProgressTracker::create(frame)) , m_loadType(FrameLoadTypeStandard) , m_inStopAllLoaders(false) , m_checkTimer(this, &FrameLoader::checkTimerFired) , m_didAccessInitialDocument(false) , m_didAccessInitialDocumentTimer(this, &FrameLoader::didAccessInitialDocumentTimerFired) , m_forcedSandboxFlags(SandboxNone) , m_dispatchingDidClearWindowObjectInMainWorld(false) , m_protectProvisionalLoader(false) { TRACE_EVENT_OBJECT_CREATED_WITH_ID(""loading"", ""FrameLoader"", this); takeObjectSnapshot(); }
Description: Blink, as used in Google Chrome before 52.0.2743.116, allows remote attackers to spoof the address bar via vectors involving a provisional URL for an initially empty document, related to FrameLoader.cpp and ScopedPageLoadDeferrer.cpp.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: IOBasicTypes::LongBufferSizeType ObjectByteWriterWithPosition::Write(const IOBasicTypes::Byte* inBuffer,IOBasicTypes::LongBufferSizeType inBufferSize) { CREATE_ISOLATE_CONTEXT; CREATE_ESCAPABLE_SCOPE; Local<Object> anArray = NEW_ARRAY((int)inBufferSize); for(int i=0;i<(int)inBufferSize;++i) anArray->Set(GET_CURRENT_CONTEXT, NEW_NUMBER(i),NEW_NUMBER(inBuffer[i])); Local<Value> value = OBJECT_FROM_PERSISTENT(mObject)->Get(GET_CURRENT_CONTEXT, NEW_STRING(""write"")).ToLocalChecked(); if(value->IsUndefined() || !value->IsFunction()) { THROW_EXCEPTION(""write is not a function, it should be you know...""); return 0; } Local<Function> func = Local<Function>::Cast(value); Local<Value> args[1]; args[0] = anArray; Local<Value> result = func->Call(GET_CURRENT_CONTEXT,  OBJECT_FROM_PERSISTENT(mObject), 1, args).ToLocalChecked(); if(result.IsEmpty()) { THROW_EXCEPTION(""wrong return value. it's empty. return the number of written characters""); return 0; } else if(result->IsNumber()) { return TO_UINT32(result)->Value(); } else { THROW_EXCEPTION(""wrong return value. write should return the number of written characters""); return 0; } }
Description: The package muhammara before 2.6.1, from 3.0.0 and before 3.1.1; all versions of package hummus are vulnerable to Denial of Service (DoS) when supplied with a maliciously crafted PDF file to be parsed.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int dns_HTTPS_add_ipv6hint(struct dns_rr_nested *svcparam, unsigned char addr[][DNS_RR_AAAA_LEN], int addr_num) { if (_dns_left_len(&svcparam->context) < 4 + addr_num * DNS_RR_AAAA_LEN) { return -1; } unsigned short value = DNS_HTTPS_T_IPV6HINT; dns_add_rr_nested_memcpy(svcparam, &value, 2); value = addr_num * DNS_RR_AAAA_LEN; dns_add_rr_nested_memcpy(svcparam, &value, 2); for (int i = 0; i < addr_num; i++) { dns_add_rr_nested_memcpy(svcparam, addr[i], DNS_RR_AAAA_LEN); } return 0; }
Description: SmartDNS through 41 before 56d0332 allows an out-of-bounds write because of a stack-based buffer overflow in the _dns_encode_domain function in the dns.c file, via a crafted DNS request.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static __inline tTcpIpPacketParsingResult ProcessTCPHeader(tTcpIpPacketParsingResult _res, PVOID pIpHeader, ULONG len, USHORT ipHeaderSize) { ULONG tcpipDataAt; tTcpIpPacketParsingResult res = _res; tcpipDataAt = ipHeaderSize + sizeof(TCPHeader); res.xxpStatus = ppresXxpIncomplete; res.TcpUdp = ppresIsTCP; if (len >= tcpipDataAt) { TCPHeader *pTcpHeader = (TCPHeader *)RtlOffsetToPointer(pIpHeader, ipHeaderSize); res.xxpStatus = ppresXxpKnown; tcpipDataAt = ipHeaderSize + TCP_HEADER_LENGTH(pTcpHeader); res.XxpIpHeaderSize = tcpipDataAt; } else { DPrintf(2, (""tcp: %d < min headers %d\n"", len, tcpipDataAt)); } return res; }
Description: The NetKVM Windows Virtio driver allows remote attackers to cause a denial of service (guest crash) via a crafted length value in an IP packet, as demonstrated by a value that does not account for the size of the IP options.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void init_xml_relax_ng() { VALUE nokogiri = rb_define_module(""Nokogiri""); VALUE xml = rb_define_module_under(nokogiri, ""XML""); VALUE klass = rb_define_class_under(xml, ""RelaxNG"", cNokogiriXmlSchema); cNokogiriXmlRelaxNG = klass; rb_define_singleton_method(klass, ""read_memory"", read_memory, 1); rb_define_singleton_method(klass, ""from_document"", from_document, 1); rb_define_private_method(klass, ""validate_document"", validate_document, 1); }
Description: Nokogiri is a Rubygem providing HTML, XML, SAX, and Reader parsers with XPath and CSS selector support. In Nokogiri before version 1.11.0.rc4 there is an XXE vulnerability. XML Schemas parsed by Nokogiri::XML::Schema are trusted by default, allowing external resources to be accessed over the network, potentially enabling XXE or SSRF attacks. This behavior is counter to the security policy followed by Nokogiri maintainers, which is to treat all input as untrusted by default whenever possible. This is fixed in Nokogiri version 1.11.0.rc4.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool  SunRasterDecoder::readData( Mat& img ) { int color = img.channels() > 1; uchar* data = img.ptr(); int step = (int)img.step; uchar  gray_palette[256] = {0}; bool   result = false; int  src_pitch = ((m_width*m_bpp + 7)/8 + 1) & -2; int  nch = color ? 3 : 1; int  width3 = m_width*nch; int  y; if( m_offset < 0 || !m_strm.isOpened()) return false; AutoBuffer<uchar> _src(src_pitch + 32); uchar* src = _src; AutoBuffer<uchar> _bgr(m_width*3 + 32); uchar* bgr = _bgr; if( !color && m_maptype == RMT_EQUAL_RGB ) CvtPaletteToGray( m_palette, gray_palette, 1 << m_bpp ); try { m_strm.setPos( m_offset ); switch( m_bpp ) { case 1: if( m_type != RAS_BYTE_ENCODED ) { for( y = 0; y < m_height; y++, data += step ) { m_strm.getBytes( src, src_pitch ); if( color ) FillColorRow1( data, src, m_width, m_palette ); else FillGrayRow1( data, src, m_width, gray_palette ); } result = true; } else { uchar* line_end = src + (m_width*m_bpp + 7)/8; uchar* tsrc = src; y = 0; for(;;) { int max_count = (int)(line_end - tsrc); int code = 0, len = 0, len1 = 0; do { code = m_strm.getByte(); if( code == 0x80 ) { len = m_strm.getByte(); if( len != 0 ) break; } tsrc[len1] = (uchar)code; } while( ++len1 < max_count ); tsrc += len1; if( len > 0 )                     { ++len; code = m_strm.getByte(); if( len > line_end - tsrc ) { assert(0); goto bad_decoding_1bpp; } memset( tsrc, code, len ); tsrc += len; } if( tsrc >= line_end ) { tsrc = src; if( color ) FillColorRow1( data, src, m_width, m_palette ); else FillGrayRow1( data, src, m_width, gray_palette ); data += step; if( ++y >= m_height ) break; } } result = true; bad_decoding_1bpp: ; } break; case 8: if( m_type != RAS_BYTE_ENCODED ) { for( y = 0; y < m_height; y++, data += step ) { m_strm.getBytes( src, src_pitch ); if( color ) FillColorRow8( data, src, m_width, m_palette ); else FillGrayRow8( data, src, m_width, gray_palette ); } result = true; } else             { uchar* line_end = data + width3; y = 0; for(;;) { int max_count = (int)(line_end - data); int code = 0, len = 0, len1; uchar* tsrc = src; do { code = m_strm.getByte(); if( code == 0x80 ) { len = m_strm.getByte(); if( len != 0 ) break; } *tsrc++ = (uchar)code; } while( (max_count -= nch) > 0 ); len1 = (int)(tsrc - src); if( len1 > 0 ) { if( color ) FillColorRow8( data, src, len1, m_palette ); else FillGrayRow8( data, src, len1, gray_palette ); data += len1*nch; } if( len > 0 )                     { len = (len + 1)*nch; code = m_strm.getByte(); if( color ) data = FillUniColor( data, line_end, step, width3, y, m_height, len, m_palette[code] ); else data = FillUniGray( data, line_end, step, width3, y, m_height, len, gray_palette[code] ); if( y >= m_height ) break; } if( data == line_end ) { if( m_strm.getByte() != 0 ) goto bad_decoding_end; line_end += step; data = line_end - width3; if( ++y >= m_height ) break; } } result = true; bad_decoding_end: ; } break; case 24: for( y = 0; y < m_height; y++, data += step ) { m_strm.getBytes( color ? data : bgr, src_pitch ); if( color ) { if( m_type == RAS_FORMAT_RGB ) icvCvt_RGB2BGR_8u_C3R( data, 0, data, 0, cvSize(m_width,1) ); } else { icvCvt_BGR2Gray_8u_C3C1R( bgr, 0, data, 0, cvSize(m_width,1), m_type == RAS_FORMAT_RGB ? 2 : 0 ); } } result = true; break; case 32: for( y = 0; y < m_height; y++, data += step ) { m_strm.getBytes( src + 3, src_pitch ); if( color ) icvCvt_BGRA2BGR_8u_C4C3R( src + 4, 0, data, 0, cvSize(m_width,1), m_type == RAS_FORMAT_RGB ? 2 : 0 ); else icvCvt_BGRA2Gray_8u_C4C1R( src + 4, 0, data, 0, cvSize(m_width,1), m_type == RAS_FORMAT_RGB ? 2 : 0 ); } result = true; break; default: assert(0); } } catch( ... ) { } return result; }
Description: OpenCV (Open Source Computer Vision Library) 3.3 has an out-of-bounds write error in the function FillColorRow1 in utils.cpp when reading an image file by using cv::imread. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-12597.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: GF_Err video_sample_entry_box_size(GF_Box *s) { GF_Box *b; u32 pos=0; GF_MPEGVisualSampleEntryBox *ptr = (GF_MPEGVisualSampleEntryBox *)s; gf_isom_video_sample_entry_size((GF_VisualSampleEntryBox *)s); gf_isom_check_position(s, (GF_Box *)ptr->esd, &pos); gf_isom_check_position(s, (GF_Box *)ptr->cfg_3gpp, &pos); gf_isom_check_position(s, (GF_Box *)ptr->avc_config, &pos); gf_isom_check_position(s, (GF_Box *)ptr->svc_config, &pos); if (ptr->mvc_config) { gf_isom_check_position(s, gf_isom_box_find_child(s->child_boxes, GF_ISOM_BOX_TYPE_VWID), &pos); gf_isom_check_position(s, (GF_Box *)ptr->mvc_config, &pos); } gf_isom_check_position(s, (GF_Box *)ptr->hevc_config, &pos); gf_isom_check_position(s, (GF_Box *)ptr->lhvc_config, &pos); gf_isom_check_position(s, (GF_Box *)ptr->vvc_config, &pos); gf_isom_check_position(s, (GF_Box *)ptr->av1_config, &pos); gf_isom_check_position(s, (GF_Box *)ptr->vp_config, &pos); gf_isom_check_position(s, (GF_Box *)ptr->jp2h, &pos); gf_isom_check_position(s, (GF_Box *)ptr->dovi_config, &pos); b = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_ST3D); if (b) gf_isom_check_position(s, b, &pos); b = gf_isom_box_find_child(ptr->child_boxes, GF_ISOM_BOX_TYPE_SV3D); if (b) gf_isom_check_position(s, b, &pos); return GF_OK; }
Description: Heap-based Buffer Overflow in GitHub repository gpac/gpac prior to V2.1.0-DEV.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static inline int make_table_template(gx_device     * pdev, gx_path       * path, const gs_fixed_rect * ibox, int             intersection_size, fixed           adjust, int           * scanlinesp, int          ** indexp, int          ** tablep) { int             scanlines; const subpath * restrict psub; int           * restrict index; int           * restrict table; int             i; int             offset, delta; fixed           base_y = ibox->p.y; *scanlinesp = 0; *indexp     = NULL; *tablep     = NULL; scanlines = ibox->q.y-base_y; index = (int *)gs_alloc_bytes(pdev->memory, (scanlines+1) * sizeof(*index), ""scanc index buffer""); if (index == NULL) return_error(gs_error_VMerror); memset(index, 0, (scanlines+1)*sizeof(int)); for (psub = path->first_subpath; psub != 0;) { const segment * restrict pseg = (const segment *)psub; fixed          ey = pseg->pt.y + adjust; fixed          iy = ey; int            iey = fixed2int(iy) - base_y; assert(pseg->type == s_start); if (iey >= 0 && iey < scanlines) { index[iey] += 2; if (iey+1 < scanlines) index[iey+1] -= 2; } while ((pseg = pseg->next) != 0 && pseg->type != s_start ) { fixed sy = ey; ey = pseg->pt.y + adjust; #ifdef DEBUG_SCAN_CONVERTER if (debugging_scan_converter) dlprintf1(""%d "", pseg->type); #endif switch (pseg->type) { default: case s_start:  case s_dash:   assert(""This should never happen"" == NULL); break; case s_curve: { const curve_segment *const restrict pcur = (const curve_segment *)pseg; fixed c1y = pcur->p1.y + adjust; fixed c2y = pcur->p2.y + adjust; fixed maxy = sy, miny = sy; int imaxy, iminy; if (miny > c1y) miny = c1y; if (miny > c2y) miny = c2y; if (miny > ey) miny = ey; if (maxy < c1y) maxy = c1y; if (maxy < c2y) maxy = c2y; if (maxy < ey) maxy = ey; iminy = fixed2int(miny) - base_y; if (iminy < 0) iminy = 0; if (iminy < scanlines) { imaxy = fixed2int(maxy) - base_y; if (imaxy >= 0) { index[iminy]+=3; if (imaxy < scanlines) index[imaxy+1]-=3; } } break; } case s_gap: case s_line: case s_line_close: { fixed miny, maxy; int imaxy, iminy; if (sy == ey) break; if (sy < ey) miny = sy, maxy = ey; else miny = ey, maxy = sy; iminy = fixed2int(miny) - base_y; if (iminy < 0) iminy = 0; if (iminy < scanlines) { imaxy = fixed2int(maxy) - base_y; if (imaxy >= 0) { index[iminy]++; if (imaxy < scanlines) { index[imaxy+1]--; } } } break; } } if (ey != iy) { fixed miny, maxy; int imaxy, iminy; if (iy < ey) miny = iy, maxy = ey; else miny = ey, maxy = iy; iminy = fixed2int(miny) - base_y; if (iminy < 0) iminy = 0; if (iminy < scanlines) { imaxy = fixed2int(maxy) - base_y; if (imaxy >= 0) { index[iminy]++; if (imaxy < scanlines) { index[imaxy+1]--; } } } } } #ifdef DEBUG_SCAN_CONVERTER if (debugging_scan_converter) dlprintf(""\n""); #endif psub = (const subpath *)pseg; } offset = 0; delta  = 0; for (i=0; i < scanlines; i++) { delta    += intersection_size*index[i];   index[i]  = offset;                       offset   += delta+1;                      } table = (int *)gs_alloc_bytes(pdev->memory, offset * sizeof(*table), ""scanc intersects buffer""); if (table == NULL) { gs_free_object(pdev->memory, table, ""scanc index buffer""); return_error(gs_error_VMerror); } for (i=0; i < scanlines; i++) { table[index[i]] = 0; } *scanlinesp = scanlines; *tablep     = table; *indexp     = index; return 0; }
Description: Integer overflow in the mark_curve function in Artifex Ghostscript 9.21 allows remote attackers to cause a denial of service (out-of-bounds write and application crash) or possibly have unspecified other impact via a crafted PostScript document.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void nfc_llcp_mac_is_down(struct nfc_dev *dev) { struct nfc_llcp_local *local; local = nfc_llcp_find_local(dev); if (local == NULL) return; local->remote_miu = LLCP_DEFAULT_MIU; local->remote_lto = LLCP_DEFAULT_LTO; nfc_llcp_socket_release(local, true, 0); }
Description: A use-after-free flaw was found in nfc_llcp_find_local in net/nfc/llcp_core.c in NFC in the Linux kernel. This flaw allows a local user with special privileges to impact a kernel information leak issue.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: xmlChar * xmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt, xmlDocPtr doc, xmlNodePtr elem, const xmlChar *name, const xmlChar *value) { xmlChar *ret, *dst; const xmlChar *src; xmlAttributePtr attrDecl = NULL; int extsubset = 0; if (doc == NULL) return(NULL); if (elem == NULL) return(NULL); if (name == NULL) return(NULL); if (value == NULL) return(NULL); if ((elem->ns != NULL) && (elem->ns->prefix != NULL)) { xmlChar fn[50]; xmlChar *fullname; fullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50); if (fullname == NULL) return(NULL); attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname, name); if ((attrDecl == NULL) && (doc->extSubset != NULL)) { attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullname, name); if (attrDecl != NULL) extsubset = 1; } if ((fullname != fn) && (fullname != elem->name)) xmlFree(fullname); } if ((attrDecl == NULL) && (doc->intSubset != NULL)) attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name); if ((attrDecl == NULL) && (doc->extSubset != NULL)) { attrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name); if (attrDecl != NULL) extsubset = 1; } if (attrDecl == NULL) return(NULL); if (attrDecl->atype == XML_ATTRIBUTE_CDATA) return(NULL); ret = xmlStrdup(value); if (ret == NULL) return(NULL); src = value; dst = ret; while (*src == 0x20) src++; while (*src != 0) { if (*src == 0x20) { while (*src == 0x20) src++; if (*src != 0) *dst++ = 0x20; } else { *dst++ = *src++; } } *dst = 0; if ((doc->standalone) && (extsubset == 1) && (!xmlStrEqual(value, ret))) { xmlErrValidNode(ctxt, elem, XML_DTD_NOT_STANDALONE, ""standalone: %s on %s value had to be normalized based on external subset declaration\n"", name, elem->name, NULL); ctxt->valid = 0; } return(ret); }
Description: valid.c in libxml2 before 2.9.13 has a use-after-free of ID and IDREF attributes.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int vsock_stream_recvmsg(struct socket *sock, struct msghdr *msg, size_t len, int flags) { struct sock *sk; struct vsock_sock *vsk; const struct vsock_transport *transport; int err; size_t target; ssize_t copied; long timeout; struct vsock_transport_recv_notify_data recv_data; DEFINE_WAIT(wait); sk = sock->sk; vsk = vsock_sk(sk); transport = vsk->transport; err = 0; lock_sock(sk); if (!transport || sk->sk_state != TCP_ESTABLISHED) { if (sock_flag(sk, SOCK_DONE)) err = 0; else err = -ENOTCONN; goto out; } if (flags & MSG_OOB) { err = -EOPNOTSUPP; goto out; } if (sk->sk_shutdown & RCV_SHUTDOWN) { err = 0; goto out; } if (!len) { err = 0; goto out; } target = sock_rcvlowat(sk, flags & MSG_WAITALL, len); if (target >= transport->stream_rcvhiwat(vsk)) { err = -ENOMEM; goto out; } timeout = sock_rcvtimeo(sk, flags & MSG_DONTWAIT); copied = 0; err = transport->notify_recv_init(vsk, target, &recv_data); if (err < 0) goto out; while (1) { s64 ready; prepare_to_wait(sk_sleep(sk), &wait, TASK_INTERRUPTIBLE); ready = vsock_stream_has_data(vsk); if (ready == 0) { if (sk->sk_err != 0 || (sk->sk_shutdown & RCV_SHUTDOWN) || (vsk->peer_shutdown & SEND_SHUTDOWN)) { finish_wait(sk_sleep(sk), &wait); break; } if (timeout == 0) { err = -EAGAIN; finish_wait(sk_sleep(sk), &wait); break; } err = transport->notify_recv_pre_block( vsk, target, &recv_data); if (err < 0) { finish_wait(sk_sleep(sk), &wait); break; } release_sock(sk); timeout = schedule_timeout(timeout); lock_sock(sk); if (signal_pending(current)) { err = sock_intr_errno(timeout); finish_wait(sk_sleep(sk), &wait); break; } else if (timeout == 0) { err = -EAGAIN; finish_wait(sk_sleep(sk), &wait); break; } } else { ssize_t read; finish_wait(sk_sleep(sk), &wait); if (ready < 0) { err = -ENOMEM; goto out; } err = transport->notify_recv_pre_dequeue( vsk, target, &recv_data); if (err < 0) break; read = transport->stream_dequeue( vsk, msg, len - copied, flags); if (read < 0) { err = -ENOMEM; break; } copied += read; err = transport->notify_recv_post_dequeue( vsk, target, read, !(flags & MSG_PEEK), &recv_data); if (err < 0) goto out; if (read >= target || flags & MSG_PEEK) break; target -= read; } } if (sk->sk_err) err = -sk->sk_err; else if (sk->sk_shutdown & RCV_SHUTDOWN) err = 0; if (copied > 0) err = copied; out: release_sock(sk); return err; }
Description: A local privilege escalation was discovered in the Linux kernel before 5.10.13. Multiple race conditions in the AF_VSOCK implementation are caused by wrong locking in net/vmw_vsock/af_vsock.c. The race conditions were implicitly introduced in the commits that added VSOCK multi-transport support.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: status_t MPEG4Extractor::readMetaData() { if (mInitCheck != NO_INIT) { return mInitCheck; } off64_t offset = 0; status_t err; bool sawMoovOrSidx = false; while (!(sawMoovOrSidx && (mMdatFound || mMoofFound))) { off64_t orig_offset = offset; err = parseChunk(&offset, 0); if (err != OK && err != UNKNOWN_ERROR) { break; } else if (offset <= orig_offset) { ALOGE(""did not advance: %lld->%lld"", (long long)orig_offset, (long long)offset); err = ERROR_MALFORMED; break; } else if (err == UNKNOWN_ERROR) { sawMoovOrSidx = true; } } if (mInitCheck == OK) { if (mHasVideo) { mFileMetaData->setCString( kKeyMIMEType, MEDIA_MIMETYPE_CONTAINER_MPEG4); } else { mFileMetaData->setCString(kKeyMIMEType, ""audio/mp4""); } } else { mInitCheck = err; } CHECK_NE(err, (status_t)NO_INIT); uint64_t psshsize = 0; for (size_t i = 0; i < mPssh.size(); i++) { psshsize += 20 + mPssh[i].datalen; } if (psshsize > 0 && psshsize <= UINT32_MAX) { char *buf = (char*)malloc(psshsize); char *ptr = buf; for (size_t i = 0; i < mPssh.size(); i++) { memcpy(ptr, mPssh[i].uuid, 20);             memcpy(ptr + 20, mPssh[i].data, mPssh[i].datalen); ptr += (20 + mPssh[i].datalen); } mFileMetaData->setData(kKeyPssh, 'pssh', buf, psshsize); free(buf); } return mInitCheck; }
Description: mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 does not limit process-memory usage, which allows remote attackers to cause a denial of service (device hang or reboot) via a crafted media file, aka internal bug 28615448.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int sendMessageEnet(short ptype, short paylen, const void* payload) { PNVCTL_ENET_PACKET_HEADER packet; ENetPacket* enetPacket; ENetEvent event; int err; LC_ASSERT(ServerMajorVersion >= 5); if (peer == NULL) { return 0; } packet = malloc(sizeof(*packet) + paylen); if (packet == NULL) { return 0; } packet->type = ptype; memcpy(&packet[1], payload, paylen); while ((err = serviceEnetHost(client, &event, 0)) > 0) { if (event.type == ENET_EVENT_TYPE_RECEIVE) { enet_packet_destroy(event.packet); } else if (event.type == ENET_EVENT_TYPE_DISCONNECT) { Limelog(""Control stream received disconnect event\n""); free(packet); return 0; } } if (err < 0) { Limelog(""Control stream connection failed\n""); return 0; } enetPacket = enet_packet_create(packet, sizeof(*packet) + paylen, ENET_PACKET_FLAG_RELIABLE); if (packet == NULL) { free(packet); return 0; } if (enet_peer_send(peer, 0, enetPacket) < 0) { Limelog(""Failed to send ENet control packet\n""); enet_packet_destroy(enetPacket); free(packet); return 0; } enet_host_flush(client); free(packet); return 1; }
Description: Moonlight-common-c contains the core GameStream client code shared between Moonlight clients. Moonlight-common-c is vulnerable to buffer overflow starting in commit f57bd745b4cbed577ea654fad4701bea4d38b44c. A malicious game streaming server could exploit a buffer overflow vulnerability to crash a moonlight client. Achieving RCE is possible but unlikely, due to stack canaries in use by modern compiler toolchains. The published binaries for official clients Qt, Android, iOS/tvOS, and Embedded are built with stack canaries, but some unofficial clients may not use stack canaries. This vulnerability takes place after the pairing process, so it requires the client to be tricked into pairing to a malicious host. It is not possible to perform using a man-in-the-middle due to public key pinning that takes place during the pairing process. The bug was addressed in commit b2497a3918a6d79808d9fd0c04734786e70d5954.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int usbip_recv_xbuff(struct usbip_device *ud, struct urb *urb) { int ret; int size; if (ud->side == USBIP_STUB) { if (usb_pipein(urb->pipe)) return 0; size = urb->transfer_buffer_length; } else { if (usb_pipeout(urb->pipe)) return 0; size = urb->actual_length; } if (!(size > 0)) return 0; ret = usbip_recv(ud->tcp_socket, urb->transfer_buffer, size); if (ret != size) { dev_err(&urb->dev->dev, ""recv xbuf, %d\n"", ret); if (ud->side == USBIP_STUB) { usbip_event_add(ud, SDEV_EVENT_ERROR_TCP); } else { usbip_event_add(ud, VDEV_EVENT_ERROR_TCP); return -EPIPE; } } return ret; }
Description: The usbip_recv_xbuff function in drivers/usb/usbip/usbip_common.c in the Linux kernel before 4.5.3 allows remote attackers to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact via a crafted length value in a USB/IP packet.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int fuse_dev_release(struct inode *inode, struct file *file) { struct fuse_conn *fc = fuse_get_conn(file); if (fc) { WARN_ON(!list_empty(&fc->pq.io)); WARN_ON(fc->iq.fasync != NULL); fuse_abort_conn(fc); fuse_conn_put(fc); } return 0; }
Description: Memory leak in the cuse_channel_release function in fs/fuse/cuse.c in the Linux kernel before 4.4 allows local users to cause a denial of service (memory consumption) or possibly have unspecified other impact by opening /dev/cuse many times.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: TfLiteStatus Eval(TfLiteContext* context, TfLiteNode* node) { auto* params = reinterpret_cast<TfLiteDivParams*>(node->builtin_data); OpData* data = reinterpret_cast<OpData*>(node->user_data); const TfLiteTensor* input1; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor1, &input1)); const TfLiteTensor* input2; TF_LITE_ENSURE_OK(context, GetInputSafe(context, node, kInputTensor2, &input2)); TfLiteTensor* output; TF_LITE_ENSURE_OK(context, GetOutputSafe(context, node, kOutputTensor, &output)); if (output->type == kTfLiteFloat32 || output->type == kTfLiteInt32) { EvalDiv<kernel_type>(context, node, params, data, input1, input2, output); } else if (output->type == kTfLiteUInt8) { TF_LITE_ENSURE_OK( context, EvalQuantized<kernel_type>(context, node, params, data, input1, input2, output)); } else { context->ReportError( context, ""Div only supports FLOAT32, INT32 and quantized UINT8 now, got %d."", output->type); return kTfLiteError; } return kTfLiteOk; }
Description: TensorFlow is an end-to-end open source platform for machine learning. In affected versions the implementation of division in TFLite is [vulnerable to a division by 0 error](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/lite/kernels/div.cc). There is no check that the divisor tensor does not contain zero elements. We have patched the issue in GitHub commit 1e206baedf8bef0334cca3eb92bab134ef525a28. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: u_int juniper_ggsn_print(netdissect_options *ndo, const struct pcap_pkthdr *h, register const u_char *p) { struct juniper_l2info_t l2info; struct juniper_ggsn_header { uint8_t svc_id; uint8_t flags_len; uint8_t proto; uint8_t flags; uint8_t vlan_id[2]; uint8_t res[2]; }; const struct juniper_ggsn_header *gh; l2info.pictype = DLT_JUNIPER_GGSN; if (juniper_parse_header(ndo, p, h, &l2info) == 0) return l2info.header_len; p+=l2info.header_len; gh = (struct juniper_ggsn_header *)&l2info.cookie; if (ndo->ndo_eflag) { ND_PRINT((ndo, ""proto %s (%u), vlan %u: "", tok2str(juniper_protocol_values,""Unknown"",gh->proto), gh->proto, EXTRACT_16BITS(&gh->vlan_id[0]))); } switch (gh->proto) { case JUNIPER_PROTO_IPV4: ip_print(ndo, p, l2info.length); break; case JUNIPER_PROTO_IPV6: ip6_print(ndo, p, l2info.length); break; default: if (!ndo->ndo_eflag) ND_PRINT((ndo, ""unknown GGSN proto (%u)"", gh->proto)); } return l2info.header_len; }
Description: The Juniper protocols parser in tcpdump before 4.9.2 has a buffer over-read in print-juniper.c, several functions.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static enum XML_Error storeAtts(XML_Parser parser, const ENCODING *enc, const char *attStr, TAG_NAME *tagNamePtr, BINDING **bindingsPtr, enum XML_Account account) { DTD *const dtd = parser->m_dtd;  ELEMENT_TYPE *elementType; int nDefaultAtts; const XML_Char **appAtts;  int attIndex = 0; int prefixLen; int i; int n; XML_Char *uri; int nPrefixes = 0; BINDING *binding; const XML_Char *localPart; elementType = (ELEMENT_TYPE *)lookup(parser, &dtd->elementTypes, tagNamePtr->str, 0); if (! elementType) { const XML_Char *name = poolCopyString(&dtd->pool, tagNamePtr->str); if (! name) return XML_ERROR_NO_MEMORY; elementType = (ELEMENT_TYPE *)lookup(parser, &dtd->elementTypes, name, sizeof(ELEMENT_TYPE)); if (! elementType) return XML_ERROR_NO_MEMORY; if (parser->m_ns && ! setElementTypePrefix(parser, elementType)) return XML_ERROR_NO_MEMORY; } nDefaultAtts = elementType->nDefaultAtts; n = XmlGetAttributes(enc, attStr, parser->m_attsSize, parser->m_atts); if (n + nDefaultAtts > parser->m_attsSize) { int oldAttsSize = parser->m_attsSize; ATTRIBUTE *temp; #ifdef XML_ATTR_INFO XML_AttrInfo *temp2; #endif parser->m_attsSize = n + nDefaultAtts + INIT_ATTS_SIZE; temp = (ATTRIBUTE *)REALLOC(parser, (void *)parser->m_atts, parser->m_attsSize * sizeof(ATTRIBUTE)); if (temp == NULL) { parser->m_attsSize = oldAttsSize; return XML_ERROR_NO_MEMORY; } parser->m_atts = temp; #ifdef XML_ATTR_INFO temp2 = (XML_AttrInfo *)REALLOC(parser, (void *)parser->m_attInfo, parser->m_attsSize * sizeof(XML_AttrInfo)); if (temp2 == NULL) { parser->m_attsSize = oldAttsSize; return XML_ERROR_NO_MEMORY; } parser->m_attInfo = temp2; #endif if (n > oldAttsSize) XmlGetAttributes(enc, attStr, n, parser->m_atts); } appAtts = (const XML_Char **)parser->m_atts; for (i = 0; i < n; i++) { ATTRIBUTE *currAtt = &parser->m_atts[i]; #ifdef XML_ATTR_INFO XML_AttrInfo *currAttInfo = &parser->m_attInfo[i]; #endif ATTRIBUTE_ID *attId = getAttributeId(parser, enc, currAtt->name, currAtt->name + XmlNameLength(enc, currAtt->name)); if (! attId) return XML_ERROR_NO_MEMORY; #ifdef XML_ATTR_INFO currAttInfo->nameStart = parser->m_parseEndByteIndex - (parser->m_parseEndPtr - currAtt->name); currAttInfo->nameEnd = currAttInfo->nameStart + XmlNameLength(enc, currAtt->name); currAttInfo->valueStart = parser->m_parseEndByteIndex - (parser->m_parseEndPtr - currAtt->valuePtr); currAttInfo->valueEnd = parser->m_parseEndByteIndex - (parser->m_parseEndPtr - currAtt->valueEnd); #endif if ((attId->name)[-1]) { if (enc == parser->m_encoding) parser->m_eventPtr = parser->m_atts[i].name; return XML_ERROR_DUPLICATE_ATTRIBUTE; } (attId->name)[-1] = 1; appAtts[attIndex++] = attId->name; if (! parser->m_atts[i].normalized) { enum XML_Error result; XML_Bool isCdata = XML_TRUE; if (attId->maybeTokenized) { int j; for (j = 0; j < nDefaultAtts; j++) { if (attId == elementType->defaultAtts[j].id) { isCdata = elementType->defaultAtts[j].isCdata; break; } } } result = storeAttributeValue( parser, enc, isCdata, parser->m_atts[i].valuePtr, parser->m_atts[i].valueEnd, &parser->m_tempPool, account); if (result) return result; appAtts[attIndex] = poolStart(&parser->m_tempPool); poolFinish(&parser->m_tempPool); } else { appAtts[attIndex] = poolStoreString(&parser->m_tempPool, enc, parser->m_atts[i].valuePtr, parser->m_atts[i].valueEnd); if (appAtts[attIndex] == 0) return XML_ERROR_NO_MEMORY; poolFinish(&parser->m_tempPool); } if (attId->prefix) { if (attId->xmlns) { enum XML_Error result = addBinding(parser, attId->prefix, attId, appAtts[attIndex], bindingsPtr); if (result) return result; --attIndex; } else { attIndex++; nPrefixes++; (attId->name)[-1] = 2; } } else attIndex++; } parser->m_nSpecifiedAtts = attIndex; if (elementType->idAtt && (elementType->idAtt->name)[-1]) { for (i = 0; i < attIndex; i += 2) if (appAtts[i] == elementType->idAtt->name) { parser->m_idAttIndex = i; break; } } else parser->m_idAttIndex = -1; for (i = 0; i < nDefaultAtts; i++) { const DEFAULT_ATTRIBUTE *da = elementType->defaultAtts + i; if (! (da->id->name)[-1] && da->value) { if (da->id->prefix) { if (da->id->xmlns) { enum XML_Error result = addBinding(parser, da->id->prefix, da->id, da->value, bindingsPtr); if (result) return result; } else { (da->id->name)[-1] = 2; nPrefixes++; appAtts[attIndex++] = da->id->name; appAtts[attIndex++] = da->value; } } else { (da->id->name)[-1] = 1; appAtts[attIndex++] = da->id->name; appAtts[attIndex++] = da->value; } } } appAtts[attIndex] = 0; i = 0; if (nPrefixes) { int j;  unsigned long version = parser->m_nsAttsVersion; int nsAttsSize = (int)1 << parser->m_nsAttsPower; unsigned char oldNsAttsPower = parser->m_nsAttsPower; if ((nPrefixes << 1) >> parser->m_nsAttsPower) {  NS_ATT *temp; while (nPrefixes >> parser->m_nsAttsPower++) ; if (parser->m_nsAttsPower < 3) parser->m_nsAttsPower = 3; nsAttsSize = (int)1 << parser->m_nsAttsPower; temp = (NS_ATT *)REALLOC(parser, parser->m_nsAtts, nsAttsSize * sizeof(NS_ATT)); if (! temp) { parser->m_nsAttsPower = oldNsAttsPower; return XML_ERROR_NO_MEMORY; } parser->m_nsAtts = temp; version = 0;  } if (! version) {  version = INIT_ATTS_VERSION; for (j = nsAttsSize; j != 0;) parser->m_nsAtts[--j].version = version; } parser->m_nsAttsVersion = --version; for (; i < attIndex; i += 2) { const XML_Char *s = appAtts[i]; if (s[-1] == 2) {  ATTRIBUTE_ID *id; const BINDING *b; unsigned long uriHash; struct siphash sip_state; struct sipkey sip_key; copy_salt_to_sipkey(parser, &sip_key); sip24_init(&sip_state, &sip_key); ((XML_Char *)s)[-1] = 0;  id = (ATTRIBUTE_ID *)lookup(parser, &dtd->attributeIds, s, 0); if (! id || ! id->prefix) { return XML_ERROR_NO_MEMORY;  } b = id->prefix->binding; if (! b) return XML_ERROR_UNBOUND_PREFIX; for (j = 0; j < b->uriLen; j++) { const XML_Char c = b->uri[j]; if (! poolAppendChar(&parser->m_tempPool, c)) return XML_ERROR_NO_MEMORY; } sip24_update(&sip_state, b->uri, b->uriLen * sizeof(XML_Char)); while (*s++ != XML_T(ASCII_COLON)) ; sip24_update(&sip_state, s, keylen(s) * sizeof(XML_Char)); do {  if (! poolAppendChar(&parser->m_tempPool, *s)) return XML_ERROR_NO_MEMORY; } while (*s++); uriHash = (unsigned long)sip24_final(&sip_state); {  unsigned char step = 0; unsigned long mask = nsAttsSize - 1; j = uriHash & mask;  while (parser->m_nsAtts[j].version == version) { if (uriHash == parser->m_nsAtts[j].hash) { const XML_Char *s1 = poolStart(&parser->m_tempPool); const XML_Char *s2 = parser->m_nsAtts[j].uriName; for (; *s1 == *s2 && *s1 != 0; s1++, s2++) ; if (*s1 == 0) return XML_ERROR_DUPLICATE_ATTRIBUTE; } if (! step) step = PROBE_STEP(uriHash, mask, parser->m_nsAttsPower); j < step ? (j += nsAttsSize - step) : (j -= step); } } if (parser->m_ns_triplets) {  parser->m_tempPool.ptr[-1] = parser->m_namespaceSeparator; s = b->prefix->name; do { if (! poolAppendChar(&parser->m_tempPool, *s)) return XML_ERROR_NO_MEMORY; } while (*s++); } s = poolStart(&parser->m_tempPool); poolFinish(&parser->m_tempPool); appAtts[i] = s; parser->m_nsAtts[j].version = version; parser->m_nsAtts[j].hash = uriHash; parser->m_nsAtts[j].uriName = s; if (! --nPrefixes) { i += 2; break; } } else                      ((XML_Char *)s)[-1] = 0;  } } for (; i < attIndex; i += 2) ((XML_Char *)(appAtts[i]))[-1] = 0; for (binding = *bindingsPtr; binding; binding = binding->nextTagBinding) binding->attId->name[-1] = 0; if (! parser->m_ns) return XML_ERROR_NONE; if (elementType->prefix) { binding = elementType->prefix->binding; if (! binding) return XML_ERROR_UNBOUND_PREFIX; localPart = tagNamePtr->str; while (*localPart++ != XML_T(ASCII_COLON)) ; } else if (dtd->defaultPrefix.binding) { binding = dtd->defaultPrefix.binding; localPart = tagNamePtr->str; } else return XML_ERROR_NONE; prefixLen = 0; if (parser->m_ns_triplets && binding->prefix->name) { for (; binding->prefix->name[prefixLen++];) ;  } tagNamePtr->localPart = localPart; tagNamePtr->uriLen = binding->uriLen; tagNamePtr->prefix = binding->prefix->name; tagNamePtr->prefixLen = prefixLen; for (i = 0; localPart[i++];) ;  n = i + binding->uriLen + prefixLen; if (n > binding->uriAlloc) { TAG *p; uri = (XML_Char *)MALLOC(parser, (n + EXPAND_SPARE) * sizeof(XML_Char)); if (! uri) return XML_ERROR_NO_MEMORY; binding->uriAlloc = n + EXPAND_SPARE; memcpy(uri, binding->uri, binding->uriLen * sizeof(XML_Char)); for (p = parser->m_tagStack; p; p = p->parent) if (p->name.str == binding->uri) p->name.str = uri; FREE(parser, binding->uri); binding->uri = uri; } uri = binding->uri + binding->uriLen; memcpy(uri, localPart, i * sizeof(XML_Char)); if (prefixLen) { uri += i - 1; *uri = parser->m_namespaceSeparator;  memcpy(uri + 1, binding->prefix->name, prefixLen * sizeof(XML_Char)); } tagNamePtr->str = binding->uri; return XML_ERROR_NONE; }
Description: In Expat (aka libexpat) before 2.4.3, a left shift by 29 (or more) places in the storeAtts function in xmlparse.c can lead to realloc misbehavior (e.g., allocating too few bytes, or only freeing memory).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: DataBuf LoaderTiff::getData() const { const ExifData &exifData = image_.exifData(); ExifData preview; for (ExifData::const_iterator pos = exifData.begin(); pos != exifData.end(); ++pos) { if (pos->groupName() == group_) { uint16_t tag = pos->tag(); if (tag != 0x00fe && tag != 0x00ff && Internal::isTiffImageTag(tag, Internal::ifd0Id)) { preview.add(ExifKey(tag, ""Image""), &pos->value()); } } } Value &dataValue = const_cast<Value&>(preview[""Exif.Image."" + offsetTag_].value()); if (dataValue.sizeDataArea() == 0) { BasicIo &io = image_.io(); if (io.open() != 0) { throw Error(kerDataSourceOpenFailed, io.path(), strError()); } IoCloser closer(io); const Exiv2::byte* base = io.mmap(); const Value &sizes = preview[""Exif.Image."" + sizeTag_].value(); if (sizes.count() == dataValue.count()) { if (sizes.count() == 1) { uint32_t offset = dataValue.toLong(0); uint32_t size = sizes.toLong(0); if (offset + size <= static_cast<uint32_t>(io.size())) dataValue.setDataArea(base + offset, size); } else { DataBuf buf(size_); Exiv2::byte* pos = buf.pData_; for (int i = 0; i < sizes.count(); i++) { uint32_t offset = dataValue.toLong(i); uint32_t size = sizes.toLong(i); if (size!=0 && offset + size <= static_cast<uint32_t>(io.size())) memcpy(pos, base + offset, size); pos += size; } dataValue.setDataArea(buf.pData_, buf.size_); } } } if (0 == strcmp(group_, ""Image2"") && image_.mimeType() == ""image/x-canon-cr2"") { preview[""Exif.Image.Compression""] = uint16_t(1); } MemIo mio; IptcData emptyIptc; XmpData  emptyXmp; TiffParser::encode(mio, 0, 0, Exiv2::littleEndian, preview, emptyIptc, emptyXmp); return DataBuf(mio.mmap(), (long) mio.size()); }
Description: Exiv2 0.26 has a heap-based buffer overflow in getData in preview.cpp.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Status AudioPolicyService::startInput(int32_t portIdAidl) { audio_port_handle_t portId = VALUE_OR_RETURN_BINDER_STATUS( aidl2legacy_int32_t_audio_port_handle_t(portIdAidl)); if (mAudioPolicyManager == NULL) { return binderStatusFromStatusT(NO_INIT); } sp<AudioRecordClient> client; { Mutex::Autolock _l(mLock); ssize_t index = mAudioRecordClients.indexOfKey(portId); if (index < 0) { return binderStatusFromStatusT(INVALID_OPERATION); } client = mAudioRecordClients.valueAt(index); } std::stringstream msg; msg << ""Audio recording on session "" << client->session; if (!(startRecording(client->attributionSource, String16(msg.str().c_str()), client->attributes.source) || client->attributes.source == AUDIO_SOURCE_FM_TUNER || client->attributes.source == AUDIO_SOURCE_REMOTE_SUBMIX || client->attributes.source == AUDIO_SOURCE_ECHO_REFERENCE)) { ALOGE(""%s permission denied: recording not allowed for attribution source %s"", __func__, client->attributionSource.toString().c_str()); return binderStatusFromStatusT(PERMISSION_DENIED); } Mutex::Autolock _l(mLock); client->active = true; client->startTimeNs = systemTime(); updateUidStates_l(); status_t status; { AutoCallerClear acc; status = mAudioPolicyManager->startInput(portId); } if (status != NO_ERROR) { static constexpr char kAudioPolicy[] = ""audiopolicy""; static constexpr char kAudioPolicyStatus[] = ""android.media.audiopolicy.status""; static constexpr char kAudioPolicyRqstSrc[] = ""android.media.audiopolicy.rqst.src""; static constexpr char kAudioPolicyRqstPkg[] = ""android.media.audiopolicy.rqst.pkg""; static constexpr char kAudioPolicyRqstSession[] = ""android.media.audiopolicy.rqst.session""; static constexpr char kAudioPolicyRqstDevice[] = ""android.media.audiopolicy.rqst.device""; static constexpr char kAudioPolicyActiveSrc[] = ""android.media.audiopolicy.active.src""; static constexpr char kAudioPolicyActivePkg[] = ""android.media.audiopolicy.active.pkg""; static constexpr char kAudioPolicyActiveSession[] = ""android.media.audiopolicy.active.session""; static constexpr char kAudioPolicyActiveDevice[] = ""android.media.audiopolicy.active.device""; mediametrics::Item *item = mediametrics::Item::create(kAudioPolicy); if (item != NULL) { item->setInt32(kAudioPolicyStatus, status); item->setCString(kAudioPolicyRqstSrc, toString(client->attributes.source).c_str()); item->setInt32(kAudioPolicyRqstSession, client->session); if (client->attributionSource.packageName.has_value() && client->attributionSource.packageName.value().size() != 0) { item->setCString(kAudioPolicyRqstPkg, client->attributionSource.packageName.value().c_str()); } else { item->setCString(kAudioPolicyRqstPkg, std::to_string(client->attributionSource.uid).c_str()); } item->setCString( kAudioPolicyRqstDevice, getDeviceTypeStrForPortId(client->deviceId).c_str()); int count = mAudioRecordClients.size(); for (int i = 0; i < count ; i++) { if (portId == mAudioRecordClients.keyAt(i)) { continue; } sp<AudioRecordClient> other = mAudioRecordClients.valueAt(i); if (other->active) { item->setCString(kAudioPolicyActiveSrc, toString(other->attributes.source).c_str()); item->setInt32(kAudioPolicyActiveSession, other->session); if (other->attributionSource.packageName.has_value() && other->attributionSource.packageName.value().size() != 0) { item->setCString(kAudioPolicyActivePkg, other->attributionSource.packageName.value().c_str()); } else { item->setCString(kAudioPolicyRqstPkg, std::to_string( other->attributionSource.uid).c_str()); } item->setCString(kAudioPolicyActiveDevice, getDeviceTypeStrForPortId(other->deviceId).c_str()); } } item->selfrecord(); delete item; item = NULL; } } if (status != NO_ERROR) { client->active = false; client->startTimeNs = 0; updateUidStates_l(); finishRecording(client->attributionSource, client->attributes.source); } return binderStatusFromStatusT(status); }
Description: In startInput of AudioPolicyInterfaceImpl.cpp, there is a possible way of erroneously displaying the microphone privacy indicator due to a race condition. This could lead to false user expectations. User interaction is needed for exploitation.


 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static inline void free_ep_req(struct usb_ep *ep, struct usb_request *req) { kfree(req->buf); usb_ep_free_request(ep, req); }
Description: In the Linux kernel before 4.16.4, a double free vulnerability in the f_midi_set_alt function of drivers/usb/gadget/function/f_midi.c in the f_midi driver may allow attackers to cause a denial of service or possibly have unspecified other impact.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int nfc_genl_llc_sdreq(struct sk_buff *skb, struct genl_info *info) { struct nfc_dev *dev; struct nfc_llcp_local *local; struct nlattr *attr, *sdp_attrs[NFC_SDP_ATTR_MAX+1]; u32 idx; u8 tid; char *uri; int rc = 0, rem; size_t uri_len, tlvs_len; struct hlist_head sdreq_list; struct nfc_llcp_sdp_tlv *sdreq; if (!info->attrs[NFC_ATTR_DEVICE_INDEX] || !info->attrs[NFC_ATTR_LLC_SDP]) return -EINVAL; idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]); dev = nfc_get_device(idx); if (!dev) return -ENODEV; device_lock(&dev->dev); if (dev->dep_link_up == false) { rc = -ENOLINK; goto exit; } local = nfc_llcp_find_local(dev); if (!local) { rc = -ENODEV; goto exit; } INIT_HLIST_HEAD(&sdreq_list); tlvs_len = 0; nla_for_each_nested(attr, info->attrs[NFC_ATTR_LLC_SDP], rem) { rc = nla_parse_nested_deprecated(sdp_attrs, NFC_SDP_ATTR_MAX, attr, nfc_sdp_genl_policy, info->extack); if (rc != 0) { rc = -EINVAL; goto exit; } if (!sdp_attrs[NFC_SDP_ATTR_URI]) continue; uri_len = nla_len(sdp_attrs[NFC_SDP_ATTR_URI]); if (uri_len == 0) continue; uri = nla_data(sdp_attrs[NFC_SDP_ATTR_URI]); if (uri == NULL || *uri == 0) continue; tid = local->sdreq_next_tid++; sdreq = nfc_llcp_build_sdreq_tlv(tid, uri, uri_len); if (sdreq == NULL) { rc = -ENOMEM; goto exit; } tlvs_len += sdreq->tlv_len; hlist_add_head(&sdreq->node, &sdreq_list); } if (hlist_empty(&sdreq_list)) { rc = -EINVAL; goto exit; } rc = nfc_llcp_send_snl_sdreq(local, &sdreq_list, tlvs_len); exit: device_unlock(&dev->dev); nfc_put_device(dev); return rc; }
Description: A use-after-free flaw was found in nfc_llcp_find_local in net/nfc/llcp_core.c in NFC in the Linux kernel. This flaw allows a local user with special privileges to impact a kernel information leak issue.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void handleMetaReferrer(const String& attributeValue, CachedDocumentParameters* documentParameters, CSSPreloadScanner* cssScanner) { if (attributeValue.isEmpty() || attributeValue.isNull() || !SecurityPolicy::referrerPolicyFromString(attributeValue, &documentParameters->referrerPolicy)) { documentParameters->referrerPolicy = ReferrerPolicyDefault; } cssScanner->setReferrerPolicy(documentParameters->referrerPolicy); }
Description: WebKit/Source/core/html/parser/HTMLPreloadScanner.cpp in Blink, as used in Google Chrome before 52.0.2743.82, does not consider referrer-policy information inside an HTML document during a preload request, which allows remote attackers to bypass the Content Security Policy (CSP) protection mechanism via a crafted web site, as demonstrated by a ""Content-Security-Policy: referrer origin-when-cross-origin"" header that overrides a ""<META name='referrer' content='no-referrer'>"" element.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void SoftAMR::onQueueFilled(OMX_U32 ) { List<BufferInfo *> &inQueue = getPortQueue(0); List<BufferInfo *> &outQueue = getPortQueue(1); if (mSignalledError || mOutputPortSettingsChange != NONE) { return; } while (!inQueue.empty() && !outQueue.empty()) { BufferInfo *inInfo = *inQueue.begin(); OMX_BUFFERHEADERTYPE *inHeader = inInfo->mHeader; BufferInfo *outInfo = *outQueue.begin(); OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader; if (inHeader->nFlags & OMX_BUFFERFLAG_EOS) { inQueue.erase(inQueue.begin()); inInfo->mOwnedByUs = false; notifyEmptyBufferDone(inHeader); outHeader->nFilledLen = 0; outHeader->nFlags = OMX_BUFFERFLAG_EOS; outQueue.erase(outQueue.begin()); outInfo->mOwnedByUs = false; notifyFillBufferDone(outHeader); return; } if (inHeader->nOffset == 0) { mAnchorTimeUs = inHeader->nTimeStamp; mNumSamplesOutput = 0; } const uint8_t *inputPtr = inHeader->pBuffer + inHeader->nOffset; int32_t numBytesRead; if (mMode == MODE_NARROW) { if (outHeader->nAllocLen < kNumSamplesPerFrameNB * sizeof(int16_t)) { ALOGE(""b/27662364: NB expected output buffer %zu bytes vs %u"", kNumSamplesPerFrameNB * sizeof(int16_t), outHeader->nAllocLen); android_errorWriteLog(0x534e4554, ""27662364""); notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL); mSignalledError = true; return; } numBytesRead = AMRDecode(mState, (Frame_Type_3GPP)((inputPtr[0] >> 3) & 0x0f), (UWord8 *)&inputPtr[1], reinterpret_cast<int16_t *>(outHeader->pBuffer), MIME_IETF); if (numBytesRead == -1) { ALOGE(""PV AMR decoder AMRDecode() call failed""); notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL); mSignalledError = true; return; } ++numBytesRead;   if (static_cast<size_t>(numBytesRead) > inHeader->nFilledLen) { notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL); mSignalledError = true; return; } } else { if (outHeader->nAllocLen < kNumSamplesPerFrameWB * sizeof(int16_t)) { ALOGE(""b/27662364: WB expected output buffer %zu bytes vs %u"", kNumSamplesPerFrameWB * sizeof(int16_t), outHeader->nAllocLen); android_errorWriteLog(0x534e4554, ""27662364""); notify(OMX_EventError, OMX_ErrorOverflow, 0, NULL); mSignalledError = true; return; } int16 mode = ((inputPtr[0] >> 3) & 0x0f); if (mode >= 10 && mode <= 13) { ALOGE(""encountered illegal frame type %d in AMR WB content."", mode); notify(OMX_EventError, OMX_ErrorUndefined, 0, NULL); mSignalledError = true; return; } size_t frameSize = getFrameSize(mode); CHECK_GE(inHeader->nFilledLen, frameSize); int16_t *outPtr = (int16_t *)outHeader->pBuffer; if (mode >= 9) { memset(outPtr, 0, kNumSamplesPerFrameWB * sizeof(int16_t)); } else if (mode < 9) { int16 frameType; RX_State_wb rx_state; mime_unsorting( const_cast<uint8_t *>(&inputPtr[1]), mInputSampleBuffer, &frameType, &mode, 1, &rx_state); int16_t numSamplesOutput; pvDecoder_AmrWb( mode, mInputSampleBuffer, outPtr, &numSamplesOutput, mDecoderBuf, frameType, mDecoderCookie); CHECK_EQ((int)numSamplesOutput, (int)kNumSamplesPerFrameWB); for (int i = 0; i < kNumSamplesPerFrameWB; ++i) { outPtr[i] &= 0xfffC; } } numBytesRead = frameSize; } inHeader->nOffset += numBytesRead; inHeader->nFilledLen -= numBytesRead; outHeader->nFlags = 0; outHeader->nOffset = 0; if (mMode == MODE_NARROW) { outHeader->nFilledLen = kNumSamplesPerFrameNB * sizeof(int16_t); outHeader->nTimeStamp = mAnchorTimeUs + (mNumSamplesOutput * 1000000ll) / kSampleRateNB; mNumSamplesOutput += kNumSamplesPerFrameNB; } else { outHeader->nFilledLen = kNumSamplesPerFrameWB * sizeof(int16_t); outHeader->nTimeStamp = mAnchorTimeUs + (mNumSamplesOutput * 1000000ll) / kSampleRateWB; mNumSamplesOutput += kNumSamplesPerFrameWB; } if (inHeader->nFilledLen == 0) { inInfo->mOwnedByUs = false; inQueue.erase(inQueue.begin()); inInfo = NULL; notifyEmptyBufferDone(inHeader); inHeader = NULL; } outInfo->mOwnedByUs = false; outQueue.erase(outQueue.begin()); outInfo = NULL; notifyFillBufferDone(outHeader); outHeader = NULL; ++mInputBufferCount; } }
Description: codecs/amrnb/dec/SoftAMR.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-05-01 does not validate buffer sizes, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bugs 27662364 and 27843673.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: PdfObject* PdfDictionary::findKeyParent(const string_view& key) const { utls::RecursionGuard guard; PdfObject* obj = findKey(key); if (obj == nullptr) { PdfObject* parent = findKey(""Parent""); if (parent == nullptr) { return nullptr; } else { if (parent->IsDictionary()) return parent->GetDictionary().findKeyParent(key); else return nullptr; } } else { return obj; } }
Description: podofoinfo 0.10.0 was discovered to contain a segmentation violation via the function PoDoFo::PdfDictionary::findKeyParent.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void xen_free_irq(unsigned irq) { struct irq_info *info = info_for_irq(irq); unsigned long flags; if (WARN_ON(!info)) return; write_lock_irqsave(&evtchn_rwlock, flags); list_del(&info->list); set_info_for_irq(irq, NULL); WARN_ON(info->refcnt > 0); write_unlock_irqrestore(&evtchn_rwlock, flags); kfree(info); if (irq < nr_legacy_irqs()) return; irq_free_desc(irq); }
Description: An issue was discovered in the Linux kernel through 5.9.1, as used with Xen through 4.14.x. Guest OS users can cause a denial of service (host OS hang) via a high rate of events to dom0, aka CID-e99502f76271.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: FT_CALLBACK_DEF( FT_Error ) tt_cmap14_validate( FT_Byte*      table, FT_Validator  valid ) { FT_Byte*  p; FT_ULong  length; FT_ULong  num_selectors; if ( table + 2 + 4 + 4 > valid->limit ) FT_INVALID_TOO_SHORT; p             = table + 2; length        = TT_NEXT_ULONG( p ); num_selectors = TT_NEXT_ULONG( p ); if ( length > (FT_ULong)( valid->limit - table ) || length < 10                                 || ( length - 10 ) / 11 < num_selectors        ) FT_INVALID_TOO_SHORT; { FT_ULong  n, lastVarSel = 1; for ( n = 0; n < num_selectors; n++ ) { FT_ULong  varSel    = TT_NEXT_UINT24( p ); FT_ULong  defOff    = TT_NEXT_ULONG( p ); FT_ULong  nondefOff = TT_NEXT_ULONG( p ); if ( defOff >= length || nondefOff >= length ) FT_INVALID_TOO_SHORT; if ( varSel < lastVarSel ) FT_INVALID_DATA; lastVarSel = varSel + 1; if ( defOff != 0 ) { FT_Byte*  defp      = table + defOff; FT_ULong  numRanges = TT_NEXT_ULONG( defp ); FT_ULong  i; FT_ULong  lastBase  = 0; if ( numRanges > (FT_ULong)( valid->limit - defp ) / 4 ) FT_INVALID_TOO_SHORT; for ( i = 0; i < numRanges; ++i ) { FT_ULong  base = TT_NEXT_UINT24( defp ); FT_ULong  cnt  = FT_NEXT_BYTE( defp ); if ( base + cnt >= 0x110000UL )               FT_INVALID_DATA; if ( base < lastBase ) FT_INVALID_DATA; lastBase = base + cnt + 1U; } } if ( nondefOff != 0 ) { FT_Byte*  ndp         = table + nondefOff; FT_ULong  numMappings = TT_NEXT_ULONG( ndp ); FT_ULong  i, lastUni  = 0; if ( numMappings > ( (FT_ULong)( valid->limit - ndp ) ) / 4 ) FT_INVALID_TOO_SHORT; for ( i = 0; i < numMappings; ++i ) { FT_ULong  uni = TT_NEXT_UINT24( ndp ); FT_ULong  gid = TT_NEXT_USHORT( ndp ); if ( uni >= 0x110000UL )                      FT_INVALID_DATA; if ( uni < lastUni ) FT_INVALID_DATA; lastUni = uni + 1U; if ( valid->level >= FT_VALIDATE_TIGHT    && gid >= TT_VALID_GLYPH_COUNT( valid ) ) FT_INVALID_GLYPH_ID; } } } } return FT_Err_Ok; }
Description: FreeType before 2.6.2 has a heap-based buffer over-read in tt_cmap14_validate in sfnt/ttcmap.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static pyc_object *get_complex_object(RzBinPycObj *pyc, RzBuffer *buffer) { pyc_object *ret = NULL; bool error = false; ut32 size = 0; ut32 n1 = 0; ut32 n2 = 0; ret = RZ_NEW0(pyc_object); if (!ret) { return NULL; } if ((pyc->magic_int & 0xffff) <= 62061) { n1 = get_ut8(buffer, &error); } else { n1 = get_st32(buffer, &error); } if (error) { free(ret); return NULL; } ut8 *s1 = malloc(n1 + 1); if (!s1) { return NULL; } size = rz_buf_read(buffer, s1, n1); if (size != n1) { RZ_FREE(s1); RZ_FREE(ret); return NULL; } s1[n1] = '\0'; if ((pyc->magic_int & 0xffff) <= 62061) { n2 = get_ut8(buffer, &error); } else n2 = get_st32(buffer, &error); if (error) { return NULL; } ut8 *s2 = malloc(n2 + 1); if (!s2) { return NULL; } size = rz_buf_read(buffer, s2, n2); if (size != n2) { RZ_FREE(s1); RZ_FREE(s2); RZ_FREE(ret); return NULL; } s2[n2] = '\0'; ret->type = TYPE_COMPLEX; ret->data = rz_str_newf(""%s+%sj"", s1, s2); RZ_FREE(s1); RZ_FREE(s2); if (!ret->data) { RZ_FREE(ret); return NULL; } return ret; }
Description: Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting data from PYC(python) files. A user opening a malicious PYC file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commit number 68948017423a12786704e54227b8b2f918c2fd27 contains a patch.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb) { int i; unsigned char max_level = 0; int unix_sock_count = 0; for (i = scm->fp->count - 1; i >= 0; i--) { struct sock *sk = unix_get_socket(scm->fp->fp[i]); if (sk) { unix_sock_count++; max_level = max(max_level, unix_sk(sk)->recursion_level); } } if (unlikely(max_level > MAX_RECURSION_LEVEL)) return -ETOOMANYREFS; UNIXCB(skb).fp = scm_fp_dup(scm->fp); if (!UNIXCB(skb).fp) return -ENOMEM; if (unix_sock_count) { for (i = scm->fp->count - 1; i >= 0; i--) unix_inflight(scm->fp->fp[i]); } return max_level; }
Description: The Linux kernel before 4.4.1 allows local users to bypass file-descriptor limits and cause a denial of service (memory consumption) by sending each descriptor over a UNIX socket before closing it, related to net/unix/af_unix.c and net/unix/garbage.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int f2fs_move_inline_dirents(struct inode *dir, struct page *ipage, struct f2fs_inline_dentry *inline_dentry) { struct page *page; struct dnode_of_data dn; struct f2fs_dentry_block *dentry_blk; int err; page = grab_cache_page(dir->i_mapping, 0); if (!page) { f2fs_put_page(ipage, 1); return -ENOMEM; } set_new_dnode(&dn, dir, ipage, NULL, 0); err = f2fs_reserve_block(&dn, 0); if (err) goto out; f2fs_wait_on_page_writeback(page, DATA); zero_user_segment(page, MAX_INLINE_DATA, PAGE_CACHE_SIZE); dentry_blk = kmap_atomic(page); memcpy(dentry_blk->dentry_bitmap, inline_dentry->dentry_bitmap, INLINE_DENTRY_BITMAP_SIZE); memset(dentry_blk->dentry_bitmap + INLINE_DENTRY_BITMAP_SIZE, 0, SIZE_OF_DENTRY_BITMAP - INLINE_DENTRY_BITMAP_SIZE); memcpy(dentry_blk->dentry, inline_dentry->dentry, sizeof(struct f2fs_dir_entry) * NR_INLINE_DENTRY); memcpy(dentry_blk->filename, inline_dentry->filename, NR_INLINE_DENTRY * F2FS_SLOT_LEN); kunmap_atomic(dentry_blk); SetPageUptodate(page); set_page_dirty(page); truncate_inline_inode(ipage, 0); stat_dec_inline_dir(dir); clear_inode_flag(F2FS_I(dir), FI_INLINE_DENTRY); if (i_size_read(dir) < PAGE_CACHE_SIZE) { i_size_write(dir, PAGE_CACHE_SIZE); set_inode_flag(F2FS_I(dir), FI_UPDATE_DIR); } sync_inode_page(&dn); out: f2fs_put_page(page, 1); return err; }
Description: An issue was discovered in fs/f2fs/inline.c in the Linux kernel through 4.4. A denial of service (out-of-bounds memory access and BUG) can occur for a modified f2fs filesystem image in which an inline inode contains an invalid reserved blkaddr.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void dissect_sccp_optional_parameters(tvbuff_t *tvb, packet_info *pinfo, proto_tree *sccp_tree, proto_tree *tree, guint16 offset, sccp_decode_context_t* sccp_info) { guint8 parameter_type; while ((parameter_type = tvb_get_guint8(tvb, offset)) != PARAMETER_END_OF_OPTIONAL_PARAMETERS) { offset += PARAMETER_TYPE_LENGTH; offset += dissect_sccp_variable_parameter(tvb, pinfo, sccp_tree, tree, parameter_type, offset, sccp_info); } dissect_sccp_parameter(tvb, pinfo, sccp_tree, tree, parameter_type, offset, END_OF_OPTIONAL_PARAMETERS_LENGTH, sccp_info); }
Description: In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-sccp.c had an infinite loop that was addressed by using a correct integer data type.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: uint8_t rfc_parse_data(tRFC_MCB* p_mcb, MX_FRAME* p_frame, BT_HDR* p_buf) { uint8_t ead, eal, fcs; uint8_t* p_data = (uint8_t*)(p_buf + 1) + p_buf->offset; uint8_t* p_start = p_data; uint16_t len; if (p_buf->len < RFCOMM_CTRL_FRAME_LEN) { RFCOMM_TRACE_ERROR(""Bad Length1: %d"", p_buf->len); return (RFC_EVENT_BAD_FRAME); } RFCOMM_PARSE_CTRL_FIELD(ead, p_frame->cr, p_frame->dlci, p_data); if (!ead) { RFCOMM_TRACE_ERROR(""Bad Address(EA must be 1)""); return (RFC_EVENT_BAD_FRAME); } RFCOMM_PARSE_TYPE_FIELD(p_frame->type, p_frame->pf, p_data); eal = *(p_data)&RFCOMM_EA; len = *(p_data)++ >> RFCOMM_SHIFT_LENGTH1; if (eal == 0 && p_buf->len < RFCOMM_CTRL_FRAME_LEN) { len += (*(p_data)++ << RFCOMM_SHIFT_LENGTH2); } else if (eal == 0) { RFCOMM_TRACE_ERROR(""Bad Length when EAL = 0: %d"", p_buf->len); android_errorWriteLog(0x534e4554, ""78288018""); return RFC_EVENT_BAD_FRAME; } p_buf->len -= (3 + !ead + !eal + 1);  p_buf->offset += (3 + !ead + !eal); if ((p_mcb->flow == PORT_FC_CREDIT) && (p_frame->type == RFCOMM_UIH) && (p_frame->dlci != RFCOMM_MX_DLCI) && (p_frame->pf == 1)) { p_frame->credit = *p_data++; p_buf->len--; p_buf->offset++; } else p_frame->credit = 0; if (p_buf->len != len) { RFCOMM_TRACE_ERROR(""Bad Length2 %d %d"", p_buf->len, len); return (RFC_EVENT_BAD_FRAME); } fcs = *(p_data + len); switch (p_frame->type) { case RFCOMM_SABME: if (RFCOMM_FRAME_IS_RSP(p_mcb->is_initiator, p_frame->cr) || !p_frame->pf || len || !RFCOMM_VALID_DLCI(p_frame->dlci) || !rfc_check_fcs(RFCOMM_CTRL_FRAME_LEN, p_start, fcs)) { RFCOMM_TRACE_ERROR(""Bad SABME""); return (RFC_EVENT_BAD_FRAME); } else return (RFC_EVENT_SABME); case RFCOMM_UA: if (RFCOMM_FRAME_IS_CMD(p_mcb->is_initiator, p_frame->cr) || !p_frame->pf || len || !RFCOMM_VALID_DLCI(p_frame->dlci) || !rfc_check_fcs(RFCOMM_CTRL_FRAME_LEN, p_start, fcs)) { RFCOMM_TRACE_ERROR(""Bad UA""); return (RFC_EVENT_BAD_FRAME); } else return (RFC_EVENT_UA); case RFCOMM_DM: if (RFCOMM_FRAME_IS_CMD(p_mcb->is_initiator, p_frame->cr) || len || !RFCOMM_VALID_DLCI(p_frame->dlci) || !rfc_check_fcs(RFCOMM_CTRL_FRAME_LEN, p_start, fcs)) { RFCOMM_TRACE_ERROR(""Bad DM""); return (RFC_EVENT_BAD_FRAME); } else return (RFC_EVENT_DM); case RFCOMM_DISC: if (RFCOMM_FRAME_IS_RSP(p_mcb->is_initiator, p_frame->cr) || !p_frame->pf || len || !RFCOMM_VALID_DLCI(p_frame->dlci) || !rfc_check_fcs(RFCOMM_CTRL_FRAME_LEN, p_start, fcs)) { RFCOMM_TRACE_ERROR(""Bad DISC""); return (RFC_EVENT_BAD_FRAME); } else return (RFC_EVENT_DISC); case RFCOMM_UIH: if (!RFCOMM_VALID_DLCI(p_frame->dlci)) { RFCOMM_TRACE_ERROR(""Bad UIH - invalid DLCI""); return (RFC_EVENT_BAD_FRAME); } else if (!rfc_check_fcs(2, p_start, fcs)) { RFCOMM_TRACE_ERROR(""Bad UIH - FCS""); return (RFC_EVENT_BAD_FRAME); } else if (RFCOMM_FRAME_IS_RSP(p_mcb->is_initiator, p_frame->cr)) { RFCOMM_TRACE_ERROR(""Bad UIH - response""); return (RFC_EVENT_UIH); } else return (RFC_EVENT_UIH); } return (RFC_EVENT_BAD_FRAME); }
Description: In rfc_process_mx_message of rfc_ts_frames.cc, there is a possible out-of-bounds read due to a missing bounds check. This could lead to remote information disclosure in the Bluetooth service with no additional execution privileges needed. User interaction is not needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-111936792
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int dns_packet_read_type_window(DnsPacket *p, Bitmap **types, size_t *start) { uint8_t window; uint8_t length; const uint8_t *bitmap; uint8_t bit = 0; unsigned i; bool found = false; _cleanup_(rewind_dns_packet) DnsPacketRewinder rewinder; int r; assert(p); assert(types); INIT_REWINDER(rewinder, p); r = bitmap_ensure_allocated(types); if (r < 0) return r; r = dns_packet_read_uint8(p, &window, NULL); if (r < 0) return r; r = dns_packet_read_uint8(p, &length, NULL); if (r < 0) return r; if (length == 0 || length > 32) return -EBADMSG; r = dns_packet_read(p, length, (const void **)&bitmap, NULL); if (r < 0) return r; for (i = 0; i < length; i++) { uint8_t bitmask = 1 << 7; if (!bitmap[i]) { found = false; bit += 8; continue; } found = true; while (bitmask) { if (bitmap[i] & bitmask) { uint16_t n; n = (uint16_t) window << 8 | (uint16_t) bit; if (dns_type_is_pseudo(n)) continue; r = bitmap_set(*types, n); if (r < 0) return r; } bit++; bitmask >>= 1; } } if (!found) return -EBADMSG; if (start) *start = rewinder.saved_rindex; CANCEL_REWINDER(rewinder); return 0; }
Description: In systemd 223 through 235, a remote DNS server can respond with a custom crafted DNS NSEC resource record to trigger an infinite loop in the dns_packet_read_type_window() function of the 'systemd-resolved' service and cause a DoS of the affected service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void main(string arg) { string file, *exparg; int szof; exparg = explode(arg, ""/""); szof = sizeof(exparg); if (szof > 1) { return 1; } if (!alsos) { setup_alsos(); } if (empty_str(arg) || (arg == ""help"")) { this_player()->more(usage()); return; } if (sscanf(arg, ""-%s"", arg)) { this_player()->more(usage()); return; } file = normalize_path(arg, ""/doc/help/""); if (show_help(file)) { return; } if (query_wizard(this_player())) { file = normalize_path(arg, ""/doc/help/wiz/""); if (show_help(file)) { return; } } if (show_help_for_command(arg)) { return; } write(capitalize(arg) + "": Unknown help topic.""); if (query_wizard(this_player())) { write(""Try one of the following for more info:\n""); write(""\tman "" + arg + ""\n""); write(""\t"" + arg + "" -h\n""); } else { write(""If "" + arg + "" is a command, for more info try: "" +  arg + "" -h\n""); } LOG_D->write_log(""help"", this_player()->query_Name() + "" on "" + ctime(time()) + "": "" + arg + ""\n""); return; }
Description: Gurbalib through 2020-04-30 allows lib/cmds/player/help.c directory traversal for reading administrative paths.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void Client::connect() { if (m_stream != NULL) { return; } if (m_suspended) { m_connectOnResume = true; return; } auto security_level = ConnectionSecurityLevel::PLAINTEXT; if (m_useSecureNetwork) { security_level = ConnectionSecurityLevel::ENCRYPTED; } try { m_serverAddress.resolve(); if (m_serverAddress.getAddress() != NULL) { LOG((CLOG_NOTE ""connecting to '%s': %s:%i"", m_serverAddress.getHostname().c_str(), ARCH->addrToString(m_serverAddress.getAddress()).c_str(), m_serverAddress.getPort())); } IDataSocket* socket = m_socketFactory->create(ARCH->getAddrFamily(m_serverAddress.getAddress()), security_level); m_socket = dynamic_cast<TCPSocket*>(socket); m_stream = socket; m_stream = new PacketStreamFilter(m_events, m_stream, true); LOG((CLOG_DEBUG1 ""connecting to server"")); setupConnecting(); setupTimer(); socket->connect(m_serverAddress); } catch (XBase& e) { cleanupTimer(); cleanupConnecting(); cleanupStream(); LOG((CLOG_DEBUG1 ""connection failed"")); sendConnectionFailedEvent(e.what()); return; } }
Description: An issue was discovered in Barrier before 2.4.0. An attacker can enter an active session state with the barriers component (aka the server-side implementation of Barrier) simply by supplying a client label that identifies a valid client configuration. This label is ""Unnamed"" by default but could instead be guessed from hostnames or other publicly available information. In the active session state, an attacker can capture input device events from the server, and also modify the clipboard content on the server.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int dissect_spoolss_buffer_data(tvbuff_t *tvb, int offset, packet_info *pinfo, proto_tree *tree, dcerpc_info *di, guint8 *drep) { BUFFER *b = (BUFFER *)di->private_data; proto_item *item; guint32 size; const guint8 *data; if (di->conformant_run) return offset; offset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep, hf_buffer_size, &size); offset = dissect_ndr_uint8s(tvb, offset, pinfo, NULL, di, drep, hf_buffer_data, size, &data); item = proto_tree_add_item( tree, hf_buffer_data, tvb, offset - size, size, ENC_NA); if (b) { b->tvb = tvb_new_child_real_data(tvb, data, size, size); add_new_data_source(pinfo, b->tvb, ""SPOOLSS buffer""); b->item = item; b->tree = proto_item_add_subtree(item, ett_BUFFER); } return offset; }
Description: In Wireshark 2.4.0 to 2.4.13, 2.6.0 to 2.6.7, and 3.0.0, the DCERPC SPOOLSS dissector could crash. This was addressed in epan/dissectors/packet-dcerpc-spoolss.c by adding a boundary check.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void process_add_identity(SocketEntry *e) { Identity *id; int success = 0, confirm = 0; char *fp, *comment = NULL, *sk_provider = NULL; char canonical_provider[PATH_MAX]; time_t death = 0; u_int seconds = 0; struct dest_constraint *dest_constraints = NULL; size_t ndest_constraints = 0; struct sshkey *k = NULL; int r = SSH_ERR_INTERNAL_ERROR; debug2_f(""entering""); if ((r = sshkey_private_deserialize(e->request, &k)) != 0 || k == NULL || (r = sshbuf_get_cstring(e->request, &comment, NULL)) != 0) { error_fr(r, ""parse""); goto out; } if (parse_key_constraints(e->request, k, &death, &seconds, &confirm, &sk_provider, &dest_constraints, &ndest_constraints) != 0) { error_f(""failed to parse constraints""); sshbuf_reset(e->request); goto out; } if (sk_provider != NULL) { if (!sshkey_is_sk(k)) { error(""Cannot add provider: %s is not an "" ""authenticator-hosted key"", sshkey_type(k)); goto out; } if (strcasecmp(sk_provider, ""internal"") == 0) { debug_f(""internal provider""); } else { if (e->nsession_ids != 0 && !remote_add_provider) { verbose(""failed add of SK provider \""%.100s\"": "" ""remote addition of providers is disabled"", sk_provider); goto out; } if (realpath(sk_provider, canonical_provider) == NULL) { verbose(""failed provider \""%.100s\"": "" ""realpath: %s"", sk_provider, strerror(errno)); goto out; } free(sk_provider); sk_provider = xstrdup(canonical_provider); if (match_pattern_list(sk_provider, allowed_providers, 0) != 1) { error(""Refusing add key: "" ""provider %s not allowed"", sk_provider); goto out; } } } if ((r = sshkey_shield_private(k)) != 0) { error_fr(r, ""shield private""); goto out; } if (lifetime && !death) death = monotime() + lifetime; if ((id = lookup_identity(k)) == NULL) { id = xcalloc(1, sizeof(Identity)); TAILQ_INSERT_TAIL(&idtab->idlist, id, next); idtab->nentries++; } else { if (identity_permitted(id, e, NULL, NULL, NULL) != 0) goto out;  sshkey_free(id->key); free(id->comment); free(id->sk_provider); free_dest_constraints(id->dest_constraints, id->ndest_constraints); } id->key = k; id->comment = comment; id->death = death; id->confirm = confirm; id->sk_provider = sk_provider; id->dest_constraints = dest_constraints; id->ndest_constraints = ndest_constraints; if ((fp = sshkey_fingerprint(k, SSH_FP_HASH_DEFAULT, SSH_FP_DEFAULT)) == NULL) fatal_f(""sshkey_fingerprint failed""); debug_f(""add %s %s \""%.100s\"" (life: %u) (confirm: %u) "" ""(provider: %s) (destination constraints: %zu)"", sshkey_ssh_name(k), fp, comment, seconds, confirm, sk_provider == NULL ? ""none"" : sk_provider, ndest_constraints); free(fp); k = NULL; comment = NULL; sk_provider = NULL; dest_constraints = NULL; ndest_constraints = 0; success = 1; out: free(sk_provider); free(comment); sshkey_free(k); free_dest_constraints(dest_constraints, ndest_constraints); send_status(e, success); }
Description: In ssh-agent in OpenSSH before 9.6, certain destination constraints can be incompletely applied. When destination constraints are specified during addition of PKCS#11-hosted private keys, these constraints are only applied to the first key, even if a PKCS#11 token returns multiple keys.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static mrb_value fiber_switch(mrb_state *mrb, mrb_value self, mrb_int len, const mrb_value *a, mrb_bool resume, mrb_bool vmexec) { struct mrb_context *c = fiber_check(mrb, self); struct mrb_context *old_c = mrb->c; mrb_value value; fiber_check_cfunc(mrb, c); if (resume && c->status == MRB_FIBER_TRANSFERRED) { mrb_raise(mrb, E_FIBER_ERROR, ""resuming transferred fiber""); } if (c->status == MRB_FIBER_RUNNING || c->status == MRB_FIBER_RESUMED) { mrb_raise(mrb, E_FIBER_ERROR, ""double resume (fib)""); } if (c->status == MRB_FIBER_TERMINATED) { mrb_raise(mrb, E_FIBER_ERROR, ""resuming dead fiber""); } mrb->c->status = resume ? MRB_FIBER_RESUMED : MRB_FIBER_TRANSFERRED; c->prev = resume ? mrb->c : (c->prev ? c->prev : mrb->root_c); if (c->status == MRB_FIBER_CREATED) { mrb_value *b, *e; if (len >= c->stend - c->stack) { mrb_raise(mrb, E_FIBER_ERROR, ""too many arguments to fiber""); } b = c->stack+1; e = b + len; while (b<e) { *b++ = *a++; } c->cibase->argc = (int)len; value = c->stack[0] = MRB_PROC_ENV(c->ci->proc)->stack[0]; } else { value = fiber_result(mrb, a, len); } fiber_switch_context(mrb, c); if (vmexec) { c->vmexec = TRUE; value = mrb_vm_exec(mrb, c->ci[-1].proc, c->ci->pc); mrb->c = old_c; } else { MARK_CONTEXT_MODIFY(c); } return value; }
Description: An issue was discovered in mruby 1.4.1. There is a heap-based buffer over-read associated with OP_ENTER because mrbgems/mruby-fiber/src/fiber.c does not extend the stack in cases of many arguments to fiber.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: struct mg_str *mg_get_http_header(struct http_message *hm, const char *name) { size_t i, len = strlen(name); for (i = 0; hm->header_names[i].len > 0; i++) { struct mg_str *h = &hm->header_names[i], *v = &hm->header_values[i]; if (h->p != NULL && h->len == len && !mg_ncasecmp(h->p, name, len)) return v; } return NULL; }
Description: A buffer overflow vulnerability exists in the mg_get_http_header function in Cesanta Mongoose 6.18 due to a lack of bounds checking. A crafted HTTP header can exploit this bug. NOTE: a committer has stated ""this will not happen in practice.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void tm_reclaim_thread(struct thread_struct *thr, struct thread_info *ti, uint8_t cause) { unsigned long msr_diff = 0; if (test_ti_thread_flag(ti, TIF_RESTORE_TM)) { msr_diff = thr->ckpt_regs.msr & ~thr->regs->msr; if (msr_diff & MSR_FP) memcpy(&thr->transact_fp, &thr->fp_state, sizeof(struct thread_fp_state)); if (msr_diff & MSR_VEC) memcpy(&thr->transact_vr, &thr->vr_state, sizeof(struct thread_vr_state)); clear_ti_thread_flag(ti, TIF_RESTORE_TM); msr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1; } tm_reclaim(thr, thr->regs->msr, cause); thr->regs->msr |= msr_diff; }
Description: The tm_reclaim_thread function in arch/powerpc/kernel/process.c in the Linux kernel before 4.4.1 on powerpc platforms does not ensure that TM suspend mode exists before proceeding with a tm_reclaim call, which allows local users to cause a denial of service (TM Bad Thing exception and panic) via a crafted application.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static struct lys_node * read_yin_anydata(struct lys_module *module, struct lys_node *parent, struct lyxml_elem *yin, LYS_NODE type, int options, struct unres_schema *unres) { struct ly_ctx *ctx = module->ctx; struct lys_node *retval; struct lys_node_anydata *anyxml; struct lyxml_elem *sub, *next; const char *value; int r; int f_mand = 0; int c_must = 0, c_ftrs = 0, c_ext = 0; void *reallocated; anyxml = calloc(1, sizeof *anyxml); LY_CHECK_ERR_RETURN(!anyxml, LOGMEM(ctx), NULL); anyxml->nodetype = type; anyxml->prev = (struct lys_node *)anyxml; retval = (struct lys_node *)anyxml; if (read_yin_common(module, parent, retval, LYEXT_PAR_NODE, yin, OPT_IDENT | OPT_MODULE | ((options & LYS_PARSE_OPT_CFG_IGNORE) ? OPT_CFG_IGNORE : (options & LYS_PARSE_OPT_CFG_NOINHERIT) ? OPT_CFG_PARSE : OPT_CFG_PARSE | OPT_CFG_INHERIT), unres)) { goto error; } LOGDBG(LY_LDGYIN, ""parsing %s statement \""%s\"""", yin->name, retval->name); if (lys_node_addchild(parent, lys_main_module(module), retval, options)) { goto error; } LY_TREE_FOR_SAFE(yin->child, next, sub) { if (strcmp(sub->ns->value, LY_NSYIN)) { YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ext, retval->ext_size, ""extensions"", ""anydata"", error); c_ext++; } else if (!strcmp(sub->name, ""mandatory"")) { if (f_mand) { LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name); goto error; } f_mand = 1; GETVAL(ctx, value, sub, ""value""); if (!strcmp(value, ""true"")) { anyxml->flags |= LYS_MAND_TRUE; } else if (!strcmp(value, ""false"")) { anyxml->flags |= LYS_MAND_FALSE; } else { LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name); goto error; } if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_MANDATORY, 0, unres)) { goto error; } lyxml_free(ctx, sub); } else if (!strcmp(sub->name, ""when"")) { if (anyxml->when) { LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name); goto error; } anyxml->when = read_yin_when(module, sub, unres); if (!anyxml->when) { lyxml_free(ctx, sub); goto error; } lyxml_free(ctx, sub); } else if (!strcmp(sub->name, ""must"")) { YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_must, anyxml->must_size, ""musts"", ""anydata"", error); c_must++; } else if (!strcmp(sub->name, ""if-feature"")) { YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ftrs, retval->iffeature_size, ""if-features"", ""anydata"", error); c_ftrs++; } else { LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, retval, sub->name); goto error; } } if (c_must) { anyxml->must = calloc(c_must, sizeof *anyxml->must); LY_CHECK_ERR_GOTO(!anyxml->must, LOGMEM(ctx), error); } if (c_ftrs) { anyxml->iffeature = calloc(c_ftrs, sizeof *anyxml->iffeature); LY_CHECK_ERR_GOTO(!anyxml->iffeature, LOGMEM(ctx), error); } if (c_ext) { reallocated = realloc(retval->ext, (c_ext + retval->ext_size) * sizeof *retval->ext); LY_CHECK_ERR_GOTO(!reallocated, LOGMEM(ctx), error); retval->ext = reallocated; memset(&retval->ext[retval->ext_size], 0, c_ext * sizeof *retval->ext); } LY_TREE_FOR_SAFE(yin->child, next, sub) { if (strcmp(sub->ns->value, LY_NSYIN)) { r = lyp_yin_fill_ext(retval, LYEXT_PAR_NODE, 0, 0, module, sub, &retval->ext, &retval->ext_size, unres); if (r) { goto error; } } else if (!strcmp(sub->name, ""must"")) { r = fill_yin_must(module, sub, &anyxml->must[anyxml->must_size], unres); anyxml->must_size++; if (r) { goto error; } } else if (!strcmp(sub->name, ""if-feature"")) { r = fill_yin_iffeature(retval, 0, sub, &anyxml->iffeature[anyxml->iffeature_size], unres); anyxml->iffeature_size++; if (r) { goto error; } } } lyp_reduce_ext_list(&retval->ext, retval->ext_size, c_ext + retval->ext_size); if (!(ctx->models.flags & LY_CTX_TRUSTED) && (anyxml->when || anyxml->must)) { if (options & LYS_PARSE_OPT_INGRP) { if (lyxp_node_check_syntax(retval)) { goto error; } } else { if (unres_schema_add_node(module, unres, retval, UNRES_XPATH, NULL) == -1) { goto error; } } } for (r = 0; r < retval->ext_size; ++r) { if (retval->ext[r]->flags & LYEXT_OPT_VALID) { retval->flags |= LYS_VALID_EXT; break; } } return retval; error: lys_node_free(ctx, retval, NULL, 0); return NULL; }
Description: In function read_yin_container() in libyang <= v1.0.225, it doesn't check whether the value of retval->ext[r] is NULL. In some cases, it can be NULL, which leads to the operation of retval->ext[r]->flags that results in a crash.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void changed_common( linenr_Tlnum, colnr_Tcol, linenr_Tlnume, longxtra) { win_T*wp; tabpage_T*tp; inti; intcols; pos_T*p; intadd; changed(); #ifdef FEAT_EVAL may_record_change(lnum, col, lnume, xtra); #endif #ifdef FEAT_DIFF if (curwin->w_p_diff && diff_internal()) curtab->tp_diff_update = TRUE; #endif if ((cmdmod.cmod_flags & CMOD_KEEPJUMPS) == 0) { curbuf->b_last_change.lnum = lnum; curbuf->b_last_change.col = col; if (curbuf->b_new_change || curbuf->b_changelistlen == 0) { if (curbuf->b_changelistlen == 0) add = TRUE; else { p = &curbuf->b_changelist[curbuf->b_changelistlen - 1]; if (p->lnum != lnum) add = TRUE; else { cols = comp_textwidth(FALSE); if (cols == 0) cols = 79; add = (p->col + cols < col || col + cols < p->col); } } if (add) { curbuf->b_new_change = FALSE; if (curbuf->b_changelistlen == JUMPLISTSIZE) { curbuf->b_changelistlen = JUMPLISTSIZE - 1; mch_memmove(curbuf->b_changelist, curbuf->b_changelist + 1, sizeof(pos_T) * (JUMPLISTSIZE - 1)); FOR_ALL_TAB_WINDOWS(tp, wp) { if (wp->w_buffer == curbuf && wp->w_changelistidx > 0) --wp->w_changelistidx; } } FOR_ALL_TAB_WINDOWS(tp, wp) { if (wp->w_buffer == curbuf && wp->w_changelistidx == curbuf->b_changelistlen) ++wp->w_changelistidx; } ++curbuf->b_changelistlen; } } curbuf->b_changelist[curbuf->b_changelistlen - 1] = curbuf->b_last_change; curwin->w_changelistidx = curbuf->b_changelistlen; } FOR_ALL_TAB_WINDOWS(tp, wp) { if (wp->w_buffer == curbuf) { #ifdef FEAT_FOLDING linenr_T last = lnume + xtra - 1;  #endif if (wp->w_redr_type < VALID) wp->w_redr_type = VALID; #ifdef FEAT_FOLDING foldUpdate(wp, lnum, last); i = hasFoldingWin(wp, lnum, &lnum, NULL, FALSE, NULL); if (wp->w_cursor.lnum == lnum) wp->w_cline_folded = i; i = hasFoldingWin(wp, last, NULL, &last, FALSE, NULL); if (wp->w_cursor.lnum == last) wp->w_cline_folded = i; if (wp->w_cursor.lnum <= lnum) { i = find_wl_entry(wp, lnum); if (i >= 0 && wp->w_cursor.lnum > wp->w_lines[i].wl_lnum) changed_line_abv_curs_win(wp); } #endif if (wp->w_cursor.lnum > lnum) changed_line_abv_curs_win(wp); else if (wp->w_cursor.lnum == lnum && wp->w_cursor.col >= col) changed_cline_bef_curs_win(wp); if (wp->w_botline >= lnum) { if (xtra < 0) invalidate_botline_win(wp); else approximate_botline_win(wp); } for (i = 0; i < wp->w_lines_valid; ++i) if (wp->w_lines[i].wl_valid) { if (wp->w_lines[i].wl_lnum >= lnum) { if (wp->w_lines[i].wl_lnum < lnume) { wp->w_lines[i].wl_valid = FALSE; } else if (xtra != 0) { wp->w_lines[i].wl_lnum += xtra; #ifdef FEAT_FOLDING wp->w_lines[i].wl_lastlnum += xtra; #endif } } #ifdef FEAT_FOLDING else if (wp->w_lines[i].wl_lastlnum >= lnum) { wp->w_lines[i].wl_valid = FALSE; } #endif } #ifdef FEAT_FOLDING if (hasAnyFolding(wp)) set_topline(wp, wp->w_topline); #endif if (wp->w_p_rnu && xtra != 0) { wp->w_last_cursor_lnum_rnu = 0; redraw_win_later(wp, VALID); } #ifdef FEAT_SYN_HL if (wp->w_p_cul) { if (xtra == 0) redraw_win_later(wp, VALID); else if (lnum <= wp->w_last_cursorline) redraw_win_later(wp, SOME_VALID); } #endif } } if (must_redraw < VALID) must_redraw = VALID; if (lnum <= curwin->w_cursor.lnum && lnume + (xtra < 0 ? -xtra : xtra) > curwin->w_cursor.lnum) last_cursormoved.lnum = 0; }
Description: Classic Buffer Overflow in GitHub repository vim/vim prior to 8.2.4969.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void prepare_singleton_class(mrb_state *mrb, struct RBasic *o) { struct RClass *sc, *c; if (o->c->tt == MRB_TT_SCLASS) return; sc = MRB_OBJ_ALLOC(mrb, MRB_TT_SCLASS, mrb->class_class); sc->flags |= MRB_FL_CLASS_IS_INHERITED; sc->mt = mt_new(mrb); sc->iv = 0; if (o->tt == MRB_TT_CLASS) { c = (struct RClass*)o; if (!c->super) { sc->super = mrb->class_class; } else { sc->super = c->super->c; } } else if (o->tt == MRB_TT_SCLASS) { c = (struct RClass*)o; while (c->super->tt == MRB_TT_ICLASS) c = c->super; make_metaclass(mrb, c->super); sc->super = c->super->c; } else { sc->super = o->c; prepare_singleton_class(mrb, (struct RBasic*)sc); } o->c = sc; mrb_field_write_barrier(mrb, (struct RBasic*)o, (struct RBasic*)sc); mrb_field_write_barrier(mrb, (struct RBasic*)sc, (struct RBasic*)o); mrb_obj_iv_set(mrb, (struct RObject*)sc, MRB_SYM(__attached__), mrb_obj_value(o)); sc->flags |= o->flags & MRB_FL_OBJ_IS_FROZEN; }
Description: mruby is vulnerable to NULL Pointer Dereference
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int vips_foreign_load_gif_scan_image( VipsForeignLoadGif *gif )  { VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif ); GifFileType *file = gif->file; ColorMapObject *map = file->Image.ColorMap ? file->Image.ColorMap : file->SColorMap; GifByteType *extension; if( DGifGetImageDesc( gif->file ) == GIF_ERROR ) { vips_foreign_load_gif_error( gif );  return( -1 ); } if( file->Image.Left < 0 || file->Image.Width < 1 || file->Image.Width > 10000 || file->Image.Left + file->Image.Width > file->SWidth || file->Image.Top < 0 || file->Image.Height < 1 || file->Image.Height > 10000 || file->Image.Top + file->Image.Height > file->SHeight ) { vips_error( class->nickname, ""%s"", _( ""bad frame size"" ) );  return( -1 );  } if( !gif->has_colour && map ) { int i; for( i = 0; i < map->ColorCount; i++ )  if( map->Colors[i].Red != map->Colors[i].Green || map->Colors[i].Green != map->Colors[i].Blue ) { gif->has_colour = TRUE; break; } } do { if( vips_foreign_load_gif_code_next( gif, &extension ) )  return( -1 ); } while( extension != NULL ); return( 0 ); }
Description: vips_foreign_load_gif_scan_image in foreign/gifload.c in libvips before 8.8.2 tries to access a color map before a DGifGetImageDesc call, leading to a use-after-free.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void tcp_mtu_probing(struct inet_connection_sock *icsk, struct sock *sk) { const struct net *net = sock_net(sk); int mss; if (!net->ipv4.sysctl_tcp_mtu_probing) return; if (!icsk->icsk_mtup.enabled) { icsk->icsk_mtup.enabled = 1; icsk->icsk_mtup.probe_timestamp = tcp_jiffies32; } else { mss = tcp_mtu_to_mss(sk, icsk->icsk_mtup.search_low) >> 1; mss = min(net->ipv4.sysctl_tcp_base_mss, mss); mss = max(mss, 68 - tcp_sk(sk)->tcp_header_len); icsk->icsk_mtup.search_low = tcp_mss_to_mtu(sk, mss); } tcp_sync_mss(sk, icsk->icsk_pmtu_cookie); }
Description: Jonathan Looney discovered that the Linux kernel default MSS is hard-coded to 48 bytes. This allows a remote peer to fragment TCP resend queues significantly more than if a larger MSS were enforced. A remote attacker could use this to cause a denial of service. This has been fixed in stable kernel releases 4.4.182, 4.9.182, 4.14.127, 4.19.52, 5.1.11, and is fixed in commits 967c05aee439e6e5d7d805e195b3a20ef5c433d6 and 5f3e2bf008c2221478101ee72f5cb4654b9fc363.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int ax25_create(struct net *net, struct socket *sock, int protocol, int kern) { struct sock *sk; ax25_cb *ax25; if (protocol < 0 || protocol > SK_PROTOCOL_MAX) return -EINVAL; if (!net_eq(net, &init_net)) return -EAFNOSUPPORT; switch (sock->type) { case SOCK_DGRAM: if (protocol == 0 || protocol == PF_AX25) protocol = AX25_P_TEXT; break; case SOCK_SEQPACKET: switch (protocol) { case 0: case PF_AX25: protocol = AX25_P_TEXT; break; case AX25_P_SEGMENT: #ifdef CONFIG_INET case AX25_P_ARP: case AX25_P_IP: #endif #ifdef CONFIG_NETROM case AX25_P_NETROM: #endif #ifdef CONFIG_ROSE case AX25_P_ROSE: #endif return -ESOCKTNOSUPPORT; #ifdef CONFIG_NETROM_MODULE case AX25_P_NETROM: if (ax25_protocol_is_registered(AX25_P_NETROM)) return -ESOCKTNOSUPPORT; break; #endif #ifdef CONFIG_ROSE_MODULE case AX25_P_ROSE: if (ax25_protocol_is_registered(AX25_P_ROSE)) return -ESOCKTNOSUPPORT; #endif default: break; } break; case SOCK_RAW: break; default: return -ESOCKTNOSUPPORT; } sk = sk_alloc(net, PF_AX25, GFP_ATOMIC, &ax25_proto, kern); if (sk == NULL) return -ENOMEM; ax25 = ax25_sk(sk)->cb = ax25_create_cb(); if (!ax25) { sk_free(sk); return -ENOMEM; } sock_init_data(sock, sk); sk->sk_destruct = ax25_free_sock; sock->ops    = &ax25_proto_ops; sk->sk_protocol = protocol; ax25->sk    = sk; return 0; }
Description: ax25_create in net/ax25/af_ax25.c in the AF_AX25 network module in the Linux kernel 3.16 through 5.3.2 does not enforce CAP_NET_RAW, which means that unprivileged users can create a raw socket, aka CID-0614e2b73768.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int acurite_00275rm_decode(r_device *decoder, bitbuffer_t *bitbuffer) { int result = 0; bitbuffer_invert(bitbuffer); uint8_t *b_rows[3] = {0}; int n_rows         = 0; for (int row = 0; row < bitbuffer->num_rows; ++row) { if (n_rows < 3 && bitbuffer->bits_per_row[row] == 88) { b_rows[n_rows] = bitbuffer->bb[row]; n_rows++; } } if (n_rows == 3) { uint8_t *b = bitbuffer->bb[bitbuffer->num_rows]; for (int i = 0; i < 11; ++i) { b[i] = (b_rows[0][i] & b_rows[1][i]) | (b_rows[1][i] & b_rows[2][i]) | (b_rows[2][i] & b_rows[0][i]); } bitbuffer->bits_per_row[bitbuffer->num_rows] = 88; bitbuffer->num_rows += 1; } for (int row = 0; row < bitbuffer->num_rows; ++row) { if (bitbuffer->bits_per_row[row] != 88) { result = DECODE_ABORT_LENGTH; continue;         } uint8_t *b = bitbuffer->bb[row]; if (crc16lsb(b, 11, 0x00b2, 0x00d0) != 0) { decoder_log_bitrow(decoder, 1, __func__, b, 11 * 8, ""sensor bad CRC""); result = DECODE_FAIL_MIC; continue;         } int id          = (b[0] << 16) | (b[1] << 8) | b[3]; int battery_low = (b[2] & 0x40) == 0; int model_flag  = (b[2] & 1); float tempc     = ((b[4] << 4) | (b[5] >> 4)) * 0.1 - 100; int probe       = b[5] & 3; int humidity    = ((b[6] & 0x1f) << 2) | (b[7] >> 6); int water = (b[7] & 0x0f) == 15;                 float ptempc = (((b[7] & 0x0f) << 8) | b[8]) * 0.1 - 100;                 int phumidity = b[9] & 0x7f;  data_t *data = data_make( ""model"",            """",             DATA_STRING,    model_flag ? ""Acurite-00275rm"" : ""Acurite-00276rm"", ""subtype"",          ""Probe"",        DATA_INT,       probe, ""id"",               """",             DATA_INT,       id, ""battery_ok"",       ""Battery"",      DATA_INT,       !battery_low, ""temperature_C"",    ""Celsius"",      DATA_FORMAT,    ""%.1f C"",  DATA_DOUBLE, tempc, ""humidity"",         ""Humidity"",     DATA_FORMAT,    ""%u %%"", DATA_INT,      humidity, ""water"",            """",             DATA_COND, probe == 1, DATA_INT,        water, ""temperature_1_C"",  ""Celsius"",      DATA_COND, probe == 2, DATA_FORMAT, ""%.1f C"",   DATA_DOUBLE, ptempc, ""temperature_1_C"",  ""Celsius"",      DATA_COND, probe == 3, DATA_FORMAT, ""%.1f C"",   DATA_DOUBLE, ptempc, ""humidity_1"",       ""Humidity"",     DATA_COND, probe == 3, DATA_FORMAT, ""%u %%"",    DATA_INT,    phumidity, ""mic"",              ""Integrity"",    DATA_STRING,    ""CRC"", NULL); decoder_output_data(decoder, data); return 1; } return result; }
Description: rtl_433 21.12 was discovered to contain a stack overflow in the function acurite_00275rm_decode at /devices/acurite.c. This vulnerability allows attackers to cause a Denial of Service (DoS) via a crafted file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static gboolean accept_ice_connection (GIOChannel           *source, GIOCondition          condition, GsmIceConnectionData *data) { IceListenObj    listener; IceConn         ice_conn; IceAcceptStatus status; GsmClient      *client; GsmXsmpServer  *server; listener = data->listener; server = data->server; g_debug (""GsmXsmpServer: accept_ice_connection()""); ice_conn = IceAcceptConnection (listener, &status); if (status != IceAcceptSuccess) { g_debug (""GsmXsmpServer: IceAcceptConnection returned %d"", status); return TRUE; } client = gsm_xsmp_client_new (ice_conn); ice_conn->context = client; gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client)); g_object_unref (client); return TRUE; }
Description: Bad reference counting in the context of accept_ice_connection() in gsm-xsmp-server.c in old versions of gnome-session up until version 2.29.92 allows a local attacker to establish ICE connections to gnome-session with invalid authentication data (an invalid magic cookie). Each failed authentication attempt will leak a file descriptor in gnome-session. When the maximum number of file descriptors is exhausted in the gnome-session process, it will enter an infinite loop trying to communicate without success, consuming 100% of the CPU. The graphical session associated with the gnome-session process will stop working correctly, because communication with gnome-session is no longer possible.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int dissect_docsis (tvbuff_t * tvb, packet_info * pinfo, proto_tree * tree, void* data _U_) { guint8 fc = 0; guint8 fctype = 0; guint8 fcparm = 0; guint8 exthdr = 0; guint16 mac_parm = 0; guint8 hdrlen = DOCSIS_MIN_HEADER_LEN; guint16 len_sid = 0; tvbuff_t *next_tvb = NULL; tvbuff_t *mgt_tvb = NULL; gint pdulen = 0; guint16 payload_length = 0; guint16 framelen = 0; gboolean save_fragmented; proto_item *ti; proto_tree *docsis_tree; static guint16 concatlen; static guint16 concatpos; fc = tvb_get_guint8 (tvb, 0);  fctype = (fc >> 6) & 0x03;     fcparm = (fc >> 1) & 0x1F;     exthdr = (fc & 0x01);          if (fcparm == FCPARM_QUEUE_DEPTH_REQ_FRM) { mac_parm = tvb_get_ntohs (tvb, 1); len_sid = tvb_get_ntohs (tvb, 3); hdrlen = DOCSIS_MIN_HEADER_LEN + 1;   } else { mac_parm = tvb_get_guint8 (tvb, 1); len_sid = tvb_get_ntohs (tvb, 2); } if (exthdr == EXT_HDR_ON) { hdrlen += mac_parm; } payload_length = tvb_captured_length_remaining (tvb, hdrlen); if ((fctype == FCTYPE_MACSPC) && (fcparm == FCPARM_RQST_FRM || fcparm == FCPARM_QUEUE_DEPTH_REQ_FRM)) { pdulen = 0; if (fcparm == FCPARM_QUEUE_DEPTH_REQ_FRM) framelen = DOCSIS_MIN_HEADER_LEN + 1; else framelen = DOCSIS_MIN_HEADER_LEN; } else { framelen = DOCSIS_MIN_HEADER_LEN + len_sid; pdulen = len_sid - (mac_parm + 2); } col_set_str (pinfo->cinfo, COL_PROTOCOL, ""DOCSIS""); switch (fctype) { case FCTYPE_PACKET: col_set_str (pinfo->cinfo, COL_INFO, ""Packet PDU""); break; case FCTYPE_RESERVED: col_set_str (pinfo->cinfo, COL_INFO, ""Reserved PDU""); break; case FCTYPE_ISOLAT: col_set_str (pinfo->cinfo, COL_INFO, ""Isolation PDU""); break; case FCTYPE_MACSPC: if (fcparm == FCPARM_RQST_FRM) col_add_fstr (pinfo->cinfo, COL_INFO, ""Request Frame SID = %u Mini Slots = %u"", len_sid, mac_parm); else if (fcparm == FCPARM_QUEUE_DEPTH_REQ_FRM) col_add_fstr (pinfo->cinfo, COL_INFO, ""Request Frame SID = %u Bytes Requested = %u"", len_sid, mac_parm); else if (fcparm == FCPARM_FRAG_HDR) col_set_str (pinfo->cinfo, COL_INFO, ""Fragmented Frame""); else col_set_str (pinfo->cinfo, COL_INFO, ""Mac Specific""); break; }   ti = proto_tree_add_item(tree, proto_docsis, tvb, 0, hdrlen, ENC_NA); docsis_tree = proto_item_add_subtree (ti, ett_docsis); proto_tree_add_item (docsis_tree, hf_docsis_fctype, tvb, 0, 1, ENC_BIG_ENDIAN); switch (fctype) { case FCTYPE_PACKET: { proto_item_append_text (ti, "" Packet PDU""); proto_tree_add_item (docsis_tree, hf_docsis_fcparm, tvb, 0, 1, ENC_BIG_ENDIAN); proto_tree_add_item (docsis_tree, hf_docsis_exthdr, tvb, 0, 1, ENC_BIG_ENDIAN); dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length); dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen); if (pdulen > 0) { next_tvb =  tvb_new_subset_remaining(tvb, hdrlen); call_dissector (eth_withoutfcs_handle, next_tvb, pinfo, docsis_tree); } if (concatlen > 0) { concatlen = concatlen - framelen; concatpos += framelen; } break; } case FCTYPE_RESERVED: { proto_item_append_text (ti, "" Reserved PDU""); proto_tree_add_item (docsis_tree, hf_docsis_fcparm, tvb, 0, 1, ENC_BIG_ENDIAN); proto_tree_add_item (docsis_tree, hf_docsis_exthdr, tvb, 0, 1, ENC_BIG_ENDIAN); dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length); dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen); if (concatlen > 0) { concatlen = concatlen - framelen; concatpos += framelen; } next_tvb =  tvb_new_subset_remaining(tvb, hdrlen); call_data_dissector(next_tvb, pinfo, tree); break; } case FCTYPE_ISOLAT: { proto_item_append_text (ti, "" Isolation PDU""); proto_tree_add_item (docsis_tree, hf_docsis_fcparm, tvb, 0, 1, ENC_BIG_ENDIAN); proto_tree_add_item (docsis_tree, hf_docsis_exthdr, tvb, 0, 1, ENC_BIG_ENDIAN); dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length); dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen); if (pdulen > 0) { next_tvb =  tvb_new_subset_remaining(tvb, hdrlen); call_dissector (eth_withoutfcs_handle, next_tvb, pinfo, docsis_tree); } if (concatlen > 0) { concatlen = concatlen - framelen; concatpos += framelen; } break; } case FCTYPE_MACSPC: { proto_item_append_text (ti, "" MAC-Specific PDU""); proto_tree_add_item (docsis_tree, hf_docsis_machdr_fcparm, tvb, 0, 1, ENC_BIG_ENDIAN); proto_tree_add_item (docsis_tree, hf_docsis_exthdr, tvb, 0, 1, ENC_BIG_ENDIAN); switch(fcparm) { case FCPARM_TIMING_HDR: case FCPARM_MAC_MGMT_HDR: { dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length); dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen); mgt_tvb = tvb_new_subset_remaining(tvb, hdrlen); call_dissector (docsis_mgmt_handle, mgt_tvb, pinfo, docsis_tree); break; } case FCPARM_RQST_FRM: { proto_tree_add_uint (docsis_tree, hf_docsis_mini_slots, tvb, 1, 1, mac_parm); proto_tree_add_uint (docsis_tree, hf_docsis_sid, tvb, 2, 2, len_sid); dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen); if (concatlen > 0) { concatlen = concatlen - framelen; concatpos += framelen; } break; } case FCPARM_FRAG_HDR: { save_fragmented = pinfo->fragmented; pinfo->fragmented = TRUE; dissect_exthdr_length_field (tvb, pinfo, docsis_tree, exthdr, mac_parm, len_sid, &payload_length); dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen); guint32 sent_fcs = tvb_get_ntohl(tvb, (hdrlen + len_sid - 4)); guint32 fcs = crc32_802_tvb(tvb, tvb_captured_length(tvb) - 4); if (sent_fcs == fcs) { fragment_item *frag_msg = NULL; frag_msg = fragment_add_seq_check(&docsis_reassembly_table, tvb, hdrlen, pinfo, frag_sid, NULL,  frag_seq,  (len_sid - 4),  !(frag_flags & FRAG_LAST));  next_tvb = process_reassembled_data(tvb, hdrlen, pinfo, ""Reassembled Message"", frag_msg, &docsis_frag_items, NULL, docsis_tree); if (frag_flags == FRAG_LAST) pinfo->fragmented = FALSE; else pinfo->fragmented = TRUE; if (frag_msg) {  proto_item_append_text (ti, "" (Message Reassembled)""); } else {  proto_item_append_text (ti, "" (Message fragment %u)"", frag_seq); } if(next_tvb) { call_dissector (eth_withoutfcs_handle, next_tvb, pinfo, docsis_tree); } else { tvbuff_t *payload_tvb = tvb_new_subset_length_caplen(tvb, hdrlen, (len_sid - 4), -1); call_data_dissector(payload_tvb, pinfo, docsis_tree); } } else { expert_add_info(pinfo, ti, &ei_docsis_frag_fcs_bad); } proto_tree_add_checksum(docsis_tree, tvb, (hdrlen + len_sid - 4), hf_docsis_frag_fcs, hf_docsis_frag_fcs_status, &ei_docsis_frag_fcs_bad, pinfo, fcs, ENC_BIG_ENDIAN, PROTO_CHECKSUM_VERIFY); pinfo->fragmented = save_fragmented; break; } case FCPARM_QUEUE_DEPTH_REQ_FRM: { proto_tree_add_uint (docsis_tree, hf_docsis_requested_size, tvb, 1, 2, mac_parm); proto_tree_add_uint (docsis_tree, hf_docsis_sid, tvb, 3, 2, len_sid); dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen); if (concatlen > 0) { concatlen = concatlen - framelen; concatpos += framelen; } break; } case FCPARM_CONCAT_HDR: { proto_item_append_text (ti, "" (Concatenated Header)""); proto_tree_add_item (docsis_tree, hf_docsis_concat_cnt, tvb, 1, 1, ENC_BIG_ENDIAN); proto_tree_add_item (docsis_tree, hf_docsis_len, tvb, 2, 2, ENC_BIG_ENDIAN); dissect_hcs_field (tvb, pinfo, docsis_tree, hdrlen); concatlen = len_sid; concatpos = DOCSIS_MIN_HEADER_LEN; while (concatlen > 0) { next_tvb = tvb_new_subset_length_caplen (tvb, concatpos, -1, concatlen); call_dissector (docsis_handle, next_tvb, pinfo, docsis_tree); } concatlen = 0; concatpos = 0; break; } default: concatlen = 0; break; }  break; } }  return tvb_captured_length(tvb); }
Description: In Wireshark 2.4.0 to 2.4.1, the DOCSIS dissector could go into an infinite loop. This was addressed in plugins/docsis/packet-docsis.c by adding decrements.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void ASessionDescription::getFormatType( size_t index, unsigned long *PT, AString *desc, AString *params) const { AString format; getFormat(index, &format); const char *lastSpacePos = strrchr(format.c_str(), ' '); CHECK(lastSpacePos != NULL); char *end; unsigned long x = strtoul(lastSpacePos + 1, &end, 10); CHECK_GT(end, lastSpacePos + 1); CHECK_EQ(*end, '\0'); *PT = x; char key[20]; sprintf(key, ""a=rtpmap:%lu"", x); CHECK(findAttribute(index, key, desc)); sprintf(key, ""a=fmtp:%lu"", x); if (!findAttribute(index, key, params)) { params->clear(); } }
Description: Multiple buffer overflows in rtsp/ASessionDescription.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 allow remote attackers to cause a denial of service (device hang or reboot) via a crafted media file, aka internal bug 25747670.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int snmp_helper(void *context, size_t hdrlen, unsigned char tag, const void *data, size_t datalen) { struct snmp_ctx *ctx = (struct snmp_ctx *)context; __be32 *pdata = (__be32 *)data; if (*pdata == ctx->from) { pr_debug(""%s: %pI4 to %pI4\n"", __func__, (void *)&ctx->from, (void *)&ctx->to); if (*ctx->check) fast_csum(ctx, (unsigned char *)data - ctx->begin); *pdata = ctx->to; } return 1; }
Description: In the Linux kernel before 4.20.12, net/ipv4/netfilter/nf_nat_snmp_basic_main.c in the SNMP NAT module has insufficient ASN.1 length checks (aka an array index error), making out-of-bounds read and write operations possible, leading to an OOPS or local privilege escalation. This affects snmp_version and snmp_helper.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static PyObject * _pickle_UnpicklerMemoProxy_copy_impl(UnpicklerMemoProxyObject *self) { Py_ssize_t i; PyObject *new_memo = PyDict_New(); if (new_memo == NULL) return NULL; for (i = 0; i < self->unpickler->memo_size; i++) { int status; PyObject *key, *value; value = self->unpickler->memo[i]; if (value == NULL) continue; key = PyLong_FromSsize_t(i); if (key == NULL) goto error; status = PyDict_SetItem(new_memo, key, value); Py_DECREF(key); if (status < 0) goto error; } return new_memo; error: Py_DECREF(new_memo); return NULL; }
Description: Modules/_pickle.c in Python before 3.7.1 has an integer overflow via a large LONG_BINPUT value that is mishandled during a ""resize to twice the size"" attempt. This issue might cause memory exhaustion, but is only relevant if the pickle format is used for serializing tens or hundreds of gigabytes of data. This issue is fixed in: v3.4.10, v3.4.10rc1; v3.5.10, v3.5.10rc1, v3.5.7, v3.5.7rc1, v3.5.8, v3.5.8rc1, v3.5.8rc2, v3.5.9; v3.6.10, v3.6.10rc1, v3.6.11, v3.6.11rc1, v3.6.12, v3.6.7, v3.6.7rc1, v3.6.7rc2, v3.6.8, v3.6.8rc1, v3.6.9, v3.6.9rc1; v3.7.1, v3.7.1rc1, v3.7.1rc2, v3.7.2, v3.7.2rc1, v3.7.3, v3.7.3rc1, v3.7.4, v3.7.4rc1, v3.7.4rc2, v3.7.5, v3.7.5rc1, v3.7.6, v3.7.6rc1, v3.7.7, v3.7.7rc1, v3.7.8, v3.7.8rc1, v3.7.9.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool SkRgnBuilder::init(int maxHeight, int maxTransitions, bool pathIsInverse) { if ((maxHeight | maxTransitions) < 0) { return false; } if (pathIsInverse) { maxTransitions += 2; } int64_t count = sk_64_mul(maxHeight + 1, 3 + maxTransitions); if (pathIsInverse) { count += 10; } if (count < 0 || !sk_64_isS32(count)) { return false; } fStorageCount = sk_64_asS32(count); int64_t size = sk_64_mul(fStorageCount, sizeof(SkRegion::RunType)); if (size < 0 || !sk_64_isS32(size)) { return false; } fStorage = (SkRegion::RunType*)sk_malloc_flags(sk_64_asS32(size), 0); if (nullptr == fStorage) { return false; } fCurrScanline = nullptr;        fPrevScanline = nullptr;        return true; }
Description: In SkSampler::Fill of SkSampler.cpp, there is a possible out of bounds write due to an integer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android ID: A-78354855
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static MagickBooleanType ReadPSDChannel(Image *image, const ImageInfo *image_info,const PSDInfo *psd_info,LayerInfo* layer_info, const size_t channel,const PSDCompressionType compression, ExceptionInfo *exception) { Image *channel_image, *mask; MagickOffsetType offset; MagickBooleanType status; channel_image=image; mask=(Image *) NULL; if ((layer_info->channel_info[channel].type < -1) && (layer_info->mask.page.width > 0) && (layer_info->mask.page.height > 0)) { const char *option; option=GetImageOption(image_info,""psd:preserve-opacity-mask""); if ((layer_info->channel_info[channel].type != -2) || (layer_info->mask.flags > 2) || ((layer_info->mask.flags & 0x02) && (IsStringTrue(option) == MagickFalse))) { SeekBlob(image,layer_info->channel_info[channel].size-2,SEEK_CUR); return(MagickTrue); } mask=CloneImage(image,layer_info->mask.page.width, layer_info->mask.page.height,MagickFalse,exception); if (mask != (Image *) NULL) { SetImageType(mask,GrayscaleType,exception); channel_image=mask; } } offset=TellBlob(image); status=MagickFalse; switch(compression) { case Raw: status=ReadPSDChannelRaw(channel_image,psd_info->channels, layer_info->channel_info[channel].type,exception); break; case RLE: { MagickOffsetType *sizes; sizes=ReadPSDRLESizes(channel_image,psd_info,channel_image->rows); if (sizes == (MagickOffsetType *) NULL) ThrowBinaryException(ResourceLimitError,""MemoryAllocationFailed"", image->filename); status=ReadPSDChannelRLE(channel_image,psd_info, layer_info->channel_info[channel].type,sizes,exception); sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes); } break; case ZipWithPrediction: case ZipWithoutPrediction: #ifdef MAGICKCORE_ZLIB_DELEGATE status=ReadPSDChannelZip(channel_image,layer_info->channels, layer_info->channel_info[channel].type,compression, layer_info->channel_info[channel].size-2,exception); #else (void) ThrowMagickException(exception,GetMagickModule(), MissingDelegateWarning,""DelegateLibrarySupportNotBuiltIn"", ""'%s' (ZLIB)"",image->filename); #endif break; default: (void) ThrowMagickException(exception,GetMagickModule(),TypeWarning, ""CompressionNotSupported"",""'%.20g'"",(double) compression); break; } SeekBlob(image,offset+layer_info->channel_info[channel].size-2,SEEK_SET); if (status == MagickFalse) { if (mask != (Image *) NULL) DestroyImage(mask); ThrowBinaryException(CoderError,""UnableToDecompressImage"", image->filename); } layer_info->mask.image=mask; return(status); }
Description: In coders/psd.c in ImageMagick 7.0.7-0 Q16, a DoS in ReadPSDLayersInternal() due to lack of an EOF (End of File) check might cause huge CPU consumption. When a crafted PSD file, which claims a large ""length"" field in the header but does not contain sufficient backing data, is provided, the loop over ""length"" would consume huge CPU resources, since there is no EOF check inside the loop.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void subtract (const hb_bit_set_invertible_t &other) { if (likely (inverted == other.inverted)) { if (unlikely (inverted)) process (hb_bitwise_lt, other); else process (hb_bitwise_gt, other);  } else { if (unlikely (inverted)) process (hb_bitwise_or, other); else process (hb_bitwise_and, other); } inverted = inverted && !other.inverted; }
Description: HarfBuzz 2.9.0 has an out-of-bounds write in hb_bit_set_invertible_t::set (called from hb_sparseset_t<hb_bit_set_invertible_t>::set and hb_set_copy).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static gint dissect_wccp2_mask_value_set_list(tvbuff_t *tvb, int offset, int length, packet_info *pinfo, proto_tree *info_tree, wccp_address_table* addr_table) { guint num_of_elem; guint i; proto_item *te; proto_tree *element_tree; guint start; if (length < 4) return length - 4; element_tree = proto_tree_add_subtree(info_tree, tvb, offset, 4, ett_mv_set_list, &te, ""Mask/Value Set List""); start = offset; num_of_elem = tvb_get_ntohl(tvb, offset); proto_tree_add_item(element_tree, hf_mask_value_set_list_num_elements, tvb, offset, 4, ENC_BIG_ENDIAN); EAT(4); for (i = 0; i < num_of_elem; i++) { gint new_length; new_length=dissect_wccp2_mask_value_set_element(tvb, offset, length, i, pinfo, element_tree, addr_table); NOTE_EATEN_LENGTH(new_length); } proto_item_set_len(te, offset-start); return length; }
Description: In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-wccp.c had a large loop that was addressed by ensuring that a calculated length was monotonically increasing.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void dissect_coap_opt_object_security(tvbuff_t *tvb, proto_item *head_item, proto_tree *subtree, gint offset, gint opt_length, packet_info *pinfo, coap_info *coinfo, coap_common_dissect_t *dissect_hf) { guint8 flag_byte = 0; gboolean non_compressed = FALSE; gboolean expand = FALSE; gboolean signature_present = FALSE; gboolean kid_context_present = FALSE; gboolean kid_present = FALSE; guint8 piv_len = 0; guint8 kid_context_len = 0; guint8 kid_len = 0; coinfo->object_security = TRUE; coinfo->oscore_info->piv = NULL; coinfo->oscore_info->kid_context = NULL; coinfo->oscore_info->kid = NULL; if (opt_length == 0) {  proto_item_append_text(head_item, "": 00 (no Flag Byte)""); } else { flag_byte = tvb_get_guint8(tvb, offset); proto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_non_compressed, tvb, offset, 1, ENC_BIG_ENDIAN); non_compressed = flag_byte & COAP_OBJECT_SECURITY_NON_COMPRESSED_MASK; proto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_expand, tvb, offset, 1, ENC_BIG_ENDIAN); expand = flag_byte & COAP_OBJECT_SECURITY_EXPAND_MASK; proto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_signature, tvb, offset, 1, ENC_BIG_ENDIAN); signature_present = flag_byte & COAP_OBJECT_SECURITY_SIGNATURE_MASK; proto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_kid_context_present, tvb, offset, 1, ENC_BIG_ENDIAN); kid_context_present = flag_byte & COAP_OBJECT_SECURITY_KID_CONTEXT_MASK; proto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_kid_present, tvb, offset, 1, ENC_BIG_ENDIAN); kid_present = flag_byte & COAP_OBJECT_SECURITY_KID_MASK; proto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_piv_len, tvb, offset, 1, ENC_BIG_ENDIAN); piv_len = (flag_byte & COAP_OBJECT_SECURITY_PIVLEN_MASK) >> 0; kid_len = opt_length; offset += 1; kid_len -= 1; if (non_compressed || expand || signature_present) { expert_add_info_format(pinfo, subtree, &dissect_hf->ei.opt_object_security_bad, ""Unsupported format""); } if (piv_len > 0) { proto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_piv, tvb, offset, piv_len, ENC_NA); coinfo->oscore_info->piv = (guint8 *) tvb_memdup(wmem_packet_scope(), tvb, offset, piv_len); coinfo->oscore_info->piv_len = piv_len; offset += piv_len; kid_len -= piv_len; } if (kid_context_present) { proto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_kid_context_len, tvb, offset, 1, ENC_BIG_ENDIAN); kid_context_len = tvb_get_guint8(tvb, offset); offset += 1; kid_len -= 1; proto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_kid_context, tvb, offset, kid_context_len, ENC_NA); coinfo->oscore_info->kid_context = (guint8 *) tvb_memdup(wmem_packet_scope(), tvb, offset, kid_context_len); coinfo->oscore_info->kid_context_len = kid_context_len; offset += kid_context_len; kid_len -= kid_context_len; } if (kid_present) { if(kid_len > 0) { proto_tree_add_item(subtree, dissect_hf->hf.opt_object_security_kid, tvb, offset, kid_len, ENC_NA); coinfo->oscore_info->kid = (guint8 *) tvb_memdup(wmem_packet_scope(), tvb, offset, kid_len); coinfo->oscore_info->kid_len = kid_len; } else { expert_add_info_format(pinfo, subtree, &dissect_hf->ei.opt_object_security_bad, ""Key ID flag is set but there are no remaining bytes to be processed""); } } proto_item_append_text(head_item, "": Key ID:%s, Key ID Context:%s, Partial IV:%s"", coinfo->oscore_info->kid == NULL ? nullstr : bytes_to_str(wmem_packet_scope(), coinfo->oscore_info->kid, coinfo->oscore_info->kid_len), coinfo->oscore_info->kid_context == NULL ? nullstr : bytes_to_str(wmem_packet_scope(), coinfo->oscore_info->kid_context, coinfo->oscore_info->kid_context_len), coinfo->oscore_info->piv == NULL ? nullstr : bytes_to_str(wmem_packet_scope(), coinfo->oscore_info->piv, coinfo->oscore_info->piv_len)); } }
Description: In Wireshark 2.6.0 to 2.6.3, the CoAP dissector could crash. This was addressed in epan/dissectors/packet-coap.c by ensuring that the piv length is correctly computed.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void qf_jump_newwin(qf_info_T*qi, intdir, interrornr, intforceit, intnewwin) { qf_list_T*qfl; qfline_T*qf_ptr; qfline_T*old_qf_ptr; intqf_index; intold_qf_index; char_u*old_swb = p_swb; unsignedold_swb_flags = swb_flags; intprev_winid; intopened_window = FALSE; intprint_message = TRUE; intold_KeyTyped = KeyTyped;     intretval = OK; if (qi == NULL) qi = &ql_info; if (qf_stack_empty(qi) || qf_list_empty(qf_get_curlist(qi))) { emsg(_(e_no_errors)); return; } incr_quickfix_busy(); qfl = qf_get_curlist(qi); qf_ptr = qfl->qf_ptr; old_qf_ptr = qf_ptr; qf_index = qfl->qf_index; old_qf_index = qf_index; qf_ptr = qf_get_entry(qfl, errornr, dir, &qf_index); if (qf_ptr == NULL) { qf_ptr = old_qf_ptr; qf_index = old_qf_index; goto theend; } qfl->qf_index = qf_index; qfl->qf_ptr = qf_ptr; if (qf_win_pos_update(qi, old_qf_index)) print_message = FALSE; prev_winid = curwin->w_id; retval = qf_jump_open_window(qi, qf_ptr, newwin, &opened_window); if (retval == FAIL) goto failed; if (retval == NOTDONE) goto theend; retval = qf_jump_to_buffer(qi, qf_index, qf_ptr, forceit, prev_winid, &opened_window, old_KeyTyped, print_message); if (retval == NOTDONE) { qi = NULL; qf_ptr = NULL; } if (retval != OK) { if (opened_window) win_close(curwin, TRUE);    if (qf_ptr != NULL && qf_ptr->qf_fnum != 0) { failed: qf_ptr = old_qf_ptr; qf_index = old_qf_index; } } theend: if (qi != NULL) { qfl->qf_ptr = qf_ptr; qfl->qf_index = qf_index; } if (p_swb != old_swb && p_swb == empty_option) { p_swb = old_swb; swb_flags = old_swb_flags; } decr_quickfix_busy(); }
Description: Use After Free in GitHub repository vim/vim prior to 9.0.0286.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: WebUIFactoryFunction GetWebUIFactoryFunction(WebUI* web_ui, Profile* profile, const GURL& url) { if (!content::HasWebUIScheme(url)) { return nullptr; } if (url.host_piece() == kAdblockHost || url.host_piece() == kAdblockInternalsHost || url.host_piece() == kWebcompatReporterHost || (url.host_piece() == kSkusInternalsHost && base::FeatureList::IsEnabled(skus::features::kSkusFeature)) || #if BUILDFLAG(ENABLE_IPFS_INTERNALS_WEBUI) (url.host_piece() == kIPFSWebUIHost && ipfs::IpfsServiceFactory::IsIpfsEnabled(profile)) || #endif  #if BUILDFLAG(IS_ANDROID) (url.is_valid() && url.host_piece() == kWalletPageHost && (url.path() == kWalletSwapPagePath || url.path() == kWalletSendPagePath || url.path() == kWalletBuyPagePath || url.path() == kWalletDepositPagePath)) || #else (base::FeatureList::IsEnabled( brave_news::features::kBraveNewsFeedUpdate) && url.host_piece() == kBraveNewsInternalsHost) || ((url.host_piece() == kWalletPanelHost || url.host_piece() == kWalletPageHost) && brave_wallet::IsAllowedForContext(profile)) || url.host_piece() == kBraveRewardsPanelHost || url.host_piece() == kBraveTipPanelHost || url.host_piece() == kSpeedreaderPanelHost || url.host_piece() == chrome::kChromeUINewTabHost || url.host_piece() == chrome::kChromeUISettingsHost || ((url.host_piece() == kWelcomeHost || url.host_piece() == chrome::kChromeUIWelcomeURL) && !profile->IsGuestSession()) || url.host_piece() == kShieldsPanelHost || (url.host_piece() == kCookieListOptInHost && base::FeatureList::IsEnabled( brave_shields::features::kBraveAdblockCookieListOptIn)) || #endif  #if BUILDFLAG(ENABLE_TOR) url.host_piece() == kTorInternalsHost || #endif url.host_piece() == kRewardsPageHost || url.host_piece() == kRewardsInternalsHost) { return &NewWebUI; } return nullptr; }
Description: Brave Browser before 1.59.40 does not properly restrict the schema for WebUI factory and redirect. This is related to browser/brave_content_browser_client.cc and browser/ui/webui/brave_web_ui_controller_factory.cc.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void sunkbd_enable(struct sunkbd *sunkbd, bool enable) { serio_pause_rx(sunkbd->serio); sunkbd->enabled = enable; serio_continue_rx(sunkbd->serio); }
Description: A vulnerability was found in the Linux Kernel where the function sunkbd_reinit having been scheduled by sunkbd_interrupt before sunkbd being freed. Though the dangling pointer is set to NULL in sunkbd_disconnect, there is still an alias in sunkbd_reinit causing Use After Free.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int dtls1_process_heartbeat(SSL *s) { unsigned char *p = &s->s3->rrec.data[0], *pl; unsigned short hbtype; unsigned int payload; unsigned int padding = 16;  hbtype = *p++; n2s(p, payload); pl = p; if (s->msg_callback) s->msg_callback(0, s->version, TLS1_RT_HEARTBEAT, &s->s3->rrec.data[0], s->s3->rrec.length, s, s->msg_callback_arg); if (hbtype == TLS1_HB_REQUEST) { unsigned char *buffer, *bp; int r; buffer = OPENSSL_malloc(1 + 2 + payload + padding); bp = buffer; *bp++ = TLS1_HB_RESPONSE; s2n(payload, bp); memcpy(bp, pl, payload); bp += payload; RAND_pseudo_bytes(bp, padding); r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding); if (r >= 0 && s->msg_callback) s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding, s, s->msg_callback_arg); OPENSSL_free(buffer); if (r < 0) return r; } else if (hbtype == TLS1_HB_RESPONSE) { unsigned int seq; n2s(pl, seq); if (payload == 18 && seq == s->tlsext_hb_seq) { dtls1_stop_timer(s); s->tlsext_hb_seq++; s->tlsext_hb_pending = 0; } } return 0; }
Description: The (1) TLS and (2) DTLS implementations in OpenSSL 1.0.1 before 1.0.1g do not properly handle Heartbeat Extension packets, which allows remote attackers to obtain sensitive information from process memory via crafted packets that trigger a buffer over-read, as demonstrated by reading private keys, related to d1_both.c and t1_lib.c, aka the Heartbleed bug.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int md_is_named_entity_contents(MD_CTX* ctx, const CHAR* text, OFF beg, OFF max_end, OFF* p_end) { OFF off = beg; if(off <= max_end  &&  ISALPHA_(text[off])) off++; else return FALSE; while(off < max_end  &&  ISALNUM_(text[off])  &&  off - beg <= 48) off++; if(2 <= off - beg  &&  off - beg <= 48) { *p_end = off; return TRUE; } else { return FALSE; } }
Description: md4c 0.2.5 has a heap-based buffer over-read because md_is_named_entity_contents has an off-by-one error.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void dissect_rtmpt_common(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, rtmpt_conv_t *rconv, int cdir, guint32 seq, guint32 lastackseq) { int     offset = 0; int     remain; int     want; guint8  header_type; int     basic_hlen; int     message_hlen; guint32 id; guint32 ts     = 0; guint32 tsd    = 0; int     body_len; guint8  cmd; guint32 src; int     chunk_size; rtmpt_frag_t   *tf; rtmpt_id_t     *ti; rtmpt_packet_t *tp; tvbuff_t       *pktbuf; remain = tvb_reported_length(tvb); if (!remain) return; RTMPT_DEBUG(""Segment: cdir=%d seq=%d-%d\n"", cdir, seq, seq+remain-1); if (pinfo->fd->flags.visited) { wmem_stack_t *packets; packets = wmem_stack_new(wmem_packet_scope()); wmem_stack_push(packets, 0); tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(rconv->packets[cdir], seq+remain-1); while (tp && tp->lastseq >= seq) { wmem_stack_push(packets, tp); tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(rconv->packets[cdir], tp->lastseq-1); } while ((tp=(rtmpt_packet_t *)wmem_stack_pop(packets)) != NULL) { if (tp->resident) { pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have); add_new_data_source(pinfo, pktbuf, ""Unchunked RTMP""); } else { pktbuf = tvb_new_subset_length(tvb, tp->data.offset, tp->have); } dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp); } return; } while (remain>0) { tf = NULL; ti = NULL; tp = NULL; if (offset == 0) { tf = (rtmpt_frag_t *)wmem_tree_lookup32_le(rconv->frags[cdir], seq+offset-1); if (tf) { RTMPT_DEBUG(""  tf seq=%d lseq=%d h=%d l=%d\n"", tf->seq, tf->lastseq, tf->have, tf->len); if (tf->have >= tf->len || seq+offset < tf->seq || seq+offset > tf->lastseq+tf->len-tf->have) { tf = NULL; } else if (!tf->ishdr) { ti = (rtmpt_id_t *)wmem_tree_lookup32(rconv->ids[cdir], tf->saved.id); if (ti) { tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(ti->packets, seq+offset-1); } if (tp && tp->chunkwant) { goto unchunk; } tf = NULL; ti = NULL; tp = NULL; } if (tf) { want = tf->len - tf->have; if (remain<want) want = remain; tvb_memcpy(tvb, tf->saved.d+tf->have, offset, want); id = tf->saved.d[0]; header_type = (id>>6) & 3; basic_hlen = rtmpt_basic_header_length(id); if ((header_type < 3) && (tf->have < (basic_hlen+3)) && (tf->have+want >= (basic_hlen+3))) { if (pntoh24(tf->saved.d+basic_hlen) == 0xffffff) { tf->len += 4; } } tf->have += want; tf->lastseq = seq+want-1; remain -= want; offset += want; if (tf->have < tf->len) { return; } } } } if (!tf) { id = tvb_get_guint8(tvb, offset); if (id == RTMPT_MAGIC && seq+offset == RTMPT_HANDSHAKE_OFFSET_1) { header_type = 4; basic_hlen = 1; message_hlen = 0; id = lastackseq == 1 ? RTMPT_TYPE_HANDSHAKE_1 : RTMPT_TYPE_HANDSHAKE_2; } else if (seq+offset == RTMPT_HANDSHAKE_OFFSET_2) { header_type = 4; basic_hlen = 0; message_hlen = 0; id = RTMPT_TYPE_HANDSHAKE_3; } else { header_type = (id>>6) & 3; basic_hlen = rtmpt_basic_header_length(id); message_hlen = rtmpt_message_header_length(id); if ((header_type < 3) && (remain >= (basic_hlen+3))) { if (tvb_get_ntoh24(tvb, offset+basic_hlen) == 0xffffff) { message_hlen += 4; } } if (remain < (basic_hlen+message_hlen)) { tf = wmem_new(wmem_file_scope(), rtmpt_frag_t); tf->ishdr = 1; tf->seq = seq + offset; tf->lastseq = tf->seq + remain - 1; tf->len = basic_hlen + message_hlen; tvb_memcpy(tvb, tf->saved.d, offset, remain); tf->have = remain; wmem_tree_insert32(rconv->frags[cdir], seq+offset, tf); return; } id = id & 0x3f; if (id == 0) id = tvb_get_guint8(tvb, offset+1) + 64; else if (id == 1) id = tvb_get_letohs(tvb, offset+1) + 64; } } else { id = tf->saved.d[0]; header_type = (id>>6) & 3; basic_hlen = rtmpt_basic_header_length(id); message_hlen = tf->len - basic_hlen; id = id & 0x3f; if (id == 0) id = tf->saved.d[1] + 64; else if (id == 1) id = pletoh16(tf->saved.d+1) + 64; } if (id <= RTMPT_ID_MAX) ti = (rtmpt_id_t *)wmem_tree_lookup32(rconv->ids[cdir], id); if (ti) tp = (rtmpt_packet_t *)wmem_tree_lookup32_le(ti->packets, seq+offset-1); if (header_type == 0) src = tf ? pntoh32(tf->saved.d+basic_hlen+7) : tvb_get_ntohl(tvb, offset+basic_hlen+7); else if (ti) src = ti->src; else src = 0; if (header_type < 2) cmd = tf ? tf->saved.d[basic_hlen+6] : tvb_get_guint8(tvb, offset+basic_hlen+6); else if (ti) cmd = ti->cmd; else cmd = 0; if (id > RTMPT_ID_MAX) { if (id == RTMPT_TYPE_HANDSHAKE_1) chunk_size = body_len = 1536; else if (id == RTMPT_TYPE_HANDSHAKE_2) chunk_size = body_len = 3072; else  chunk_size = body_len = 1536; } else { chunk_size = GPOINTER_TO_INT(wmem_tree_lookup32_le(rconv->chunksize[cdir], seq+offset-1)); if (!chunk_size) chunk_size = RTMPT_DEFAULT_CHUNK_SIZE; if (header_type < 2) body_len = tf ? pntoh24(tf->saved.d+basic_hlen+3) : tvb_get_ntoh24(tvb, offset+basic_hlen+3); else if (ti) body_len = ti->len; else body_len = chunk_size; if (body_len > (gint)rtmpt_max_packet_size) { return; } } if (!ti || !tp || header_type<3 || tp->have == tp->want || tp->chunkhave != tp->chunkwant) { RTMPT_DEBUG(""New packet cdir=%d seq=%d ti=%p tp=%p header_type=%d header_len=%d id=%d tph=%d tpw=%d len=%d cs=%d\n"", cdir, seq+offset, ti, tp, header_type, basic_hlen+message_hlen, id, tp?tp->have:0, tp?tp->want:0, body_len, chunk_size); if (!ti) { ti = wmem_new(wmem_file_scope(), rtmpt_id_t); ti->packets = wmem_tree_new(wmem_file_scope()); ti->ts  = 0; ti->tsd = 0; wmem_tree_insert32(rconv->ids[cdir], id, ti); } if (header_type == 0) { ts = tf ? pntoh24(tf->saved.d+basic_hlen) : tvb_get_ntoh24(tvb, offset+basic_hlen); if (ts == 0xffffff) { ts = tf ? pntoh32(tf->saved.d+basic_hlen+11) : tvb_get_ntohl(tvb, offset+basic_hlen+11); } tsd = ts - ti->ts; } else if (header_type < 3) { tsd = tf ? pntoh24(tf->saved.d+basic_hlen) : tvb_get_ntoh24(tvb, offset+basic_hlen); if (tsd == 0xffffff) { ts  = tf ? pntoh32(tf->saved.d+basic_hlen+message_hlen-4) : tvb_get_ntohl(tvb, offset+basic_hlen+message_hlen-4); tsd = ti->tsd;  } else { ts  = ti->ts + tsd; } } else { ts  = ti->ts + ti->tsd; tsd = ti->tsd; } tp             = wmem_new(wmem_file_scope(), rtmpt_packet_t); tp->seq        = tp->lastseq = tf ? tf->seq : seq+offset; tp->have       = 0; tp->want       = basic_hlen + message_hlen + body_len; tp->chunkwant  = 0; tp->chunkhave  = 0; tp->bhlen      = basic_hlen; tp->mhlen      = message_hlen; tp->fmt        = header_type; tp->id         = id; tp->ts         = ts; tp->len        = body_len; if (id > RTMPT_ID_MAX) tp->cmd = id; else tp->cmd = cmd & 0x7f; tp->src        = src; tp->txid       = 0; tp->isresponse = FALSE; tp->otherframe = 0; ti->ts  = ts; ti->tsd = tsd; ti->len = body_len; ti->cmd = cmd; ti->src = src; wmem_tree_insert32(ti->packets, tp->seq, tp); if (!tf && body_len <= chunk_size && tp->want <= remain) { tp->resident    = FALSE; tp->data.offset = offset; tp->lastseq     = seq+offset+tp->want-1; tp->have        = tp->want; wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp); pktbuf = tvb_new_subset_length(tvb, tp->data.offset, tp->have); dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp); offset += tp->want; remain -= tp->want; continue; } else { tp->resident = TRUE; tp->data.p = (guint8 *)wmem_alloc(wmem_file_scope(), tp->bhlen+tp->mhlen+tp->len); if (tf && tf->ishdr) { memcpy(tp->data.p, tf->saved.d, tf->len); } else { tvb_memcpy(tvb, tp->data.p, offset, basic_hlen+message_hlen); offset += basic_hlen + message_hlen; remain -= basic_hlen + message_hlen; } tp->lastseq = seq+offset-1; tp->have = basic_hlen + message_hlen; if (tp->have == tp->want) { wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp); pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have); add_new_data_source(pinfo, pktbuf, ""Unchunked RTMP""); dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp); continue; } tp->chunkwant = chunk_size; if (tp->chunkwant > tp->want-tp->have) tp->chunkwant = tp->want - tp->have; } } else { RTMPT_DEBUG(""Old packet cdir=%d seq=%d ti=%p tp=%p header_len=%d id=%d tph=%d tpw=%d len=%d cs=%d\n"", cdir, seq+offset, ti, tp, basic_hlen+message_hlen, id, tp?tp->have:0, tp?tp->want:0, body_len, chunk_size); tp->chunkwant = chunk_size; if (tp->chunkwant > tp->want-tp->have) tp->chunkwant = tp->want - tp->have; offset += basic_hlen + message_hlen; remain -= basic_hlen + message_hlen; } tf = NULL; unchunk: want = tp->chunkwant - tp->chunkhave; if (want > remain) want = remain; RTMPT_DEBUG(""  cw=%d ch=%d r=%d w=%d\n"", tp->chunkwant, tp->chunkhave, remain, want); tvb_memcpy(tvb, tp->data.p+tp->have, offset, want); if (tf) { tf->have += want; tf->lastseq = seq+offset+want-1; } tp->lastseq = seq+offset+want-1; tp->have += want; tp->chunkhave += want; offset += want; remain -= want; if (tp->chunkhave == tp->chunkwant) { tp->chunkhave = 0; tp->chunkwant = 0; } if (tp->have == tp->want) { wmem_tree_insert32(rconv->packets[cdir], tp->lastseq, tp); pktbuf = tvb_new_child_real_data(tvb, tp->data.p, tp->have, tp->have); add_new_data_source(pinfo, pktbuf, ""Unchunked RTMP""); dissect_rtmpt(pktbuf, pinfo, tree, rconv, cdir, tp); } else if (tp->chunkhave < tp->chunkwant) { rtmpt_frag_t *tf2 = wmem_new(wmem_file_scope(), rtmpt_frag_t); tf2->ishdr    = 0; tf2->seq      = seq + offset - want; tf2->lastseq  = tf2->seq + remain - 1 + want; tf2->have     = tp->chunkhave; tf2->len      = tp->chunkwant; tf2->saved.id = tp->id; RTMPT_DEBUG(""  inserting tf @ %d\n"", seq+offset-want-1); wmem_tree_insert32(rconv->frags[cdir], seq+offset-want-1, tf2); } } }
Description: In Wireshark 2.2.0 to 2.2.4 and 2.0.0 to 2.0.10, there is an RTMPT dissector infinite loop, triggered by packet injection or a malformed capture file. This was addressed in epan/dissectors/packet-rtmpt.c by properly incrementing a certain sequence value.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: WORK_STATE ossl_statem_server_pre_work(SSL *s, WORK_STATE wst) { OSSL_STATEM *st = &s->statem; switch (st->hand_state) { case TLS_ST_SW_HELLO_REQ: s->shutdown = 0; if (SSL_IS_DTLS(s)) dtls1_clear_record_buffer(s); break; case DTLS_ST_SW_HELLO_VERIFY_REQUEST: s->shutdown = 0; if (SSL_IS_DTLS(s)) { dtls1_clear_record_buffer(s); st->use_timer = 0; } break; case TLS_ST_SW_SRVR_HELLO: if (SSL_IS_DTLS(s)) { st->use_timer = 1; } break; case TLS_ST_SW_SRVR_DONE: #ifndef OPENSSL_NO_SCTP if (SSL_IS_DTLS(s) && BIO_dgram_is_sctp(SSL_get_wbio(s))) return dtls_wait_for_dry(s); #endif return WORK_FINISHED_CONTINUE; case TLS_ST_SW_SESSION_TICKET: if (SSL_IS_DTLS(s)) { st->use_timer = 0; } break; case TLS_ST_SW_CHANGE: s->session->cipher = s->s3->tmp.new_cipher; if (!s->method->ssl3_enc->setup_key_block(s)) { ossl_statem_set_error(s); return WORK_ERROR; } if (SSL_IS_DTLS(s)) { st->use_timer = 0; } return WORK_FINISHED_CONTINUE; case TLS_ST_OK: return tls_finish_handshake(s, wst); default: break; } return WORK_FINISHED_CONTINUE; }
Description: The DTLS implementation in OpenSSL before 1.1.0 does not properly restrict the lifetime of queue entries associated with unused out-of-order messages, which allows remote attackers to cause a denial of service (memory consumption) by maintaining many crafted DTLS sessions simultaneously, related to d1_lib.c, statem_dtls.c, statem_lib.c, and statem_srvr.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: SIXELAPI SIXELSTATUS sixel_dither_new( sixel_dither_t     **ppdither,  int                 ncolors,     sixel_allocator_t   *allocator)  { SIXELSTATUS status = SIXEL_FALSE; size_t headsize; size_t datasize; size_t wholesize; int quality_mode; if (ppdither == NULL) { sixel_helper_set_additional_message( ""sixel_dither_new: ppdither is null.""); status = SIXEL_BAD_ARGUMENT; goto end; } if (allocator == NULL) { status = sixel_allocator_new(&allocator, NULL, NULL, NULL, NULL); if (SIXEL_FAILED(status)) { *ppdither = NULL; goto end; } } else { sixel_allocator_ref(allocator); } if (ncolors < 0) { ncolors = 256; quality_mode = SIXEL_QUALITY_HIGHCOLOR; } else { if (ncolors > SIXEL_PALETTE_MAX) { ncolors = 256; } else if (ncolors < 2) { ncolors = 2; } quality_mode = SIXEL_QUALITY_LOW; } headsize = sizeof(sixel_dither_t); datasize = (size_t)(ncolors * 3); wholesize = headsize + datasize; *ppdither = (sixel_dither_t *)sixel_allocator_malloc(allocator, wholesize); if (*ppdither == NULL) { sixel_allocator_unref(allocator); sixel_helper_set_additional_message( ""sixel_dither_new: sixel_allocator_malloc() failed.""); status = SIXEL_BAD_ALLOCATION; goto end; } (*ppdither)->ref = 1; (*ppdither)->palette = (unsigned char*)(*ppdither + 1); (*ppdither)->cachetable = NULL; (*ppdither)->reqcolors = ncolors; (*ppdither)->ncolors = ncolors; (*ppdither)->origcolors = (-1); (*ppdither)->keycolor = (-1); (*ppdither)->optimized = 0; (*ppdither)->optimize_palette = 0; (*ppdither)->complexion = 1; (*ppdither)->bodyonly = 0; (*ppdither)->method_for_largest = SIXEL_LARGE_NORM; (*ppdither)->method_for_rep = SIXEL_REP_CENTER_BOX; (*ppdither)->method_for_diffuse = SIXEL_DIFFUSE_FS; (*ppdither)->quality_mode = quality_mode; (*ppdither)->pixelformat = SIXEL_PIXELFORMAT_RGB888; (*ppdither)->allocator = allocator; status = SIXEL_OK; end: return status; }
Description: An issue in the dither.c component of libsixel prior to v1.8.4 allows attackers to cause a denial of service (DOS) via a crafted PNG file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void evtchn_free(struct domain *d, struct evtchn *chn) { evtchn_port_clear_pending(d, chn); chn->state          = ECS_FREE; chn->notify_vcpu_id = 0; chn->xen_consumer   = 0; xsm_evtchn_close_post(chn); }
Description: An issue was discovered in Xen through 4.14.x. There are evtchn_reset() race conditions. Uses of EVTCHNOP_reset (potentially by a guest on itself) or XEN_DOMCTL_soft_reset (by itself covered by XSA-77) can lead to the violation of various internal assumptions. This may lead to out of bounds memory accesses or triggering of bug checks. In particular, x86 PV guests may be able to elevate their privilege to that of the host. Host and guest crashes are also possible, leading to a Denial of Service (DoS). Information leaks cannot be ruled out. All Xen versions from 4.5 onwards are vulnerable. Xen versions 4.4 and earlier are not vulnerable.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static xmlNodePtr xsltCopyText(xsltTransformContextPtr ctxt, xmlNodePtr target, xmlNodePtr cur, int interned) { xmlNodePtr copy; if ((cur->type != XML_TEXT_NODE) && (cur->type != XML_CDATA_SECTION_NODE)) return(NULL); if (cur->content == NULL) return(NULL); #ifdef WITH_XSLT_DEBUG_PROCESS if (cur->type == XML_CDATA_SECTION_NODE) { XSLT_TRACE(ctxt,XSLT_TRACE_COPY_TEXT,xsltGenericDebug(xsltGenericDebugContext, ""xsltCopyText: copy CDATA text %s\n"", cur->content)); } else if (cur->name == xmlStringTextNoenc) { XSLT_TRACE(ctxt,XSLT_TRACE_COPY_TEXT,xsltGenericDebug(xsltGenericDebugContext, ""xsltCopyText: copy unescaped text %s\n"", cur->content)); } else { XSLT_TRACE(ctxt,XSLT_TRACE_COPY_TEXT,xsltGenericDebug(xsltGenericDebugContext, ""xsltCopyText: copy text %s\n"", cur->content)); } #endif if ((target == NULL) || (target->children == NULL)) { ctxt->lasttext = NULL; } if ((ctxt->style->cdataSection != NULL) && (ctxt->type == XSLT_OUTPUT_XML) && (target != NULL) && (target->type == XML_ELEMENT_NODE) && (((target->ns == NULL) && (xmlHashLookup2(ctxt->style->cdataSection, target->name, NULL) != NULL)) || ((target->ns != NULL) && (xmlHashLookup2(ctxt->style->cdataSection, target->name, target->ns->href) != NULL)))) { if ((target->last != NULL) && (target->last->type == XML_CDATA_SECTION_NODE)) { copy = xsltAddTextString(ctxt, target->last, cur->content, xmlStrlen(cur->content)); goto exit; } else { unsigned int len; len = xmlStrlen(cur->content); copy = xmlNewCDataBlock(ctxt->output, cur->content, len); if (copy == NULL) goto exit; ctxt->lasttext = copy->content; ctxt->lasttsize = len; ctxt->lasttuse = len; } } else if ((target != NULL) && (target->last != NULL) && (((target->last->type == XML_TEXT_NODE) && (target->last->name == cur->name)) || (((target->last->type == XML_CDATA_SECTION_NODE) && (cur->name == xmlStringTextNoenc))))) { copy = xsltAddTextString(ctxt, target->last, cur->content, xmlStrlen(cur->content)); goto exit; } else if ((interned) && (target != NULL) && (target->doc != NULL) && (target->doc->dict == ctxt->dict)) { copy = xmlNewTextLen(NULL, 0); if (copy == NULL) goto exit; if (cur->name == xmlStringTextNoenc) copy->name = xmlStringTextNoenc; if (xmlDictOwns(ctxt->dict, cur->content)) copy->content = cur->content; else { if ((copy->content = xmlStrdup(cur->content)) == NULL) return NULL; } } else { unsigned int len; len = xmlStrlen(cur->content); copy = xmlNewTextLen(cur->content, len); if (copy == NULL) goto exit; if (cur->name == xmlStringTextNoenc) copy->name = xmlStringTextNoenc; ctxt->lasttext = copy->content; ctxt->lasttsize = len; ctxt->lasttuse = len; } if (copy != NULL) { if (target != NULL) { copy->doc = target->doc; copy = xsltAddChild(target, copy); } } else { xsltTransformError(ctxt, NULL, target, ""xsltCopyText: text copy failed\n""); } exit: if ((copy == NULL) || (copy->content == NULL)) { xsltTransformError(ctxt, NULL, target, ""Internal error in xsltCopyText(): "" ""Failed to copy the string.\n""); ctxt->state = XSLT_STATE_STOPPED; } return(copy); }
Description: In xsltCopyText in transform.c in libxslt 1.1.33, a pointer variable isn't reset under certain circumstances. If the relevant memory area happened to be freed and reused in a certain way, a bounds check could fail and memory outside a buffer could be written to, or uninitialized data could be disclosed.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bfd_boolean _bfd_elf_parse_gnu_properties (bfd *abfd, Elf_Internal_Note *note) { const struct elf_backend_data *bed = get_elf_backend_data (abfd); unsigned int align_size = bed->s->elfclass == ELFCLASS64 ? 8 : 4; bfd_byte *ptr = (bfd_byte *) note->descdata; bfd_byte *ptr_end = ptr + note->descsz; if (note->descsz < 8 || (note->descsz % align_size) != 0) { bad_size: _bfd_error_handler (_(""warning: %B: corrupt GNU_PROPERTY_TYPE (%ld) size: %#lx""), abfd, note->type, note->descsz); return FALSE; } while (1) { unsigned int type = bfd_h_get_32 (abfd, ptr); unsigned int datasz = bfd_h_get_32 (abfd, ptr + 4); elf_property *prop; ptr += 8; if ((ptr + datasz) > ptr_end) { _bfd_error_handler (_(""warning: %B: corrupt GNU_PROPERTY_TYPE (%ld) type (0x%x) datasz: 0x%x""), abfd, note->type, type, datasz); elf_properties (abfd) = NULL; return FALSE; } if (type >= GNU_PROPERTY_LOPROC) { if (bed->elf_machine_code == EM_NONE) { goto next; } else if (type < GNU_PROPERTY_LOUSER && bed->parse_gnu_properties) { enum elf_property_kind kind = bed->parse_gnu_properties (abfd, type, ptr, datasz); if (kind == property_corrupt) { elf_properties (abfd) = NULL; return FALSE; } else if (kind != property_ignored) goto next; } } else { switch (type) { case GNU_PROPERTY_STACK_SIZE: if (datasz != align_size) { _bfd_error_handler (_(""warning: %B: corrupt stack size: 0x%x""), abfd, datasz); elf_properties (abfd) = NULL; return FALSE; } prop = _bfd_elf_get_property (abfd, type, datasz); if (datasz == 8) prop->u.number = bfd_h_get_64 (abfd, ptr); else prop->u.number = bfd_h_get_32 (abfd, ptr); prop->pr_kind = property_number; goto next; case GNU_PROPERTY_NO_COPY_ON_PROTECTED: if (datasz != 0) { _bfd_error_handler (_(""warning: %B: corrupt no copy on protected size: 0x%x""), abfd, datasz); elf_properties (abfd) = NULL; return FALSE; } prop = _bfd_elf_get_property (abfd, type, datasz); elf_has_no_copy_on_protected (abfd) = TRUE; prop->pr_kind = property_number; goto next; default: break; } } _bfd_error_handler (_(""warning: %B: unsupported GNU_PROPERTY_TYPE (%ld) type: 0x%x""), abfd, note->type, type); next: ptr += (datasz + (align_size - 1)) & ~ (align_size - 1); if (ptr == ptr_end) break; if (ptr > (ptr_end - 8)) goto bad_size; } return TRUE; }
Description: The _bfd_elf_parse_gnu_properties function in elf-properties.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29.1, does not prevent negative pointers, which allows remote attackers to cause a denial of service (out-of-bounds read and application crash) or possibly have unspecified other impact via a crafted ELF file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int64_t TensorByteSize(const TensorProto& t) { int64_t num_elems = TensorShape(t.tensor_shape()).num_elements(); return num_elems < 0 ? -1 : num_elems * DataTypeSize(t.dtype()); }
Description: Tensorflow is an Open Source Machine Learning Framework. A malicious user can cause a denial of service by altering a `SavedModel` such that `TensorByteSize` would trigger `CHECK` failures. `TensorShape` constructor throws a `CHECK`-fail if shape is partial or has a number of elements that would overflow the size of an `int`. The `PartialTensorShape` constructor instead does not cause a `CHECK`-abort if the shape is partial, which is exactly what this function needs to be able to return `-1`. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int ib_prctl_get(struct task_struct *task) { if (!boot_cpu_has_bug(X86_BUG_SPECTRE_V2)) return PR_SPEC_NOT_AFFECTED; switch (spectre_v2_user) { case SPECTRE_V2_USER_NONE: return PR_SPEC_ENABLE; case SPECTRE_V2_USER_PRCTL: case SPECTRE_V2_USER_SECCOMP: if (task_spec_ib_force_disable(task)) return PR_SPEC_PRCTL | PR_SPEC_FORCE_DISABLE; if (task_spec_ib_disable(task)) return PR_SPEC_PRCTL | PR_SPEC_DISABLE; return PR_SPEC_PRCTL | PR_SPEC_ENABLE; case SPECTRE_V2_USER_STRICT: case SPECTRE_V2_USER_STRICT_PREFERRED: return PR_SPEC_DISABLE; default: return PR_SPEC_NOT_AFFECTED; } }
Description: A flaw was found in the Linux kernel before 5.8-rc1 in the implementation of the Enhanced IBPB (Indirect Branch Prediction Barrier). The IBPB mitigation will be disabled when STIBP is not available or when the Enhanced Indirect Branch Restricted Speculation (IBRS) is available. This flaw allows a local attacker to perform a Spectre V2 style attack when this configuration is active. The highest threat from this vulnerability is to confidentiality.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int parseOperand(RAsm *a, const char *str, Operand *op, bool isrepop) { size_t pos, nextpos = 0; x86newTokenType last_type; int size_token = 1; bool explicit_size = false; int reg_index = 0; op->type = 0; while (size_token) { pos = nextpos; last_type = getToken (str, &pos, &nextpos); if (!r_str_ncasecmp (str + pos, ""ptr"", 3)) { continue; } else if (!r_str_ncasecmp (str + pos, ""byte"", 4)) { op->type |= OT_MEMORY | OT_BYTE; op->dest_size = OT_BYTE; explicit_size = true; } else if (!r_str_ncasecmp (str + pos, ""word"", 4)) { op->type |= OT_MEMORY | OT_WORD; op->dest_size = OT_WORD; explicit_size = true; } else if (!r_str_ncasecmp (str + pos, ""dword"", 5)) { op->type |= OT_MEMORY | OT_DWORD; op->dest_size = OT_DWORD; explicit_size = true; } else if (!r_str_ncasecmp (str + pos, ""qword"", 5)) { op->type |= OT_MEMORY | OT_QWORD; op->dest_size = OT_QWORD; explicit_size = true; } else if (!r_str_ncasecmp (str + pos, ""oword"", 5)) { op->type |= OT_MEMORY | OT_OWORD; op->dest_size = OT_OWORD; explicit_size = true; } else if (!r_str_ncasecmp (str + pos, ""tbyte"", 5)) { op->type |= OT_MEMORY | OT_TBYTE; op->dest_size = OT_TBYTE; explicit_size = true; } else { size_token = 0; } } if (str[pos] == '[') { if (!op->type) { op->type = OT_MEMORY; } op->offset = op->scale[0] = op->scale[1] = 0; ut64 temp = 1; Register reg = X86R_UNDEFINED; bool first_reg = true; while (str[pos] != ']') { if (pos > nextpos) { break; } pos = nextpos; if (!str[pos]) { break; } last_type = getToken (str, &pos, &nextpos); if (last_type == TT_SPECIAL) { if (str[pos] == '+' || str[pos] == '-' || str[pos] == ']') { if (reg != X86R_UNDEFINED) { op->regs[reg_index] = reg; op->scale[reg_index] = temp; ++reg_index; } else { op->offset += temp; op->regs[reg_index] = X86R_UNDEFINED; } temp = 1; reg = X86R_UNDEFINED; } else if (str[pos] == '*') { } } else if (last_type == TT_WORD) { ut32 reg_type = 0; if (reg != X86R_UNDEFINED) { op->type = 0;} nextpos = pos; reg = parseReg (a, str, &nextpos, &reg_type); if (first_reg) { op->extended = false; if (reg > 8) { op->extended = true; op->reg = reg - 9; } first_reg = false; } else if (reg > 8) { op->reg = reg - 9; } if (reg_type & OT_REGTYPE & OT_SEGMENTREG) { op->reg = reg; op->type = reg_type; parse_segment_offset (a, str, &nextpos, op, reg_index); return nextpos; } if (!explicit_size) { op->type |= reg_type; } op->reg_size = reg_type; op->explicit_size = explicit_size; if (!(reg_type & OT_GPREG)) { op->type = 0;} } else { char *p = strchr (str, '+'); op->offset_sign = 1; if (!p) { p = strchr (str, '-'); if (p) { op->offset_sign = -1; } } char * plus = strchr (str, '+'); char * minus = strchr (str, '-'); char * closeB = strchr (str, ']'); if (plus && minus && plus < closeB && minus < closeB) { op->offset_sign = -1; } char *tmp; tmp = malloc (strlen (str + pos) + 1); strcpy (tmp, str + pos); strtok (tmp, ""+-""); st64 read = getnum (a, tmp); free (tmp); temp *= read; } } } else if (last_type == TT_WORD) {   nextpos = pos; RFlagItem *flag; if (isrepop) { op->is_good_flag = false; strncpy (op->rep_op, str, MAX_REPOP_LENGTH - 1); op->rep_op[MAX_REPOP_LENGTH - 1] = '\0'; return nextpos; } op->reg = parseReg (a, str, &nextpos, &op->type); op->extended = false; if (op->reg > 8) { op->extended = true; op->reg -= 9; } if (op->type & OT_REGTYPE & OT_SEGMENTREG) { parse_segment_offset (a, str, &nextpos, op, reg_index); return nextpos; } if (op->reg == X86R_UNDEFINED) { op->is_good_flag = false; if (a->num && a->num->value == 0) { return nextpos; } op->type = OT_CONSTANT; RCore *core = a->num? (RCore *)(a->num->userptr): NULL; if (core && (flag = r_flag_get (core->flags, str))) { op->is_good_flag = true; } char *p = strchr (str, '-'); if (p) { op->sign = -1; str = ++p; } op->immediate = getnum (a, str); } else if (op->reg < X86R_UNDEFINED) { strncpy (op->rep_op, str, MAX_REPOP_LENGTH - 1); op->rep_op[MAX_REPOP_LENGTH - 1] = '\0'; } } else {                             op->type = OT_CONSTANT; op->sign = 1; char *p = strchr (str, '-'); if (p) { op->sign = -1; str = ++p; } op->immediate = getnum (a, str); } return nextpos; }
Description: In radare2 prior to 3.1.1, the parseOperand function inside libr/asm/p/asm_x86_nz.c may allow attackers to cause a denial of service (application crash via a stack-based buffer overflow) by crafting an input file, a related issue to CVE-2018-20456.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: uerr_t ftp_loop (struct url *u, char **local_file, int *dt, struct url *proxy, bool recursive, bool glob) { ccon con;                      uerr_t res; *dt = 0; xzero (con); con.csock = -1; con.st = ON_YOUR_OWN; con.rs = ST_UNIX; con.id = NULL; con.proxy = proxy; if (!*u->file && !recursive) { struct fileinfo *f; res = ftp_get_listing (u, &con, &f); if (res == RETROK) { if (opt.htmlify && !opt.spider) { char *filename = (opt.output_document ? xstrdup (opt.output_document) : (con.target ? xstrdup (con.target) : url_file_name (u, NULL))); res = ftp_index (filename, u, f); if (res == FTPOK && opt.verbose) { if (!opt.output_document) { struct_stat st; wgint sz; if (stat (filename, &st) == 0) sz = st.st_size; else sz = -1; logprintf (LOG_NOTQUIET, _(""Wrote HTML-ized index to %s [%s].\n""), quote (filename), number_to_static_string (sz)); } else logprintf (LOG_NOTQUIET, _(""Wrote HTML-ized index to %s.\n""), quote (filename)); } xfree (filename); } freefileinfo (f); } } else { bool ispattern = false; if (glob) { char *file_part = strrchr (u->path, '/'); if (!file_part) file_part = u->path; ispattern = has_wildcards_p (file_part); } if (ispattern || recursive || opt.timestamping || opt.preserve_perm) { res = ftp_retrieve_glob (u, &con, ispattern ? GLOB_GLOBALL : GLOB_GETONE); } else res = ftp_loop_internal (u, NULL, &con, local_file, false); } if (res == FTPOK) res = RETROK; if (res == RETROK) *dt |= RETROKF; if (con.csock != -1) fd_close (con.csock); xfree (con.id); xfree (con.target); return res; }
Description: GNU wget before 1.18 allows remote servers to write to arbitrary files by redirecting a request from HTTP to a crafted FTP resource.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static inline LineContribType * _gdContributionsAlloc(unsigned int line_length, unsigned int windows_size) { unsigned int u = 0; LineContribType *res; int overflow_error = 0; res = (LineContribType *) gdMalloc(sizeof(LineContribType)); if (!res) { return NULL; } res->WindowSize = windows_size; res->LineLength = line_length; if (overflow2(line_length, sizeof(ContributionType))) { gdFree(res); return NULL; } res->ContribRow = (ContributionType *) gdMalloc(line_length * sizeof(ContributionType)); if (res->ContribRow == NULL) { gdFree(res); return NULL; } for (u = 0 ; u < line_length ; u++) { if (overflow2(windows_size, sizeof(double))) { overflow_error = 1; } else { res->ContribRow[u].Weights = (double *) gdMalloc(windows_size * sizeof(double)); } if (overflow_error == 1 || res->ContribRow[u].Weights == NULL) { unsigned int i; u--; for (i=0;i<=u;i++) { gdFree(res->ContribRow[i].Weights); } gdFree(res->ContribRow); gdFree(res); return NULL; } } return res; }
Description: Integer underflow in the _gdContributionsAlloc function in gd_interpolation.c in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to have unspecified impact via vectors related to decrementing the u variable.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static Image *ReadPDBImage(const ImageInfo *image_info,ExceptionInfo *exception) { unsigned char attributes, tag[3]; Image *image; MagickBooleanType status; PDBImage pdb_image; PDBInfo pdb_info; Quantum index; register ssize_t x; register Quantum *q; register unsigned char *p; size_t bits_per_pixel, num_pad_bytes, one, packets; ssize_t count, img_offset, comment_offset = 0, y; unsigned char *pixels; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); image=AcquireImage(image_info,exception); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } count=ReadBlob(image,sizeof(pdb_info.name),(unsigned char *) pdb_info.name); if (count != sizeof(pdb_info.name)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); pdb_info.attributes=(short) ReadBlobMSBShort(image); pdb_info.version=(short) ReadBlobMSBShort(image); pdb_info.create_time=ReadBlobMSBLong(image); pdb_info.modify_time=ReadBlobMSBLong(image); pdb_info.archive_time=ReadBlobMSBLong(image); pdb_info.modify_number=ReadBlobMSBLong(image); pdb_info.application_info=ReadBlobMSBLong(image); pdb_info.sort_info=ReadBlobMSBLong(image); (void) ReadBlob(image,4,(unsigned char *) pdb_info.type); (void) ReadBlob(image,4,(unsigned char *) pdb_info.id); pdb_info.seed=ReadBlobMSBLong(image); pdb_info.next_record=ReadBlobMSBLong(image); pdb_info.number_records=(short) ReadBlobMSBShort(image); if ((memcmp(pdb_info.type,""vIMG"",4) != 0) || (memcmp(pdb_info.id,""View"",4) != 0)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); if (pdb_info.next_record != 0) ThrowReaderException(CoderError,""MultipleRecordListNotSupported""); img_offset=(ssize_t) ((int) ReadBlobMSBLong(image)); attributes=(unsigned char) ReadBlobByte(image); (void) attributes; count=ReadBlob(image,3,(unsigned char *) tag); if (count != 3  ||  memcmp(tag,""\x6f\x80\x00"",3) != 0) ThrowReaderException(CorruptImageError,""CorruptImage""); if (pdb_info.number_records > 1) { comment_offset=(ssize_t) ((int) ReadBlobMSBLong(image)); attributes=(unsigned char) ReadBlobByte(image); count=ReadBlob(image,3,(unsigned char *) tag); if (count != 3  ||  memcmp(tag,""\x6f\x80\x01"",3) != 0) ThrowReaderException(CorruptImageError,""CorruptImage""); } num_pad_bytes = (size_t) (img_offset - TellBlob( image )); while (num_pad_bytes-- != 0) { int c; c=ReadBlobByte(image); if (c == EOF) break; } count=ReadBlob(image,sizeof(pdb_image.name),(unsigned char *) pdb_image.name); if (count != sizeof(pdb_image.name)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); pdb_image.version=ReadBlobByte(image); pdb_image.type=(unsigned char) ((int) ReadBlobByte(image)); pdb_image.reserved_1=ReadBlobMSBLong(image); pdb_image.note=ReadBlobMSBLong(image); pdb_image.x_last=(short) ReadBlobMSBShort(image); pdb_image.y_last=(short) ReadBlobMSBShort(image); pdb_image.reserved_2=ReadBlobMSBLong(image); pdb_image.x_anchor=ReadBlobMSBShort(image); pdb_image.y_anchor=ReadBlobMSBShort(image); pdb_image.width=(short) ReadBlobMSBShort(image); pdb_image.height=(short) ReadBlobMSBShort(image); image->columns=(size_t) pdb_image.width; image->rows=(size_t) pdb_image.height; image->depth=8; status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) return(DestroyImageList(image)); image->storage_class=PseudoClass; bits_per_pixel=pdb_image.type == 0 ? 2UL : pdb_image.type == 2 ? 4UL : 1UL; one=1; if (AcquireImageColormap(image,one << bits_per_pixel,exception) == MagickFalse) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); if (image_info->ping != MagickFalse) { (void) CloseBlob(image); return(GetFirstImageInList(image)); } packets=(bits_per_pixel*image->columns+7)/8; pixels=(unsigned char *) AcquireQuantumMemory(packets+256UL,image->rows* sizeof(*pixels)); if (pixels == (unsigned char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); switch (pdb_image.version & 0x07)  { case 0: { image->compression=NoCompression; count=(ssize_t) ReadBlob(image, packets * image -> rows, pixels); break; } case 1: { image->compression=RLECompression; if (!DecodeImage(image, pixels, packets * image -> rows)) ThrowReaderException( CorruptImageError, ""RLEDecoderError"" ); break; } default: ThrowReaderException(CorruptImageError, ""UnrecognizedImageCompressionType"" ); } p=pixels; switch (bits_per_pixel) { case 1: { int bit; for (y=0; y < (ssize_t) image->rows; y++) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < ((ssize_t) image->columns-7); x+=8) { for (bit=0; bit < 8; bit++) { index=(Quantum) (*p & (0x80 >> bit) ? 0x00 : 0x01); SetPixelIndex(image,index,q); q+=GetPixelChannels(image); } p++; } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } (void) SyncImage(image,exception); break; } case 2: { for (y=0; y < (ssize_t) image->rows; y++) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns-3; x+=4) { index=ConstrainColormapIndex(image,3UL-((*p >> 6) & 0x03),exception); SetPixelIndex(image,index,q); q+=GetPixelChannels(image); index=ConstrainColormapIndex(image,3UL-((*p >> 4) & 0x03),exception); SetPixelIndex(image,index,q); q+=GetPixelChannels(image); index=ConstrainColormapIndex(image,3UL-((*p >> 2) & 0x03),exception); SetPixelIndex(image,index,q); q+=GetPixelChannels(image); index=ConstrainColormapIndex(image,3UL-((*p) & 0x03),exception); SetPixelIndex(image,index,q); p++; q+=GetPixelChannels(image); } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } (void) SyncImage(image,exception); break; } case 4: { for (y=0; y < (ssize_t) image->rows; y++) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns-1; x+=2) { index=ConstrainColormapIndex(image,15UL-((*p >> 4) & 0x0f),exception); SetPixelIndex(image,index,q); q+=GetPixelChannels(image); index=ConstrainColormapIndex(image,15UL-((*p) & 0x0f),exception); SetPixelIndex(image,index,q); p++; q+=GetPixelChannels(image); } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } (void) SyncImage(image,exception); break; } default: ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } pixels=(unsigned char *) RelinquishMagickMemory(pixels); if (EOFBlob(image) != MagickFalse) ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"", image->filename); if (pdb_info.number_records > 1) { char *comment; int c; register char *p; size_t length; num_pad_bytes = (size_t) (comment_offset - TellBlob( image )); while (num_pad_bytes--) ReadBlobByte( image ); c=ReadBlobByte(image); length=MagickPathExtent; comment=AcquireString((char *) NULL); for (p=comment; c != EOF; p++) { if ((size_t) (p-comment+MagickPathExtent) >= length) { *p='\0'; length<<=1; length+=MagickPathExtent; comment=(char *) ResizeQuantumMemory(comment,length+MagickPathExtent, sizeof(*comment)); if (comment == (char *) NULL) break; p=comment+strlen(comment); } *p=c; c=ReadBlobByte(image); } *p='\0'; if (comment == (char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); (void) SetImageProperty(image,""comment"",comment,exception); comment=DestroyString(comment); } (void) CloseBlob(image); return(GetFirstImageInList(image)); }
Description: MagickCore/memory.c in ImageMagick allows remote attackers to cause a denial of service (out-of-bounds access) via a crafted PDB file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: DeleteRunner(ReferenceHandle& that, Local<Value> key_handle) : key{ExternalCopy::CopyIfPrimitive(key_handle)}, context{that.context}, reference{that.reference} { that.CheckDisposed(); if (!key) { throw RuntimeTypeError(""Invalid `key`""); } }
Description: isolated-vm is a library for nodejs which gives you access to v8's Isolate interface. Versions of isolated-vm before v4.0.0 have API pitfalls which may make it easy for implementers to expose supposed secure isolates to the permissions of the main nodejs isolate. Reference objects allow access to the underlying reference's full prototype chain. In an environment where the implementer has exposed a Reference instance to an attacker they would be able to use it to acquire a Reference to the nodejs context's Function object. Similar application-specific attacks could be possible by modifying the local prototype of other API objects. Access to NativeModule objects could allow an attacker to load and run native code from anywhere on the filesystem. If combined with, for example, a file upload API this would allow for arbitrary code execution. This is addressed in v4.0.0 through a series of related changes.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static guint32 s7comm_decode_ud_cpu_alarm_main(tvbuff_t *tvb, packet_info *pinfo, proto_tree *data_tree, guint8 type,                 guint8 subfunc,              guint32 offset)              { guint32 start_offset; guint32 asc_start_offset; guint32 msg_obj_start_offset; guint32 ev_id; proto_item *msg_item = NULL; proto_tree *msg_item_tree = NULL; proto_item *msg_obj_item = NULL; proto_tree *msg_obj_item_tree = NULL; proto_item *msg_work_item = NULL; proto_tree *msg_work_item_tree = NULL; guint8 nr_objects; guint8 i; guint8 syntax_id; guint8 nr_of_additional_values; guint8 signalstate; guint8 sig_nr; guint8 ret_val; guint8 querytype; guint8 varspec_length; start_offset = offset; msg_item = proto_tree_add_item(data_tree, hf_s7comm_cpu_alarm_message_item, tvb, offset, 0, ENC_NA); msg_item_tree = proto_item_add_subtree(msg_item, ett_s7comm_cpu_alarm_message); if (subfunc == S7COMM_UD_SUBF_CPU_ALARM8_IND || subfunc == S7COMM_UD_SUBF_CPU_ALARMACK_IND || subfunc == S7COMM_UD_SUBF_CPU_ALARMSQ_IND || subfunc == S7COMM_UD_SUBF_CPU_ALARMS_IND || subfunc == S7COMM_UD_SUBF_CPU_NOTIFY_IND || subfunc == S7COMM_UD_SUBF_CPU_NOTIFY8_IND) { msg_work_item = proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_timestamp_coming, tvb, offset, 8, ENC_NA); msg_work_item_tree = proto_item_add_subtree(msg_work_item, ett_s7comm_cpu_alarm_message_timestamp); offset = s7comm_add_timestamp_to_tree(tvb, msg_work_item_tree, offset, TRUE, FALSE); } proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_function, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; nr_objects = tvb_get_guint8(tvb, offset); proto_tree_add_uint(msg_item_tree, hf_s7comm_cpu_alarm_message_nr_objects, tvb, offset, 1, nr_objects); offset += 1; for (i = 1; i <= nr_objects; i++) { msg_obj_start_offset = offset; msg_obj_item = proto_tree_add_item(msg_item_tree, hf_s7comm_cpu_alarm_message_obj_item, tvb, offset, 0, ENC_NA); msg_obj_item_tree = proto_item_add_subtree(msg_obj_item, ett_s7comm_cpu_alarm_message_object); proto_item_append_text(msg_obj_item_tree, "" [%d]"", i); if (type == S7COMM_UD_TYPE_REQ || type == S7COMM_UD_TYPE_PUSH) { proto_tree_add_item(msg_obj_item_tree, hf_s7comm_item_varspec, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; varspec_length = tvb_get_guint8(tvb, offset); proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_item_varspec_length, tvb, offset, 1, varspec_length); offset += 1; syntax_id = tvb_get_guint8(tvb, offset); proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_item_syntax_id, tvb, offset, 1, syntax_id); offset += 1; switch (syntax_id) { case S7COMM_SYNTAXID_ALARM_LOCKFREESET: case S7COMM_SYNTAXID_ALARM_INDSET: case S7COMM_SYNTAXID_NOTIFY_INDSET: case S7COMM_SYNTAXID_ALARM_ACKSET: nr_of_additional_values = tvb_get_guint8(tvb, offset); proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_nr_add_values, tvb, offset, 1, nr_of_additional_values); offset += 1; ev_id = tvb_get_ntohl(tvb, offset); proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_eventid, tvb, offset, 4, ev_id); offset += 4; proto_item_append_text(msg_obj_item_tree, "": EventID=0x%08x"", ev_id); col_append_fstr(pinfo->cinfo, COL_INFO, "" EventID=0x%08x"", ev_id); if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) { signalstate = tvb_get_guint8(tvb, offset); proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_eventstate, ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN); offset += 1; if (signalstate > 0) { col_append_fstr(pinfo->cinfo, COL_INFO, "" On=[""); for (sig_nr = 0; sig_nr < 8; sig_nr++) { if (signalstate & 0x01) { signalstate >>= 1; if (signalstate == 0) { col_append_fstr(pinfo->cinfo, COL_INFO, ""SIG_%d"", sig_nr + 1); } else { col_append_fstr(pinfo->cinfo, COL_INFO, ""SIG_%d,"", sig_nr + 1); } } else { signalstate >>= 1; } } col_append_fstr(pinfo->cinfo, COL_INFO, ""]""); } proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_state, ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN); offset += 1; } if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_ALARM_ACKSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) { proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_ackstate_going, ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN); offset += 1; proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_ackstate_coming, ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN); offset += 1; } if (syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) { proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_going, ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN); offset += 1; proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_coming, ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN); offset += 1; proto_tree_add_bitmask(msg_obj_item_tree, tvb, offset, hf_s7comm_cpu_alarm_message_event_lastchanged, ett_s7comm_cpu_alarm_message_signal, s7comm_cpu_alarm_message_signal_fields, ENC_BIG_ENDIAN); offset += 1; proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_event_reserved, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; } if (syntax_id == S7COMM_SYNTAXID_ALARM_INDSET || syntax_id == S7COMM_SYNTAXID_NOTIFY_INDSET) { if (nr_of_additional_values > 0) { asc_start_offset = offset; msg_work_item = proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_associated_value, tvb, offset, 0, ENC_NA); msg_work_item_tree = proto_item_add_subtree(msg_work_item, ett_s7comm_cpu_alarm_message_associated_value); offset = s7comm_decode_response_read_data(tvb, msg_work_item_tree, nr_of_additional_values, offset); proto_item_set_len(msg_work_item_tree, offset - asc_start_offset); } } break; case S7COMM_SYNTAXID_ALARM_QUERYREQSET: proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_unknown1, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; querytype = tvb_get_guint8(tvb, offset); proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_querytype, tvb, offset, 1, querytype); offset += 1; proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_unknown2, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; ev_id = tvb_get_ntohl(tvb, offset); switch (querytype) { case S7COMM_ALARM_MESSAGE_QUERYTYPE_BYALARMTYPE: proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_query_alarmtype, tvb, offset, 4, ENC_BIG_ENDIAN); col_append_fstr(pinfo->cinfo, COL_INFO, "" ByAlarmtype=%s"", val_to_str(ev_id, alarm_message_query_alarmtype_names, ""Unknown Alarmtype: %u"")); break; case S7COMM_ALARM_MESSAGE_QUERYTYPE_BYEVENTID: proto_tree_add_item(msg_obj_item_tree, hf_s7comm_cpu_alarm_message_eventid, tvb, offset, 4, ENC_BIG_ENDIAN); col_append_fstr(pinfo->cinfo, COL_INFO, "" ByEventID=0x%08x"", ev_id); break; default: break; } offset += 4; break; default: offset += (varspec_length - 1); break; } } else if (type == S7COMM_UD_TYPE_RES) { ret_val = tvb_get_guint8(tvb, offset); proto_item_append_text(msg_obj_item_tree, "": (%s)"", val_to_str(ret_val, s7comm_item_return_valuenames, ""Unknown code: 0x%02x"")); proto_tree_add_uint(msg_obj_item_tree, hf_s7comm_data_returncode, tvb, offset, 1, ret_val); offset += 1; } proto_item_set_len(msg_obj_item_tree, offset - msg_obj_start_offset); } proto_item_set_len(msg_item_tree, offset - start_offset); return offset; }
Description: In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-s7comm.c had an infinite loop that was addressed by correcting off-by-one errors.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int stbi__process_frame_header(stbi__jpeg *z, int scan) { stbi__context *s = z->s; int Lf,p,i,q, h_max=1,v_max=1,c; Lf = stbi__get16be(s);         if (Lf < 11) return stbi__err(""bad SOF len"",""Corrupt JPEG"");    p  = stbi__get8(s);            if (p != 8) return stbi__err(""only 8-bit"",""JPEG format not supported: 8-bit only"");    s->img_y = stbi__get16be(s);   if (s->img_y == 0) return stbi__err(""no header height"", ""JPEG format not supported: delayed height"");    s->img_x = stbi__get16be(s);   if (s->img_x == 0) return stbi__err(""0 width"",""Corrupt JPEG"");    if (s->img_y > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)""); if (s->img_x > STBI_MAX_DIMENSIONS) return stbi__err(""too large"",""Very large image (corrupt?)""); c = stbi__get8(s); if (c != 3 && c != 1 && c != 4) return stbi__err(""bad component count"",""Corrupt JPEG""); s->img_n = c; for (i=0; i < c; ++i) { z->img_comp[i].data = NULL; z->img_comp[i].linebuf = NULL; } if (Lf != 8+3*s->img_n) return stbi__err(""bad SOF len"",""Corrupt JPEG""); z->rgb = 0; for (i=0; i < s->img_n; ++i) { static const unsigned char rgb[3] = { 'R', 'G', 'B' }; z->img_comp[i].id = stbi__get8(s); if (s->img_n == 3 && z->img_comp[i].id == rgb[i]) ++z->rgb; q = stbi__get8(s); z->img_comp[i].h = (q >> 4);  if (!z->img_comp[i].h || z->img_comp[i].h > 4) return stbi__err(""bad H"",""Corrupt JPEG""); z->img_comp[i].v = q & 15;    if (!z->img_comp[i].v || z->img_comp[i].v > 4) return stbi__err(""bad V"",""Corrupt JPEG""); z->img_comp[i].tq = stbi__get8(s);  if (z->img_comp[i].tq > 3) return stbi__err(""bad TQ"",""Corrupt JPEG""); } if (scan != STBI__SCAN_load) return 1; if (!stbi__mad3sizes_valid(s->img_x, s->img_y, s->img_n, 0)) return stbi__err(""too large"", ""Image too large to decode""); for (i=0; i < s->img_n; ++i) { if (z->img_comp[i].h > h_max) h_max = z->img_comp[i].h; if (z->img_comp[i].v > v_max) v_max = z->img_comp[i].v; } z->img_h_max = h_max; z->img_v_max = v_max; z->img_mcu_w = h_max * 8; z->img_mcu_h = v_max * 8; z->img_mcu_x = (s->img_x + z->img_mcu_w-1) / z->img_mcu_w; z->img_mcu_y = (s->img_y + z->img_mcu_h-1) / z->img_mcu_h; for (i=0; i < s->img_n; ++i) { z->img_comp[i].x = (s->img_x * z->img_comp[i].h + h_max-1) / h_max; z->img_comp[i].y = (s->img_y * z->img_comp[i].v + v_max-1) / v_max; z->img_comp[i].w2 = z->img_mcu_x * z->img_comp[i].h * 8; z->img_comp[i].h2 = z->img_mcu_y * z->img_comp[i].v * 8; z->img_comp[i].coeff = 0; z->img_comp[i].raw_coeff = 0; z->img_comp[i].linebuf = NULL; z->img_comp[i].raw_data = stbi__malloc_mad2(z->img_comp[i].w2, z->img_comp[i].h2, 15); if (z->img_comp[i].raw_data == NULL) return stbi__free_jpeg_components(z, i+1, stbi__err(""outofmem"", ""Out of memory"")); z->img_comp[i].data = (stbi_uc*) (((size_t) z->img_comp[i].raw_data + 15) & ~15); if (z->progressive) { z->img_comp[i].coeff_w = z->img_comp[i].w2 / 8; z->img_comp[i].coeff_h = z->img_comp[i].h2 / 8; z->img_comp[i].raw_coeff = stbi__malloc_mad3(z->img_comp[i].w2, z->img_comp[i].h2, sizeof(short), 15); if (z->img_comp[i].raw_coeff == NULL) return stbi__free_jpeg_components(z, i+1, stbi__err(""outofmem"", ""Out of memory"")); z->img_comp[i].coeff = (short*) (((size_t) z->img_comp[i].raw_coeff + 15) & ~15); } } return 1; }
Description: stb_image.h 2.27 has a heap-based buffer over in stbi__jpeg_load, leading to Information Disclosure or Denial of Service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int connection_exit_begin_conn(cell_t *cell, circuit_t *circ) { edge_connection_t *n_stream; relay_header_t rh; char *address = NULL; uint16_t port = 0; or_circuit_t *or_circ = NULL; const or_options_t *options = get_options(); begin_cell_t bcell; int rv; uint8_t end_reason=0; assert_circuit_ok(circ); if (!CIRCUIT_IS_ORIGIN(circ)) or_circ = TO_OR_CIRCUIT(circ); relay_header_unpack(&rh, cell->payload); if (rh.length > RELAY_PAYLOAD_SIZE) return -END_CIRC_REASON_TORPROTOCOL; if (!server_mode(options) && circ->purpose != CIRCUIT_PURPOSE_S_REND_JOINED) { log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL, ""Relay begin cell at non-server. Closing.""); relay_send_end_cell_from_edge(rh.stream_id, circ, END_STREAM_REASON_EXITPOLICY, NULL); return 0; } rv = begin_cell_parse(cell, &bcell, &end_reason); if (rv < -1) { return -END_CIRC_REASON_TORPROTOCOL; } else if (rv == -1) { tor_free(bcell.address); relay_send_end_cell_from_edge(rh.stream_id, circ, end_reason, NULL); return 0; } if (! bcell.is_begindir) { address = bcell.address; port = bcell.port; if (or_circ && or_circ->p_chan) { if (!options->AllowSingleHopExits && (or_circ->is_first_hop || (!connection_or_digest_is_known_relay( or_circ->p_chan->identity_digest) && should_refuse_unknown_exits(options)))) { log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL, ""Attempt by %s to open a stream %s. Closing."", safe_str(channel_get_canonical_remote_descr(or_circ->p_chan)), or_circ->is_first_hop ? ""on first hop of circuit"" : ""from unknown relay""); relay_send_end_cell_from_edge(rh.stream_id, circ, or_circ->is_first_hop ? END_STREAM_REASON_TORPROTOCOL : END_STREAM_REASON_MISC, NULL); tor_free(address); return 0; } } } else if (rh.command == RELAY_COMMAND_BEGIN_DIR) { if (!directory_permits_begindir_requests(options) || circ->purpose != CIRCUIT_PURPOSE_OR) { relay_send_end_cell_from_edge(rh.stream_id, circ, END_STREAM_REASON_NOTDIRECTORY, NULL); return 0; } if (or_circ && or_circ->p_chan) address = tor_strdup(channel_get_actual_remote_address(or_circ->p_chan)); else address = tor_strdup(""127.0.0.1""); port = 1;  } else { log_warn(LD_BUG, ""Got an unexpected command %d"", (int)rh.command); relay_send_end_cell_from_edge(rh.stream_id, circ, END_STREAM_REASON_INTERNAL, NULL); return 0; } if (! options->IPv6Exit) { bcell.flags &= ~BEGIN_FLAG_IPV6_PREFERRED; if (bcell.flags & BEGIN_FLAG_IPV4_NOT_OK) { tor_free(address); relay_send_end_cell_from_edge(rh.stream_id, circ, END_STREAM_REASON_EXITPOLICY, NULL); return 0; } } log_debug(LD_EXIT,""Creating new exit connection.""); n_stream = edge_connection_new(CONN_TYPE_EXIT, AF_INET); n_stream->dirreq_id = circ->dirreq_id; n_stream->base_.purpose = EXIT_PURPOSE_CONNECT; n_stream->begincell_flags = bcell.flags; n_stream->stream_id = rh.stream_id; n_stream->base_.port = port; n_stream->package_window = STREAMWINDOW_START; n_stream->deliver_window = STREAMWINDOW_START; if (circ->purpose == CIRCUIT_PURPOSE_S_REND_JOINED) { origin_circuit_t *origin_circ = TO_ORIGIN_CIRCUIT(circ); log_info(LD_REND,""begin is for rendezvous. configuring stream.""); n_stream->base_.address = tor_strdup(""(rendezvous)""); n_stream->base_.state = EXIT_CONN_STATE_CONNECTING; n_stream->rend_data = rend_data_dup(origin_circ->rend_data); tor_assert(connection_edge_is_rendezvous_stream(n_stream)); assert_circuit_ok(circ); const int r = rend_service_set_connection_addr_port(n_stream, origin_circ); if (r < 0) { log_info(LD_REND,""Didn't find rendezvous service (port %d)"", n_stream->base_.port); relay_send_end_cell_from_edge(rh.stream_id, circ, END_STREAM_REASON_DONE, origin_circ->cpath->prev); connection_free(TO_CONN(n_stream)); tor_free(address); if (r < -1) return END_CIRC_AT_ORIGIN; else return 0; } assert_circuit_ok(circ); log_debug(LD_REND,""Finished assigning addr/port""); n_stream->cpath_layer = origin_circ->cpath->prev;  n_stream->next_stream = origin_circ->p_streams; n_stream->on_circuit = circ; origin_circ->p_streams = n_stream; assert_circuit_ok(circ); origin_circ->rend_data->nr_streams++; connection_exit_connect(n_stream); pathbias_mark_use_success(origin_circ); tor_free(address); return 0; } tor_strlower(address); n_stream->base_.address = address; n_stream->base_.state = EXIT_CONN_STATE_RESOLVEFAILED; if (we_are_hibernating()) { relay_send_end_cell_from_edge(rh.stream_id, circ, END_STREAM_REASON_HIBERNATING, NULL); connection_free(TO_CONN(n_stream)); return 0; } n_stream->on_circuit = circ; if (rh.command == RELAY_COMMAND_BEGIN_DIR) { tor_addr_t tmp_addr; tor_assert(or_circ); if (or_circ->p_chan && channel_get_addr_if_possible(or_circ->p_chan, &tmp_addr)) { tor_addr_copy(&n_stream->base_.addr, &tmp_addr); } return connection_exit_connect_dir(n_stream); } log_debug(LD_EXIT,""about to start the dns_resolve().""); switch (dns_resolve(n_stream)) { case 1:  assert_circuit_ok(circ); log_debug(LD_EXIT,""about to call connection_exit_connect().""); connection_exit_connect(n_stream); return 0; case -1:  relay_send_end_cell_from_edge(rh.stream_id, circ, END_STREAM_REASON_RESOLVEFAILED, NULL); break; case 0:  assert_circuit_ok(circ); break; } return 0; }
Description: The hidden-service feature in Tor before 0.3.0.8 allows a denial of service (assertion failure and daemon exit) in the relay_send_end_cell_from_edge_ function via a malformed BEGIN cell.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void gf_isom_cenc_get_default_info_internal(GF_TrackBox *trak, u32 sampleDescriptionIndex, u32 *container_type, Bool *default_IsEncrypted, u8 *crypt_byte_block, u8 *skip_byte_block, const u8 **key_info, u32 *key_info_size) { GF_ProtectionSchemeInfoBox *sinf; if (default_IsEncrypted) *default_IsEncrypted = GF_FALSE; if (crypt_byte_block) *crypt_byte_block = 0; if (skip_byte_block) *skip_byte_block = 0; if (container_type) *container_type = 0; if (key_info) *key_info = NULL; if (key_info_size) *key_info_size = 0; sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENC_SCHEME, NULL); if (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBC_SCHEME, NULL); if (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CENS_SCHEME, NULL); if (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_CBCS_SCHEME, NULL); if (!sinf) sinf = isom_get_sinf_entry(trak, sampleDescriptionIndex, GF_ISOM_PIFF_SCHEME, NULL); if (!sinf) { u32 i, nb_stsd = gf_list_count(trak->Media->information->sampleTable->SampleDescription->child_boxes); for (i=0; i<nb_stsd; i++) { GF_ProtectionSchemeInfoBox *a_sinf; GF_SampleEntryBox *sentry=NULL; if (i+1==sampleDescriptionIndex) continue; sentry = gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, i); a_sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(sentry->child_boxes, GF_ISOM_BOX_TYPE_SINF); if (!a_sinf) continue; return; } } if (sinf && sinf->info && sinf->info->tenc) { if (default_IsEncrypted) *default_IsEncrypted = sinf->info->tenc->isProtected; if (crypt_byte_block) *crypt_byte_block = sinf->info->tenc->crypt_byte_block; if (skip_byte_block) *skip_byte_block = sinf->info->tenc->skip_byte_block; if (key_info) *key_info = sinf->info->tenc->key_info; if (key_info_size) { *key_info_size = 20; if (!sinf->info->tenc->key_info[3]) *key_info_size += 1 + sinf->info->tenc->key_info[20]; } if (container_type) *container_type = GF_ISOM_BOX_TYPE_SENC; } else if (sinf && sinf->info && sinf->info->piff_tenc) { if (default_IsEncrypted) *default_IsEncrypted = GF_TRUE; if (key_info) *key_info = sinf->info->piff_tenc->key_info; if (key_info_size) *key_info_size = 19; if (container_type) *container_type = GF_ISOM_BOX_UUID_PSEC; } else { u32 i, count = 0; GF_CENCSampleEncryptionGroupEntry *seig_entry = NULL; if (!trak->moov->mov->is_smooth) count = gf_list_count(trak->Media->information->sampleTable->sampleGroupsDescription); for (i=0; i<count; i++) { GF_SampleGroupDescriptionBox *sgdesc = (GF_SampleGroupDescriptionBox*)gf_list_get(trak->Media->information->sampleTable->sampleGroupsDescription, i); if (sgdesc->grouping_type!=GF_ISOM_SAMPLE_GROUP_SEIG) continue; if (sgdesc->default_description_index) seig_entry = gf_list_get(sgdesc->group_descriptions, sgdesc->default_description_index-1); else seig_entry = gf_list_get(sgdesc->group_descriptions, 0); if (!seig_entry->key_info[0]) seig_entry = NULL; break; } if (seig_entry) { if (default_IsEncrypted) *default_IsEncrypted = seig_entry->IsProtected; if (crypt_byte_block) *crypt_byte_block = seig_entry->crypt_byte_block; if (skip_byte_block) *skip_byte_block = seig_entry->skip_byte_block; if (key_info) *key_info = seig_entry->key_info; if (key_info_size) *key_info_size = seig_entry->key_info_size; if (container_type) *container_type = GF_ISOM_BOX_TYPE_SENC; } else { if (! trak->moov->mov->is_smooth ) { trak->moov->mov->is_smooth = GF_TRUE; GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[iso file] senc box without tenc, assuming MS smooth+piff\n"")); } if (default_IsEncrypted) *default_IsEncrypted = GF_TRUE; if (container_type) *container_type = GF_ISOM_BOX_UUID_PSEC; } } if (container_type && trak->sample_encryption) { if (trak->sample_encryption->type == GF_ISOM_BOX_TYPE_SENC) *container_type = GF_ISOM_BOX_TYPE_SENC; else if (trak->sample_encryption->type == GF_ISOM_BOX_TYPE_UUID) *container_type = ((GF_UUIDBox*)trak->sample_encryption)->internal_4cc; } }
Description: The gf_isom_cenc_get_default_info_internal function in GPAC 1.0.1 allows attackers to cause a denial of service (NULL pointer dereference) via a crafted file in the MP4Box command.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static String HHVM_FUNCTION(bcsub, const String& left, const String& right, int64_t scale ) { if (scale < 0) scale = BCG(bc_precision); bc_num first, second, result; bc_init_num(&first); bc_init_num(&second); bc_init_num(&result); php_str2num(&first, (char*)left.data()); php_str2num(&second, (char*)right.data()); bc_sub(first, second, &result, scale); if (result->n_scale > scale) { result->n_scale = scale; } String ret(bc_num2str(result), AttachString); bc_free_num(&first); bc_free_num(&second); bc_free_num(&result); return ret; }
Description: Integer overflow in bcmath in Facebook HHVM before 3.15.0 allows attackers to have unspecified impact via unknown vectors, which triggers a buffer overflow.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Status ImportGenericFunction( GraphFuncOp func_op, const FunctionDef& func, llvm::StringMap<llvm::StringMap<SmallVector<Value, 1>>>& values_map, OpBuilder& builder) { const OpDef& signature = func.signature(); Location unknown_loc = builder.getUnknownLoc(); MLIRContext* context = builder.getContext(); NamedAttrList attrs; DictionaryAttr func_attrs = builder.getDictionaryAttr({}); if (signature.name().empty()) return InvalidArgument(""generic function without a name""); attrs.append(""sym_name"", builder.getStringAttr(signature.name())); attrs.append(""generic"", builder.getUnitAttr()); if (!signature.description().empty()) attrs.append(""description"", builder.getStringAttr(signature.description())); if (signature.is_stateful()) attrs.append(""is_stateful"", builder.getUnitAttr()); if (signature.control_output_size()) { SmallVector<Attribute> control_outputs; for (const std::string& output : signature.control_output()) control_outputs.push_back(builder.getStringAttr(output)); attrs.append(""control_output"", builder.getArrayAttr(control_outputs)); } { NamedAttrList attr_defs; for (const OpDef_AttrDef& attr : signature.attr()) { NamedAttrList attr_def; if (attr.name().empty()) return InvalidArgument(""Missing name for function attribute""); if (!attr.type().empty()) attr_def.append(builder.getNamedAttr( ""function_type"", builder.getStringAttr(attr.type()))); if (attr.has_default_value()) { TF_ASSIGN_OR_RETURN(Attribute attr, ConvertAttributeValue( attr.default_value(), builder)); attr_def.append(builder.getNamedAttr(""default_value"", attr)); } if (!attr.description().empty()) attr_def.append(builder.getNamedAttr( ""description"", builder.getStringAttr(attr.description()))); if (attr.has_minimum() || attr.minimum()) attr_def.append(builder.getNamedAttr( ""minimum"", builder.getI32IntegerAttr(attr.minimum()))); if (attr.has_allowed_values()) { TF_ASSIGN_OR_RETURN( Attribute attr, ConvertAttributeValue(attr.allowed_values(), builder)); attr_def.append(builder.getNamedAttr(""allowed_values"", attr)); } attr_defs.append(builder.getNamedAttr( attr.name(), attr_def.getDictionary(builder.getContext()))); } if (!attr_defs.empty()) { func_attrs = attr_defs.getDictionary(builder.getContext()); attrs.append(""tfg.func_attrs"", func_attrs); } } if (func.resource_arg_unique_id_size()) { SmallVector<int32_t> resource_arg_unique_ids_keys; SmallVector<int32_t> resource_arg_unique_ids_values; for (const auto& unique_id : func.resource_arg_unique_id()) { resource_arg_unique_ids_keys.push_back(unique_id.first); resource_arg_unique_ids_values.push_back(unique_id.second); } attrs.append(""resource_arg_unique_ids_keys"", builder.getI32TensorAttr(resource_arg_unique_ids_keys)); attrs.append(""resource_arg_unique_ids_values"", builder.getI32TensorAttr(resource_arg_unique_ids_values)); } for (const auto& namedAttr : func.attr()) { if (namedAttr.first.empty()) return InvalidArgument(""Invalid function attribute name""); const std::string& name = ""tf."" + namedAttr.first; const AttrValue& tf_attr = namedAttr.second; TF_ASSIGN_OR_RETURN(Attribute attr, ConvertAttributeValue(tf_attr, builder)); attrs.append(name, attr); } SmallString<8> arg_or_res_attr_name; SmallString<8> sub_arg_attr_name; int arg_num = 0; SmallVector<StringRef> arg_names; SmallVector<Type> arg_types; SmallVector<Attribute> args_attrs; SmallVector<Attribute> res_attrs; for (const auto& enumerated_input : llvm::enumerate(signature.input_arg())) { const OpDef::ArgDef& input = enumerated_input.value(); TF_ASSIGN_OR_RETURN(NamedAttrList input_attrs, ConvertArgDefAttributes(input, builder)); auto it = func.arg_attr().find(enumerated_input.index()); if (it != func.arg_attr().end()) { NamedAttrList arg_attr; for (const auto& named_attr : it->second.attr()) { TF_ASSIGN_OR_RETURN(Attribute attr, ConvertAttributeValue(named_attr.second, builder)); arg_attr.append(named_attr.first, attr); } input_attrs.append(""tfg.arg_attrs"", arg_attr.getDictionary(builder.getContext())); } arg_names.push_back(builder.getStringAttr(input.name()).getValue()); arg_types.push_back(OpaqueTensorType::get(context)); args_attrs.push_back(input_attrs.getDictionary(context)); args_attrs.push_back(NamedAttrList{}.getDictionary(context)); arg_num++; } attrs.push_back(builder.getNamedAttr(func_op.getArgAttrsAttrName(), builder.getArrayAttr(args_attrs))); int res_num = 0; for (const OpDef::ArgDef& output : signature.output_arg()) { TF_ASSIGN_OR_RETURN(NamedAttrList output_attrs, ConvertArgDefAttributes(output, builder)); res_attrs.push_back(output_attrs.getDictionary(context)); ++res_num; } for (const std::string& output : signature.control_output()) { NamedAttrList output_attrs; output_attrs.append(""tfg.name"", builder.getStringAttr(output)); res_attrs.push_back(output_attrs.getDictionary(context)); ++res_num; } attrs.push_back(builder.getNamedAttr(func_op.getResAttrsAttrName(), builder.getArrayAttr(res_attrs))); values_map.clear(); Block* body = new Block(); func_op.getBody().push_back(body); Type control_ty = ControlType::get(context); for (auto type_and_name : llvm::zip(arg_types, arg_names)) { Value arg = body->addArgument(std::get<0>(type_and_name), unknown_loc); llvm::StringMap<SmallVector<Value, 1>>& values = values_map[std::get<1>(type_and_name)]; Value ctl = body->addArgument(control_ty, unknown_loc); values[""""].push_back(arg); values[""^""].push_back(ctl); } OpBuilder body_builder = OpBuilder::atBlockEnd(body); OperationName mlir_placeholder(""tfg.__mlir_placeholder"", context); Type placeholder_ty = OpaqueTensorType::get(context); ValueMapManager value_manager(values_map, body_builder, mlir_placeholder, placeholder_ty, control_ty, unknown_loc); TF_RETURN_WITH_CONTEXT_IF_ERROR( ImportNodes(value_manager, func.node_def(), body_builder), "" when importing function "", func.signature().name()); res_num = 0; llvm::StringMap<int> output_name_to_position; for (const OpDef::ArgDef& output : signature.output_arg()) { if (output_name_to_position.count(output.name())) return InvalidArgument(""Duplicated output_arg entry"", output.name()); output_name_to_position[output.name()] = res_num; ++res_num; } res_num = 0; llvm::StringMap<int> control_output_to_position; for (const std::string& output : signature.control_output()) { if (control_output_to_position.count(output)) return InvalidArgument(""Duplicated control_output entry"", output); control_output_to_position[output] = res_num; ++res_num; } SmallVector<Value> ret_vals(func.ret_size() + func.control_ret_size(), Value()); for (const auto& ret_val : func.ret()) { auto position = output_name_to_position.find(ret_val.first); if (position == output_name_to_position.end()) { return InvalidArgument( ""Can't import function, returned value references unknown output "" ""argument "", ret_val.first); } if (ret_val.second.empty()) { return InvalidArgument(""Function '"", func.signature().name(), ""' has empty result name""); } ret_vals[position->second] = value_manager.GetValueOrCreatePlaceholder(ret_val.second); } for (const auto& ret_val : func.control_ret()) { auto position = control_output_to_position.find(ret_val.first); if (position == control_output_to_position.end()) { return InvalidArgument( ""Can't import function, returned value references unknown output "" ""argument "", ret_val.first); } if (ret_val.second.empty()) { return InvalidArgument(""Function '"", func.signature().name(), ""' has empty control result name""); } Value result = value_manager.GetValueOrCreatePlaceholder( (Twine(""^"") + ret_val.second).str()); if (!result.getType().isa<ControlType>()) return InvalidArgument(""failed to map returned value "", ret_val.second, "", isn't a control output""); ret_vals[func.ret_size() + position->second] = result; } for (auto& indexed_val : llvm::enumerate(ret_vals)) { if (indexed_val.value()) continue; return InvalidArgument( ""Failed to import function, missing output for position "", indexed_val.index()); } MutableArrayRef<Value> operands = ret_vals; ReturnOp ret_op = body_builder.create<ReturnOp>( unknown_loc, operands.slice(0, func.ret_size()), operands.slice(func.ret_size())); { SmallVector<Type> arg_types_with_ctl; for (Type type : arg_types) { arg_types_with_ctl.push_back(type); arg_types_with_ctl.push_back(control_ty); } attrs.append(""function_type"", TypeAttr::get(builder.getFunctionType( arg_types_with_ctl, ret_op.getOperandTypes()))); } func_op->setAttrs(attrs); return ::tensorflow::OkStatus(); }
Description: TensorFlow is an open source platform for machine learning. There is out-of-bounds access due to mismatched integer type sizes. A fix is included in TensorFlow version 2.12.0 and version 2.11.1.

 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void Auth::Private::dataPending() { Auth *auth = qobject_cast<Auth*>(parent()); Msg m = MSG_UNKNOWN; SafeDataStream str(socket); str.receive(); str >> m; switch (m) { case ERROR: { QString message; Error type = ERROR_NONE; str >> message >> type; Q_EMIT auth->error(message, type); break; } case INFO: { QString message; Info type = INFO_NONE; str >> message >> type; Q_EMIT auth->info(message, type); break; } case REQUEST: { Request r; str >> r; request->setRequest(&r); break; } case AUTHENTICATED: { QString user; str >> user; if (!user.isEmpty()) { auth->setUser(user); Q_EMIT auth->authentication(user, true); str.reset(); str << AUTHENTICATED << environment; str.send(); } else { Q_EMIT auth->authentication(user, false); } break; } case SESSION_STATUS: { bool status; str >> status; Q_EMIT auth->session(status); str.reset(); str << SESSION_STATUS; str.send(); break; } default: { Q_EMIT auth->error(QString(""Auth: Unexpected value received: %1"").arg(m), ERROR_INTERNAL); } } }
Description: Simple Desktop Display Manager (SDDM) before 0.10.0 allows local users to gain root privileges because code running as root performs write operations within a user home directory, and this user may have created links in advance (exploitation requires the user to win a race condition in the ~/.Xauthority chown case, but not other cases).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int powermate_probe(struct usb_interface *intf, const struct usb_device_id *id) { struct usb_device *udev = interface_to_usbdev (intf); struct usb_host_interface *interface; struct usb_endpoint_descriptor *endpoint; struct powermate_device *pm; struct input_dev *input_dev; int pipe, maxp; int error = -ENOMEM; interface = intf->cur_altsetting; endpoint = &interface->endpoint[0].desc; if (!usb_endpoint_is_int_in(endpoint)) return -EIO; usb_control_msg(udev, usb_sndctrlpipe(udev, 0), 0x0a, USB_TYPE_CLASS | USB_RECIP_INTERFACE, 0, interface->desc.bInterfaceNumber, NULL, 0, USB_CTRL_SET_TIMEOUT); pm = kzalloc(sizeof(struct powermate_device), GFP_KERNEL); input_dev = input_allocate_device(); if (!pm || !input_dev) goto fail1; if (powermate_alloc_buffers(udev, pm)) goto fail2; pm->irq = usb_alloc_urb(0, GFP_KERNEL); if (!pm->irq) goto fail2; pm->config = usb_alloc_urb(0, GFP_KERNEL); if (!pm->config) goto fail3; pm->udev = udev; pm->intf = intf; pm->input = input_dev; usb_make_path(udev, pm->phys, sizeof(pm->phys)); strlcat(pm->phys, ""/input0"", sizeof(pm->phys)); spin_lock_init(&pm->lock); switch (le16_to_cpu(udev->descriptor.idProduct)) { case POWERMATE_PRODUCT_NEW: input_dev->name = pm_name_powermate; break; case POWERMATE_PRODUCT_OLD: input_dev->name = pm_name_soundknob; break; default: input_dev->name = pm_name_soundknob; printk(KERN_WARNING ""powermate: unknown product id %04x\n"", le16_to_cpu(udev->descriptor.idProduct)); } input_dev->phys = pm->phys; usb_to_input_id(udev, &input_dev->id); input_dev->dev.parent = &intf->dev; input_set_drvdata(input_dev, pm); input_dev->event = powermate_input_event; input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REL) | BIT_MASK(EV_MSC); input_dev->keybit[BIT_WORD(BTN_0)] = BIT_MASK(BTN_0); input_dev->relbit[BIT_WORD(REL_DIAL)] = BIT_MASK(REL_DIAL); input_dev->mscbit[BIT_WORD(MSC_PULSELED)] = BIT_MASK(MSC_PULSELED); pipe = usb_rcvintpipe(udev, endpoint->bEndpointAddress); maxp = usb_maxpacket(udev, pipe, usb_pipeout(pipe)); if (maxp < POWERMATE_PAYLOAD_SIZE_MIN || maxp > POWERMATE_PAYLOAD_SIZE_MAX) { printk(KERN_WARNING ""powermate: Expected payload of %d--%d bytes, found %d bytes!\n"", POWERMATE_PAYLOAD_SIZE_MIN, POWERMATE_PAYLOAD_SIZE_MAX, maxp); maxp = POWERMATE_PAYLOAD_SIZE_MAX; } usb_fill_int_urb(pm->irq, udev, pipe, pm->data, maxp, powermate_irq, pm, endpoint->bInterval); pm->irq->transfer_dma = pm->data_dma; pm->irq->transfer_flags |= URB_NO_TRANSFER_DMA_MAP; if (usb_submit_urb(pm->irq, GFP_KERNEL)) { error = -EIO; goto fail4; } error = input_register_device(pm->input); if (error) goto fail5; pm->requires_update = UPDATE_PULSE_ASLEEP | UPDATE_PULSE_AWAKE | UPDATE_PULSE_MODE | UPDATE_STATIC_BRIGHTNESS; powermate_pulse_led(pm, 0x80, 255, 0, 1, 0);  usb_set_intfdata(intf, pm); return 0; fail5:usb_kill_urb(pm->irq); fail4:usb_free_urb(pm->config); fail3:usb_free_urb(pm->irq); fail2:powermate_free_buffers(udev, pm); fail1:input_free_device(input_dev); kfree(pm); return error; }
Description: The powermate_probe function in drivers/input/misc/powermate.c in the Linux kernel before 4.5.1 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) via a crafted endpoints value in a USB device descriptor.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static inline size_t base64_estimate_decode_size(size_t base64_in_size) { return ((base64_in_size / 4) * 3); }
Description: RIOT 2020.04 has a buffer overflow in the base64 decoder. The decoding function base64_decode() uses an output buffer estimation function to compute the required buffer capacity and validate against the provided buffer size. The base64_estimate_decode_size() function calculates the expected decoded size with an arithmetic round-off error and does not take into account possible padding bytes. Due to this underestimation, it may be possible to craft base64 input that causes a buffer overflow.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static guint32 parse_wbxml_tag_defined (proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, guint32 offset, guint32 str_tbl, guint8 *level, guint8 *codepage_stag, guint8 *codepage_attr, const wbxml_decoding *map) { guint32      tvb_len  = tvb_reported_length (tvb); guint32      off      = offset; guint32      len; guint        str_len; guint32      ent; guint32      idx; guint8       peek; guint32      tag_len;                      guint8       tag_save_known      = 0;      guint8       tag_new_known       = 0;      const char  *tag_save_literal    = NULL;   const char  *tag_new_literal;              const gchar *str; guint8       parsing_tag_content = FALSE;  DebugLog((""parse_wbxml_tag_defined (level = %u, offset = %u)\n"", *level, offset)); while (off < tvb_len) { peek = tvb_get_guint8 (tvb, off); DebugLog((""STAG: (top of while) level = %3u, peek = 0x%02X, off = %u, tvb_len = %u\n"", *level, peek, off, tvb_len)); if ((peek & 0x3F) < 4) switch (peek) {  case 0x00:  *codepage_stag = tvb_get_guint8 (tvb, off+1); proto_tree_add_uint_format(tree, hf_wbxml_switch_page, tvb, off, 2, *codepage_stag, ""      | Tag   | T -->%3d | SWITCH_PAGE (Tag code page)     |"", *codepage_stag); off += 2; break; case 0x01:  if (tag_save_known) {  proto_tree_add_string_format(tree, hf_wbxml_end_known_tag, tvb, off, 1, tag_save_literal, ""  %3d | Tag   | T %3d    | END (Known Tag 0x%02X)            | %s</%s>"", *level, *codepage_stag, tag_save_known, Indent (*level), tag_save_literal);  } else {  proto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off, 1, tag_save_literal ? tag_save_literal : """", ""  %3d | Tag   | T %3d    | END (Literal Tag)               | %s</%s>"", *level, *codepage_stag, Indent (*level), tag_save_literal ? tag_save_literal : """"); } (*level)--; off++; DebugLog((""STAG: level = %u, Return: len = %u\n"", *level, off - offset)); return (off - offset); case 0x02:  ent = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar); proto_tree_add_uint_format(tree, hf_wbxml_entity, tvb, off, 1+len, ent, ""  %3d | Tag   | T %3d    | ENTITY                          | %s'&#%u;'"", *level, *codepage_stag, Indent (*level), ent); off += 1+len; break; case 0x03:  len = tvb_strsize (tvb, off+1); str = tvb_format_text (tvb, off+1, len-1); proto_tree_add_string_format(tree, hf_wbxml_str_i, tvb, off, 1+len, str, ""  %3d | Tag   | T %3d    | STR_I (Inline string)           | %s\'%s\'"", *level, *codepage_stag, Indent(*level), str); off += 1+len; break; case 0x40:  case 0x41:  case 0x42:  len = tvb_strsize (tvb, off+1); str = tvb_format_text (tvb, off+1, len-1); proto_tree_add_string_format(tree, hf_wbxml_ext_i, tvb, off, 1+len, str, ""  %3d | Tag   | T %3d    | EXT_I_%1x    (Extension Token)    | %s(%s: \'%s\')"", *level, *codepage_stag, peek & 0x0f, Indent (*level), ((map != NULL) ? map_token (map->global, 0, peek) : ""Inline string extension""), str); off += 1+len; break; case 0x43:  proto_tree_add_none_format(tree, hf_wbxml_pi_xml, tvb, off, 1, ""  %3d | Tag   | T %3d    | PI (XML Processing Instruction) | %s<?xml"", *level, *codepage_stag, Indent (*level)); len = parse_wbxml_attribute_list_defined (tree, tvb, pinfo, off, str_tbl, *level, codepage_attr, map); off += len; if (off >= tvb_len) { DebugLog((""STAG: level = %u, ThrowException: len = %u (short frame)\n"", *level, off - offset)); THROW(ReportedBoundsError); } proto_tree_add_none_format(tree, hf_wbxml_end_pi, tvb, off-1, 1, ""  %3d | Tag   | T %3d    | END (PI)                        | %s?>"", *level, *codepage_stag, Indent (*level)); break; case 0x80:  case 0x81:  case 0x82:  idx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar); { char *s; if (map) { if (map->ext_t[peek & 0x03]) s = (map->ext_t[peek & 0x03])(tvb, idx, str_tbl); else s = wmem_strdup_printf(wmem_packet_scope(), ""EXT_T_%1x (%s)"", peek & 0x03, map_token (map->global, 0, peek)); } else { s = wmem_strdup_printf(wmem_packet_scope(), ""(Extension Token, integer value: %u)"", idx); } proto_tree_add_string_format(tree, hf_wbxml_ext_t, tvb, off, 1+len, s, ""  %3d | Tag   | T %3d    | EXT_T_%1x    (Extension Token)    | %s%s"", *level, *codepage_stag, peek & 0x0f, Indent (*level), s); } off += 1+len; break; case 0x83:  idx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar); str_len = tvb_strsize (tvb, str_tbl+idx); str = tvb_format_text (tvb, str_tbl+idx, str_len-1); proto_tree_add_string_format(tree, hf_wbxml_str_t, tvb, off, 1+len, str, ""  %3d | Tag   | T %3d    | STR_T (Tableref string)         | %s\'%s\'"", *level, *codepage_stag, Indent (*level), str); off += 1+len; break; case 0xC0:  case 0xC1:  case 0xC2:  str = (map != NULL) ? map_token (map->global, 0, peek) : ""Single-byte extension""; proto_tree_add_string_format(tree, hf_wbxml_extension_token, tvb, off, 1, str, ""  %3d | Tag   | T %3d    | EXT_%1x      (Extension Token)    | %s(%s)"", *level, *codepage_stag, peek & 0x0f, Indent (*level), str); off++; break; case 0xC3:  if (tvb_get_guint8 (tvb, 0)) {  if (map != NULL) { char *tmp_str; if (tag_save_known) {  if (map->opaque_binary_tag) { tmp_str = map->opaque_binary_tag(tvb, off + 1, tag_save_known, *codepage_stag, &len, pinfo); } else { tmp_str = default_opaque_binary_tag(tvb, off + 1, tag_save_known, *codepage_stag, &len, pinfo); } } else {  if (map->opaque_literal_tag) { tmp_str = map->opaque_literal_tag(tvb, off + 1, tag_save_literal, *codepage_stag, &len, pinfo); } else { tmp_str = default_opaque_literal_tag(tvb, off + 1, tag_save_literal, *codepage_stag, &len, pinfo); } } proto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len, NULL, ""  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s%s"", *level, *codepage_stag, Indent (*level), tmp_str); off += 1 + len; } else { idx = tvb_get_guintvar (tvb, off+1, &len, pinfo, &ei_wbxml_oversized_uintvar); proto_tree_add_bytes_format(tree, hf_wbxml_opaque_data, tvb, off, 1 + len + idx, NULL, ""  %3d | Tag   | T %3d    | OPAQUE (Opaque data)            | %s(%u bytes of opaque data)"", *level, *codepage_stag, Indent (*level), idx); off += 1+len+idx; } } else {  proto_tree_add_none_format(tree, hf_wbxml_reserved_2, tvb, off, 1, ""  %3d | Tag   | T %3d    | RESERVED_2     (Invalid Token!) | WBXML 1.0 parsing stops here."", *level, *codepage_stag); off = tvb_len; DebugLog((""STAG: level = %u, Return: len = %u\n"", *level, off - offset)); return (off - offset); } break; } else {  tag_len = 0; if ((peek & 0x3F) == 4) {  DebugLog((""STAG: LITERAL tag (peek = 0x%02X, off = %u) - TableRef follows!\n"", peek, off)); idx = tvb_get_guintvar (tvb, off+1, &tag_len, pinfo, &ei_wbxml_oversized_uintvar); str_len = tvb_strsize (tvb, str_tbl+idx); tag_new_literal = (const gchar*)tvb_get_ptr (tvb, str_tbl+idx, str_len); tag_new_known = 0;  } else {  tag_new_known = peek & 0x3F; if (map != NULL) { tag_new_literal = map_token (map->tags, *codepage_stag, tag_new_known); } else { tag_new_literal = wmem_strdup_printf(wmem_packet_scope(), ""Tag_0x%02X"", tag_new_known); } } if (peek & 0x40) {  if (parsing_tag_content) {  DebugLog((""STAG: Tag in Tag - RECURSE! (off = %u)\n"", off)); (*level)++; len = parse_wbxml_tag_defined (tree, tvb, pinfo, off, str_tbl, level, codepage_stag, codepage_attr, map); off += len; } else {  if ((peek & 0x3F) == 4) {  tag_save_literal = tag_new_literal; tag_save_known = 0; } else {  tag_save_known = tag_new_known; tag_save_literal = tag_new_literal; } if (peek & 0x80) {  if (tag_new_known) {  proto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal, ""  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (AC) | %s<%s"", *level, *codepage_stag, tag_new_known, Indent (*level), tag_new_literal); off++; } else {  proto_tree_add_string_format(tree, hf_wbxml_literal_ac, tvb, off, 1, tag_new_literal, ""  %3d | Tag   | T %3d    | LITERAL_AC (Literal tag)   (AC) | %s<%s"", *level, *codepage_stag, Indent (*level), tag_new_literal); off += 1 + tag_len; } len = parse_wbxml_attribute_list_defined (tree, tvb, pinfo, off, str_tbl, *level, codepage_attr, map); off += len; if (off >= tvb_len) { DebugLog((""STAG: level = %u, ThrowException: len = %u (short frame)\n"", *level, off - offset)); THROW(ReportedBoundsError); } proto_tree_add_none_format(tree, hf_wbxml_end_attribute_list, tvb, off-1, 1, ""  %3d | Tag   | T %3d    | END (attribute list)            | %s>"", *level, *codepage_stag, Indent (*level)); } else {  if (tag_new_known) {  proto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal, ""  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (.C) | %s<%s>"", *level, *codepage_stag, tag_new_known, Indent (*level), tag_new_literal); off++; } else {  proto_tree_add_string_format(tree, hf_wbxml_literal_c, tvb, off, 1, tag_new_literal, ""  %3d | Tag   | T %3d    | LITERAL_C  (Literal Tag)   (.C) | %s<%s>"", *level, *codepage_stag, Indent (*level), tag_new_literal); off += 1 + tag_len; } } parsing_tag_content = TRUE; DebugLog((""Tag in Tag - No recursion this time! (off = %u)\n"", off)); } } else {  DebugLog((""<Tag/> in Tag - No recursion! (off = %u)\n"", off)); (*level)++; if (peek & 0x80) {  if (tag_new_known) {  proto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal, ""  %3d | Tag   | T %3d    |   Known Tag 0x%02X           (A.) | %s<%s"", *level, *codepage_stag, tag_new_known, Indent (*level), tag_new_literal); off++; len = parse_wbxml_attribute_list_defined (tree, tvb, pinfo, off, str_tbl, *level, codepage_attr, map); off += len; if (off > tvb_len) { DebugLog((""STAG: level = %u, ThrowException: len = %u (short frame)\n"", *level, off - offset)); THROW(ReportedBoundsError); } proto_tree_add_uint_format(tree, hf_wbxml_end_known_tag_uint, tvb, off-1, 1, *codepage_stag, ""  %3d | Tag   | T %3d    | END (Known Tag)                 | %s/>"", *level, *codepage_stag, Indent (*level)); } else {  proto_tree_add_string_format(tree, hf_wbxml_literal_a, tvb, off, 1, tag_new_literal, ""  %3d | Tag   | T %3d    | LITERAL_A  (Literal Tag)   (A.) | %s<%s"", *level, *codepage_stag, Indent (*level), tag_new_literal); off += 1 + tag_len; len = parse_wbxml_attribute_list_defined (tree, tvb, pinfo, off, str_tbl, *level, codepage_attr, map); off += len; if (off >= tvb_len) { DebugLog((""STAG: level = %u, ThrowException: len = %u (short frame)\n"", *level, off - offset)); THROW(ReportedBoundsError); } proto_tree_add_string_format(tree, hf_wbxml_end_literal_tag, tvb, off-1, 1, """", ""  %3d | Tag   | T %3d    | END (Literal Tag)               | %s/>"", *level, *codepage_stag, Indent (*level)); } } else {  if (tag_new_known) {  proto_tree_add_string_format(tree, hf_wbxml_known_tag, tvb, off, 1, tag_new_literal, ""  %3d | Tag   | T %3d    |   Known Tag 0x%02x           (..) | %s<%s />"", *level, *codepage_stag, tag_new_known, Indent (*level), tag_new_literal); off++; } else {  proto_tree_add_string_format(tree, hf_wbxml_literal, tvb, off, 1, tag_new_literal, ""  %3d | Tag   | T %3d    | LITERAL    (Literal Tag)   (..) | %s<%s />"", *level, *codepage_stag, Indent (*level), tag_new_literal); off += 1 + tag_len; } } (*level)--; } }  }  DebugLog((""STAG: level = %u, Return: len = %u (end of function body)\n"", *level, off - offset)); return (off - offset); }
Description: epan/dissectors/packet-wbxml.c in the WBXML dissector in Wireshark 2.x before 2.0.5 does not restrict the recursion depth, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Status SparseTensorFromContext(OpKernelContext* ctx, const int32_t base_index, const bool validate_indices, sparse::SparseTensor* tensor) { TensorShape shape; TF_RETURN_IF_ERROR(TensorShape::BuildTensorShape( ctx->input(base_index + 2).vec<int64_t>(), &shape)); CheckRankAtLeast2(ctx, shape); std::vector<int64_t> order(shape.dims()); std::iota(order.begin(), order.end(), 0); Status status = sparse::SparseTensor::Create( ctx->input(base_index), ctx->input(base_index + 1), shape, order, tensor); if (!validate_indices || !status.ok()) return status; return tensor->IndicesValid(); }
Description: TensorFlow is an open source platform for machine learning. When `SetSize` receives an input `set_shape` that is not a 1D tensor, it gives a `CHECK` fails that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit cf70b79d2662c0d3c6af74583641e345fc939467. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int pirq_guest_unmask(struct domain *d) { unsigned int pirq = 0, n, i; struct pirq *pirqs[16]; do { n = radix_tree_gang_lookup(&d->pirq_tree, (void **)pirqs, pirq, ARRAY_SIZE(pirqs)); for ( i = 0; i < n; ++i ) { pirq = pirqs[i]->pirq; if ( pirqs[i]->masked && !evtchn_port_is_masked(d, evtchn_from_port(d, pirqs[i]->evtchn)) ) pirq_guest_eoi(pirqs[i]); } } while ( ++pirq < d->nr_pirqs && n == ARRAY_SIZE(pirqs) ); return 0; }
Description: Xen through 4.8.x does not validate the port numbers of polled event channel ports, which allows guest OS users to cause a denial of service (NULL pointer dereference and host OS crash) or possibly obtain sensitive information, aka XSA-221.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool cachefiles_set_volume_xattr(struct cachefiles_volume *volume) { unsigned int len = volume->vcookie->coherency_len; const void *p = volume->vcookie->coherency; struct dentry *dentry = volume->dentry; int ret; _enter(""%x,#%d"", volume->vcookie->debug_id, len); ret = cachefiles_inject_write_error(); if (ret == 0) ret = vfs_setxattr(&init_user_ns, dentry, cachefiles_xattr_cache, p, len, 0); if (ret < 0) { trace_cachefiles_vfs_error(NULL, d_inode(dentry), ret, cachefiles_trace_setxattr_error); trace_cachefiles_vol_coherency(volume, d_inode(dentry)->i_ino, cachefiles_coherency_vol_set_fail); if (ret != -ENOMEM) cachefiles_io_error( volume->cache, ""Failed to set xattr with error %d"", ret); } else { trace_cachefiles_vol_coherency(volume, d_inode(dentry)->i_ino, cachefiles_coherency_vol_set_ok); } _leave("" = %d"", ret); return ret == 0; }
Description: An out-of-bounds (OOB) memory write flaw was found in the Linux kernel’s watch_queue event notification subsystem. This flaw can overwrite parts of the kernel state, potentially allowing a local user to gain privileged access or cause a denial of service on the system.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void* Zone::New(size_t size) { size = RoundUp(size, kAlignment); if (kPointerSize == 4 && kAlignment == 4) { position_ += ((~size) & 4) & (reinterpret_cast<intptr_t>(position_) & 4); } else { DCHECK(kAlignment >= kPointerSize); } Address result = position_; const size_t size_with_redzone = size + kASanRedzoneBytes; if (limit_ < position_ + size_with_redzone) { result = NewExpand(size_with_redzone); } else { position_ += size_with_redzone; } Address redzone_position = result + size; DCHECK(redzone_position + kASanRedzoneBytes == position_); ASAN_POISON_MEMORY_REGION(redzone_position, kASanRedzoneBytes); DCHECK(IsAddressAligned(result, kAlignment, 0)); allocation_size_ += size; return reinterpret_cast<void*>(result); }
Description: The Zone::New function in zone.cc in Google V8 before 5.0.71.47, as used in Google Chrome before 50.0.2661.102, does not properly determine when to expand certain memory allocations, which allows remote attackers to cause a denial of service (buffer overflow) or possibly have unspecified other impact via crafted JavaScript code.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int line6_init_pcm(struct usb_line6 *line6, struct line6_pcm_properties *properties) { int i, err; unsigned ep_read = line6->properties->ep_audio_r; unsigned ep_write = line6->properties->ep_audio_w; struct snd_pcm *pcm; struct snd_line6_pcm *line6pcm; if (!(line6->properties->capabilities & LINE6_CAP_PCM)) return 0; err = snd_line6_new_pcm(line6, &pcm); if (err < 0) return err; line6pcm = kzalloc(sizeof(*line6pcm), GFP_KERNEL); if (!line6pcm) return -ENOMEM; mutex_init(&line6pcm->state_mutex); line6pcm->pcm = pcm; line6pcm->properties = properties; line6pcm->volume_playback[0] = line6pcm->volume_playback[1] = 255; line6pcm->volume_monitor = 255; line6pcm->line6 = line6; line6pcm->max_packet_size_in = usb_maxpacket(line6->usbdev, usb_rcvisocpipe(line6->usbdev, ep_read), 0); line6pcm->max_packet_size_out = usb_maxpacket(line6->usbdev, usb_sndisocpipe(line6->usbdev, ep_write), 1); spin_lock_init(&line6pcm->out.lock); spin_lock_init(&line6pcm->in.lock); line6pcm->impulse_period = LINE6_IMPULSE_DEFAULT_PERIOD; line6->line6pcm = line6pcm; pcm->private_data = line6pcm; pcm->private_free = line6_cleanup_pcm; err = line6_create_audio_out_urbs(line6pcm); if (err < 0) return err; err = line6_create_audio_in_urbs(line6pcm); if (err < 0) return err; for (i = 0; i < ARRAY_SIZE(line6_controls); i++) { err = snd_ctl_add(line6->card, snd_ctl_new1(&line6_controls[i], line6pcm)); if (err < 0) return err; } return 0; }
Description: An issue was discovered in the Linux kernel before 5.1.17. There is a NULL pointer dereference caused by a malicious USB device in the sound/usb/line6/pcm.c driver.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static ssize_t eth_rx(NetClientState *nc, const uint8_t *buf, size_t size) { struct xlx_ethlite *s = qemu_get_nic_opaque(nc); unsigned int rxbase = s->rxbuf * (0x800 / 4); if (!(buf[0] & 0x80) && memcmp(&s->conf.macaddr.a[0], buf, 6)) return size; if (s->regs[rxbase + R_RX_CTRL0] & CTRL_S) { D(qemu_log(""ethlite lost packet %x\n"", s->regs[R_RX_CTRL0])); return -1; } D(qemu_log(""%s %zd rxbase=%x\n"", __func__, size, rxbase)); memcpy(&s->regs[rxbase + R_RX_BUF0], buf, size); s->regs[rxbase + R_RX_CTRL0] |= CTRL_S; if (s->regs[R_RX_CTRL0] & CTRL_I) { eth_pulse_irq(s); } s->rxbuf ^= s->c_rx_pingpong; return size; }
Description: Heap-based buffer overflow in the .receive callback of xlnx.xps-ethernetlite in QEMU (aka Quick Emulator) allows attackers to execute arbitrary code on the QEMU host via a large ethlite packet.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int main (int    argc, char **argv) { mode_t old_umask; cleanup_free char *base_path = NULL; int clone_flags; char *old_cwd = NULL; pid_t pid; int event_fd = -1; int child_wait_fd = -1; const char *new_cwd; uid_t ns_uid; gid_t ns_gid; struct stat sbuf; uint64_t val; int res UNUSED; real_uid = getuid (); real_gid = getgid (); acquire_privs (); if (prctl (PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0) die_with_error (""prctl(PR_SET_NO_NEW_CAPS) failed""); read_overflowids (); argv0 = argv[0]; if (isatty (1)) host_tty_dev = ttyname (1); argv++; argc--; if (argc == 0) usage (EXIT_FAILURE, stderr); parse_args (&argc, &argv); if (!is_privileged && getuid () != 0) opt_unshare_user = TRUE; if (opt_unshare_user_try && stat (""/proc/self/ns/user"", &sbuf) == 0) { bool disabled = FALSE; if (stat (""/sys/module/user_namespace/parameters/enable"", &sbuf) == 0) { cleanup_free char *enable = NULL; enable = load_file_at (AT_FDCWD, ""/sys/module/user_namespace/parameters/enable""); if (enable != NULL && enable[0] == 'N') disabled = TRUE; } if (!disabled) opt_unshare_user = TRUE; } if (argc == 0) usage (EXIT_FAILURE, stderr); __debug__ ((""Creating root mount point\n"")); if (opt_sandbox_uid == -1) opt_sandbox_uid = real_uid; if (opt_sandbox_gid == -1) opt_sandbox_gid = real_gid; if (!opt_unshare_user && opt_sandbox_uid != real_uid) die (""Specifying --uid requires --unshare-user""); if (!opt_unshare_user && opt_sandbox_gid != real_gid) die (""Specifying --gid requires --unshare-user""); if (!opt_unshare_uts && opt_sandbox_hostname != NULL) die (""Specifying --hostname requires --unshare-uts""); proc_fd = open (""/proc"", O_RDONLY | O_PATH); if (proc_fd == -1) die_with_error (""Can't open /proc""); base_path = xasprintf (""/run/user/%d/.bubblewrap"", real_uid); if (mkdir (base_path, 0755) && errno != EEXIST) { free (base_path); base_path = xasprintf (""/tmp/.bubblewrap-%d"", real_uid); if (mkdir (base_path, 0755) && errno != EEXIST) die_with_error (""Creating root mountpoint failed""); } __debug__ ((""creating new namespace\n"")); if (opt_unshare_pid) { event_fd = eventfd (0, EFD_CLOEXEC | EFD_NONBLOCK); if (event_fd == -1) die_with_error (""eventfd()""); } block_sigchild (); clone_flags = SIGCHLD | CLONE_NEWNS; if (opt_unshare_user) clone_flags |= CLONE_NEWUSER; if (opt_unshare_pid) clone_flags |= CLONE_NEWPID; if (opt_unshare_net) clone_flags |= CLONE_NEWNET; if (opt_unshare_ipc) clone_flags |= CLONE_NEWIPC; if (opt_unshare_uts) clone_flags |= CLONE_NEWUTS; if (opt_unshare_cgroup) { if (stat (""/proc/self/ns/cgroup"", &sbuf)) { if (errno == ENOENT) die (""Cannot create new cgroup namespace because the kernel does not support it""); else die_with_error (""stat on /proc/self/ns/cgroup failed""); } clone_flags |= CLONE_NEWCGROUP; } if (opt_unshare_cgroup_try) if (!stat (""/proc/self/ns/cgroup"", &sbuf)) clone_flags |= CLONE_NEWCGROUP; child_wait_fd = eventfd (0, EFD_CLOEXEC); if (child_wait_fd == -1) die_with_error (""eventfd()""); pid = raw_clone (clone_flags, NULL); if (pid == -1) { if (opt_unshare_user) { if (errno == EINVAL) die (""Creating new namespace failed, likely because the kernel does not support user namespaces.  bwrap must be installed setuid on such systems.""); else if (errno == EPERM && !is_privileged) die (""No permissions to creating new namespace, likely because the kernel does not allow non-privileged user namespaces. On e.g. debian this can be enabled with 'sysctl kernel.unprivileged_userns_clone=1'.""); } die_with_error (""Creating new namespace failed""); } ns_uid = opt_sandbox_uid; ns_gid = opt_sandbox_gid; if (pid != 0) { if (is_privileged && opt_unshare_user) { write_uid_gid_map (ns_uid, real_uid, ns_gid, real_gid, pid, TRUE, opt_needs_devpts); } drop_privs (); val = 1; res = write (child_wait_fd, &val, 8); close (child_wait_fd); if (opt_info_fd != -1) { cleanup_free char *output = xasprintf (""{\n    \""child-pid\"": %i\n}\n"", pid); size_t len = strlen (output); if (write (opt_info_fd, output, len) != len) die_with_error (""Write to info_fd""); close (opt_info_fd); } monitor_child (event_fd); exit (0);  } if (opt_info_fd != -1) close (opt_info_fd); res = read (child_wait_fd, &val, 8); close (child_wait_fd); switch_to_user_with_privs (); if (opt_unshare_net && loopback_setup () != 0) die (""Can't create loopback device""); ns_uid = opt_sandbox_uid; ns_gid = opt_sandbox_gid; if (!is_privileged && opt_unshare_user) { if (opt_needs_devpts) { ns_uid = 0; ns_gid = 0; } write_uid_gid_map (ns_uid, real_uid, ns_gid, real_gid, -1, TRUE, FALSE); } old_umask = umask (0); resolve_symlinks_in_ops (); if (mount (NULL, ""/"", NULL, MS_SLAVE | MS_REC, NULL) < 0) die_with_error (""Failed to make / slave""); if (mount ("""", base_path, ""tmpfs"", MS_NODEV | MS_NOSUID, NULL) != 0) die_with_error (""Failed to mount tmpfs""); old_cwd = get_current_dir_name (); if (chdir (base_path) != 0) die_with_error (""chdir base_path""); if (mkdir (""newroot"", 0755)) die_with_error (""Creating newroot failed""); if (mkdir (""oldroot"", 0755)) die_with_error (""Creating oldroot failed""); if (pivot_root (base_path, ""oldroot"")) die_with_error (""pivot_root""); if (chdir (""/"") != 0) die_with_error (""chdir / (base path)""); if (is_privileged) { pid_t child; int privsep_sockets[2]; if (socketpair (AF_UNIX, SOCK_SEQPACKET | SOCK_CLOEXEC, 0, privsep_sockets) != 0) die_with_error (""Can't create privsep socket""); child = fork (); if (child == -1) die_with_error (""Can't fork unprivileged helper""); if (child == 0) { drop_privs (); close (privsep_sockets[0]); setup_newroot (opt_unshare_pid, privsep_sockets[1]); exit (0); } else { int status; uint32_t buffer[2048];   uint32_t op, flags; const char *arg1, *arg2; cleanup_fd int unpriv_socket = -1; unpriv_socket = privsep_sockets[0]; close (privsep_sockets[1]); do { op = read_priv_sec_op (unpriv_socket, buffer, sizeof (buffer), &flags, &arg1, &arg2); privileged_op (-1, op, flags, arg1, arg2); if (write (unpriv_socket, buffer, 1) != 1) die (""Can't write to op_socket""); } while (op != PRIV_SEP_OP_DONE); waitpid (child, &status, 0); } } else { setup_newroot (opt_unshare_pid, -1); } if (mount (""oldroot"", ""oldroot"", NULL, MS_REC | MS_PRIVATE, NULL) != 0) die_with_error (""Failed to make old root rprivate""); if (umount2 (""oldroot"", MNT_DETACH)) die_with_error (""unmount old root""); if (opt_unshare_user && (ns_uid != opt_sandbox_uid || ns_gid != opt_sandbox_gid)) { if (unshare (CLONE_NEWUSER)) die_with_error (""unshare user ns""); write_uid_gid_map (opt_sandbox_uid, ns_uid, opt_sandbox_gid, ns_gid, -1, FALSE, FALSE); } if (chdir (""/newroot"") != 0) die_with_error (""chdir newroot""); if (chroot (""/newroot"") != 0) die_with_error (""chroot /newroot""); if (chdir (""/"") != 0) die_with_error (""chdir /""); drop_privs (); if (opt_block_fd != -1) { char b[1]; read (opt_block_fd, b, 1); close (opt_block_fd); } if (opt_seccomp_fd != -1) { cleanup_free char *seccomp_data = NULL; size_t seccomp_len; struct sock_fprog prog; seccomp_data = load_file_data (opt_seccomp_fd, &seccomp_len); if (seccomp_data == NULL) die_with_error (""Can't read seccomp data""); if (seccomp_len % 8 != 0) die (""Invalid seccomp data, must be multiple of 8""); prog.len = seccomp_len / 8; prog.filter = (struct sock_filter *) seccomp_data; close (opt_seccomp_fd); if (prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &prog) != 0) die_with_error (""prctl(PR_SET_SECCOMP)""); } umask (old_umask); new_cwd = ""/""; if (opt_chdir_path) { if (chdir (opt_chdir_path)) die_with_error (""Can't chdir to %s"", opt_chdir_path); new_cwd = opt_chdir_path; } else if (chdir (old_cwd) == 0) { new_cwd = old_cwd; } else { const char *home = getenv (""HOME""); if (home != NULL && chdir (home) == 0) new_cwd = home; } xsetenv (""PWD"", new_cwd, 1); free (old_cwd); __debug__ ((""forking for child\n"")); if (opt_unshare_pid || lock_files != NULL || opt_sync_fd != -1) { pid = fork (); if (pid == -1) die_with_error (""Can't fork for pid 1""); if (pid != 0) { { int dont_close[3]; int j = 0; if (event_fd != -1) dont_close[j++] = event_fd; if (opt_sync_fd != -1) dont_close[j++] = opt_sync_fd; dont_close[j++] = -1; fdwalk (proc_fd, close_extra_fds, dont_close); } return do_init (event_fd, pid); } } __debug__ ((""launch executable %s\n"", argv[0])); if (proc_fd != -1) close (proc_fd); if (opt_sync_fd != -1) close (opt_sync_fd); unblock_sigchild (); if (label_exec (opt_exec_label) == -1) die_with_error (""label_exec %s"", argv[0]); if (execvp (argv[0], argv) == -1) die_with_error (""execvp %s"", argv[0]); return 0; }
Description: When executing a program via the bubblewrap sandbox, the nonpriv session can escape to the parent session by using the TIOCSTI ioctl to push characters into the terminal's input buffer, allowing an attacker to escape the sandbox.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: ImmutableConstantOp::ImmutableConstantOp(OpKernelConstruction* context) : OpKernel(context) { OP_REQUIRES_OK(context, context->GetAttr(kMemoryRegionNameAttr, &region_name_)); OP_REQUIRES_OK(context, context->GetAttr(kDTypeAttr, &dtype_)); OP_REQUIRES_OK(context, context->GetAttr(kShapeAttr, &shape_)); }
Description: TensorFlow is an end-to-end open source platform for machine learning. Calling `tf.raw_ops.ImmutableConst`(https://www.tensorflow.org/api_docs/python/tf/raw_ops/ImmutableConst) with a `dtype` of `tf.resource` or `tf.variant` results in a segfault in the implementation as code assumes that the tensor contents are pure scalars. We have patched the issue in 4f663d4b8f0bec1b48da6fa091a7d29609980fa4 and will release TensorFlow 2.5.0 containing the patch. TensorFlow nightly packages after this commit will also have the issue resolved. If using `tf.raw_ops.ImmutableConst` in code, you can prevent the segfault by inserting a filter for the `dtype` argument.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static h2o_http2_conn_t *create_conn(h2o_context_t *ctx, h2o_hostconf_t **hosts, h2o_socket_t *sock, struct timeval connected_at) { static const h2o_conn_callbacks_t callbacks = { .get_sockname = get_sockname, .get_peername = get_peername, .get_ptls = get_ptls, .skip_tracing = skip_tracing, .get_req_id = get_req_id, .push_path = push_path, .get_debug_state = h2o_http2_get_debug_state, .close_idle_connection = close_idle_connection, .foreach_request = foreach_request, .request_shutdown = initiate_graceful_shutdown, .get_rtt = get_rtt, .log_ = {{ .transport = { .cc_name = log_tcp_congestion_controller, .delivery_rate = log_tcp_delivery_rate, }, .ssl = { .protocol_version = log_ssl_protocol_version, .session_reused = log_ssl_session_reused, .cipher = log_ssl_cipher, .cipher_bits = log_ssl_cipher_bits, .session_id = log_ssl_session_id, .server_name = log_ssl_server_name, .negotiated_protocol = log_ssl_negotiated_protocol, .ech_config_id = log_ssl_ech_config_id, .ech_kem = log_ssl_ech_kem, .ech_cipher = log_ssl_ech_cipher, .ech_cipher_bits = log_ssl_ech_cipher_bits, .backend = log_ssl_backend, }, .http2 = { .stream_id = log_stream_id, .priority_received = log_priority_received, .priority_received_exclusive = log_priority_received_exclusive, .priority_received_parent = log_priority_received_parent, .priority_received_weight = log_priority_received_weight, .priority_actual = log_priority_actual, .priority_actual_parent = log_priority_actual_parent, .priority_actual_weight = log_priority_actual_weight, }, }}, }; h2o_http2_conn_t *conn = (void *)h2o_create_connection(sizeof(*conn), ctx, hosts, connected_at, &callbacks); memset((char *)conn + sizeof(conn->super), 0, sizeof(*conn) - sizeof(conn->super)); conn->sock = sock; conn->peer_settings = H2O_HTTP2_SETTINGS_DEFAULT; conn->streams = kh_init(h2o_http2_stream_t); h2o_http2_scheduler_init(&conn->scheduler); conn->state = H2O_HTTP2_CONN_STATE_OPEN; conn->_read_expect = expect_preface; conn->_input_header_table.hpack_capacity = conn->_input_header_table.hpack_max_capacity = H2O_HTTP2_SETTINGS_DEFAULT.header_table_size; h2o_http2_window_init(&conn->_input_window, H2O_HTTP2_SETTINGS_HOST_CONNECTION_WINDOW_SIZE); conn->_output_header_table.hpack_capacity = H2O_HTTP2_SETTINGS_DEFAULT.header_table_size; h2o_linklist_init_anchor(&conn->_pending_reqs); h2o_buffer_init(&conn->_write.buf, &h2o_http2_wbuf_buffer_prototype); h2o_linklist_init_anchor(&conn->_write.streams_to_proceed); conn->_write.timeout_entry.cb = emit_writereq; h2o_http2_window_init(&conn->_write.window, conn->peer_settings.initial_window_size); h2o_linklist_init_anchor(&conn->early_data.blocked_streams); conn->is_chromium_dependency_tree = 1;  conn->received_any_request = 0; return conn; }
Description: The HTTP/2 protocol allows a denial of service (server resource consumption) because request cancellation can reset many streams quickly, as exploited in the wild in August through October 2023.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: char *EXPORT_CALL lou_setDataPath(const char *path) { static char dataPath[MAXSTRING]; dataPathPtr = NULL; if (path == NULL) return NULL; strcpy(dataPath, path); dataPathPtr = dataPath; return dataPathPtr; }
Description: Buffer Overflow vulnerability found in Liblouis v.3.24.0 allows a remote attacker to cause a denial of service via the lou_logFile function at logginc.c endpoint.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg) { struct xc2028_data *priv = fe->tuner_priv; struct xc2028_ctrl *p    = priv_cfg; int                 rc   = 0; tuner_dbg(""%s called\n"", __func__); mutex_lock(&priv->lock); kfree(priv->ctrl.fname); memcpy(&priv->ctrl, p, sizeof(priv->ctrl)); if (p->fname) { priv->ctrl.fname = kstrdup(p->fname, GFP_KERNEL); if (priv->ctrl.fname == NULL) rc = -ENOMEM; } if (!firmware_name[0] && p->fname && priv->fname && strcmp(p->fname, priv->fname)) free_firmware(priv); if (priv->ctrl.max_len < 9) priv->ctrl.max_len = 13; if (priv->state == XC2028_NO_FIRMWARE) { if (!firmware_name[0]) priv->fname = priv->ctrl.fname; else priv->fname = firmware_name; rc = request_firmware_nowait(THIS_MODULE, 1, priv->fname, priv->i2c_props.adap->dev.parent, GFP_KERNEL, fe, load_firmware_cb); if (rc < 0) { tuner_err(""Failed to request firmware %s\n"", priv->fname); priv->state = XC2028_NODEV; } else priv->state = XC2028_WAITING_FIRMWARE; } mutex_unlock(&priv->lock); return rc; }
Description: The xc2028_set_config function in drivers/media/tuners/tuner-xc2028.c in the Linux kernel before 4.6 allows local users to gain privileges or cause a denial of service (use-after-free) via vectors involving omission of the firmware name from a certain data structure.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int parse_cmd_address(exarg_T *eap, char **errormsg, int silent) { intaddress_count = 1; linenr_Tlnum; intneed_check_cursor = FALSE; intret = FAIL; for (;;) { eap->line1 = eap->line2; eap->line2 = default_address(eap); eap->cmd = skipwhite(eap->cmd); lnum = get_address(eap, &eap->cmd, eap->addr_type, eap->skip, silent, eap->addr_count == 0, address_count++); if (eap->cmd == NULL)    goto theend; if (lnum == MAXLNUM) { if (*eap->cmd == '%')       { ++eap->cmd; switch (eap->addr_type) { case ADDR_LINES: case ADDR_OTHER: eap->line1 = 1; eap->line2 = curbuf->b_ml.ml_line_count; break; case ADDR_LOADED_BUFFERS: { buf_T*buf = firstbuf; while (buf->b_next != NULL && buf->b_ml.ml_mfp == NULL) buf = buf->b_next; eap->line1 = buf->b_fnum; buf = lastbuf; while (buf->b_prev != NULL && buf->b_ml.ml_mfp == NULL) buf = buf->b_prev; eap->line2 = buf->b_fnum; break; } case ADDR_BUFFERS: eap->line1 = firstbuf->b_fnum; eap->line2 = lastbuf->b_fnum; break; case ADDR_WINDOWS: case ADDR_TABS: if (IS_USER_CMDIDX(eap->cmdidx)) { eap->line1 = 1; eap->line2 = eap->addr_type == ADDR_WINDOWS ? LAST_WIN_NR : LAST_TAB_NR; } else { *errormsg = _(e_invalid_range); goto theend; } break; case ADDR_TABS_RELATIVE: case ADDR_UNSIGNED: case ADDR_QUICKFIX: *errormsg = _(e_invalid_range); goto theend; case ADDR_ARGUMENTS: if (ARGCOUNT == 0) eap->line1 = eap->line2 = 0; else { eap->line1 = 1; eap->line2 = ARGCOUNT; } break; case ADDR_QUICKFIX_VALID: #ifdef FEAT_QUICKFIX eap->line1 = 1; eap->line2 = qf_get_valid_size(eap); if (eap->line2 == 0) eap->line2 = 1; #endif break; case ADDR_NONE: break; } ++eap->addr_count; } else if (*eap->cmd == '*' && vim_strchr(p_cpo, CPO_STAR) == NULL) { pos_T    *fp; if (eap->addr_type != ADDR_LINES) { *errormsg = _(e_invalid_range); goto theend; } ++eap->cmd; if (!eap->skip) { fp = getmark('<', FALSE); if (check_mark(fp) == FAIL) goto theend; eap->line1 = fp->lnum; fp = getmark('>', FALSE); if (check_mark(fp) == FAIL) goto theend; eap->line2 = fp->lnum; ++eap->addr_count; } } } else eap->line2 = lnum; eap->addr_count++; if (*eap->cmd == ';') { if (!eap->skip) { curwin->w_cursor.lnum = eap->line2; if (eap->line2 > 0) check_cursor(); need_check_cursor = TRUE; } } else if (*eap->cmd != ',') break; ++eap->cmd; } if (eap->addr_count == 1) { eap->line1 = eap->line2; if (lnum == MAXLNUM) eap->addr_count = 0; } ret = OK; theend: if (need_check_cursor) check_cursor(); return ret; }
Description: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 8.2.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: ssize_t nbd_wr_syncv(QIOChannel *ioc, struct iovec *iov, size_t niov, size_t length, bool do_read) { ssize_t done = 0; Error *local_err = NULL; struct iovec *local_iov = g_new(struct iovec, niov); struct iovec *local_iov_head = local_iov; unsigned int nlocal_iov = niov; nlocal_iov = iov_copy(local_iov, nlocal_iov, iov, niov, 0, length); while (nlocal_iov > 0) { ssize_t len; if (do_read) { len = qio_channel_readv(ioc, local_iov, nlocal_iov, &local_err); } else { len = qio_channel_writev(ioc, local_iov, nlocal_iov, &local_err); } if (len == QIO_CHANNEL_ERR_BLOCK) { if (qemu_in_coroutine()) { qemu_coroutine_yield(); } else if (done) { qio_channel_wait(ioc, do_read ? G_IO_IN : G_IO_OUT); } else { return -EAGAIN; } continue; } if (len < 0) { TRACE(""I/O error: %s"", error_get_pretty(local_err)); error_free(local_err); done = -EIO; goto cleanup; } if (do_read && len == 0) { break; } iov_discard_front(&local_iov, &nlocal_iov, len); done += len; } cleanup: g_free(local_iov_head); return done; }
Description: An assertion-failure flaw was found in Qemu before 2.10.1, in the Network Block Device (NBD) server's initial connection negotiation, where the I/O coroutine was undefined. This could crash the qemu-nbd server if a client sent unexpected data during connection negotiation. A remote user or process could use this flaw to crash the qemu-nbd server resulting in denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void JPXStream::init() { Object oLen, cspace, smaskInData; if (getDict()) { oLen = getDict()->lookup(""Length""); cspace = getDict()->lookup(""ColorSpace""); smaskInData = getDict()->lookup(""SMaskInData""); } int bufSize = BUFFER_INITIAL_SIZE; if (oLen.isInt()) bufSize = oLen.getInt(); bool indexed = false; if (cspace.isArray() && cspace.arrayGetLength() > 0) { const Object cstype = cspace.arrayGet(0); if (cstype.isName(""Indexed"")) indexed = true; } priv->smaskInData = 0; if (smaskInData.isInt()) priv->smaskInData = smaskInData.getInt(); int length = 0; unsigned char *buf = str->toUnsignedChars(&length, bufSize); priv->init2(OPJ_CODEC_JP2, buf, length, indexed); gfree(buf); if (priv->image) { int numComps = (priv->image) ? priv->image->numcomps : 1; int alpha = 0; if (priv->image) { if (priv->image->color_space == OPJ_CLRSPC_SRGB && numComps == 4) { numComps = 3; alpha = 1; } else if (priv->image->color_space == OPJ_CLRSPC_SYCC && numComps == 4) { numComps = 3; alpha = 1; } else if (numComps == 2) { numComps = 1; alpha = 1; } else if (numComps > 4) { numComps = 4; alpha = 1; } else { alpha = 0; } } priv->npixels = priv->image->comps[0].w * priv->image->comps[0].h; priv->ncomps = priv->image->numcomps; if (alpha == 1 && priv->smaskInData == 0) priv->ncomps--; for (int component = 0; component < priv->ncomps; component++) { if (priv->image->comps[component].data == nullptr) { close(); break; } unsigned char *cdata = (unsigned char *)priv->image->comps[component].data; int adjust = 0; int depth = priv->image->comps[component].prec; if (priv->image->comps[component].prec > 8) adjust = priv->image->comps[component].prec - 8; int sgndcorr = 0; if (priv->image->comps[component].sgnd) sgndcorr = 1 << (priv->image->comps[0].prec - 1); for (int i = 0; i < priv->npixels; i++) { int r = priv->image->comps[component].data[i]; *(cdata++) = adjustComp(r, adjust, depth, sgndcorr, indexed); } } } else { priv->npixels = 0; } priv->counter = 0; priv->ccounter = 0; priv->inited = true; }
Description: In Poppler through 0.76.1, there is a heap-based buffer over-read in JPXStream::init in JPEG2000Stream.cc via data with inconsistent heights or widths.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int dissect_xra_tlv_ms_info(tvbuff_t * tvb, proto_tree * tree, void* data _U_, guint16 tlv_length) { proto_item *it; proto_tree *xra_tlv_ms_info_tree; it = proto_tree_add_item (tree, hf_xra_tlv_ms_info, tvb, 0, tlv_length, ENC_NA); xra_tlv_ms_info_tree = proto_item_add_subtree (it, ett_xra_tlv_ms_info); guint32 tlv_index =0; while (tlv_index < tlv_length) { guint8 type = tvb_get_guint8 (tvb, tlv_index); ++tlv_index; guint8 length = tvb_get_guint8 (tvb, tlv_index); ++tlv_index; switch (type) { case XRA_TLV_MINISLOT_INFO_START_MINISLOT_ID: proto_tree_add_item (xra_tlv_ms_info_tree, hf_xra_tlv_start_minislot_id_abs, tvb, tlv_index, length, ENC_BIG_ENDIAN); break; case XRA_TLV_MINISLOT_INFO_REL_START_MINISLOT: proto_tree_add_item (xra_tlv_ms_info_tree, hf_xra_tlv_start_minislot_id_rel, tvb, tlv_index, length, ENC_BIG_ENDIAN); break; case XRA_TLV_MINISLOT_INFO_REL_STOP_MINISLOT: proto_tree_add_item (xra_tlv_ms_info_tree, hf_xra_tlv_stop_minislot_id_rel, tvb, tlv_index, length, ENC_BIG_ENDIAN); break; default: proto_tree_add_item (xra_tlv_ms_info_tree, hf_xra_unknown, tvb, tlv_index, length, ENC_NA); break; } tlv_index+=length; } return tvb_captured_length(tvb); }
Description: XRA dissector infinite loop in Wireshark 4.0.0 to 4.0.5 and 3.6.0 to 3.6.13 allows denial of service via packet injection or crafted capture file
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static gint dissect_prefixed_bencode(tvbuff_t *tvb, gint offset, packet_info *pinfo, proto_tree *tree) { guint32     plen; proto_tree *prefixed_bencode_tree; proto_item *ti; tvbuff_t *subtvb; plen = tvb_get_ntohl(tvb, offset); ti = proto_tree_add_item(tree, hf_bzr_prefixed_bencode, tvb, offset, 4 + plen, ENC_NA); prefixed_bencode_tree = proto_item_add_subtree(ti, ett_prefixed_bencode); proto_tree_add_item(prefixed_bencode_tree, hf_bzr_prefixed_bencode_len, tvb, offset, 4, ENC_BIG_ENDIAN); subtvb = tvb_new_subset_length(tvb, offset+4, plen); call_dissector(bencode_handle, subtvb, pinfo, prefixed_bencode_tree); return 4 + plen; }
Description: In Wireshark 2.6.0 to 2.6.1, 2.4.0 to 2.4.7, and 2.2.0 to 2.2.15, the Bazaar protocol dissector could go into an infinite loop. This was addressed in epan/dissectors/packet-bzr.c by properly handling items that are too long.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void Compute(OpKernelContext* ctx) override { const Tensor* hypothesis_indices; const Tensor* hypothesis_values; const Tensor* hypothesis_shape; const Tensor* truth_indices; const Tensor* truth_values; const Tensor* truth_shape; OP_REQUIRES_OK(ctx, ctx->input(""hypothesis_indices"", &hypothesis_indices)); OP_REQUIRES_OK(ctx, ctx->input(""hypothesis_values"", &hypothesis_values)); OP_REQUIRES_OK(ctx, ctx->input(""hypothesis_shape"", &hypothesis_shape)); OP_REQUIRES_OK(ctx, ctx->input(""truth_indices"", &truth_indices)); OP_REQUIRES_OK(ctx, ctx->input(""truth_values"", &truth_values)); OP_REQUIRES_OK(ctx, ctx->input(""truth_shape"", &truth_shape)); OP_REQUIRES_OK( ctx, ValidateShapes(ctx, *hypothesis_indices, *hypothesis_values, *hypothesis_shape, *truth_indices, *truth_values, *truth_shape)); TensorShape hypothesis_st_shape; OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape( hypothesis_shape->vec<int64_t>().data(), hypothesis_shape->NumElements(), &hypothesis_st_shape)); TensorShape truth_st_shape; OP_REQUIRES_OK(ctx, TensorShapeUtils::MakeShape( truth_shape->vec<int64_t>().data(), truth_shape->NumElements(), &truth_st_shape)); std::vector<int64_t> sorted_order(truth_st_shape.dims()); std::iota(sorted_order.begin(), sorted_order.end(), 0); sparse::SparseTensor hypothesis; OP_REQUIRES_OK(ctx, sparse::SparseTensor::Create( *hypothesis_indices, *hypothesis_values, hypothesis_st_shape, sorted_order, &hypothesis)); sparse::SparseTensor truth; OP_REQUIRES_OK(ctx, sparse::SparseTensor::Create( *truth_indices, *truth_values, truth_st_shape, sorted_order, &truth)); std::vector<int64_t> group_dims(truth_st_shape.dims() - 1); std::iota(group_dims.begin(), group_dims.end(), 0); TensorShape output_shape; for (int d = 0; d < static_cast<int>(group_dims.size()); ++d) { output_shape.AddDim(std::max(hypothesis_st_shape.dim_size(d), truth_st_shape.dim_size(d))); } const auto output_elements = output_shape.num_elements(); OP_REQUIRES( ctx, output_elements > 0, errors::InvalidArgument(""Got output shape "", output_shape.DebugString(), "" which has 0 elements"")); Tensor* output = nullptr; OP_REQUIRES_OK(ctx, ctx->allocate_output(""output"", output_shape, &output)); auto output_t = output->flat<float>(); output_t.setZero(); std::vector<int64_t> output_strides(output_shape.dims()); output_strides[output_shape.dims() - 1] = 1; for (int d = output_shape.dims() - 2; d >= 0; --d) { output_strides[d] = output_strides[d + 1] * output_shape.dim_size(d + 1); } auto hypothesis_grouper = hypothesis.group(group_dims); auto truth_grouper = truth.group(group_dims); auto hypothesis_iter = hypothesis_grouper.begin(); auto truth_iter = truth_grouper.begin(); auto cmp = std::equal_to<T>(); while (hypothesis_iter != hypothesis_grouper.end() && truth_iter != truth_grouper.end()) { sparse::Group truth_i = *truth_iter; sparse::Group hypothesis_j = *hypothesis_iter; std::vector<int64_t> g_truth = truth_i.group(); std::vector<int64_t> g_hypothesis = hypothesis_j.group(); auto truth_seq = truth_i.values<T>(); auto hypothesis_seq = hypothesis_j.values<T>(); if (g_truth == g_hypothesis) { auto loc = std::inner_product(g_truth.begin(), g_truth.end(), output_strides.begin(), int64_t{0}); OP_REQUIRES( ctx, loc < output_elements, errors::Internal(""Got an inner product "", loc, "" which would require in writing to outside of "" ""the buffer for the output tensor (max elements "", output_elements, "")"")); output_t(loc) = gtl::LevenshteinDistance<T>(truth_seq, hypothesis_seq, cmp); if (normalize_) output_t(loc) /= truth_seq.size(); ++hypothesis_iter; ++truth_iter; } else if (g_truth > g_hypothesis) {          auto loc = std::inner_product(g_hypothesis.begin(), g_hypothesis.end(), output_strides.begin(), int64_t{0}); OP_REQUIRES( ctx, loc < output_elements, errors::Internal(""Got an inner product "", loc, "" which would require in writing to outside of "" ""the buffer for the output tensor (max elements "", output_elements, "")"")); output_t(loc) = hypothesis_seq.size(); if (normalize_ && output_t(loc) != 0.0f) { output_t(loc) = std::numeric_limits<float>::infinity(); } ++hypothesis_iter; } else {          auto loc = std::inner_product(g_truth.begin(), g_truth.end(), output_strides.begin(), int64_t{0}); OP_REQUIRES( ctx, loc < output_elements, errors::Internal(""Got an inner product "", loc, "" which would require in writing to outside of "" ""the buffer for the output tensor (max elements "", output_elements, "")"")); output_t(loc) = (normalize_) ? 1.0 : truth_seq.size(); ++truth_iter; } } while (hypothesis_iter != hypothesis_grouper.end()) {        sparse::Group hypothesis_j = *hypothesis_iter; std::vector<int64_t> g_hypothesis = hypothesis_j.group(); auto hypothesis_seq = hypothesis_j.values<T>(); auto loc = std::inner_product(g_hypothesis.begin(), g_hypothesis.end(), output_strides.begin(), int64_t{0}); OP_REQUIRES( ctx, loc < output_elements, errors::Internal(""Got an inner product "", loc, "" which would require in writing to outside of the "" ""buffer for the output tensor (max elements "", output_elements, "")"")); output_t(loc) = hypothesis_seq.size(); if (normalize_ && output_t(loc) != 0.0f) { output_t(loc) = std::numeric_limits<float>::infinity(); } ++hypothesis_iter; } while (truth_iter != truth_grouper.end()) {        sparse::Group truth_i = *truth_iter; std::vector<int64_t> g_truth = truth_i.group(); auto truth_seq = truth_i.values<T>(); auto loc = std::inner_product(g_truth.begin(), g_truth.end(), output_strides.begin(), int64_t{0}); OP_REQUIRES( ctx, loc < output_elements, errors::Internal(""Got an inner product "", loc, "" which would require in writing to outside of the "" ""buffer for the output tensor (max elements "", output_elements, "")"")); output_t(loc) = (normalize_) ? 1.0 : truth_seq.size(); ++truth_iter; } }
Description: TensorFlow is an open source platform for machine learning. Prior to versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4, the implementation of `tf.raw_ops.EditDistance` has incomplete validation. Users can pass negative values to cause a segmentation fault based denial of service. In multiple places throughout the code, one may compute an index for a write operation. However, the existing validation only checks against the upper bound of the array. Hence, it is possible to write before the array by massaging the input to generate negative values for `loc`. Versions 2.9.0, 2.8.1, 2.7.2, and 2.6.4 contain a patch for this issue.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int xenmem_add_to_physmap_one( struct domain *d, unsigned int space, union add_to_physmap_extra extra, unsigned long idx, gfn_t gpfn) { struct page_info *page = NULL; unsigned long gfn = 0 , old_gpfn; mfn_t prev_mfn; int rc = 0; mfn_t mfn = INVALID_MFN; p2m_type_t p2mt; switch ( space ) { case XENMAPSPACE_shared_info: if ( idx == 0 ) mfn = virt_to_mfn(d->shared_info); break; case XENMAPSPACE_grant_table: rc = gnttab_map_frame(d, idx, gpfn, &mfn); if ( rc ) return rc; break; case XENMAPSPACE_gmfn: { p2m_type_t p2mt; gfn = idx; mfn = get_gfn_unshare(d, gfn, &p2mt); if ( p2m_is_shared(p2mt) ) { put_gfn(d, gfn); return -ENOMEM; } page = get_page_from_mfn(mfn, d); if ( unlikely(!page) ) mfn = INVALID_MFN; break; } case XENMAPSPACE_gmfn_foreign: return p2m_add_foreign(d, idx, gfn_x(gpfn), extra.foreign_domid); } if ( mfn_eq(mfn, INVALID_MFN) ) { rc = -EINVAL; goto put_both; } prev_mfn = get_gfn(d, gfn_x(gpfn), &p2mt); old_gpfn = get_gpfn_from_mfn(mfn_x(mfn)); ASSERT(!SHARED_M2P(old_gpfn)); if ( space == XENMAPSPACE_gmfn && old_gpfn != gfn ) { rc = -EXDEV; goto put_all; } if ( p2mt == p2m_mmio_direct ) rc = -EPERM; else if ( mfn_valid(prev_mfn) ) { if ( is_special_page(mfn_to_page(prev_mfn)) ) rc = guest_physmap_remove_page(d, gpfn, prev_mfn, PAGE_ORDER_4K); else if ( !mfn_eq(mfn, prev_mfn) ) rc = guest_remove_page(d, gfn_x(gpfn)); } if ( !rc && old_gpfn != INVALID_M2P_ENTRY ) rc = guest_physmap_remove_page(d, _gfn(old_gpfn), mfn, PAGE_ORDER_4K); if ( !rc ) rc = guest_physmap_add_page(d, gpfn, mfn, PAGE_ORDER_4K); put_all: put_gfn(d, gfn_x(gpfn)); put_both: if ( space == XENMAPSPACE_gmfn ) { put_gfn(d, gfn); if ( !rc && extra.ppage ) { *extra.ppage = page; page = NULL; } } if ( page ) put_page(page); return rc; }
Description: Another race in XENMAPSPACE_grant_table handling Guests are permitted access to certain Xen-owned pages of memory. The majority of such pages remain allocated / associated with a guest for its entire lifetime. Grant table v2 status pages, however, are de-allocated when a guest switches (back) from v2 to v1. Freeing such pages requires that the hypervisor enforce that no parallel request can result in the addition of a mapping of such a page to a guest. That enforcement was missing, allowing guests to retain access to pages that were freed and perhaps re-used for other purposes. Unfortunately, when XSA-379 was being prepared, this similar issue was not noticed.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void binder_deferred_fd_close(int fd) { struct binder_task_work_cb *twcb; twcb = kzalloc(sizeof(*twcb), GFP_KERNEL); if (!twcb) return; init_task_work(&twcb->twork, binder_do_fd_close); __close_fd_get_file(fd, &twcb->file); if (twcb->file) task_work_add(current, &twcb->twork, TWA_RESUME); else kfree(twcb); }
Description: The code in UEK6 U3 was missing an appropiate file descriptor count to be missing. This resulted in a use count error that allowed a file descriptor to a socket to be closed and freed while it was still in use by another portion of the kernel. An attack with local access can operate on the socket, and cause a denial of service. CVSS 3.1 Base Score 5.5 (Availability impacts). CVSS Vector: (CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void asus_kbd_backlight_set(struct led_classdev *led_cdev, enum led_brightness brightness) { struct asus_kbd_leds *led = container_of(led_cdev, struct asus_kbd_leds, cdev); unsigned long flags; spin_lock_irqsave(&led->lock, flags); led->brightness = brightness; spin_unlock_irqrestore(&led->lock, flags); schedule_work(&led->work); }
Description: A flaw was found in the Linux kernel. A use-after-free may be triggered in asus_kbd_backlight_set when plugging/disconnecting in a malicious USB device, which advertises itself as an Asus device. Similarly to the previous known CVE-2023-25012, but in asus devices, the work_struct may be scheduled by the LED controller while the device is disconnecting, triggering a use-after-free on the struct asus_kbd_leds *led structure. A malicious USB device may exploit the issue to cause memory corruption with controlled data.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int domain_adjust_node_perms(struct connection *conn, struct node *node) { unsigned int i; int ret; ret = chk_domain_generation(node->perms.p[0].id, node->generation); if (ret < 0) return errno; if (!ret) { node->perms.p[0].id = priv_domid; } for (i = 1; i < node->perms.num; i++) { if (node->perms.p[i].perms & XS_PERM_IGNORE) continue; ret = chk_domain_generation(node->perms.p[i].id, node->generation); if (ret < 0) return errno; if (!ret) node->perms.p[i].perms |= XS_PERM_IGNORE; } return 0; }
Description: Xenstore: Guests can get access to Xenstore nodes of deleted domains Access rights of Xenstore nodes are per domid. When a domain is gone, there might be Xenstore nodes left with access rights containing the domid of the removed domain. This is normally no problem, as those access right entries will be corrected when such a node is written later. There is a small time window when a new domain is created, where the access rights of a past domain with the same domid as the new one will be regarded to be still valid, leading to the new domain being able to get access to a node which was meant to be accessible by the removed domain. For this to happen another domain needs to write the node before the newly created domain is being introduced to Xenstore by dom0.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int dynamicGetbuf (gdIOCtxPtr ctx, void *buf, int len) { int rlen, remain; dpIOCtxPtr dctx; dynamicPtr *dp; dctx = (dpIOCtxPtr) ctx; dp = dctx->dp; remain = dp->logicalSize - dp->pos; if (remain >= len) { rlen = len; } else { if (remain == 0) { return EOF; } rlen = remain; } memcpy(buf, (void *) ((char *) dp->data + dp->pos), rlen); dp->pos += rlen; return rlen; }
Description: Integer signedness error in the dynamicGetbuf function in gd_io_dp.c in the GD Graphics Library (aka libgd) through 2.2.3, as used in PHP before 5.6.28 and 7.x before 7.0.13, allows remote attackers to cause a denial of service (stack-based buffer overflow) or possibly have unspecified other impact via a crafted imagecreatefromstring call.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int dissect_diameter_base_framed_ipv6_prefix(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, void *data) { diam_sub_dis_t *diam_sub_dis = (diam_sub_dis_t*)data; guint8 prefix_len, prefix_len_bytes; proto_tree_add_item(tree, hf_framed_ipv6_prefix_reserved, tvb, 0, 1, ENC_BIG_ENDIAN); proto_tree_add_item(tree, hf_framed_ipv6_prefix_length, tvb, 1, 1, ENC_BIG_ENDIAN); prefix_len = tvb_get_guint8(tvb, 1); prefix_len_bytes = prefix_len / 8; if (prefix_len % 8) prefix_len_bytes++; proto_tree_add_item(tree, hf_framed_ipv6_prefix_bytes, tvb, 2, prefix_len_bytes, ENC_NA); if (prefix_len_bytes == 16) { proto_tree_add_item(tree, hf_framed_ipv6_prefix_ipv6, tvb, 2, prefix_len_bytes, ENC_NA); } else { struct e_in6_addr value; address addr; memset(&value.bytes, 0, sizeof(value)); tvb_memcpy(tvb, (guint8 *)&value.bytes, 2, prefix_len_bytes); value.bytes[prefix_len_bytes] = value.bytes[prefix_len_bytes] & (0xff<<(prefix_len % 8)); proto_tree_add_ipv6(tree, hf_framed_ipv6_prefix_ipv6, tvb, 2, prefix_len_bytes, &value); set_address(&addr, AT_IPv6, 16, value.bytes); diam_sub_dis->avp_str = wmem_strdup_printf(wmem_packet_scope(), ""%s/%u"", address_to_str(wmem_packet_scope(), &addr), prefix_len); } return(prefix_len_bytes+2); }
Description: The dissect_diameter_base_framed_ipv6_prefix function in epan/dissectors/packet-diameter.c in the DIAMETER dissector in Wireshark 1.12.x before 1.12.9 and 2.0.x before 2.0.1 does not validate the IPv6 prefix length, which allows remote attackers to cause a denial of service (stack-based buffer overflow and application crash) via a crafted packet.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static time_t addgetnetgrentX (struct database_dyn *db, int fd, request_header *req, const char *key, uid_t uid, struct hashentry *he, struct datahead *dh, struct dataset **resultp) { if (__glibc_unlikely (debug_level > 0)) { if (he == NULL) dbg_log (_(""Haven't found \""%s\"" in netgroup cache!""), key); else dbg_log (_(""Reloading \""%s\"" in netgroup cache!""), key); } static service_user *netgroup_database; time_t timeout; struct dataset *dataset; bool cacheable = false; ssize_t total; bool found = false; char *key_copy = NULL; struct __netgrent data; size_t buflen = MAX (1024, sizeof (*dataset) + req->key_len); size_t buffilled = sizeof (*dataset); char *buffer = NULL; size_t nentries = 0; size_t group_len = strlen (key) + 1; union { struct name_list elem; char mem[sizeof (struct name_list) + group_len]; } first_needed; if (netgroup_database == NULL && __nss_database_lookup (""netgroup"", NULL, NULL, &netgroup_database)) { cacheable = do_notfound (db, fd, req, key, &dataset, &total, &timeout, &key_copy); goto writeout; } memset (&data, '\0', sizeof (data)); buffer = xmalloc (buflen); first_needed.elem.next = &first_needed.elem; memcpy (first_needed.elem.name, key, group_len); data.needed_groups = &first_needed.elem; while (data.needed_groups != NULL) { struct name_list *this_group = data.needed_groups->next; if (this_group == data.needed_groups) data.needed_groups = NULL; else data.needed_groups->next = this_group->next; this_group->next = data.known_groups; data.known_groups = this_group; union { enum nss_status (*f) (const char *, struct __netgrent *); void *ptr; } setfct; service_user *nip = netgroup_database; int no_more = __nss_lookup (&nip, ""setnetgrent"", NULL, &setfct.ptr); while (!no_more) { enum nss_status status = DL_CALL_FCT (*setfct.f, (data.known_groups->name, &data)); if (status == NSS_STATUS_SUCCESS) { found = true; union { enum nss_status (*f) (struct __netgrent *, char *, size_t, int *); void *ptr; } getfct; getfct.ptr = __nss_lookup_function (nip, ""getnetgrent_r""); if (getfct.f != NULL) while (1) { int e; status = getfct.f (&data, buffer + buffilled, buflen - buffilled, &e); if (status == NSS_STATUS_RETURN || status == NSS_STATUS_NOTFOUND) break; if (status == NSS_STATUS_SUCCESS) { if (data.type == triple_val) { const char *nhost = data.val.triple.host; const char *nuser = data.val.triple.user; const char *ndomain = data.val.triple.domain; if (nhost == NULL || nuser == NULL || ndomain == NULL || nhost > nuser || nuser > ndomain) { const char *last = nhost; if (last == NULL || (nuser != NULL && nuser > last)) last = nuser; if (last == NULL || (ndomain != NULL && ndomain > last)) last = ndomain; size_t bufused = (last == NULL ? buffilled : last + strlen (last) + 1 - buffer); size_t hostlen = strlen (nhost ?: """") + 1; size_t userlen = strlen (nuser ?: """") + 1; size_t domainlen = strlen (ndomain ?: """") + 1; size_t needed = hostlen + userlen + domainlen; if (buflen - req->key_len - bufused < needed) { buflen += MAX (buflen, 2 * needed); size_t nhostdiff = nhost - buffer; size_t nuserdiff = nuser - buffer; size_t ndomaindiff = ndomain - buffer; char *newbuf = xrealloc (buffer, buflen); nhost = (nhost ? newbuf + nhostdiff : NULL); nuser = (nuser ? newbuf + nuserdiff : NULL); ndomain = (ndomain ? newbuf + ndomaindiff : NULL); buffer = newbuf; } nhost = memcpy (buffer + bufused, nhost ?: """", hostlen); nuser = memcpy ((char *) nhost + hostlen, nuser ?: """", userlen); ndomain = memcpy ((char *) nuser + userlen, ndomain ?: """", domainlen); } char *wp = buffer + buffilled; wp = stpcpy (wp, nhost) + 1; wp = stpcpy (wp, nuser) + 1; wp = stpcpy (wp, ndomain) + 1; buffilled = wp - buffer; ++nentries; } else { struct name_list *runp = data.needed_groups; if (runp != NULL) while (1) { if (strcmp (runp->name, data.val.group) == 0) break; runp = runp->next; if (runp == data.needed_groups) { runp = NULL; break; } } if (runp == NULL) { runp = data.known_groups; while (runp != NULL) if (strcmp (runp->name, data.val.group) == 0) break; else runp = runp->next; } if (runp == NULL) { size_t namelen = strlen (data.val.group) + 1; struct name_list *newg = alloca (sizeof (*newg) + namelen); memcpy (newg->name, data.val.group, namelen); if (data.needed_groups == NULL) data.needed_groups = newg->next = newg; else { newg->next = data.needed_groups->next; data.needed_groups->next = newg; data.needed_groups = newg; } } } } else if (status == NSS_STATUS_UNAVAIL && e == ERANGE) { buflen *= 2; buffer = xrealloc (buffer, buflen); } } enum nss_status (*endfct) (struct __netgrent *); endfct = __nss_lookup_function (nip, ""endnetgrent""); if (endfct != NULL) (void) DL_CALL_FCT (*endfct, (&data)); break; } no_more = __nss_next2 (&nip, ""setnetgrent"", NULL, &setfct.ptr, status, 0); } } if (!found) { cacheable = do_notfound (db, fd, req, key, &dataset, &total, &timeout, &key_copy); goto writeout; } total = buffilled; dataset = (struct dataset *) buffer; dataset->head.allocsize = total + req->key_len; dataset->head.recsize = total - offsetof (struct dataset, resp); dataset->head.notfound = false; dataset->head.nreloads = he == NULL ? 0 : (dh->nreloads + 1); dataset->head.usable = true; dataset->head.ttl = db->postimeout; timeout = dataset->head.timeout = time (NULL) + dataset->head.ttl; dataset->resp.version = NSCD_VERSION; dataset->resp.found = 1; dataset->resp.nresults = nentries; dataset->resp.result_len = buffilled - sizeof (*dataset); assert (buflen - buffilled >= req->key_len); key_copy = memcpy (buffer + buffilled, key, req->key_len); buffilled += req->key_len; if (he != NULL) { assert (fd == -1); if (dataset->head.allocsize == dh->allocsize && dataset->head.recsize == dh->recsize && memcmp (&dataset->resp, dh->data, dh->allocsize - offsetof (struct dataset, resp)) == 0) { dh->timeout = dataset->head.timeout; dh->ttl = dataset->head.ttl; ++dh->nreloads; dataset = (struct dataset *) dh; goto out; } } { struct dataset *newp = (struct dataset *) mempool_alloc (db, total + req->key_len, 1); if (__glibc_likely (newp != NULL)) { key_copy = (char *) newp + (key_copy - buffer); dataset = memcpy (newp, dataset, total + req->key_len); cacheable = true; if (he != NULL) dh->usable = false; } } if (he == NULL && fd != -1) { writeout: #ifdef HAVE_SENDFILE if (__builtin_expect (db->mmap_used, 1) && cacheable) { assert (db->wr_fd != -1); assert ((char *) &dataset->resp > (char *) db->data); assert ((char *) dataset - (char *) db->head + total <= (sizeof (struct database_pers_head) + db->head->module * sizeof (ref_t) + db->head->data_size)); # ifndef __ASSUME_SENDFILE ssize_t written = # endif sendfileall (fd, db->wr_fd, (char *) &dataset->resp - (char *) db->head, dataset->head.recsize); # ifndef __ASSUME_SENDFILE if (written == -1 && errno == ENOSYS) goto use_write; # endif } else #endif { #if defined HAVE_SENDFILE && !defined __ASSUME_SENDFILE use_write: #endif writeall (fd, &dataset->resp, dataset->head.recsize); } } if (cacheable) { if (db->persistent) { uintptr_t pval = (uintptr_t) dataset & ~pagesize_m1; msync ((void *) pval, ((uintptr_t) dataset & pagesize_m1) + total + req->key_len, MS_ASYNC); } (void) cache_add (req->type, key_copy, req->key_len, &dataset->head, true, db, uid, he == NULL); pthread_rwlock_unlock (&db->lock); if (dh != NULL) dh->usable = false; } out: free (buffer); *resultp = dataset; return timeout; }
Description: nscd in the GNU C Library (aka glibc or libc6) before version 2.20 does not correctly compute the size of an internal buffer when processing netgroup requests, possibly leading to an nscd daemon crash or code execution as the user running nscd.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void control_work_handler(struct work_struct *work) { struct ports_device *portdev; struct virtqueue *vq; struct port_buffer *buf; unsigned int len; portdev = container_of(work, struct ports_device, control_work); vq = portdev->c_ivq; spin_lock(&portdev->c_ivq_lock); while ((buf = virtqueue_get_buf(vq, &len))) { spin_unlock(&portdev->c_ivq_lock); buf->len = len; buf->offset = 0; handle_control_message(vq->vdev, portdev, buf); spin_lock(&portdev->c_ivq_lock); if (add_inbuf(portdev->c_ivq, buf) < 0) { dev_warn(&portdev->vdev->dev, ""Error adding buffer to queue\n""); free_buf(buf, false); } } spin_unlock(&portdev->c_ivq_lock); }
Description: In drivers/char/virtio_console.c in the Linux kernel before 5.13.4, data corruption or loss can be triggered by an untrusted device that supplies a buf->len value exceeding the buffer size. NOTE: the vendor indicates that the cited data corruption is not a vulnerability in any existing use case; the length validation was added solely for robustness in the face of anomalous host OS behavior
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int dissect_wg(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void *data _U_) { proto_item *ti; proto_tree *wg_tree; guint32     message_type; const char *message_type_str; wg_packet_info_t *wg_pinfo; message_type = tvb_get_guint8(tvb, 0); message_type_str = try_val_to_str(message_type, wg_type_names); if (!message_type_str) return 0; if (message_type == WG_TYPE_TRANSPORT_DATA && tvb_reported_length(tvb) == 32) { message_type_str = ""Keepalive""; } col_set_str(pinfo->cinfo, COL_PROTOCOL, ""WireGuard""); col_set_str(pinfo->cinfo, COL_INFO, message_type_str); ti = proto_tree_add_item(tree, proto_wg, tvb, 0, -1, ENC_NA); wg_tree = proto_item_add_subtree(ti, ett_wg); proto_tree_add_item(wg_tree, hf_wg_type, tvb, 0, 1, ENC_NA); proto_tree_add_item(wg_tree, hf_wg_reserved, tvb, 1, 3, ENC_NA); if (!PINFO_FD_VISITED(pinfo)) { wg_pinfo = wmem_new0(wmem_file_scope(), wg_packet_info_t); p_add_proto_data(wmem_file_scope(), pinfo, proto_wg, 0, wg_pinfo); } else { wg_pinfo = (wg_packet_info_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_wg, 0); } switch ((wg_message_type)message_type) { case WG_TYPE_HANDSHAKE_INITIATION: return wg_dissect_handshake_initiation(tvb, pinfo, wg_tree, wg_pinfo); case WG_TYPE_HANDSHAKE_RESPONSE: return wg_dissect_handshake_response(tvb, pinfo, wg_tree, wg_pinfo); case WG_TYPE_COOKIE_REPLY: return wg_dissect_handshake_cookie(tvb, pinfo, wg_tree, wg_pinfo); case WG_TYPE_TRANSPORT_DATA: return wg_dissect_data(tvb, pinfo, wg_tree, wg_pinfo); } DISSECTOR_ASSERT_NOT_REACHED(); }
Description: In Wireshark 3.2.0 to 3.2.1, the WireGuard dissector could crash. This was addressed in epan/dissectors/packet-wireguard.c by handling the situation where a certain data structure intentionally has a NULL value.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void operator()(OpKernelContext* context, const Tensor& input_tensor, Tensor& output_tensor, int n, bool reverse) { const T* input = input_tensor.flat<T>().data(); T* output = output_tensor.flat<T>().data(); const int num_rows = output_tensor.NumElements(); const int last_dim = input_tensor.dim_size(input_tensor.dims() - 1); auto SubNthElement = [&, input, output, last_dim, n](int start, int limit) { std::vector<T> buf(last_dim); for (int b = start; b < limit; ++b) { const T* input_start = input + b * last_dim; const T* input_end = input + (b + 1) * last_dim; std::copy(input_start, input_end, buf.begin()); std::nth_element(buf.begin(), buf.begin() + n, buf.end()); output[b] = buf[n]; } }; auto worker_threads = *(context->device()->tensorflow_cpu_worker_threads()); Shard(worker_threads.num_threads, worker_threads.workers, num_rows, 20 * last_dim, SubNthElement); }
Description: In Tensorflow before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, the `Shard` API in TensorFlow expects the last argument to be a function taking two `int64` (i.e., `long long`) arguments. However, there are several places in TensorFlow where a lambda taking `int` or `int32` arguments is being used. In these cases, if the amount of work to be parallelized is large enough, integer truncation occurs. Depending on how the two arguments of the lambda are used, this can result in segfaults, read/write outside of heap allocated arrays, stack overflows, or data corruption. The issue is patched in commits 27b417360cbd671ef55915e4bb6bb06af8b8a832 and ca8c013b5e97b1373b3bb1c97ea655e69f31a575, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: BT_HDR* avdt_msg_asmbl(AvdtpCcb* p_ccb, BT_HDR* p_buf) { uint8_t* p; uint8_t pkt_type; BT_HDR* p_ret; p = (uint8_t*)(p_buf + 1) + p_buf->offset; if (p_buf->len < 1) { android_errorWriteLog(0x534e4554, ""78287084""); osi_free(p_buf); p_ret = NULL; return p_ret; } AVDT_MSG_PRS_PKT_TYPE(p, pkt_type); if (p_buf->len < avdt_msg_pkt_type_len[pkt_type]) { osi_free(p_buf); AVDT_TRACE_WARNING(""Bad length during reassembly""); p_ret = NULL; } else if (pkt_type == AVDT_PKT_TYPE_SINGLE) { if (p_ccb->p_rx_msg != NULL) AVDT_TRACE_WARNING(""Got single during reassembly""); osi_free_and_reset((void**)&p_ccb->p_rx_msg); p_ret = p_buf; } else if (pkt_type == AVDT_PKT_TYPE_START) { if (p_ccb->p_rx_msg != NULL) AVDT_TRACE_WARNING(""Got start during reassembly""); osi_free_and_reset((void**)&p_ccb->p_rx_msg); if (sizeof(BT_HDR) + p_buf->offset + p_buf->len > BT_DEFAULT_BUFFER_SIZE) { android_errorWriteLog(0x534e4554, ""232023771""); osi_free(p_buf); p_ret = NULL; return p_ret; } p_ccb->p_rx_msg = (BT_HDR*)osi_malloc(BT_DEFAULT_BUFFER_SIZE); memcpy(p_ccb->p_rx_msg, p_buf, sizeof(BT_HDR) + p_buf->offset + p_buf->len); osi_free(p_buf); p = (uint8_t*)(p_ccb->p_rx_msg + 1) + p_ccb->p_rx_msg->offset; *(p + 1) = *p; p_ccb->p_rx_msg->offset += p_ccb->p_rx_msg->len; p_ccb->p_rx_msg->len -= 1; p_ret = NULL; } else { if (p_ccb->p_rx_msg == NULL) { osi_free(p_buf); AVDT_TRACE_WARNING(""Pkt type=%d out of order"", pkt_type); p_ret = NULL; } else { uint16_t buf_len = BT_DEFAULT_BUFFER_SIZE - sizeof(BT_HDR); p_buf->offset += AVDT_LEN_TYPE_CONT; p_buf->len -= AVDT_LEN_TYPE_CONT; if ((p_ccb->p_rx_msg->offset + p_buf->len) > buf_len) { AVDT_TRACE_WARNING(""%s: Fragmented message too big!"", __func__); osi_free_and_reset((void**)&p_ccb->p_rx_msg); osi_free(p_buf); p_ret = NULL; } else { memcpy((uint8_t*)(p_ccb->p_rx_msg + 1) + p_ccb->p_rx_msg->offset, (uint8_t*)(p_buf + 1) + p_buf->offset, p_buf->len); if (pkt_type == AVDT_PKT_TYPE_END) { p_ccb->p_rx_msg->offset -= p_ccb->p_rx_msg->len; p_ccb->p_rx_msg->len += p_buf->len; p_ret = p_ccb->p_rx_msg; p_ccb->p_rx_msg = NULL; } else { p_ccb->p_rx_msg->offset += p_buf->len; p_ccb->p_rx_msg->len += p_buf->len; p_ret = NULL; } osi_free(p_buf); } } } return p_ret; }
Description: In avdt_msg_asmbl of avdt_msg.cc, there is a possible out of bounds write due to an integer overflow. This could lead to paired device escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void ipv6_select_ident(struct frag_hdr *fhdr, struct rt6_info *rt) { static u32 ip6_idents_hashrnd __read_mostly; u32 hash, id; net_get_random_once(&ip6_idents_hashrnd, sizeof(ip6_idents_hashrnd)); hash = __ipv6_addr_jhash(&rt->rt6i_dst.addr, ip6_idents_hashrnd); hash = __ipv6_addr_jhash(&rt->rt6i_src.addr, hash); id = ip_idents_reserve(hash, 1); fhdr->identification = htonl(id); }
Description: In the Linux kernel before 5.1.7, a device can be tracked by an attacker using the IP ID values the kernel produces for connection-less protocols (e.g., UDP and ICMP). When such traffic is sent to multiple destination IP addresses, it is possible to obtain hash collisions (of indices to the counter array) and thereby obtain the hashing key (via enumeration). An attack may be conducted by hosting a crafted web page that uses WebRTC or gQUIC to force UDP traffic to attacker-controlled IP addresses.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int sc_oberthur_read_file(struct sc_pkcs15_card *p15card, const char *in_path, unsigned char **out, size_t *out_len, int verify_pin) { struct sc_context *ctx = p15card->card->ctx; struct sc_card *card = p15card->card; struct sc_file *file = NULL; struct sc_path path; size_t sz; int rv; LOG_FUNC_CALLED(ctx); if (!in_path || !out || !out_len) LOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, ""Cannot read oberthur file""); sc_log(ctx, ""read file '%s'; verify_pin:%i"", in_path, verify_pin); *out = NULL; *out_len = 0; sc_format_path(in_path, &path); rv = sc_select_file(card, &path, &file); if (rv != SC_SUCCESS) { sc_file_free(file); LOG_TEST_RET(ctx, rv, ""Cannot select oberthur file to read""); } if (file->ef_structure == SC_FILE_EF_TRANSPARENT) sz = file->size; else sz = (file->record_length + 2) * file->record_count; *out = calloc(sz, 1); if (*out == NULL) { sc_file_free(file); LOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, ""Cannot read oberthur file""); } if (file->ef_structure == SC_FILE_EF_TRANSPARENT)   { rv = sc_read_binary(card, 0, *out, sz, 0); } else{ size_t rec; size_t offs = 0; size_t rec_len = file->record_length; for (rec = 1; ; rec++)   { if (rec > file->record_count) { rv = 0; break; } rv = sc_read_record(card, rec, *out + offs + 2, rec_len, SC_RECORD_BY_REC_NR); if (rv == SC_ERROR_RECORD_NOT_FOUND)   { rv = 0; break; } else if (rv < 0)   { break; } rec_len = rv; *(*out + offs) = 'R'; *(*out + offs + 1) = rv; offs += rv + 2; } sz = offs; } sc_log(ctx, ""read oberthur file result %i"", rv); if (verify_pin && rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   { struct sc_pkcs15_object *objs[0x10], *pin_obj = NULL; const struct sc_acl_entry *acl = sc_file_get_acl_entry(file, SC_AC_OP_READ); int ii; if (acl == NULL) { sc_file_free(file); free(*out); *out = NULL; LOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_DATA); } rv = sc_pkcs15_get_objects(p15card, SC_PKCS15_TYPE_AUTH_PIN, objs, 0x10); if (rv != SC_SUCCESS) { sc_file_free(file); free(*out); *out = NULL; LOG_TEST_RET(ctx, rv, ""Cannot read oberthur file: get AUTH objects error""); } for (ii=0; ii<rv; ii++)   { struct sc_pkcs15_auth_info *auth_info = (struct sc_pkcs15_auth_info *) objs[ii]->data; sc_log(ctx, ""compare PIN/ACL refs:%i/%i, method:%i/%i"", auth_info->attrs.pin.reference, acl->key_ref, auth_info->auth_method, acl->method); if (auth_info->attrs.pin.reference == (int)acl->key_ref && auth_info->auth_method == (unsigned)acl->method)   { pin_obj = objs[ii]; break; } } if (!pin_obj || !pin_obj->content.value)    { rv = SC_ERROR_SECURITY_STATUS_NOT_SATISFIED; } else    { rv = sc_pkcs15_verify_pin(p15card, pin_obj, pin_obj->content.value, pin_obj->content.len); if (!rv) rv = sc_oberthur_read_file(p15card, in_path, out, out_len, 0); } } sc_file_free(file); if (rv < 0)   { free(*out); *out = NULL; *out_len = 0; } *out_len = sz; LOG_FUNC_RETURN(ctx, rv); }
Description: A heap use after free issue was found in Opensc before version 0.22.0 in sc_file_valid.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int TIFFMergeFieldInfo(TIFF* tif, const TIFFFieldInfo info[], uint32_t n) { static const char module[] = ""TIFFMergeFieldInfo""; static const char reason[] = ""for fields array""; TIFFField *tp; size_t nfields; uint32_t i; if (tif->tif_nfieldscompat > 0) { tif->tif_fieldscompat = (TIFFFieldArray *) _TIFFCheckRealloc(tif, tif->tif_fieldscompat, tif->tif_nfieldscompat + 1, sizeof(TIFFFieldArray), reason); } else { tif->tif_fieldscompat = (TIFFFieldArray *) _TIFFCheckMalloc(tif, 1, sizeof(TIFFFieldArray), reason); } if (!tif->tif_fieldscompat) { TIFFErrorExt(tif->tif_clientdata, module, ""Failed to allocate fields array""); return -1; } nfields = tif->tif_nfieldscompat++; tif->tif_fieldscompat[nfields].type = tfiatOther; tif->tif_fieldscompat[nfields].allocated_size = n; tif->tif_fieldscompat[nfields].count = n; tif->tif_fieldscompat[nfields].fields = (TIFFField *)_TIFFCheckMalloc(tif, n, sizeof(TIFFField), reason); if (!tif->tif_fieldscompat[nfields].fields) { TIFFErrorExt(tif->tif_clientdata, module, ""Failed to allocate fields array""); return -1; } tp = tif->tif_fieldscompat[nfields].fields; for (i = 0; i < n; i++) { tp->field_tag = info[i].field_tag; tp->field_readcount = info[i].field_readcount; tp->field_writecount = info[i].field_writecount; tp->field_type = info[i].field_type; tp->reserved = 0; tp->set_field_type = _TIFFSetGetType(info[i].field_type, info[i].field_readcount, info[i].field_passcount); tp->get_field_type = _TIFFSetGetType(info[i].field_type, info[i].field_readcount, info[i].field_passcount); tp->field_bit = info[i].field_bit; tp->field_oktochange = info[i].field_oktochange; tp->field_passcount = info[i].field_passcount; if (info[i].field_name == NULL) { TIFFErrorExt(tif->tif_clientdata, module, ""Field_name of %d.th allocation tag %d is NULL"", i, info[i].field_tag); return -1; } tp->field_name = info[i].field_name; tp->field_subfields = NULL; tp++; } if (!_TIFFMergeFields(tif, tif->tif_fieldscompat[nfields].fields, n)) { TIFFErrorExt(tif->tif_clientdata, module, ""Setting up field info failed""); return -1; } return 0; }
Description: A stack buffer overflow flaw was found in Libtiffs' tiffcp.c in main() function. This flaw allows an attacker to pass a crafted TIFF file to the tiffcp tool, triggering a stack buffer overflow issue, possibly corrupting the memory, and causing a crash that leads to a denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static njs_int_t njs_array_prototype_concat(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs, njs_index_t unused) { double       idx; int64_t      k, len, length; njs_int_t    ret; njs_uint_t   i; njs_value_t  this, retval, *e; njs_array_t  *array, *keys; ret = njs_value_to_object(vm, &args[0]); if (njs_slow_path(ret != NJS_OK)) { return ret; } array = njs_array_alloc(vm, 0, 0, NJS_ARRAY_SPARE); if (njs_slow_path(array == NULL)) { return NJS_ERROR; } njs_set_array(&this, array); len = 0; length = 0; for (i = 0; i < nargs; i++) { e = njs_argument(args, i); ret = njs_is_concat_spreadable(vm, e); if (njs_slow_path(ret == NJS_ERROR)) { return NJS_ERROR; } if (ret == NJS_OK) { ret = njs_object_length(vm, e, &len); if (njs_slow_path(ret == NJS_ERROR)) { return ret; } if (njs_slow_path((length + len) > NJS_MAX_LENGTH)) { njs_type_error(vm, ""Invalid length""); return NJS_ERROR; } if (njs_is_fast_array(e) || njs_fast_object(len)) { for (k = 0; k < len; k++, length++) { ret = njs_value_property_i64(vm, e, k, &retval); if (njs_slow_path(ret != NJS_OK)) { if (ret == NJS_ERROR) { return NJS_ERROR; } njs_set_invalid(&retval); } ret = njs_array_add(vm, array, &retval); if (njs_slow_path(ret != NJS_OK)) { return NJS_ERROR; } } continue; } keys = njs_array_indices(vm, e); if (njs_slow_path(keys == NULL)) { return NJS_ERROR; } for (k = 0; k < keys->length; k++) { ret = njs_value_property(vm, e, &keys->start[k], &retval); if (njs_slow_path(ret == NJS_ERROR)) { return ret; } if (ret == NJS_OK) { idx = njs_string_to_index(&keys->start[k]) + length; ret = njs_value_property_i64_set(vm, &this, idx, &retval); if (njs_slow_path(ret == NJS_ERROR)) { njs_array_destroy(vm, keys); return ret; } } } njs_array_destroy(vm, keys); length += len; continue; } if (njs_slow_path((length + len) >= NJS_MAX_LENGTH)) { njs_type_error(vm, ""Invalid length""); return NJS_ERROR; } ret = njs_value_property_i64_set(vm, &this, length, e); if (njs_slow_path(ret == NJS_ERROR)) { return ret; } length++; } ret = njs_object_length_set(vm, &this, length); if (njs_slow_path(ret != NJS_OK)) { return NJS_ERROR; } vm->retval = this; return NJS_OK; }
Description: nginx njs 0.7.2 is vulnerable to Buffer Overflow. Type confused in Array.prototype.concat() when a slow array appended element is fast array.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void TabHelper::OnReenableComplete(int install_id, int return_route_id, ExtensionReenabler::ReenableResult result) { extension_reenabler_.reset(); webstore_install::Result webstore_result = webstore_install::SUCCESS; std::string error; switch (result) { case ExtensionReenabler::REENABLE_SUCCESS: break;      case ExtensionReenabler::USER_CANCELED: webstore_result = webstore_install::USER_CANCELLED; error = ""User canceled install.""; break; case ExtensionReenabler::NOT_ALLOWED: webstore_result = webstore_install::NOT_PERMITTED; error = ""Install not permitted.""; break; case ExtensionReenabler::ABORTED: webstore_result = webstore_install::ABORTED; error = ""Aborted due to tab closing.""; break; } OnInlineInstallComplete(install_id, return_route_id, result == ExtensionReenabler::REENABLE_SUCCESS, error, webstore_result); }
Description: The Chrome Web Store inline-installation implementation in the Extensions subsystem in Google Chrome before 52.0.2743.82 does not properly consider object lifetimes during progress observation, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted web site.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: MaybeHandle<JSArray> Fast_ArrayConcat(Isolate* isolate, Arguments* args) { if (!isolate->IsFastArrayConstructorPrototypeChainIntact()) { return MaybeHandle<JSArray>(); } int n_arguments = args->length(); int result_len = 0; { DisallowHeapAllocation no_gc; Object* array_proto = isolate->array_function()->prototype(); for (int i = 0; i < n_arguments; i++) { Object* arg = (*args)[i]; if (!arg->IsJSArray()) return MaybeHandle<JSArray>(); Handle<JSArray> array(JSArray::cast(arg), isolate); if (!array->HasFastElements()) return MaybeHandle<JSArray>(); PrototypeIterator iter(isolate, *array); if (iter.GetCurrent() != array_proto) return MaybeHandle<JSArray>(); if (HasConcatSpreadableModifier(isolate, array)) { return MaybeHandle<JSArray>(); } int len = Smi::cast(array->length())->value(); const int kHalfOfMaxInt = 1 << (kBitsPerInt - 2); STATIC_ASSERT(FixedArray::kMaxLength < kHalfOfMaxInt); USE(kHalfOfMaxInt); result_len += len; DCHECK(result_len >= 0); if (FixedArray::kMaxLength < result_len) { THROW_NEW_ERROR(isolate, NewRangeError(MessageTemplate::kInvalidArrayLength), JSArray); } } } return ElementsAccessor::Concat(isolate, args, n_arguments); }
Description: The Array.prototype.concat implementation in builtins.cc in Google V8, as used in Google Chrome before 49.0.2623.108, does not properly consider element data types, which allows remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via crafted JavaScript code.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int decomp_get_rddata(js_string *compressed, js_string *out, unsigned int compressed_offset, int type, int rdlength) { char *desc; int subtype, total, len; desc = decomp_get_rrdesc(type); if(desc == 0) {  if(rdlength == 0) { return JS_SUCCESS; } if(decomp_append_bytes(compressed,out,compressed_offset, rdlength) != JS_SUCCESS) { return JS_ERROR; } else { return JS_SUCCESS; } } else { subtype = *desc; total = 0; while(subtype != 0) { if(subtype > 0 && subtype < 64) { if(decomp_append_bytes(compressed,out, compressed_offset,subtype) != JS_SUCCESS) { return JS_ERROR; } total += subtype; compressed_offset += subtype; } else if(subtype == RRSUB_DLABEL) { len = decomp_append_dlabel(compressed,out, compressed_offset); if(len == JS_ERROR) { return JS_ERROR; } total += len; compressed_offset += len; } else if(subtype == RRSUB_TEXT) { len = *(compressed->string + compressed_offset); len += 1;  if(len < 0 || len > 256) { return JS_ERROR; } if(decomp_append_bytes(compressed,out, compressed_offset,len) != JS_SUCCESS) { return JS_ERROR; } total += len; compressed_offset += len; } else if(subtype == RRSUB_VARIABLE) { len = rdlength - total; if(len == 0) { break; } if(decomp_append_bytes(compressed,out, compressed_offset,len) != JS_SUCCESS) { return JS_ERROR; } total += len; compressed_offset += len; } else {  return JS_ERROR; } desc++; if(subtype != RRSUB_VARIABLE) subtype = *desc; else subtype = 0;  } if(rdlength != total) { return JS_ERROR; } } return JS_SUCCESS; }
Description: MaraDNS is open-source software that implements the Domain Name System (DNS). In version 3.5.0024 and prior, a remotely exploitable integer underflow vulnerability in the DNS packet decompression function allows an attacker to cause a Denial of Service by triggering an abnormal program termination.

The vulnerability exists in the `decomp_get_rddata` function within the `Decompress.c` file. When handling a DNS packet with an Answer RR of qtype 16 (TXT record) and any qclass, if the `rdlength` is smaller than `rdata`, the result of the line `Decompress.c:886` is a negative number `len = rdlength - total;`. This value is then passed to the `decomp_append_bytes` function without proper validation, causing the program to attempt to allocate a massive chunk of memory that is impossible to allocate. Consequently, the program exits with an error code of 64, causing a Denial of Service.

One proposed fix for this vulnerability is to patch `Decompress.c:887` by breaking `if(len <= 0)`, which has been incorporated in version 3.5.0036 via commit bab062bde40b2ae8a91eecd522e84d8b993bab58.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static cairo_surface_t * rsvg_filter_primitive_image_render_in (RsvgFilterPrimitive * self, RsvgFilterContext * context) { RsvgDrawingCtx *ctx; RsvgFilterPrimitiveImage *upself; RsvgNode *drawable; ctx = context->ctx; upself = (RsvgFilterPrimitiveImage *) self; if (!upself->href) return NULL; drawable = rsvg_defs_lookup (ctx->defs, upself->href->str); if (!drawable) return NULL; rsvg_current_state (ctx)->affine = context->paffine; return rsvg_get_surface_of_node (ctx, drawable, context->width, context->height); }
Description: librsvg before 2.40.12 allows context-dependent attackers to cause a denial of service (infinite loop, stack consumption, and application crash) via cyclic references in an SVG document.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void gf_filter_pid_detach_task(GF_FSTask *task) { u32 i, count; GF_Filter *filter = task->filter; GF_FilterPid *pid = task->pid->pid; GF_FilterPidInst *pidinst=NULL; GF_Filter *new_chain_input = task->udta; if (pid->filter->stream_reset_pending) { TASK_REQUEUE(task) return; } if (new_chain_input->in_pid_connection_pending) { TASK_REQUEUE(task) return; } count = pid->num_destinations; for (i=0; i<count; i++) { pidinst = gf_list_get(pid->destinations, i); if (pidinst->filter==filter) { break; } pidinst=NULL; } if (pidinst && gf_fq_count(pidinst->packets)) { Bool in_process = filter->in_process; filter->in_process = GF_FALSE; filter->in_force_flush = GF_TRUE; pidinst->force_flush = GF_TRUE; gf_filter_process_inline(filter); pidinst->force_flush = GF_FALSE; filter->in_force_flush = GF_FALSE; filter->in_process = in_process; TASK_REQUEUE(task) return; } assert(filter->freg->configure_pid); GF_LOG(GF_LOG_INFO, GF_LOG_FILTER, (""Filter %s pid %s detach from %s\n"", task->pid->pid->filter->name, task->pid->pid->name, task->filter->name)); assert(pid->filter->detach_pid_tasks_pending); safe_int_dec(&pid->filter->detach_pid_tasks_pending); if (!pidinst) { GF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, (""Trying to detach PID %s not present in filter %s inputs\n"",  pid->name, filter->name)); assert(!new_chain_input->swap_pidinst_src); new_chain_input->swap_needs_init = GF_FALSE; return; } if (pidinst->props) { assert(pidinst->props->reference_count); if (safe_int_dec(& pidinst->props->reference_count) == 0) { gf_mx_p(pidinst->pid->filter->tasks_mx); gf_list_del_item(pidinst->pid->properties, pidinst->props); gf_mx_v(pidinst->pid->filter->tasks_mx); gf_props_del(pidinst->props); } } pidinst->props = NULL; gf_mx_p(filter->tasks_mx); count = gf_fq_count(pidinst->packets); assert(count <= filter->pending_packets); safe_int_sub(&filter->pending_packets, (s32) count); gf_filter_pid_inst_reset(pidinst); pidinst->pid = NULL; gf_list_del_item(pid->destinations, pidinst); pid->num_destinations = gf_list_count(pid->destinations); gf_list_del_item(filter->input_pids, pidinst); filter->num_input_pids = gf_list_count(filter->input_pids); if (!filter->num_input_pids) filter->single_source = NULL; gf_mx_v(filter->tasks_mx); if (!filter->detached_pid_inst) { filter->detached_pid_inst = gf_list_new(); } if (gf_list_find(filter->detached_pid_inst, pidinst)<0) gf_list_add(filter->detached_pid_inst, pidinst); if (new_chain_input->swap_needs_init) { new_chain_input->swap_pidinst_dst = NULL; new_chain_input->swap_pidinst_src = NULL; new_chain_input->swap_needs_init = GF_FALSE; } assert(new_chain_input->detach_pid_tasks_pending); safe_int_dec(&new_chain_input->detach_pid_tasks_pending); }
Description: Denial of Service in GitHub repository gpac/gpac prior to 2.4.0.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void print_internal_information(struct html_feed_environ *henv) { int i; Str s; TextLineList *tl = newTextLineList(); s = Strnew_charp(""<internal>""); pushTextLine(tl, newTextLine(s, 0)); if (henv->title) { s = Strnew_m_charp(""<title_alt title=\"""", html_quote(henv->title), ""\"">"", NULL); pushTextLine(tl, newTextLine(s, 0)); } #if 0 if (form_max >= 0) { FormList *fp; for (i = 0; i <= form_max; i++) { fp = forms[i]; s = Sprintf(""<form_int fid=\""%d\"" action=\""%s\"" method=\""%s\"""", i, html_quote(fp->action->ptr), (fp->method == FORM_METHOD_POST) ? ""post"" : ((fp->method == FORM_METHOD_INTERNAL) ? ""internal"" : ""get"")); if (fp->target) Strcat(s, Sprintf("" target=\""%s\"""", html_quote(fp->target))); if (fp->enctype == FORM_ENCTYPE_MULTIPART) Strcat_charp(s, "" enctype=\""multipart/form-data\""""); #ifdef USE_M17N if (fp->charset) Strcat(s, Sprintf("" accept-charset=\""%s\"""", html_quote(fp->charset))); #endif Strcat_charp(s, "">""); pushTextLine(tl, newTextLine(s, 0)); } } #endif #ifdef MENU_SELECT if (n_select > 0) { FormSelectOptionItem *ip; for (i = 0; i < n_select; i++) { s = Sprintf(""<select_int selectnumber=%d>"", i); pushTextLine(tl, newTextLine(s, 0)); for (ip = select_option[i].first; ip; ip = ip->next) { s = Sprintf(""<option_int value=\""%s\"" label=\""%s\""%s>"", html_quote(ip->value ? ip->value->ptr : ip->label->ptr), html_quote(ip->label->ptr), ip->checked ? "" selected"" : """"); pushTextLine(tl, newTextLine(s, 0)); } s = Strnew_charp(""</select_int>""); pushTextLine(tl, newTextLine(s, 0)); } } #endif if (n_textarea > 0) { for (i = 0; i < n_textarea; i++) { s = Sprintf(""<textarea_int textareanumber=%d>"", i); pushTextLine(tl, newTextLine(s, 0)); s = Strnew_charp(html_quote(textarea_str[i]->ptr)); Strcat_charp(s, ""</textarea_int>""); pushTextLine(tl, newTextLine(s, 0)); } } s = Strnew_charp(""</internal>""); pushTextLine(tl, newTextLine(s, 0)); if (henv->buf) appendTextLineList(henv->buf, tl); else if (henv->f) { TextLineListItem *p; for (p = tl->first; p; p = p->next) fprintf(henv->f, ""%s\n"", Str_conv_to_halfdump(p->ptr->line)->ptr); } }
Description: An issue was discovered in the Tatsuya Kinoshita w3m fork before 0.5.3-33. w3m allows remote attackers to cause a denial of service (segmentation fault and crash) via a crafted HTML page.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int rewrite_packets(tcpedit_t *tcpedit, pcap_t *pin, pcap_dumper_t *pout) { tcpr_dir_t cache_result = TCPR_DIR_C2S;      struct pcap_pkthdr pkthdr, *pkthdr_ptr;      const u_char *pktconst = NULL;               u_char **pktdata = NULL; static u_char *pktdata_buff; static char *frag = NULL; COUNTER packetnum = 0; int rcode; #ifdef ENABLE_FRAGROUTE int frag_len, i, proto; #endif pkthdr_ptr = &pkthdr; if (pktdata_buff == NULL) pktdata_buff = (u_char *)safe_malloc(MAXPACKET); pktdata = &pktdata_buff; if (frag == NULL) frag = (char *)safe_malloc(MAXPACKET); while ((pktconst = pcap_next(pin, pkthdr_ptr)) != NULL) { packetnum++; dbgx(2, ""packet "" COUNTER_SPEC "" caplen %d"", packetnum, pkthdr.caplen); memcpy(*pktdata, pktconst, pkthdr.caplen); #ifdef ENABLE_VERBOSE if (options.verbose) tcpdump_print(&tcpdump, pkthdr_ptr, *pktdata); #endif if (options.cachedata != NULL) { cache_result = check_cache(options.cachedata, packetnum); } if (cache_result == TCPR_DIR_NOSEND) goto WRITE_PACKET;  if ((rcode = tcpedit_packet(tcpedit, &pkthdr_ptr, pktdata, cache_result)) == TCPEDIT_ERROR) { return -1; } else if ((rcode == TCPEDIT_SOFT_ERROR) && HAVE_OPT(SKIP_SOFT_ERRORS)) { dbgx(1, ""Packet "" COUNTER_SPEC "" is suppressed from being written due to soft errors"", packetnum); continue; } WRITE_PACKET: #ifdef ENABLE_FRAGROUTE if (options.frag_ctx == NULL) { pcap_dump((u_char *)pout, pkthdr_ptr, *pktdata); } else { proto = tcpedit_l3proto(tcpedit, AFTER_PROCESS, *pktdata, pkthdr_ptr->caplen); if ((proto ==  ETHERTYPE_IP || proto == ETHERTYPE_IP6) && ((options.fragroute_dir == FRAGROUTE_DIR_BOTH) || (cache_result == TCPR_DIR_C2S && options.fragroute_dir == FRAGROUTE_DIR_C2S) || (cache_result == TCPR_DIR_S2C && options.fragroute_dir == FRAGROUTE_DIR_S2C))) { if (fragroute_process(options.frag_ctx, *pktdata, pkthdr_ptr->caplen) < 0) errx(-1, ""Error processing packet via fragroute: %s"", options.frag_ctx->errbuf); i = 0; while ((frag_len = fragroute_getfragment(options.frag_ctx, &frag)) > 0) { dbgx(1, ""processing packet "" COUNTER_SPEC "" frag: %u (%d)"", packetnum, i++, frag_len); pkthdr_ptr->caplen = frag_len; pkthdr_ptr->len = frag_len; pcap_dump((u_char *)pout, pkthdr_ptr, (u_char *)frag); } } else { pcap_dump((u_char *)pout, pkthdr_ptr, *pktdata); } } #else pcap_dump((u_char *)pout, pkthdr_ptr, *pktdata); #endif }  return 0; }
Description: tcprewrite in tcpreplay before 4.1.2 allows remote attackers to cause a denial of service (segmentation fault) via a large frame, a related issue to CVE-2017-14266.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static ssize_t show_transport_handle(struct device *dev, struct device_attribute *attr, char *buf) { struct iscsi_internal *priv = dev_to_iscsi_internal(dev); return sprintf(buf, ""%llu\n"", (unsigned long long)iscsi_handle(priv->iscsi_transport)); }
Description: An issue was discovered in the Linux kernel through 5.11.3. A kernel pointer leak can be used to determine the address of the iscsi_transport structure. When an iSCSI transport is registered with the iSCSI subsystem, the transport's handle is available to unprivileged users via the sysfs file system, at /sys/class/iscsi_transport/$TRANSPORT_NAME/handle. When read, the show_transport_handle function (in drivers/scsi/scsi_transport_iscsi.c) is called, which leaks the handle. This handle is actually the pointer to an iscsi_transport struct in the kernel module's global variables.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool GIFInput::read_subimage_data() { GifColorType* colormap = NULL; if (m_gif_file->Image.ColorMap) {          colormap = m_gif_file->Image.ColorMap->Colors; } else if (m_gif_file->SColorMap) {          colormap = m_gif_file->SColorMap->Colors; } else { errorf(""Neither local nor global colormap present.""); return false; } if (m_subimage == 0 || m_previous_disposal_method == DISPOSE_BACKGROUND) { std::fill(m_canvas.begin(), m_canvas.end(), 0x00); } bool interlacing = m_spec.get_int_attribute(""gif:Interlacing"") != 0; int window_height = m_gif_file->Image.Height; int window_width  = m_gif_file->Image.Width; int window_top    = m_gif_file->Image.Top; int window_left   = m_gif_file->Image.Left; std::unique_ptr<unsigned char[]> fscanline(new unsigned char[window_width]); for (int wy = 0; wy < window_height; wy++) { if (DGifGetLine(m_gif_file, &fscanline[0], window_width) == GIF_ERROR) { report_last_error(); return false; } int y = window_top + (interlacing ? decode_line_number(wy, window_height) : wy); if (0 <= y && y < m_spec.height) { for (int wx = 0; wx < window_width; wx++) { int x   = window_left + wx; int idx = m_spec.nchannels * (y * m_spec.width + x); if (0 <= x && x < m_spec.width && fscanline[wx] != m_transparent_color) { m_canvas[idx]     = colormap[fscanline[wx]].Red; m_canvas[idx + 1] = colormap[fscanline[wx]].Green; m_canvas[idx + 2] = colormap[fscanline[wx]].Blue; m_canvas[idx + 3] = 0xff; } } } } return true; }
Description: Buffer Overflow vulnerability in OpenImageIO oiio v.2.4.12.0 allows a remote attacker to execute arbitrary code and cause a denial of service via the read_subimage_data function.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: MmsValue* MmsValue_decodeMmsData(uint8_t* buffer, int bufPos, int bufferLength, int* endBufPos) { MmsValue* value = NULL; int dataEndBufPos = bufPos + bufferLength; uint8_t tag = buffer[bufPos++]; int dataLength; bufPos = BerDecoder_decodeLength(buffer, &dataLength, bufPos, dataEndBufPos); if (bufPos < 0) goto exit_with_error; switch (tag) { case 0xa1:  case 0xa2:  { int elementCount = getNumberOfElements(buffer, bufPos, dataLength); if (elementCount < 0) goto exit_with_error; if (tag == 0xa1) value = MmsValue_createEmptyArray(elementCount); else value = MmsValue_createEmptyStructure(elementCount); int i; for (i = 0; i < elementCount; i++) { int elementLength; int newBufPos = BerDecoder_decodeLength(buffer, &elementLength, bufPos + 1, dataEndBufPos); if (newBufPos < 0) goto exit_with_error; if (newBufPos + elementLength > dataEndBufPos) goto exit_with_error; int elementBufLength = newBufPos - bufPos + elementLength; MmsValue* elementValue = MmsValue_decodeMmsData(buffer, bufPos, elementBufLength, NULL); if (elementValue == NULL) goto exit_with_error; MmsValue_setElement(value, i, elementValue); bufPos = newBufPos + elementLength; } if (value == NULL) goto exit_with_error; } break; case 0x80:  value = MmsValue_newDataAccessError((MmsDataAccessError) BerDecoder_decodeUint32(buffer, dataLength, bufPos)); bufPos += dataLength; break; case 0x83:  value = MmsValue_newBoolean(BerDecoder_decodeBoolean(buffer, bufPos)); bufPos += dataLength; break; case 0x84:  { int padding = buffer[bufPos]; int bitStringLength = (8 * (dataLength - 1)) - padding; value = MmsValue_newBitString(bitStringLength); memcpy(value->value.bitString.buf, buffer + bufPos + 1, dataLength - 1); bufPos += dataLength; } break; case 0x85:  if (dataLength > 8) goto exit_with_error; value = MmsValue_newInteger(dataLength * 8); memcpy(value->value.integer->octets, buffer + bufPos, dataLength); value->value.integer->size = dataLength; bufPos += dataLength; break; case 0x86:  if (dataLength > 8) goto exit_with_error; value = MmsValue_newUnsigned(dataLength * 8); memcpy(value->value.integer->octets, buffer + bufPos, dataLength); value->value.integer->size = dataLength; bufPos += dataLength; break; case 0x87:  if (dataLength == 9) value = MmsValue_newDouble(BerDecoder_decodeDouble(buffer, bufPos)); else if (dataLength == 5) value = MmsValue_newFloat(BerDecoder_decodeFloat(buffer, bufPos)); bufPos += dataLength; break; case 0x89:  value = MmsValue_newOctetString(dataLength, dataLength); memcpy(value->value.octetString.buf, buffer + bufPos, dataLength); bufPos += dataLength; break; case 0x8a:  value = MmsValue_newVisibleStringFromByteArray(buffer + bufPos, dataLength); bufPos += dataLength; break; case 0x8c:  if (dataLength == 4) value = MmsValue_newBinaryTime(true); else if (dataLength == 6) value = MmsValue_newBinaryTime(false); if ((dataLength == 4) || (dataLength == 6)) memcpy(value->value.binaryTime.buf, buffer + bufPos, dataLength); bufPos += dataLength; break; case 0x90:  value = MmsValue_newVisibleStringFromByteArray(buffer + bufPos, dataLength); value->type = MMS_STRING; bufPos += dataLength; break; case 0x91:  if (dataLength == 8) { value = MmsValue_newUtcTime(0); MmsValue_setUtcTimeByBuffer(value, buffer + bufPos); bufPos += dataLength; } else goto exit_with_error; break; default:  goto exit_with_error; } if (endBufPos != NULL) *endBufPos = bufPos; return value; exit_with_error: if (value != NULL) MmsValue_delete(value); return NULL; }
Description: MmsValue_decodeMmsData in mms/iso_mms/server/mms_access_result.c in libIEC61850 through 1.4.0 has a heap-based buffer overflow when parsing the MMS_BIT_STRING data type.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int decode_block(AVCodecContext *avctx, void *tdata, int jobnr, int threadnr) { EXRContext *s = avctx->priv_data; AVFrame *const p = s->picture; EXRThreadData *td = &s->thread_data[threadnr]; const uint8_t *channel_buffer[4] = { 0 }; const uint8_t *buf = s->buf; uint64_t line_offset, uncompressed_size; uint16_t *ptr_x; uint8_t *ptr; uint32_t data_size, line, col = 0; uint32_t tileX, tileY, tileLevelX, tileLevelY; const uint8_t *src; int axmax = (avctx->width - (s->xmax + 1)) * 2 * s->desc->nb_components;  int bxmin = s->xmin * 2 * s->desc->nb_components;  int i, x, buf_size = s->buf_size; float one_gamma = 1.0f / s->gamma; avpriv_trc_function trc_func = avpriv_get_trc_function_from_trc(s->apply_trc_type); int ret; line_offset = AV_RL64(s->gb.buffer + jobnr * 8); if (s->is_tile) { if (line_offset > buf_size - 20) return AVERROR_INVALIDDATA; src  = buf + line_offset + 20; tileX = AV_RL32(src - 20); tileY = AV_RL32(src - 16); tileLevelX = AV_RL32(src - 12); tileLevelY = AV_RL32(src - 8); data_size = AV_RL32(src - 4); if (data_size <= 0 || data_size > buf_size) return AVERROR_INVALIDDATA; if (tileLevelX || tileLevelY) {  avpriv_report_missing_feature(s->avctx, ""Subres tile before full res tile""); return AVERROR_PATCHWELCOME; } line = s->tile_attr.ySize * tileY; col = s->tile_attr.xSize * tileX; td->ysize = FFMIN(s->tile_attr.ySize, s->ydelta - tileY * s->tile_attr.ySize); td->xsize = FFMIN(s->tile_attr.xSize, s->xdelta - tileX * s->tile_attr.xSize); if (col) {  bxmin = 0;  } if ((col + td->xsize) != s->xdelta) axmax = 0;  td->channel_line_size = td->xsize * s->current_channel_offset; uncompressed_size = td->channel_line_size * (uint64_t)td->ysize; } else { if (line_offset > buf_size - 8) return AVERROR_INVALIDDATA; src  = buf + line_offset + 8; line = AV_RL32(src - 8); if (line < s->ymin || line > s->ymax) return AVERROR_INVALIDDATA; data_size = AV_RL32(src - 4); if (data_size <= 0 || data_size > buf_size) return AVERROR_INVALIDDATA; td->ysize          = FFMIN(s->scan_lines_per_block, s->ymax - line + 1);  td->xsize          = s->xdelta; td->channel_line_size = td->xsize * s->current_channel_offset; uncompressed_size = td->channel_line_size * (uint64_t)td->ysize; if ((s->compression == EXR_RAW && (data_size != uncompressed_size || line_offset > buf_size - uncompressed_size)) || (s->compression != EXR_RAW && (data_size > uncompressed_size || line_offset > buf_size - data_size))) { return AVERROR_INVALIDDATA; } } if (data_size < uncompressed_size || s->is_tile) {  av_fast_padded_malloc(&td->tmp, &td->tmp_size, uncompressed_size); if (!td->tmp) return AVERROR(ENOMEM); } if (data_size < uncompressed_size) { av_fast_padded_malloc(&td->uncompressed_data, &td->uncompressed_size, uncompressed_size); if (!td->uncompressed_data) return AVERROR(ENOMEM); ret = AVERROR_INVALIDDATA; switch (s->compression) { case EXR_ZIP1: case EXR_ZIP16: ret = zip_uncompress(src, data_size, uncompressed_size, td); break; case EXR_PIZ: ret = piz_uncompress(s, src, data_size, uncompressed_size, td); break; case EXR_PXR24: ret = pxr24_uncompress(s, src, data_size, uncompressed_size, td); break; case EXR_RLE: ret = rle_uncompress(src, data_size, uncompressed_size, td); break; case EXR_B44: case EXR_B44A: ret = b44_uncompress(s, src, data_size, uncompressed_size, td); break; } if (ret < 0) { av_log(avctx, AV_LOG_ERROR, ""decode_block() failed.\n""); return ret; } src = td->uncompressed_data; } channel_buffer[0] = src + td->xsize * s->channel_offsets[0]; channel_buffer[1] = src + td->xsize * s->channel_offsets[1]; channel_buffer[2] = src + td->xsize * s->channel_offsets[2]; if (s->channel_offsets[3] >= 0) channel_buffer[3] = src + td->xsize * s->channel_offsets[3]; ptr = p->data[0] + line * p->linesize[0] + (col * s->desc->nb_components * 2); for (i = 0; i < td->ysize; i++, ptr += p->linesize[0]) { const uint8_t *r, *g, *b, *a; r = channel_buffer[0]; g = channel_buffer[1]; b = channel_buffer[2]; if (channel_buffer[3]) a = channel_buffer[3]; ptr_x = (uint16_t *) ptr; memset(ptr_x, 0, bxmin); ptr_x += s->xmin * s->desc->nb_components; if (s->pixel_type == EXR_FLOAT) { if (trc_func) { for (x = 0; x < td->xsize; x++) { union av_intfloat32 t; t.i = bytestream_get_le32(&r); t.f = trc_func(t.f); *ptr_x++ = exr_flt2uint(t.i); t.i = bytestream_get_le32(&g); t.f = trc_func(t.f); *ptr_x++ = exr_flt2uint(t.i); t.i = bytestream_get_le32(&b); t.f = trc_func(t.f); *ptr_x++ = exr_flt2uint(t.i); if (channel_buffer[3]) *ptr_x++ = exr_flt2uint(bytestream_get_le32(&a)); } } else { for (x = 0; x < td->xsize; x++) { union av_intfloat32 t; t.i = bytestream_get_le32(&r); if (t.f > 0.0f)   t.f = powf(t.f, one_gamma); *ptr_x++ = exr_flt2uint(t.i); t.i = bytestream_get_le32(&g); if (t.f > 0.0f) t.f = powf(t.f, one_gamma); *ptr_x++ = exr_flt2uint(t.i); t.i = bytestream_get_le32(&b); if (t.f > 0.0f) t.f = powf(t.f, one_gamma); *ptr_x++ = exr_flt2uint(t.i); if (channel_buffer[3]) *ptr_x++ = exr_flt2uint(bytestream_get_le32(&a)); } } } else { for (x = 0; x < td->xsize; x++) { *ptr_x++ = s->gamma_table[bytestream_get_le16(&r)]; *ptr_x++ = s->gamma_table[bytestream_get_le16(&g)]; *ptr_x++ = s->gamma_table[bytestream_get_le16(&b)]; if (channel_buffer[3]) *ptr_x++ = exr_halflt2uint(bytestream_get_le16(&a)); } } memset(ptr_x, 0, axmax); channel_buffer[0] += td->channel_line_size; channel_buffer[1] += td->channel_line_size; channel_buffer[2] += td->channel_line_size; if (channel_buffer[3]) channel_buffer[3] += td->channel_line_size; } return 0; }
Description: Heap-based buffer overflow in the decode_block function in libavcodec/exr.c in FFmpeg before 3.1.3 allows remote attackers to cause a denial of service (application crash) via vectors involving tile positions.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void task_numa_free(struct task_struct *p) { struct numa_group *grp = p->numa_group; void *numa_faults = p->numa_faults; unsigned long flags; int i; if (grp) { spin_lock_irqsave(&grp->lock, flags); for (i = 0; i < NR_NUMA_HINT_FAULT_STATS * nr_node_ids; i++) grp->faults[i] -= p->numa_faults[i]; grp->total_faults -= p->total_numa_faults; grp->nr_tasks--; spin_unlock_irqrestore(&grp->lock, flags); RCU_INIT_POINTER(p->numa_group, NULL); put_numa_group(grp); } p->numa_faults = NULL; kfree(numa_faults); }
Description: An issue was discovered in the Linux kernel before 5.2.6. On NUMA systems, the Linux fair scheduler has a use-after-free in show_numa_stats() because NUMA fault statistics are inappropriately freed, aka CID-16d51a590a8c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool FrameLoader::prepareForCommit() { PluginScriptForbiddenScope forbidPluginDestructorScripting; RefPtrWillBeRawPtr<DocumentLoader> pdl = m_provisionalDocumentLoader; if (m_frame->document()) { unsigned totalNodeCount = InstanceCounters::counterValue(InstanceCounters::NodeCounter); int nodeCount = static_cast<int>(totalNodeCount); for (Document* document : Document::liveDocumentSet()) { if (document != m_frame->document()) nodeCount -= document->nodeCount(); } ASSERT(nodeCount >= 0); float ratio = static_cast<float>(nodeCount) / totalNodeCount; ThreadState::current()->schedulePageNavigationGCIfNeeded(ratio); } if (m_documentLoader) { client()->dispatchWillClose(); dispatchUnloadEvent(); } m_frame->detachChildren(); if (pdl != m_provisionalDocumentLoader) return false; if (m_documentLoader) { FrameNavigationDisabler navigationDisabler(*m_frame); detachDocumentLoader(m_documentLoader); } if (!m_frame->client()) return false; if (m_frame->document()) m_frame->document()->detach(); m_documentLoader = m_provisionalDocumentLoader.release(); return true; }
Description: The DOM implementation in Google Chrome before 48.0.2564.109 does not properly restrict frame-attach operations from occurring during or after frame-detach operations, which allows remote attackers to bypass the Same Origin Policy via a crafted web site, related to FrameLoader.cpp, HTMLFrameOwnerElement.h, LocalFrame.cpp, and WebLocalFrameImpl.cpp.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static ssize_t module_gzip_decompress(struct load_info *info, const void *buf, size_t size) { struct z_stream_s s = { 0 }; size_t new_size = 0; size_t gzip_hdr_len; ssize_t retval; int rc; gzip_hdr_len = module_gzip_header_len(buf, size); if (!gzip_hdr_len) { pr_err(""not a gzip compressed module\n""); return -EINVAL; } s.next_in = buf + gzip_hdr_len; s.avail_in = size - gzip_hdr_len; s.workspace = kmalloc(zlib_inflate_workspacesize(), GFP_KERNEL); if (!s.workspace) return -ENOMEM; rc = zlib_inflateInit2(&s, -MAX_WBITS); if (rc != Z_OK) { pr_err(""failed to initialize decompressor: %d\n"", rc); retval = -EINVAL; goto out; } do { struct page *page = module_get_next_page(info); if (!page) { retval = -ENOMEM; goto out_inflate_end; } s.next_out = kmap_local_page(page); s.avail_out = PAGE_SIZE; rc = zlib_inflate(&s, 0); kunmap_local(s.next_out); new_size += PAGE_SIZE - s.avail_out; } while (rc == Z_OK); if (rc != Z_STREAM_END) { pr_err(""decompression failed with status %d\n"", rc); retval = -EINVAL; goto out_inflate_end; } retval = new_size; out_inflate_end: zlib_inflateEnd(&s); out: kfree(s.workspace); return retval; }
Description: In the Linux kernel before 6.1.2, kernel/module/decompress.c misinterprets the module_get_next_page return value (expects it to be NULL in the error case, whereas it is actually an error pointer).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int iommu_do_dt_domctl(struct xen_domctl *domctl, struct domain *d, XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl) { int ret; struct dt_device_node *dev; switch ( domctl->cmd ) { case XEN_DOMCTL_assign_device: ASSERT(d); case XEN_DOMCTL_test_assign_device: ret = -ENODEV; if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_DT ) break; ret = -EINVAL; if ( (d && d->is_dying) || domctl->u.assign_device.flags ) break; ret = dt_find_node_by_gpath(domctl->u.assign_device.u.dt.path, domctl->u.assign_device.u.dt.size, &dev); if ( ret ) break; ret = xsm_assign_dtdevice(XSM_HOOK, d, dt_node_full_name(dev)); if ( ret ) break; if ( domctl->cmd == XEN_DOMCTL_test_assign_device ) { if ( iommu_dt_device_is_assigned(dev) ) { printk(XENLOG_G_ERR ""%s already assigned.\n"", dt_node_full_name(dev)); ret = -EINVAL; } break; } ret = iommu_add_dt_device(dev); if ( ret < 0 && ret != -EEXIST ) { printk(XENLOG_G_ERR ""Failed to add %s to the IOMMU\n"", dt_node_full_name(dev)); break; } ret = iommu_assign_dt_device(d, dev); if ( ret ) printk(XENLOG_G_ERR ""XEN_DOMCTL_assign_dt_device: assign \""%s\"""" "" to dom%u failed (%d)\n"", dt_node_full_name(dev), d->domain_id, ret); break; case XEN_DOMCTL_deassign_device: ret = -ENODEV; if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_DT ) break; ret = -EINVAL; if ( domctl->u.assign_device.flags ) break; ret = dt_find_node_by_gpath(domctl->u.assign_device.u.dt.path, domctl->u.assign_device.u.dt.size, &dev); if ( ret ) break; ret = xsm_deassign_dtdevice(XSM_HOOK, d, dt_node_full_name(dev)); ret = iommu_deassign_dt_device(d, dev); if ( ret ) printk(XENLOG_G_ERR ""XEN_DOMCTL_assign_dt_device: assign \""%s\"""" "" to dom%u failed (%d)\n"", dt_node_full_name(dev), d->domain_id, ret); break; default: ret = -ENOSYS; break; } return ret; }
Description: An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int snd_timer_user_open(struct inode *inode, struct file *file) { struct snd_timer_user *tu; int err; err = nonseekable_open(inode, file); if (err < 0) return err; tu = kzalloc(sizeof(*tu), GFP_KERNEL); if (tu == NULL) return -ENOMEM; spin_lock_init(&tu->qlock); init_waitqueue_head(&tu->qchange_sleep); mutex_init(&tu->tread_sem); tu->ticks = 1; tu->queue_size = 128; tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read), GFP_KERNEL); if (tu->queue == NULL) { kfree(tu); return -ENOMEM; } file->private_data = tu; return 0; }
Description: sound/core/timer.c in the Linux kernel before 4.4.1 uses an incorrect type of mutex, which allows local users to cause a denial of service (race condition, use-after-free, and system crash) via a crafted ioctl call.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static BOOL region16_simplify_bands(REGION16* region) { RECTANGLE_16* band1, *band2, *endPtr, *endBand, *tmp; int nbRects, finalNbRects; int bandItems, toMove; finalNbRects = nbRects = region16_n_rects(region); if (nbRects < 2) return TRUE; band1 = region16_rects_noconst(region); endPtr = band1 + nbRects; do { band2 = next_band(band1, endPtr, &bandItems); if (band2 == endPtr) break; if ((band1->bottom == band2->top) && band_match(band1, band2, endPtr)) { tmp = band1; while (tmp < band2) { tmp->bottom = band2->bottom; tmp++; } endBand = band2 + bandItems; toMove = (endPtr - endBand) * sizeof(RECTANGLE_16); if (toMove) MoveMemory(band2, endBand, toMove); finalNbRects -= bandItems; endPtr -= bandItems; } else { band1 = band2; } } while (TRUE); if (finalNbRects != nbRects) { int allocSize = sizeof(REGION16_DATA) + (finalNbRects * sizeof(RECTANGLE_16)); region->data = realloc(region->data, allocSize); if (!region->data) { region->data = &empty_region; return FALSE; } region->data->nbRects = finalNbRects; region->data->size = allocSize; } return TRUE; }
Description: libfreerdp/codec/region.c in FreeRDP through 1.1.x and 2.x through 2.0.0-rc4 has memory leaks because a supplied realloc pointer (i.e., the first argument to realloc) is also used for a realloc return value.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int fsmMkdir(const char *path, mode_t mode) { int rc = mkdir(path, (mode & 07777)); if (_fsm_debug) rpmlog(RPMLOG_DEBUG, "" %8s (%s, 0%04o) %s\n"", __func__, path, (unsigned)(mode & 07777), (rc < 0 ? strerror(errno) : """")); if (rc < 0)rc = RPMERR_MKDIR_FAILED; return rc; }
Description: It was found that the fix for CVE-2017-7500 and CVE-2017-7501 was incomplete: the check was only implemented for the parent directory of the file to be created. A local unprivileged user who owns another ancestor directory could potentially use this flaw to gain root privileges. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static char * lookup(char *sym, struct author_data *data) { static char buf[5]; if (STREQ(sym, ""user"")) { if (is_valid_name(data->id->username)) { return(tac_strdup(data->id->username)); } } if (STREQ(sym, ""name"")) { if (is_valid_name(data->id->NAS_name)) { return(tac_strdup(data->id->username)); } } if (STREQ(sym, ""ip"")) { return(tac_strdup(data->id->NAS_ip)); } if (STREQ(sym, ""port"")) { return(tac_strdup(data->id->NAS_port)); } if (STREQ(sym, ""address"")) { if (is_valid_name(data->id->NAC_address)) { return(tac_strdup(data->id->NAC_address)); } } if (STREQ(sym, ""priv"")) { snprintf(buf, sizeof(buf), ""%d"", data->id->priv_lvl); return(tac_strdup(buf)); } if (STREQ(sym, ""method"")) { snprintf(buf, sizeof(buf), ""%d"", data->authen_method); return(tac_strdup(buf)); } if (STREQ(sym, ""type"")) { snprintf(buf, sizeof(buf), ""%d"", data->authen_type); return(tac_strdup(buf)); } if (STREQ(sym, ""service"")) { snprintf(buf, sizeof(buf), ""%d"", data->service); return(tac_strdup(buf)); } if (STREQ(sym, ""status"")) { switch (data->status) { default: return(tac_strdup(""unknown"")); case AUTHOR_STATUS_PASS_ADD: case AUTHOR_STATUS_PASS_REPL: return(tac_strdup(""pass"")); case AUTHOR_STATUS_FAIL: return(tac_strdup(""fail"")); case AUTHOR_STATUS_ERROR: return(tac_strdup(""error"")); } } return(tac_strdup(""unknown"")); }
Description: A lack of input validation exists in tac_plus prior to commit 4fdf178 which, when pre or post auth commands are enabled, allows an attacker who can control the username, rem-addr, or NAC address sent to tac_plus to inject shell commands and gain remote code execution on the tac_plus server.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int handle_vmon(struct kvm_vcpu *vcpu) { int ret; gpa_t vmptr; struct page *page; struct vcpu_vmx *vmx = to_vmx(vcpu); const u64 VMXON_NEEDED_FEATURES = FEATURE_CONTROL_LOCKED | FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX; if (!kvm_read_cr4_bits(vcpu, X86_CR4_VMXE)) { kvm_queue_exception(vcpu, UD_VECTOR); return 1; } if (vmx->nested.vmxon) { nested_vmx_failValid(vcpu, VMXERR_VMXON_IN_VMX_ROOT_OPERATION); return kvm_skip_emulated_instruction(vcpu); } if ((vmx->msr_ia32_feature_control & VMXON_NEEDED_FEATURES) != VMXON_NEEDED_FEATURES) { kvm_inject_gp(vcpu, 0); return 1; } if (nested_vmx_get_vmptr(vcpu, &vmptr)) return 1; if (!PAGE_ALIGNED(vmptr) || (vmptr >> cpuid_maxphyaddr(vcpu))) { nested_vmx_failInvalid(vcpu); return kvm_skip_emulated_instruction(vcpu); } page = kvm_vcpu_gpa_to_page(vcpu, vmptr); if (is_error_page(page)) { nested_vmx_failInvalid(vcpu); return kvm_skip_emulated_instruction(vcpu); } if (*(u32 *)kmap(page) != VMCS12_REVISION) { kunmap(page); kvm_release_page_clean(page); nested_vmx_failInvalid(vcpu); return kvm_skip_emulated_instruction(vcpu); } kunmap(page); kvm_release_page_clean(page); vmx->nested.vmxon_ptr = vmptr; ret = enter_vmx_operation(vcpu); if (ret) return ret; nested_vmx_succeed(vcpu); return kvm_skip_emulated_instruction(vcpu); }
Description: In arch/x86/kvm/vmx.c in the Linux kernel before 4.17.2, when nested virtualization is used, local attackers could cause L1 KVM guests to VMEXIT, potentially allowing privilege escalations and denial of service attacks due to lack of checking of CPL.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Error HeifContext::interpret_heif_file() { m_all_images.clear(); m_top_level_images.clear(); m_primary_image.reset(); std::vector<heif_item_id> image_IDs = m_heif_file->get_item_IDs(); bool primary_is_grid = false; for (heif_item_id id : image_IDs) { auto infe_box = m_heif_file->get_infe_box(id); if (!infe_box) { continue; } if (item_type_is_image(infe_box->get_item_type())) { auto image = std::make_shared<Image>(this, id); m_all_images.insert(std::make_pair(id, image)); if (!infe_box->is_hidden_item()) { if (id==m_heif_file->get_primary_image_ID()) { image->set_primary(true); m_primary_image = image; primary_is_grid = infe_box->get_item_type() == ""grid""; } m_top_level_images.push_back(image); } } } if (!m_primary_image) { return Error(heif_error_Invalid_input, heif_suberror_Nonexisting_item_referenced, ""'pitm' box references a non-existing image""); } auto iref_box = m_heif_file->get_iref_box(); if (iref_box) { for (auto& pair : m_all_images) { auto& image = pair.second; std::vector<Box_iref::Reference> references = iref_box->get_references_from(image->get_id()); for (const Box_iref::Reference& ref : references) { uint32_t type = ref.header.get_short_type(); if (type==fourcc(""thmb"")) { std::vector<heif_item_id> refs = ref.to_item_ID; if (refs.size() != 1) { return Error(heif_error_Invalid_input, heif_suberror_Unspecified, ""Too many thumbnail references""); } image->set_is_thumbnail_of(refs[0]); auto master_iter = m_all_images.find(refs[0]); if (master_iter == m_all_images.end()) { return Error(heif_error_Invalid_input, heif_suberror_Nonexisting_item_referenced, ""Thumbnail references a non-existing image""); } if (master_iter->second->is_thumbnail()) { return Error(heif_error_Invalid_input, heif_suberror_Nonexisting_item_referenced, ""Thumbnail references another thumbnail""); } if (image.get() == master_iter->second.get()) { return Error(heif_error_Invalid_input, heif_suberror_Nonexisting_item_referenced, ""Recursive thumbnail image detected""); } master_iter->second->add_thumbnail(image); remove_top_level_image(image); } else if (type==fourcc(""auxl"")) { std::vector<Box_ipco::Property> properties; Error err = m_heif_file->get_properties(image->get_id(), properties); if (err) { return err; } std::shared_ptr<Box_auxC> auxC_property; for (const auto& property : properties) { auto auxC = std::dynamic_pointer_cast<Box_auxC>(property.property); if (auxC) { auxC_property = auxC; } } if (!auxC_property) { std::stringstream sstr; sstr << ""No auxC property for image "" << image->get_id(); return Error(heif_error_Invalid_input, heif_suberror_Auxiliary_image_type_unspecified, sstr.str()); } std::vector<heif_item_id> refs = ref.to_item_ID; if (refs.size() != 1) { return Error(heif_error_Invalid_input, heif_suberror_Unspecified, ""Too many auxiliary image references""); } if (auxC_property->get_aux_type() == ""urn:mpeg:avc:2015:auxid:1"" || auxC_property->get_aux_type() == ""urn:mpeg:hevc:2015:auxid:1"") { image->set_is_alpha_channel_of(refs[0]); auto master_iter = m_all_images.find(refs[0]); if (image.get() == master_iter->second.get()) { return Error(heif_error_Invalid_input, heif_suberror_Nonexisting_item_referenced, ""Recursive alpha image detected""); } master_iter->second->set_alpha_channel(image); } if (auxC_property->get_aux_type() == ""urn:mpeg:hevc:2015:auxid:2"") { image->set_is_depth_channel_of(refs[0]); auto master_iter = m_all_images.find(refs[0]); if (image.get() == master_iter->second.get()) { return Error(heif_error_Invalid_input, heif_suberror_Nonexisting_item_referenced, ""Recursive depth image detected""); } master_iter->second->set_depth_channel(image); auto subtypes = auxC_property->get_subtypes(); std::vector<std::shared_ptr<SEIMessage>> sei_messages; Error err = decode_hevc_aux_sei_messages(subtypes, sei_messages); for (auto& msg : sei_messages) { auto depth_msg = std::dynamic_pointer_cast<SEIMessage_depth_representation_info>(msg); if (depth_msg) { image->set_depth_representation_info(*depth_msg); } } } remove_top_level_image(image); } else { } } } } for (auto& pair : m_all_images) { auto& image = pair.second; std::shared_ptr<Box_infe> infe = m_heif_file->get_infe_box(image->get_id()); if (infe->get_item_type() == ""hvc1"") { auto ipma = m_heif_file->get_ipma_box(); auto ipco = m_heif_file->get_ipco_box(); if (!ipco->get_property_for_item_ID(image->get_id(), ipma, fourcc(""hvcC""))) { return Error(heif_error_Invalid_input, heif_suberror_No_hvcC_box, ""No hvcC property in hvc1 type image""); } } } for (auto& pair : m_all_images) { auto& image = pair.second; std::vector<Box_ipco::Property> properties; Error err = m_heif_file->get_properties(pair.first, properties); if (err) { return err; } bool ispe_read = false; bool primary_colr_set = false; for (const auto& prop : properties) { auto ispe = std::dynamic_pointer_cast<Box_ispe>(prop.property); if (ispe) { uint32_t width = ispe->get_width(); uint32_t height = ispe->get_height(); if (width  >= static_cast<uint32_t>(MAX_IMAGE_WIDTH) || height >= static_cast<uint32_t>(MAX_IMAGE_HEIGHT)) { std::stringstream sstr; sstr << ""Image size "" << width << ""x"" << height << "" exceeds the maximum image size "" << MAX_IMAGE_WIDTH << ""x"" << MAX_IMAGE_HEIGHT << ""\n""; return Error(heif_error_Memory_allocation_error, heif_suberror_Security_limit_exceeded, sstr.str()); } image->set_resolution(width, height); image->set_ispe_resolution(width, height); ispe_read = true; } if (ispe_read) { auto clap = std::dynamic_pointer_cast<Box_clap>(prop.property); if (clap) { image->set_resolution( clap->get_width_rounded(), clap->get_height_rounded() ); } auto irot = std::dynamic_pointer_cast<Box_irot>(prop.property); if (irot) { if (irot->get_rotation()==90 || irot->get_rotation()==270) { image->set_resolution( image->get_height(), image->get_width() ); } } } auto colr = std::dynamic_pointer_cast<Box_colr>(prop.property); if (colr) { auto profile = colr->get_color_profile(); image->set_color_profile(profile); const bool is_grid_item = !image->is_primary() && !image->is_alpha_channel() && !image->is_depth_channel(); if (primary_is_grid && !primary_colr_set && is_grid_item) { m_primary_image->set_color_profile(profile); primary_colr_set = true; } } } } for (heif_item_id id : image_IDs) { std::string item_type    = m_heif_file->get_item_type(id); std::string content_type = m_heif_file->get_content_type(id); if (item_type == ""Exif"" || (item_type==""mime"" && content_type==""application/rdf+xml"")) { std::shared_ptr<ImageMetadata> metadata = std::make_shared<ImageMetadata>(); metadata->item_id = id; metadata->item_type = item_type; metadata->content_type = content_type; Error err = m_heif_file->get_compressed_image_data(id, &(metadata->m_data)); if (err) { return err; } if (iref_box) { std::vector<Box_iref::Reference> references = iref_box->get_references_from(id); for (const auto& ref : references) { if (ref.header.get_short_type() == fourcc(""cdsc"")) { std::vector<uint32_t> refs = ref.to_item_ID; if (refs.size() != 1) { return Error(heif_error_Invalid_input, heif_suberror_Unspecified, ""Exif data not correctly assigned to image""); } uint32_t exif_image_id = refs[0]; auto img_iter = m_all_images.find(exif_image_id); if (img_iter == m_all_images.end()) { return Error(heif_error_Invalid_input, heif_suberror_Nonexisting_item_referenced, ""Exif data assigned to non-existing image""); } img_iter->second->add_metadata(metadata); } } } } } return Error::Ok; }
Description: libheif 1.4.0 has a use-after-free in heif::HeifContext::Image::set_alpha_channel in heif_context.h because heif_context.cc mishandles references to non-existing alpha images.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: de265_error read_scaling_list(bitreader* br, const seq_parameter_set* sps, scaling_list_data* sclist, bool inPPS) { int dc_coeff[4][6]; for (int sizeId=0;sizeId<4;sizeId++) { uint8_t scaling_list[6][32*32]; for (int matrixId=0 ; matrixId<6 ; matrixId += (sizeId==3 ? 3 : 1)) { uint8_t* curr_scaling_list = scaling_list[matrixId]; int scaling_list_dc_coef; int canonicalMatrixId = matrixId; if (sizeId==3 && matrixId==1) { canonicalMatrixId=3; } char scaling_list_pred_mode_flag = get_bits(br,1); if (!scaling_list_pred_mode_flag) { int scaling_list_pred_matrix_id_delta = get_uvlc(br); if (scaling_list_pred_matrix_id_delta == UVLC_ERROR || scaling_list_pred_matrix_id_delta > matrixId) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; } dc_coeff[sizeId][matrixId] = 16; scaling_list_dc_coef       = 16; if (scaling_list_pred_matrix_id_delta==0) { if (sizeId==0) { memcpy(curr_scaling_list, default_ScalingList_4x4, 16); } else { if (canonicalMatrixId<3) { memcpy(curr_scaling_list, default_ScalingList_8x8_intra,64); } else { memcpy(curr_scaling_list, default_ScalingList_8x8_inter,64); } } } else { if (sizeId==3) { assert(scaling_list_pred_matrix_id_delta==1); } int mID = matrixId - scaling_list_pred_matrix_id_delta; int len = (sizeId == 0 ? 16 : 64); memcpy(curr_scaling_list, scaling_list[mID], len); scaling_list_dc_coef       = dc_coeff[sizeId][mID]; dc_coeff[sizeId][matrixId] = dc_coeff[sizeId][mID]; } } else { int nextCoef=8; int coefNum = (sizeId==0 ? 16 : 64); if (sizeId>1) { scaling_list_dc_coef = get_svlc(br); if (scaling_list_dc_coef < -7 || scaling_list_dc_coef > 247) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; } scaling_list_dc_coef += 8; nextCoef=scaling_list_dc_coef; dc_coeff[sizeId][matrixId] = scaling_list_dc_coef; } else { scaling_list_dc_coef = 16; } for (int i=0;i<coefNum;i++) { int scaling_list_delta_coef = get_svlc(br); if (scaling_list_delta_coef < -128 || scaling_list_delta_coef >  127) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; } nextCoef = (nextCoef + scaling_list_delta_coef + 256) % 256; curr_scaling_list[i] = nextCoef; } } switch (sizeId) { case 0: fill_scaling_factor(&sclist->ScalingFactor_Size0[matrixId][0][0], curr_scaling_list, 0); break; case 1: fill_scaling_factor(&sclist->ScalingFactor_Size1[matrixId][0][0], curr_scaling_list, 1); break; case 2: fill_scaling_factor(&sclist->ScalingFactor_Size2[matrixId][0][0], curr_scaling_list, 2); sclist->ScalingFactor_Size2[matrixId][0][0] = scaling_list_dc_coef; break; case 3: fill_scaling_factor(&sclist->ScalingFactor_Size3[matrixId][0][0], curr_scaling_list, 3); sclist->ScalingFactor_Size3[matrixId][0][0] = scaling_list_dc_coef; break; } } } const position* scan = get_scan_order(3, 0 ); for (int matrixId=0;matrixId<6;matrixId++) if (matrixId!=0 && matrixId!=3) { for (int i=0;i<64;i++) { int x = scan[i].x; int y = scan[i].y; int v = sclist->ScalingFactor_Size1[matrixId][y][x]; for (int dy=0;dy<4;dy++) for (int dx=0;dx<4;dx++) { sclist->ScalingFactor_Size3[matrixId][4*y+dy][4*x+dx] = v; } } sclist->ScalingFactor_Size3[matrixId][0][0] = sclist->ScalingFactor_Size1[matrixId][0][0]; } return DE265_OK; }
Description: There is an Assertion `scaling_list_pred_matrix_id_delta==1' failed at sps.cc:925 in libde265 v1.0.8 when decoding file, which allows attackers to cause a Denial of Service (DoS) by running the application with a crafted file or possibly have unspecified other impact.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int nfc_disable_se(struct nfc_dev *dev, u32 se_idx) { struct nfc_se *se; int rc; pr_debug(""%s se index %d\n"", dev_name(&dev->dev), se_idx); device_lock(&dev->dev); if (!device_is_registered(&dev->dev)) { rc = -ENODEV; goto error; } if (!dev->dev_up) { rc = -ENODEV; goto error; } if (!dev->ops->enable_se || !dev->ops->disable_se) { rc = -EOPNOTSUPP; goto error; } se = nfc_find_se(dev, se_idx); if (!se) { rc = -EINVAL; goto error; } if (se->state == NFC_SE_DISABLED) { rc = -EALREADY; goto error; } rc = dev->ops->disable_se(dev, se_idx); if (rc >= 0) se->state = NFC_SE_DISABLED; error: device_unlock(&dev->dev); return rc; }
Description: A use-after-free flaw was found in the Linux kernel's NFC core functionality due to a race condition between kobject creation and delete. This vulnerability allows a local attacker with CAP_NET_ADMIN privilege to leak kernel information.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void process_add_smartcard_key(SocketEntry *e) { char *provider = NULL, *pin = NULL, canonical_provider[PATH_MAX]; char **comments = NULL; int r, i, count = 0, success = 0, confirm = 0; u_int seconds = 0; time_t death = 0; struct sshkey **keys = NULL, *k; Identity *id; struct dest_constraint *dest_constraints = NULL; size_t ndest_constraints = 0; debug2_f(""entering""); if ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 || (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0) { error_fr(r, ""parse""); goto send; } if (parse_key_constraints(e->request, NULL, &death, &seconds, &confirm, NULL, &dest_constraints, &ndest_constraints) != 0) { error_f(""failed to parse constraints""); goto send; } if (realpath(provider, canonical_provider) == NULL) { verbose(""failed PKCS#11 add of \""%.100s\"": realpath: %s"", provider, strerror(errno)); goto send; } if (match_pattern_list(canonical_provider, allowed_providers, 0) != 1) { verbose(""refusing PKCS#11 add of \""%.100s\"": "" ""provider not allowed"", canonical_provider); goto send; } debug_f(""add %.100s"", canonical_provider); if (lifetime && !death) death = monotime() + lifetime; count = pkcs11_add_provider(canonical_provider, pin, &keys, &comments); for (i = 0; i < count; i++) { k = keys[i]; if (lookup_identity(k) == NULL) { id = xcalloc(1, sizeof(Identity)); id->key = k; keys[i] = NULL;  id->provider = xstrdup(canonical_provider); if (*comments[i] != '\0') { id->comment = comments[i]; comments[i] = NULL;  } else { id->comment = xstrdup(canonical_provider); } id->death = death; id->confirm = confirm; id->dest_constraints = dest_constraints; id->ndest_constraints = ndest_constraints; dest_constraints = NULL;  ndest_constraints = 0; TAILQ_INSERT_TAIL(&idtab->idlist, id, next); idtab->nentries++; success = 1; } sshkey_free(keys[i]); free(comments[i]); } send: free(pin); free(provider); free(keys); free(comments); free_dest_constraints(dest_constraints, ndest_constraints); send_status(e, success); }
Description: The PKCS#11 feature in ssh-agent in OpenSSH before 9.3p2 has an insufficiently trustworthy search path, leading to remote code execution if an agent is forwarded to an attacker-controlled system. (Code in /usr/lib is not necessarily safe for loading into ssh-agent.) NOTE: this issue exists because of an incomplete fix for CVE-2016-10009.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static const char *fuse_get_link(struct dentry *dentry, struct inode *inode, struct delayed_call *callback) { struct fuse_conn *fc = get_fuse_conn(inode); struct page *page; int err; err = -EIO; if (is_bad_inode(inode)) goto out_err; if (fc->cache_symlinks) return page_get_link(dentry, inode, callback); err = -ECHILD; if (!dentry) goto out_err; page = alloc_page(GFP_KERNEL); err = -ENOMEM; if (!page) goto out_err; err = fuse_readlink_page(inode, page); if (err) { __free_page(page); goto out_err; } set_delayed_call(callback, page_put_link, page); return page_address(page); out_err: return ERR_PTR(err); }
Description: An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: char_u * compile_redir(char_u *line, exarg_T *eap, cctx_T *cctx) { char_u  *arg = eap->arg; lhs_T   *lhs = &cctx->ctx_redir_lhs; if (lhs->lhs_name != NULL) { if (STRNCMP(arg, ""END"", 3) == 0) { if (lhs->lhs_append) { if (compile_load_lhs_with_index(lhs, lhs->lhs_whole, cctx) == FAIL) return NULL; } generate_instr_type(cctx, ISN_REDIREND, &t_string); if (lhs->lhs_append) generate_CONCAT(cctx, 2); if (lhs->lhs_has_index) { if (compile_assign_unlet(lhs->lhs_whole, lhs, TRUE, &t_string, cctx) == FAIL) return NULL; } else if (generate_store_lhs(cctx, lhs, -1, FALSE) == FAIL) return NULL; VIM_CLEAR(lhs->lhs_name); VIM_CLEAR(lhs->lhs_whole); return arg + 3; } emsg(_(e_cannot_nest_redir)); return NULL; } if (arg[0] == '=' && arg[1] == '>') { int    append = FALSE; arg += 2; if (*arg == '>') { ++arg; append = TRUE; } arg = skipwhite(arg); if (compile_assign_lhs(arg, lhs, CMD_redir, FALSE, FALSE, FALSE, 1, cctx) == FAIL) return NULL; if (need_type(&t_string, lhs->lhs_member_type, -1, 0, cctx, FALSE, FALSE) == FAIL) return NULL; generate_instr(cctx, ISN_REDIRSTART); lhs->lhs_append = append; if (lhs->lhs_has_index) { lhs->lhs_whole = vim_strnsave(arg, lhs->lhs_varlen_total); if (lhs->lhs_whole == NULL) return NULL; } return arg + lhs->lhs_varlen_total; } return compile_exec(line, eap, cctx); }
Description: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.0742.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void mp4_report(GF_SceneLoader *load, GF_Err e, char *format, ...) { #ifndef GPAC_DISABLE_LOG if (gf_log_tool_level_on(GF_LOG_PARSER, e ? GF_LOG_ERROR : GF_LOG_WARNING)) { char szMsg[1024]; va_list args; va_start(args, format); vsprintf(szMsg, format, args); va_end(args); GF_LOG((u32) (e ? GF_LOG_ERROR : GF_LOG_WARNING), GF_LOG_PARSER, (""[MP4 Loading] %s\n"", szMsg) ); } #endif }
Description: GPAC 0.7.1 has a buffer overflow issue in gf_import_message() in media_import.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: GF_Err abst_box_read(GF_Box *s, GF_BitStream *bs) { GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s; int i; u32 tmp_strsize; char *tmp_str; GF_Err e; ISOM_DECREASE_SIZE(ptr, 25) ptr->bootstrapinfo_version = gf_bs_read_u32(bs); ptr->profile = gf_bs_read_int(bs, 2); ptr->live = gf_bs_read_int(bs, 1); ptr->update = gf_bs_read_int(bs, 1); ptr->reserved = gf_bs_read_int(bs, 4); ptr->time_scale = gf_bs_read_u32(bs); ptr->current_media_time = gf_bs_read_u64(bs); ptr->smpte_time_code_offset = gf_bs_read_u64(bs); i=0; if (ptr->size<8) return GF_ISOM_INVALID_FILE; tmp_strsize =(u32)ptr->size-8; tmp_str = gf_malloc(sizeof(char)*tmp_strsize); if (!tmp_str) return GF_OUT_OF_MEM; memset(tmp_str, 0, sizeof(char)*tmp_strsize); while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) { ptr->movie_identifier = gf_strdup(tmp_str); } ISOM_DECREASE_SIZE(ptr, 1) ptr->server_entry_count = gf_bs_read_u8(bs); for (i=0; i<ptr->server_entry_count; i++) { int j=0; tmp_strsize=(u32)ptr->size; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[j] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[j]) break; j++; } if (j) { gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i); } } ISOM_DECREASE_SIZE(ptr, 1) ptr->quality_entry_count = gf_bs_read_u8(bs); for (i=0; i<ptr->quality_entry_count; i++) { int j=0; tmp_strsize=(u32)ptr->size; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[j] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[j]) break; j++; } if (j) { gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i); } } i=0; tmp_strsize=(u32)ptr->size; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) { ptr->drm_data = gf_strdup(tmp_str); } i=0; tmp_strsize=(u32)ptr->size; while (tmp_strsize) { ISOM_DECREASE_SIZE(ptr, 1) tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) { ptr->meta_data = gf_strdup(tmp_str); } ISOM_DECREASE_SIZE(ptr, 1) ptr->segment_run_table_count = gf_bs_read_u8(bs); for (i=0; i<ptr->segment_run_table_count; i++) { GF_AdobeSegmentRunTableBox *asrt = NULL; e = gf_isom_box_parse((GF_Box **)&asrt, bs); if (e) { if (asrt) gf_isom_box_del((GF_Box*)asrt); gf_free(tmp_str); return e; } gf_list_add(ptr->segment_run_table_entries, asrt); } ISOM_DECREASE_SIZE(ptr, 1) ptr->fragment_run_table_count = gf_bs_read_u8(bs); for (i=0; i<ptr->fragment_run_table_count; i++) { GF_AdobeFragmentRunTableBox *afrt = NULL; e = gf_isom_box_parse((GF_Box **)&afrt, bs); if (e) { if (afrt) gf_isom_box_del((GF_Box*)afrt); gf_free(tmp_str); return e; } gf_list_add(ptr->fragment_run_table_entries, afrt); } gf_free(tmp_str); return GF_OK; }
Description: An issue was discovered in gpac before 1.0.1. The abst_box_read function in box_code_adobe.c has a heap-based buffer over-read.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static VALUE read_memory(VALUE klass, VALUE content) { xmlSchemaPtr schema; xmlSchemaParserCtxtPtr ctx = xmlSchemaNewMemParserCtxt( (const char *)StringValuePtr(content), (int)RSTRING_LEN(content) ); VALUE rb_schema; VALUE errors = rb_ary_new(); xmlSetStructuredErrorFunc((void *)errors, Nokogiri_error_array_pusher); #ifdef HAVE_XMLSCHEMASETPARSERSTRUCTUREDERRORS xmlSchemaSetParserStructuredErrors( ctx, Nokogiri_error_array_pusher, (void *)errors ); #endif schema = xmlSchemaParse(ctx); xmlSetStructuredErrorFunc(NULL, NULL); xmlSchemaFreeParserCtxt(ctx); if(NULL == schema) { xmlErrorPtr error = xmlGetLastError(); if(error) Nokogiri_error_raise(NULL, error); else rb_raise(rb_eRuntimeError, ""Could not parse document""); return Qnil; } rb_schema = Data_Wrap_Struct(klass, 0, dealloc, schema); rb_iv_set(rb_schema, ""@errors"", errors); return rb_schema; }
Description: Nokogiri is a Rubygem providing HTML, XML, SAX, and Reader parsers with XPath and CSS selector support. In Nokogiri before version 1.11.0.rc4 there is an XXE vulnerability. XML Schemas parsed by Nokogiri::XML::Schema are trusted by default, allowing external resources to be accessed over the network, potentially enabling XXE or SSRF attacks. This behavior is counter to the security policy followed by Nokogiri maintainers, which is to treat all input as untrusted by default whenever possible. This is fixed in Nokogiri version 1.11.0.rc4.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int z2restore(i_ctx_t *i_ctx_p) { os_ptr op = osp; check_type(*op, t_save); while (gs_gstate_saved(gs_gstate_saved(igs))) { if (restore_page_device(igs, gs_gstate_saved(igs))) return push_callout(i_ctx_p, ""%restore1pagedevice""); gs_grestore(igs); } if (restore_page_device(igs, gs_gstate_saved(igs))) return push_callout(i_ctx_p, ""%restorepagedevice""); return zrestore(i_ctx_p); }
Description: It was found that RHSA-2018:2918 did not fully fix CVE-2018-16509. An attacker could possibly exploit another variant of the flaw and bypass the -dSAFER protection to, for example, execute arbitrary shell commands via a specially crafted PostScript document. This only affects ghostscript 9.07 as shipped with Red Hat Enterprise Linux 7.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int redisAeAttach(aeEventLoop *loop, redisAsyncContext *ac) { redisContext *c = &(ac->c); redisAeEvents *e; if (ac->ev.data != NULL) return REDIS_ERR; e = (redisAeEvents*)malloc(sizeof(*e)); e->context = ac; e->loop = loop; e->fd = c->fd; e->reading = e->writing = 0; ac->ev.addRead = redisAeAddRead; ac->ev.delRead = redisAeDelRead; ac->ev.addWrite = redisAeAddWrite; ac->ev.delWrite = redisAeDelWrite; ac->ev.cleanup = redisAeCleanup; ac->ev.data = e; return REDIS_OK; }
Description: async.c and dict.c in libhiredis.a in hiredis through 0.14.0 allow a NULL pointer dereference because malloc return values are unchecked.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int nfc_genl_llc_set_params(struct sk_buff *skb, struct genl_info *info) { struct nfc_dev *dev; struct nfc_llcp_local *local; u8 rw = 0; u16 miux = 0; u32 idx; int rc = 0; if (!info->attrs[NFC_ATTR_DEVICE_INDEX] || (!info->attrs[NFC_ATTR_LLC_PARAM_LTO] && !info->attrs[NFC_ATTR_LLC_PARAM_RW] && !info->attrs[NFC_ATTR_LLC_PARAM_MIUX])) return -EINVAL; if (info->attrs[NFC_ATTR_LLC_PARAM_RW]) { rw = nla_get_u8(info->attrs[NFC_ATTR_LLC_PARAM_RW]); if (rw > LLCP_MAX_RW) return -EINVAL; } if (info->attrs[NFC_ATTR_LLC_PARAM_MIUX]) { miux = nla_get_u16(info->attrs[NFC_ATTR_LLC_PARAM_MIUX]); if (miux > LLCP_MAX_MIUX) return -EINVAL; } idx = nla_get_u32(info->attrs[NFC_ATTR_DEVICE_INDEX]); dev = nfc_get_device(idx); if (!dev) return -ENODEV; device_lock(&dev->dev); local = nfc_llcp_find_local(dev); if (!local) { rc = -ENODEV; goto exit; } if (info->attrs[NFC_ATTR_LLC_PARAM_LTO]) { if (dev->dep_link_up) { rc = -EINPROGRESS; goto exit; } local->lto = nla_get_u8(info->attrs[NFC_ATTR_LLC_PARAM_LTO]); } if (info->attrs[NFC_ATTR_LLC_PARAM_RW]) local->rw = rw; if (info->attrs[NFC_ATTR_LLC_PARAM_MIUX]) local->miux = cpu_to_be16(miux); exit: device_unlock(&dev->dev); nfc_put_device(dev); return rc; }
Description: A use-after-free flaw was found in nfc_llcp_find_local in net/nfc/llcp_core.c in NFC in the Linux kernel. This flaw allows a local user with special privileges to impact a kernel information leak issue.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static struct sock *unix_create1(struct net *net, struct socket *sock, int kern) { struct sock *sk = NULL; struct unix_sock *u; atomic_long_inc(&unix_nr_socks); if (atomic_long_read(&unix_nr_socks) > 2 * get_max_files()) goto out; sk = sk_alloc(net, PF_UNIX, GFP_KERNEL, &unix_proto, kern); if (!sk) goto out; sock_init_data(sock, sk); lockdep_set_class(&sk->sk_receive_queue.lock, &af_unix_sk_receive_queue_lock_key); sk->sk_write_space= unix_write_space; sk->sk_max_ack_backlog= net->unx.sysctl_max_dgram_qlen; sk->sk_destruct= unix_sock_destructor; u  = unix_sk(sk); u->path.dentry = NULL; u->path.mnt = NULL; spin_lock_init(&u->lock); atomic_long_set(&u->inflight, 0); INIT_LIST_HEAD(&u->link); mutex_init(&u->readlock);  init_waitqueue_head(&u->peer_wait); unix_insert_socket(unix_sockets_unbound(sk), sk); out: if (sk == NULL) atomic_long_dec(&unix_nr_socks); else { local_bh_disable(); sock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1); local_bh_enable(); } return sk; }
Description: Use-after-free vulnerability in net/unix/af_unix.c in the Linux kernel before 4.3.3 allows local users to bypass intended AF_UNIX socket permissions or cause a denial of service (panic) via crafted epoll_ctl calls.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static inline char *parse_ip_address_ex(const char *str, size_t str_len, int *portno, int get_err, zend_string **err) { char *colon; char *host = NULL; #ifdef HAVE_IPV6 char *p; if (*(str) == '[' && str_len > 1) { p = memchr(str + 1, ']', str_len - 2); if (!p || *(p + 1) != ':') { if (get_err) { *err = strpprintf(0, ""Failed to parse IPv6 address \""%s\"""", str); } return NULL; } *portno = atoi(p + 2); return estrndup(str + 1, p - str - 1); } #endif if (str_len) { colon = memchr(str, ':', str_len - 1); } else { colon = NULL; } if (colon) { *portno = atoi(colon + 1); host = estrndup(str, colon - str); } else { if (get_err) { *err = strpprintf(0, ""Failed to parse address \""%s\"""", str); } return NULL; } return host; }
Description: PHP through 7.1.11 enables potential SSRF in applications that accept an fsockopen or pfsockopen hostname argument with an expectation that the port number is constrained. Because a :port syntax is recognized, fsockopen will use the port number that is specified in the hostname argument, instead of the port number in the second argument of the function.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static cache_accel_t *read_cache_accel(RBuffer *cache_buf, cache_hdr_t *hdr, cache_map_t *maps) { if (!cache_buf || !hdr || !hdr->accelerateInfoSize || !hdr->accelerateInfoAddr) { return NULL; } ut64 offset = va2pa (hdr->accelerateInfoAddr, hdr->mappingCount, maps, cache_buf, 0, NULL, NULL); if (!offset) { return NULL; } ut64 size = sizeof (cache_accel_t); cache_accel_t *accel = R_NEW0 (cache_accel_t); if (!accel) { return NULL; } if (r_buf_fread_at (cache_buf, offset, (ut8*) accel, ""16il"", 1) != size) { R_FREE (accel); return NULL; } accel->imagesExtrasOffset += offset; accel->bottomUpListOffset += offset; accel->dylibTrieOffset += offset; accel->initializersOffset += offset; accel->dofSectionsOffset += offset; accel->reExportListOffset += offset; accel->depListOffset += offset; accel->rangeTableOffset += offset; return accel; }
Description: Heap-based Buffer Overflow in GitHub repository radareorg/radare2 prior to 5.6.4.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void fx_TypedArray(txMachine* the) { txSlot* instance = fxConstructTypedArray(the); txSlot* dispatch = instance->next; txSlot* view = dispatch->next; txSlot* buffer = view->next; txSlot* data = C_NULL; txU2 shift = dispatch->value.typedArray.dispatch->shift; txSlot* slot; if ((mxArgc > 0) && (mxArgv(0)->kind == XS_REFERENCE_KIND)) { slot = mxArgv(0)->value.reference->next; if (slot && ((slot->kind == XS_ARRAY_BUFFER_KIND) || (slot->kind == XS_HOST_KIND))) { txInteger offset = fxArgToByteLength(the, 1, 0); txInteger size; txSlot* info; if (offset & ((1 << shift) - 1)) mxRangeError(""invalid byteOffset %ld"", offset); size = fxArgToByteLength(the, 2, -1); info = fxGetBufferInfo(the, mxArgv(0)); if (size >= 0) { size <<= shift; if (info->value.bufferInfo.length < (offset + size)) mxRangeError(""out of range byteLength %ld"", size); } else { if (info->value.bufferInfo.length & ((1 << shift) - 1)) mxRangeError(""invalid byteLength %ld"", info->value.bufferInfo.length); size = info->value.bufferInfo.length - offset; if (size < 0) mxRangeError(""out of range byteLength %ld"", size); if (info->value.bufferInfo.maxLength >= 0) size = -1; } view->value.dataView.offset = offset; view->value.dataView.size = size; buffer->kind = XS_REFERENCE_KIND; buffer->value.reference = mxArgv(0)->value.reference; } else if (slot && (slot->kind == XS_TYPED_ARRAY_KIND)) { txSlot* sourceDispatch = slot; txSlot* sourceView = sourceDispatch->next; txSlot* sourceBuffer = sourceView->next; txU2 sourceShift = sourceDispatch->value.typedArray.dispatch->shift; txInteger sourceLength = fxCheckDataViewSize(the, sourceView, sourceBuffer, XS_IMMUTABLE) >> sourceShift; txSlot* sourceData = sourceBuffer->value.reference->next; txInteger sourceDelta = sourceDispatch->value.typedArray.dispatch->size; txInteger sourceOffset = sourceView->value.dataView.offset; txInteger offset = 0; txInteger size = sourceLength << shift; mxPushUninitialized(); mxPush(mxArrayBufferConstructor); if (sourceData->kind == XS_ARRAY_BUFFER_KIND) { mxPushSlot(sourceBuffer); mxGetID(mxID(_constructor)); fxToSpeciesConstructor(the, &mxArrayBufferConstructor); } else mxPush(mxArrayBufferConstructor); mxPushUndefined(); mxPushUninitialized(); mxPushUninitialized(); sourceLength = fxGetDataViewSize(the, sourceView, sourceBuffer) >> sourceShift; size = sourceLength << shift; mxPushInteger(size); mxRunCount(1); mxPullSlot(buffer); sourceLength = fxCheckDataViewSize(the, sourceView, sourceBuffer, XS_IMMUTABLE) >> sourceShift; size = sourceLength << shift; data = fxCheckArrayBufferDetached(the, buffer, XS_MUTABLE); view->value.dataView.offset = offset; view->value.dataView.size = size; if (dispatch == sourceDispatch) c_memcpy(data->value.arrayBuffer.address + offset, sourceData->value.arrayBuffer.address + sourceOffset, size); else { txBoolean contentType = (dispatch->value.typedArray.dispatch->constructorID == _BigInt64Array) || (dispatch->value.typedArray.dispatch->constructorID == _BigUint64Array); txBoolean sourceContentType = (sourceDispatch->value.typedArray.dispatch->constructorID == _BigInt64Array) || (sourceDispatch->value.typedArray.dispatch->constructorID == _BigUint64Array); if (contentType != sourceContentType) mxTypeError(""incompatible content type""); mxPushUndefined(); while (offset < size) { (*sourceDispatch->value.typedArray.dispatch->getter)(the, sourceData, sourceOffset, the->stack, EndianNative); (*dispatch->value.typedArray.dispatch->coerce)(the, the->stack); (*dispatch->value.typedArray.dispatch->setter)(the, data, offset, the->stack, EndianNative); sourceOffset += sourceDelta; offset += 1 << shift; } mxPop(); } } else { fx_TypedArray_from_object(the, instance, C_NULL, C_NULL); } } else { txInteger length = fxArgToByteLength(the, 0, 0); if (length & (((1 << shift) - 1) << (32 - shift))) mxRangeError(""out of range byteLength""); length <<= shift; mxPush(mxArrayBufferConstructor); mxNew(); mxPushInteger(length); mxRunCount(1); mxPullSlot(buffer); view->value.dataView.offset = 0; view->value.dataView.size = length; } }
Description: Moddable commit before 135aa9a4a6a9b49b60aa730ebc3bcc6247d75c45 was discovered to contain an out-of-bounds read via the function fxUint8Getter at /moddable/xs/sources/xsDataView.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: const char * _bfd_elf_get_symbol_version_string (bfd *abfd, asymbol *symbol, bfd_boolean base_p, bfd_boolean *hidden) { const char *version_string = NULL; if (elf_dynversym (abfd) != 0 && (elf_dynverdef (abfd) != 0 || elf_dynverref (abfd) != 0)) { unsigned int vernum = ((elf_symbol_type *) symbol)->version; *hidden = (vernum & VERSYM_HIDDEN) != 0; vernum &= VERSYM_VERSION; if (vernum == 0) version_string = """"; else if (vernum == 1 && (vernum > elf_tdata (abfd)->cverdefs || (elf_tdata (abfd)->verdef[0].vd_flags == VER_FLG_BASE))) version_string = base_p ? ""Base"" : """"; else if (vernum <= elf_tdata (abfd)->cverdefs) { const char *nodename = elf_tdata (abfd)->verdef[vernum - 1].vd_nodename; version_string = ((base_p || strcmp (symbol->name, nodename)) ? nodename : """"); } else { Elf_Internal_Verneed *t; version_string = _(""<corrupt>""); for (t = elf_tdata (abfd)->verref; t != NULL; t = t->vn_nextref) { Elf_Internal_Vernaux *a; for (a = t->vn_auxptr; a != NULL; a = a->vna_nextptr) { if (a->vna_other == vernum) { version_string = a->vna_nodename; break; } } } } } return version_string; }
Description: A Null Pointer Dereference vulnerability exists in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.35, in _bfd_elf_get_symbol_version_string, as demonstrated in nm-new, that can cause a denial of service via a crafted file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static unsigned char * pnm_get_line(unsigned char *p, unsigned char *end, unsigned char *line) { int n; do { for (n = 0 ; p < end && *p >= ' '; p++) { if (n < 255) { line[n++] = *p; } } if (p < end && *p == '\n') { p++; } line[n] = '\0'; } while (line[0] == '#'); return p; }
Description: The load_pnm function in frompnm.c in libsixel.a in libsixel 1.8.2 has infinite recursion.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn, struct nlattr *rp) { struct xfrm_replay_state_esn *up; int ulen; if (!replay_esn || !rp) return 0; up = nla_data(rp); ulen = xfrm_replay_state_esn_len(up); if (nla_len(rp) < ulen || xfrm_replay_state_esn_len(replay_esn) != ulen) return -EINVAL; return 0; }
Description: The xfrm_replay_verify_len function in net/xfrm/xfrm_user.c in the Linux kernel through 4.10.6 does not validate certain size data after an XFRM_MSG_NEWAE update, which allows local users to obtain root privileges or cause a denial of service (heap-based out-of-bounds access) by leveraging the CAP_NET_ADMIN capability, as demonstrated during a Pwn2Own competition at CanSecWest 2017 for the Ubuntu 16.10 linux-image-* package 4.8.0.41.52.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: AP4_UnknownUuidAtom::AP4_UnknownUuidAtom(AP4_UI64 size, const AP4_UI08* uuid, AP4_ByteStream& stream) :  AP4_UuidAtom(size, uuid) { m_Data.SetDataSize((AP4_Size)size-GetHeaderSize()); stream.Read(m_Data.UseData(), m_Data.GetDataSize()); }
Description: Buffer overflow vulnerability in function AP4_MemoryByteStream::WritePartial in mp42aac in Bento4 v1.6.0-639, allows attackers to cause a denial of service via a crafted file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int generate_key(DH *dh) { int ok = 0; int generate_new_key = 0; unsigned l; BN_CTX *ctx; BN_MONT_CTX *mont = NULL; BIGNUM *pub_key = NULL, *priv_key = NULL; ctx = BN_CTX_new(); if (ctx == NULL) goto err; if (dh->priv_key == NULL) { priv_key = BN_new(); if (priv_key == NULL) goto err; generate_new_key = 1; } else priv_key = dh->priv_key; if (dh->pub_key == NULL) { pub_key = BN_new(); if (pub_key == NULL) goto err; } else pub_key = dh->pub_key; if (dh->flags & DH_FLAG_CACHE_MONT_P) { mont = BN_MONT_CTX_set_locked(&dh->method_mont_p, CRYPTO_LOCK_DH, dh->p, ctx); if (!mont) goto err; } if (generate_new_key) { if (dh->q) { do { if (!BN_rand_range(priv_key, dh->q)) goto err; } while (BN_is_zero(priv_key) || BN_is_one(priv_key)); } else { l = dh->length ? dh->length : BN_num_bits(dh->p) - 1; if (!BN_rand(priv_key, l, 0, 0)) goto err; } } { BIGNUM local_prk; BIGNUM *prk; if ((dh->flags & DH_FLAG_NO_EXP_CONSTTIME) == 0) { BN_init(&local_prk); prk = &local_prk; BN_with_flags(prk, priv_key, BN_FLG_CONSTTIME); } else prk = priv_key; if (!dh->meth->bn_mod_exp(dh, pub_key, dh->g, prk, dh->p, ctx, mont)) goto err; } dh->pub_key = pub_key; dh->priv_key = priv_key; ok = 1; err: if (ok != 1) DHerr(DH_F_GENERATE_KEY, ERR_R_BN_LIB); if ((pub_key != NULL) && (dh->pub_key == NULL)) BN_free(pub_key); if ((priv_key != NULL) && (dh->priv_key == NULL)) BN_free(priv_key); BN_CTX_free(ctx); return (ok); }
Description: During key agreement in a TLS handshake using a DH(E) based ciphersuite a malicious server can send a very large prime value to the client. This will cause the client to spend an unreasonably long period of time generating a key for this prime resulting in a hang until the client has finished. This could be exploited in a Denial Of Service attack. Fixed in OpenSSL 1.1.0i-dev (Affected 1.1.0-1.1.0h). Fixed in OpenSSL 1.0.2p-dev (Affected 1.0.2-1.0.2o).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void scroll_cursor_bot(int min_scroll, int set_topbot) { intused; intscrolled = 0; intextra = 0; inti; linenr_Tline_count; linenr_Told_topline = curwin->w_topline; intold_skipcol = curwin->w_skipcol; lineoff_Tloff; lineoff_Tboff; #ifdef FEAT_DIFF intold_topfill = curwin->w_topfill; intfill_below_window; #endif linenr_Told_botline = curwin->w_botline; linenr_Told_valid = curwin->w_valid; intold_empty_rows = curwin->w_empty_rows; linenr_Tcln;        longso = get_scrolloff_value(); intdo_sms = curwin->w_p_wrap && curwin->w_p_sms; cln = curwin->w_cursor.lnum; if (set_topbot) { int set_skipcol = FALSE; used = 0; curwin->w_botline = cln + 1; #ifdef FEAT_DIFF loff.fill = 0; #endif for (curwin->w_topline = curwin->w_botline; curwin->w_topline > 1; curwin->w_topline = loff.lnum) { loff.lnum = curwin->w_topline; topline_back_winheight(&loff, FALSE); if (loff.height == MAXCOL) break; if (used + loff.height > curwin->w_height) { if (do_sms) { if (used < curwin->w_height) { int plines_offset = used + loff.height - curwin->w_height; used = curwin->w_height; #ifdef FEAT_DIFF curwin->w_topfill = loff.fill; #endif curwin->w_topline = loff.lnum; curwin->w_skipcol = skipcol_from_plines( curwin, plines_offset); set_skipcol = TRUE; } } break; } used += loff.height; #ifdef FEAT_DIFF curwin->w_topfill = loff.fill; #endif } set_empty_rows(curwin, used); curwin->w_valid |= VALID_BOTLINE|VALID_BOTLINE_AP; if (curwin->w_topline != old_topline #ifdef FEAT_DIFF || curwin->w_topfill != old_topfill #endif || set_skipcol || curwin->w_skipcol != 0) { curwin->w_valid &= ~(VALID_WROW|VALID_CROW); if (set_skipcol) redraw_later(UPD_NOT_VALID); else reset_skipcol(); } } else validate_botline(); #ifdef FEAT_DIFF used = plines_nofill(cln); #else validate_cheight(); used = curwin->w_cline_height; #endif if (cln >= curwin->w_botline) { scrolled = used; if (cln == curwin->w_botline) scrolled -= curwin->w_empty_rows; if (do_sms) { int top_plines = #ifdef FEAT_DIFF plines_win_nofill #else plines_win #endif (curwin, curwin->w_topline, FALSE); int skip_lines = 0; int width1 = curwin->w_width - curwin_col_off(); if (width1 > 0) { int width2 = width1 + curwin_col_off2(); if (curwin->w_skipcol > width1) skip_lines += (curwin->w_skipcol - width1) / width2 + 1; else if (curwin->w_skipcol > 0) skip_lines = 1; top_plines -= skip_lines; if (top_plines > curwin->w_height) { scrolled += (top_plines - curwin->w_height); } } } } #ifdef FEAT_FOLDING if (!hasFolding(curwin->w_cursor.lnum, &loff.lnum, &boff.lnum)) #endif { loff.lnum = cln; boff.lnum = cln; } #ifdef FEAT_DIFF loff.fill = 0; boff.fill = 0; fill_below_window = diff_check_fill(curwin, curwin->w_botline) - curwin->w_filler_rows; #endif while (loff.lnum > 1) { if ((((scrolled <= 0 || scrolled >= min_scroll) && extra >= (mouse_dragging > 0 ? mouse_dragging - 1 : so)) || boff.lnum + 1 > curbuf->b_ml.ml_line_count) && loff.lnum <= curwin->w_botline #ifdef FEAT_DIFF && (loff.lnum < curwin->w_botline || loff.fill >= fill_below_window) #endif ) break; topline_back(&loff); if (loff.height == MAXCOL) used = MAXCOL; else used += loff.height; if (used > curwin->w_height) break; if (loff.lnum >= curwin->w_botline #ifdef FEAT_DIFF && (loff.lnum > curwin->w_botline || loff.fill <= fill_below_window) #endif ) { scrolled += loff.height; if (loff.lnum == curwin->w_botline #ifdef FEAT_DIFF && loff.fill == 0 #endif ) scrolled -= curwin->w_empty_rows; } if (boff.lnum < curbuf->b_ml.ml_line_count) { botline_forw(&boff); used += boff.height; if (used > curwin->w_height) break; if (extra < ( mouse_dragging > 0 ? mouse_dragging - 1 : so) || scrolled < min_scroll) { extra += boff.height; if (boff.lnum >= curwin->w_botline #ifdef FEAT_DIFF || (boff.lnum + 1 == curwin->w_botline && boff.fill > curwin->w_filler_rows) #endif ) { scrolled += boff.height; if (boff.lnum == curwin->w_botline #ifdef FEAT_DIFF && boff.fill == 0 #endif ) scrolled -= curwin->w_empty_rows; } } } } if (scrolled <= 0) line_count = 0; else if (used > curwin->w_height) line_count = used; else { line_count = 0; #ifdef FEAT_DIFF boff.fill = curwin->w_topfill; #endif boff.lnum = curwin->w_topline - 1; for (i = 0; i < scrolled && boff.lnum < curwin->w_botline; ) { botline_forw(&boff); i += boff.height; ++line_count; } if (i < scrolled)    line_count = 9999; } if (line_count >= curwin->w_height && line_count > min_scroll) scroll_cursor_halfway(FALSE, TRUE); else if (line_count > 0) { if (do_sms) scrollup(scrolled, TRUE);  else scrollup(line_count, TRUE); } if (curwin->w_topline == old_topline && curwin->w_skipcol == old_skipcol && set_topbot) { curwin->w_botline = old_botline; curwin->w_empty_rows = old_empty_rows; curwin->w_valid = old_valid; } curwin->w_valid |= VALID_TOPLINE; }
Description: Divide By Zero in vim/vim from 9.0.1367-1 to 9.0.1367-3

 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static bool r_egg_Cfile_parseCompiled(const char *file) { char *fileExt = r_str_newf (""%s.tmp"", file); char *buffer = r_file_slurp (fileExt, NULL); buffer = r_str_replace (buffer, ""rdata"", ""text"", false); buffer = r_str_replace (buffer, ""rodata"", ""text"", false); buffer = r_str_replace (buffer, ""get_pc_thunk.bx"", ""__getesp__"", true); const char *words[] = {"".cstring"", ""size"", ""___main"", ""section"", ""__alloca"", ""zero"", ""cfi""}; size_t i; for (i = 0; i < 7; i++) { r_str_stripLine (buffer, words[i]); } free (fileExt); fileExt = r_str_newf (""%s.s"", file); if (!r_file_dump (fileExt, (const ut8*) buffer, strlen (buffer), true)) { eprintf (""Error while opening %s.s\n"", file); goto fail; } free (buffer); free (fileExt); return true; fail: free (buffer); free (fileExt); return false; }
Description: radare2 through 4.0.0 lacks validation of the content variable in the function r_asm_pseudo_incbin at libr/asm/asm.c, ultimately leading to an arbitrary write. This allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via crafted input.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static gboolean file_copy_fallback (GFile                  *source, GFile                  *destination, GFileCopyFlags          flags, GCancellable           *cancellable, GFileProgressCallback   progress_callback, gpointer                progress_callback_data, GError                **error) { gboolean ret = FALSE; GFileInputStream *file_in = NULL; GInputStream *in = NULL; GOutputStream *out = NULL; GFileInfo *info = NULL; const char *target; char *attrs_to_read; gboolean do_set_attributes = FALSE; info = g_file_query_info (source, G_FILE_ATTRIBUTE_STANDARD_TYPE "","" G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS, cancellable, error); if (!info) goto out; if ((flags & G_FILE_COPY_NOFOLLOW_SYMLINKS) && g_file_info_get_file_type (info) == G_FILE_TYPE_SYMBOLIC_LINK) { target = g_file_info_get_symlink_target (info); if (target) { if (!copy_symlink (destination, flags, cancellable, target, error)) goto out; ret = TRUE; goto out; } } else if (g_file_info_get_file_type (info) == G_FILE_TYPE_SPECIAL) { g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED, _(""Can’t copy special file"")); goto out; } file_in = open_source_for_copy (source, destination, flags, cancellable, error); if (!file_in) goto out; in = G_INPUT_STREAM (file_in); if (!build_attribute_list_for_copy (destination, flags, &attrs_to_read, cancellable, error)) goto out; if (attrs_to_read != NULL) { GError *tmp_error = NULL; g_object_unref (info); info = g_file_input_stream_query_info (file_in, attrs_to_read, cancellable, &tmp_error); if (!info) { if (g_error_matches (tmp_error, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED)) { g_clear_error (&tmp_error); info = g_file_query_info (source, attrs_to_read, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS, cancellable, error); } else { g_free (attrs_to_read); g_propagate_error (error, tmp_error); goto out; } } g_free (attrs_to_read); if (!info) goto out; do_set_attributes = TRUE; } if (G_IS_LOCAL_FILE (destination)) { if (flags & G_FILE_COPY_OVERWRITE) out = (GOutputStream*)_g_local_file_output_stream_replace (_g_local_file_get_filename (G_LOCAL_FILE (destination)), FALSE, NULL, flags & G_FILE_COPY_BACKUP, G_FILE_CREATE_REPLACE_DESTINATION, info, cancellable, error); else out = (GOutputStream*)_g_local_file_output_stream_create (_g_local_file_get_filename (G_LOCAL_FILE (destination)), FALSE, 0, info, cancellable, error); } else if (flags & G_FILE_COPY_OVERWRITE) { out = (GOutputStream *)g_file_replace (destination, NULL, flags & G_FILE_COPY_BACKUP, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, error); } else { out = (GOutputStream *)g_file_create (destination, 0, cancellable, error); } if (!out) goto out; #ifdef __linux__ if (G_IS_FILE_DESCRIPTOR_BASED (in) && G_IS_FILE_DESCRIPTOR_BASED (out)) { GError *reflink_err = NULL; if (!btrfs_reflink_with_progress (in, out, info, cancellable, progress_callback, progress_callback_data, &reflink_err)) { if (g_error_matches (reflink_err, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED)) { g_clear_error (&reflink_err); } else { g_propagate_error (error, reflink_err); goto out; } } else { ret = TRUE; goto out; } } #endif #ifdef HAVE_SPLICE if (G_IS_FILE_DESCRIPTOR_BASED (in) && G_IS_FILE_DESCRIPTOR_BASED (out)) { GError *splice_err = NULL; if (!splice_stream_with_progress (in, out, cancellable, progress_callback, progress_callback_data, &splice_err)) { if (g_error_matches (splice_err, G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED)) { g_clear_error (&splice_err); } else { g_propagate_error (error, splice_err); goto out; } } else { ret = TRUE; goto out; } } #endif if (!copy_stream_with_progress (in, out, source, cancellable, progress_callback, progress_callback_data, error)) goto out; ret = TRUE; out: if (in) { (void) g_input_stream_close (in, cancellable, NULL); g_object_unref (in); } if (out) { if (!g_output_stream_close (out, cancellable, ret ? error : NULL)) ret = FALSE; g_object_unref (out); } if (ret && do_set_attributes) { g_file_set_attributes_from_info (destination, info, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS, cancellable, NULL); } g_clear_object (&info); return ret; }
Description: file_copy_fallback in gio/gfile.c in GNOME GLib 2.15.0 through 2.61.1 does not properly restrict file permissions while a copy operation is in progress. Instead, default permissions are used.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int x509_verify_ctx_add_chain(struct x509_verify_ctx *ctx, struct x509_verify_chain *chain, char *name) { size_t depth; X509 *last = x509_verify_chain_last(chain); X509 *leaf = x509_verify_chain_leaf(chain); depth = sk_X509_num(chain->certs); if (depth > 0) depth--; if (ctx->chains_count >= ctx->max_chains) return x509_verify_cert_error(ctx, last, depth, X509_V_ERR_CERT_CHAIN_TOO_LONG, 0); if (chain->cert_errors[depth] == X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY) chain->cert_errors[depth] = X509_V_OK; if (!x509_verify_ctx_validate_legacy_chain(ctx, chain, depth)) return 0; if ((ctx->chains[ctx->chains_count] = x509_verify_chain_dup(chain)) == NULL) { return x509_verify_cert_error(ctx, last, depth, X509_V_ERR_OUT_OF_MEM, 0); } if (!x509_verify_cert_valid(ctx, leaf, NULL)) return 0; if (!x509_verify_cert_hostname(ctx, leaf, name)) return 0; ctx->chains_count++; ctx->error = X509_V_OK; ctx->error_depth = depth; return 1; }
Description: An issue was discovered in x509/x509_verify.c in LibreSSL before 3.6.1, and in OpenBSD before 7.2 errata 001. x509_verify_ctx_add_chain does not store errors that occur during leaf certificate verification, and therefore an incorrect error is returned. This behavior occurs when there is an installed verification callback that instructs the verifier to continue upon detecting an invalid certificate.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: PyObject *PyACL::AddAuditAccessObjectAce(PyObject *self, PyObject *args) { DWORD accessmask, acerevision, aceflags; BOOL bAuditSuccess, bAuditFailure; PyObject *obSID; GUID ObjectTypeGuid, InheritedObjectTypeGuid; GUID *pObjectTypeGuid = NULL, *pInheritedObjectTypeGuid = NULL; PyObject *obObjectTypeGuid, *obInheritedObjectTypeGuid; BOOL bsuccess; PSID psid; PACL psacl; PyACL *This = (PyACL *)self; psacl = This->GetACL(); PACL psacl_padded = NULL; if (addauditaccessobjectace == NULL) return PyErr_Format(PyExc_NotImplementedError, ""AddAuditAccessObjectAce not supported by this version of Windows""); if (!PyArg_ParseTuple(args, ""lllOOOii:AddAuditAccessObjectAce"", &acerevision, &aceflags, &accessmask, &obObjectTypeGuid, &obInheritedObjectTypeGuid, &obSID, &bAuditSuccess, &bAuditFailure)) return NULL; if (obObjectTypeGuid != Py_None) { if (!PyWinObject_AsIID(obObjectTypeGuid, &ObjectTypeGuid)) return NULL; pObjectTypeGuid = &ObjectTypeGuid; } if (obInheritedObjectTypeGuid != Py_None) { if (!PyWinObject_AsIID(obInheritedObjectTypeGuid, &InheritedObjectTypeGuid)) return NULL; pInheritedObjectTypeGuid = &InheritedObjectTypeGuid; } if (!PyWinObject_AsSID(obSID, &psid, FALSE)) return NULL; bsuccess = (*addauditaccessobjectace)(psacl, acerevision, aceflags, accessmask, pObjectTypeGuid, pInheritedObjectTypeGuid, psid, bAuditSuccess, bAuditFailure); if (!bsuccess) { DWORD err = GetLastError(); if (err != ERROR_ALLOTTED_SPACE_EXCEEDED) return PyWin_SetAPIError(""AddAuditAccessObjectAce"", err); unsigned short required_size = psacl->AclSize + sizeof(SYSTEM_AUDIT_OBJECT_ACE) + (unsigned short)GetLengthSid(psid); psacl_padded = (ACL *)malloc(required_size); if (psacl_padded == NULL) return PyErr_Format(PyExc_MemoryError, ""AddAuditAccessObjectAce: unable to allocated %d bytes"", required_size); ZeroMemory(psacl_padded, required_size); memcpy(psacl_padded, psacl, psacl->AclSize); psacl_padded->AclSize = required_size; bsuccess = (*addauditaccessobjectace)(psacl_padded, acerevision, aceflags, accessmask, pObjectTypeGuid, pInheritedObjectTypeGuid, psid, bAuditSuccess, bAuditFailure); if (bsuccess) bsuccess = This->SetACL(psacl_padded); else PyWin_SetAPIError(""AddAuditAccessObjectAce""); } if (psacl_padded) free(psacl_padded); if (bsuccess) { Py_INCREF(Py_None); return Py_None; } return NULL; }
Description: An integer overflow exists in pywin32 prior to version b301 when adding an access control entry (ACE) to an access control list (ACL) that would cause the size to be greater than 65535 bytes. An attacker who successfully exploited this vulnerability could crash the vulnerable process.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void php_mb_regex_free_cache(php_mb_regex_t **pre)  { onig_free(*pre); }
Description: Double free vulnerability in the _php_mb_regex_ereg_replace_exec function in php_mbregex.c in the mbstring extension in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8 allows remote attackers to execute arbitrary code or cause a denial of service (application crash) by leveraging a callback exception.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void client_reset(t_client *client) { char *hash; char *msg; char *cidinfo; debug(LOG_DEBUG, ""Resetting client [%s]"", client->mac); client->counters.incoming = 0; client->counters.outgoing = 0; client->counters.last_updated = time(NULL); client->session_start = 0; client->session_end = 0; hash = safe_calloc(STATUS_BUF); client->token = safe_calloc(STATUS_BUF); safe_snprintf(client->token, STATUS_BUF, ""%04hx%04hx"", rand16(), rand16()); hash_str(hash, STATUS_BUF, client->token); client->hid = safe_strdup(hash); free(hash); client->custom = safe_calloc(MID_BUF); client->client_type = safe_calloc(STATUS_BUF); if (client->cid) { if (strlen(client->cid) > 0) { msg = safe_calloc(SMALL_BUF); cidinfo = safe_calloc(MID_BUF); safe_snprintf(cidinfo, MID_BUF, ""cid=\""%s\"""", client->cid); write_client_info(msg, SMALL_BUF, ""rmcid"", client->cid, cidinfo); free(msg); free(cidinfo); } client->cid = safe_calloc(SMALL_BUF); } }
Description: An issue was discovered in the captive portal in OpenNDS before version 10.1.3. It has multiple memory leaks due to not freeing up allocated memory. This may lead to a Denial-of-Service condition due to the consumption of all available memory.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void proto_register_lwapp(void) { static hf_register_info hf[] = { { &hf_lwapp_version, { ""Version"", ""lwapp.version"", FT_UINT8, BASE_DEC, NULL, 0x00, NULL, HFILL }}, { &hf_lwapp_slotid, { ""slotId"",""lwapp.slotId"", FT_UINT24, BASE_DEC, NULL, 0x0, NULL, HFILL }}, { &hf_lwapp_flags, { ""Flags"", ""lwapp.flags"", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }}, { &hf_lwapp_flags_type, { ""Type"", ""lwapp.flags.type"", FT_BOOLEAN, 8, TFS(&lwapp_flags_type), LWAPP_FLAGS_T, NULL, HFILL }}, { &hf_lwapp_flags_fragment, { ""Fragment"", ""lwapp.flags.fragment"", FT_BOOLEAN, 8, TFS(&tfs_set_notset), LWAPP_FLAGS_F, NULL, HFILL }}, { &hf_lwapp_flags_fragment_type, { ""Fragment Type"", ""lwapp.flags.fragmentType"", FT_BOOLEAN, 8, TFS(&tfs_set_notset), LWAPP_FLAGS_FT, NULL, HFILL }}, { &hf_lwapp_fragment_id, { ""Fragment Id"",""lwapp.fragmentId"", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }}, { &hf_lwapp_length, { ""Length"",""lwapp.Length"", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }}, { &hf_lwapp_rssi, { ""RSSI"",""lwapp.rssi"", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }}, { &hf_lwapp_snr, { ""SNR"",""lwapp.snr"", FT_UINT8, BASE_HEX, NULL, 0x0, NULL, HFILL }}, #if 0 { &hf_lwapp_control, { ""Control Data (not dissected yet)"",""lwapp.control"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL }}, #endif { &hf_lwapp_control_mac, { ""AP Identity"", ""lwapp.apid"", FT_ETHER, BASE_NONE, NULL, 0x0, ""Access Point Identity"", HFILL }}, { &hf_lwapp_control_type, { ""Control Type"", ""lwapp.control.type"", FT_UINT8, BASE_DEC|BASE_EXT_STRING, &control_msg_vals_ext, 0x00, NULL, HFILL }}, { &hf_lwapp_control_seq_no, { ""Control Sequence Number"", ""lwapp.control.seqno"", FT_UINT8, BASE_DEC, NULL, 0x00, NULL, HFILL }}, { &hf_lwapp_control_length, { ""Control Length"",""lwapp.control.length"", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL }}, }; static gint *ett[] = { &ett_lwapp_l3, &ett_lwapp, &ett_lwapp_control, &ett_lwapp_flags }; module_t *lwapp_module; proto_lwapp = proto_register_protocol (""LWAPP Encapsulated Packet"", ""LWAPP"", ""lwapp""); proto_lwapp_l3 = proto_register_protocol (""LWAPP Layer 3 Packet"", ""LWAPP-L3"", ""lwapp-l3""); proto_lwapp_control = proto_register_protocol (""LWAPP Control Message"", ""LWAPP-CNTL"", ""lwapp-cntl""); proto_register_field_array(proto_lwapp, hf, array_length(hf)); proto_register_subtree_array(ett, array_length(ett)); lwapp_module = prefs_register_protocol(proto_lwapp, NULL); prefs_register_bool_preference(lwapp_module,""swap_fc"",""Swap Frame Control"", ""Swap frame control bytes (needed for some APs"", &swap_frame_control); }
Description: In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, the LWAPP dissector could crash. This was addressed in epan/dissectors/packet-lwapp.c by limiting the encapsulation levels to restrict the recursion depth.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: CallResult<HermesValue> copyDataPropertiesSlowPath_RJS( Runtime &runtime, Handle<JSObject> target, Handle<JSObject> from, Handle<JSObject> excludedItems) { assert( from->isProxyObject() && ""copyDataPropertiesSlowPath_RJS is only for Proxy""); auto cr = JSProxy::getOwnPropertyKeys( from, runtime, OwnKeysFlags() .plusIncludeSymbols() .plusIncludeNonSymbols() .plusIncludeNonEnumerable()); if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION)) { return ExecutionStatus::EXCEPTION; } auto keys = *cr; MutableHandle<> nextKeyHandle{runtime}; MutableHandle<> propValueHandle{runtime}; MutableHandle<SymbolID> tmpSymbolStorage{runtime}; GCScopeMarkerRAII marker{runtime}; for (uint32_t nextKeyIdx = 0, endIdx = keys->getEndIndex(); nextKeyIdx < endIdx; ++nextKeyIdx) { marker.flush(); nextKeyHandle = keys->at(runtime, nextKeyIdx).unboxToHV(runtime); if (nextKeyHandle->isNumber()) { CallResult<PseudoHandle<StringPrimitive>> strRes = toString_RJS(runtime, nextKeyHandle); if (LLVM_UNLIKELY(strRes == ExecutionStatus::EXCEPTION)) { return ExecutionStatus::EXCEPTION; } nextKeyHandle = strRes->getHermesValue(); } if (excludedItems) { assert( !excludedItems->isProxyObject() && ""internal excludedItems object is a proxy""); ComputedPropertyDescriptor desc; CallResult<bool> cr = JSObject::getOwnComputedPrimitiveDescriptor( excludedItems, runtime, nextKeyHandle, JSObject::IgnoreProxy::Yes, tmpSymbolStorage, desc); if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION)) return ExecutionStatus::EXCEPTION; if (*cr) continue; } ComputedPropertyDescriptor desc; CallResult<bool> crb = JSProxy::getOwnProperty(from, runtime, nextKeyHandle, desc, nullptr); if (LLVM_UNLIKELY(crb == ExecutionStatus::EXCEPTION)) return ExecutionStatus::EXCEPTION; if (*crb && desc.flags.enumerable) { CallResult<PseudoHandle<>> crv = JSProxy::getComputed(from, runtime, nextKeyHandle, from); if (LLVM_UNLIKELY(crv == ExecutionStatus::EXCEPTION)) return ExecutionStatus::EXCEPTION; propValueHandle = std::move(*crv); crb = JSObject::defineOwnComputed( target, runtime, nextKeyHandle, DefinePropertyFlags::getDefaultNewPropertyFlags(), propValueHandle); if (LLVM_UNLIKELY(cr == ExecutionStatus::EXCEPTION)) return ExecutionStatus::EXCEPTION; assert( crb != ExecutionStatus::EXCEPTION && *crb && ""CreateDataProperty failed""); } } return target.getHermesValue(); }
Description: An error in Hermes' algorithm for copying objects properties prior to commit a00d237346894c6067a594983be6634f4168c9ad could be used by a malicious attacker to execute arbitrary code via type confusion. Note that this is only exploitable in cases where Hermes is used to execute untrusted JavaScript. Hence, most React Native applications are not affected.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: TEE_Result syscall_authenc_init(unsigned long state, const void *nonce, size_t nonce_len, size_t tag_len, size_t aad_len, size_t payload_len) { TEE_Result res; struct tee_cryp_state *cs; struct tee_ta_session *sess; struct tee_obj *o; struct tee_cryp_obj_secret *key; res = tee_ta_get_current_session(&sess); if (res != TEE_SUCCESS) return res; res = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx), TEE_MEMORY_ACCESS_READ | TEE_MEMORY_ACCESS_ANY_OWNER, (uaddr_t)nonce, nonce_len); if (res != TEE_SUCCESS) return res; res = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(state), &cs); if (res != TEE_SUCCESS) return res; res = tee_obj_get(to_user_ta_ctx(sess->ctx), cs->key1, &o); if (res != TEE_SUCCESS) return res; if ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0) return TEE_ERROR_BAD_PARAMETERS; key = o->attr; res = crypto_authenc_init(cs->ctx, cs->algo, cs->mode, (uint8_t *)(key + 1), key->key_size, nonce, nonce_len, tag_len, aad_len, payload_len); if (res != TEE_SUCCESS) return res; cs->ctx_finalize = (tee_cryp_ctx_finalize_func_t)crypto_authenc_final; return TEE_SUCCESS; }
Description: In Linaro OP-TEE before 3.7.0, by using inconsistent or malformed data, it is possible to call update and final cryptographic functions directly, causing a crash that could leak sensitive information.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static GF_Err gf_sm_load_run_isom(GF_SceneLoader *load) { GF_Err e; FILE *logs; u32 i, j, di, nbBifs, nbLaser, nb_samp, samp_done, init_offset; GF_StreamContext *sc; GF_ESD *esd; GF_ODCodec *od_dec; #ifndef GPAC_DISABLE_BIFS GF_BifsDecoder *bifs_dec; #endif #ifndef GPAC_DISABLE_LASER GF_LASeRCodec *lsr_dec; #endif if (!load || !load->isom) return GF_BAD_PARAM; nbBifs = nbLaser = 0; e = GF_OK; #ifndef GPAC_DISABLE_BIFS bifs_dec = gf_bifs_decoder_new(load->scene_graph, 1); #endif od_dec = gf_odf_codec_new(); logs = NULL; #ifndef GPAC_DISABLE_LASER lsr_dec = gf_laser_decoder_new(load->scene_graph); #endif esd = NULL; nb_samp = 0; for (i=0; i<gf_isom_get_track_count(load->isom); i++) { u32 type = gf_isom_get_media_type(load->isom, i+1); u32 subtype = gf_isom_get_mpeg4_subtype(load->isom, i+1, 1); switch (type) { case GF_ISOM_MEDIA_SCENE: case GF_ISOM_MEDIA_OD: nb_samp += gf_isom_get_sample_count(load->isom, i+1); break; default: if (subtype==GF_ISOM_SUBTYPE_MP4S) { nb_samp += gf_isom_get_sample_count(load->isom, i+1); } break; } } samp_done = 1; gf_isom_text_set_streaming_mode(load->isom, 1); for (i=0; i<gf_isom_get_track_count(load->isom); i++) { u32 type = gf_isom_get_media_type(load->isom, i+1); u32 subtype = gf_isom_get_mpeg4_subtype(load->isom, i+1, 1); switch (type) { case GF_ISOM_MEDIA_SCENE: case GF_ISOM_MEDIA_OD: break; default: if (subtype!=GF_ISOM_SUBTYPE_MP4S) continue; break; } esd = gf_isom_get_esd(load->isom, i+1, 1); if (!esd) continue; if (!esd->decoderConfig || (esd->decoderConfig->objectTypeIndication==GF_CODECID_TEXT_MPEG4)) { gf_odf_desc_del((GF_Descriptor *) esd); continue; } if ((esd->decoderConfig->objectTypeIndication == GF_CODECID_AFX) || (esd->decoderConfig->objectTypeIndication == GF_CODECID_SYNTHESIZED_TEXTURE) ) { nb_samp += gf_isom_get_sample_count(load->isom, i+1); gf_odf_desc_del((GF_Descriptor *) esd); continue; } sc = gf_sm_stream_new(load->ctx, esd->ESID, esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication); sc->streamType = esd->decoderConfig->streamType; sc->ESID = esd->ESID; sc->codec_id = esd->decoderConfig->objectTypeIndication; sc->timeScale = gf_isom_get_media_timescale(load->isom, i+1); if (esd->decoderConfig->streamType==GF_STREAM_SCENE) { #ifndef GPAC_DISABLE_BIFS if (esd->decoderConfig->objectTypeIndication<=2) { if (!esd->dependsOnESID && nbBifs && !i) mp4_report(load, GF_OK, ""several scene namespaces used or improper scene dependencies in file - import may be incorrect""); if (!esd->decoderConfig->decoderSpecificInfo) { e = gf_bifs_decoder_configure_stream(bifs_dec, esd->ESID, NULL, 0, esd->decoderConfig->objectTypeIndication); } else { e = gf_bifs_decoder_configure_stream(bifs_dec, esd->ESID, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, esd->decoderConfig->objectTypeIndication); } if (e) goto exit; nbBifs++; } #endif #ifndef GPAC_DISABLE_LASER if (esd->decoderConfig->objectTypeIndication==0x09) { if (!esd->dependsOnESID && nbBifs && !i) mp4_report(load, GF_OK, ""several scene namespaces used or improper scene dependencies in file - import may be incorrect""); if (!esd->decoderConfig->decoderSpecificInfo) e = GF_NON_COMPLIANT_BITSTREAM; else e = gf_laser_decoder_configure_stream(lsr_dec, esd->ESID, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength); if (e) goto exit; nbLaser++; } #endif } init_offset = 0; for (j=0; j<gf_isom_get_sample_count(load->isom, i+1); j++) { GF_AUContext *au; GF_ISOSample *samp = gf_isom_get_sample(load->isom, i+1, j+1, &di); if (!samp) { mp4_report(load, gf_isom_last_error(load->isom), ""Unable to fetch sample %d from track ID %d - aborting track import"", j+1, gf_isom_get_track_id(load->isom, i+1)); break; } if (!j && gf_isom_get_edits_count(load->isom, i+1)) { u64 EditTime, dur, mtime; GF_ISOEditType mode; gf_isom_get_edit(load->isom, i+1, 1, &EditTime, &dur, &mtime, &mode); if (mode==GF_ISOM_EDIT_EMPTY) { init_offset = (u32) (dur * sc->timeScale / gf_isom_get_timescale(load->isom) ); } } samp->DTS += init_offset; au = gf_sm_stream_au_new(sc, samp->DTS, ((Double)(s64) samp->DTS) / sc->timeScale, (samp->IsRAP==RAP) ? 1 : 0); if (esd->decoderConfig->streamType==GF_STREAM_SCENE) { #ifndef GPAC_DISABLE_BIFS if (esd->decoderConfig->objectTypeIndication<=2) e = gf_bifs_decode_command_list(bifs_dec, esd->ESID, samp->data, samp->dataLength, au->commands); #endif #ifndef GPAC_DISABLE_LASER if (esd->decoderConfig->objectTypeIndication==0x09) e = gf_laser_decode_command_list(lsr_dec, esd->ESID, samp->data, samp->dataLength, au->commands); #endif } else { e = gf_odf_codec_set_au(od_dec, samp->data, samp->dataLength); if (!e) e = gf_odf_codec_decode(od_dec); if (!e) { while (1) { GF_ODCom *odc = gf_odf_codec_get_com(od_dec); if (!odc) break; UpdateODCommand(load->isom, odc); gf_list_add(au->commands, odc); } } } gf_isom_sample_del(&samp); if (e) { mp4_report(load, gf_isom_last_error(load->isom), ""decoding sample %d from track ID %d failed"", j+1, gf_isom_get_track_id(load->isom, i+1)); goto exit; } samp_done++; gf_set_progress(""MP4 Loading"", samp_done, nb_samp); } gf_odf_desc_del((GF_Descriptor *) esd); esd = NULL; } gf_isom_text_set_streaming_mode(load->isom, 0); exit: #ifndef GPAC_DISABLE_BIFS gf_bifs_decoder_del(bifs_dec); #endif gf_odf_codec_del(od_dec); #ifndef GPAC_DISABLE_LASER gf_laser_decoder_del(lsr_dec); #endif if (esd) gf_odf_desc_del((GF_Descriptor *) esd); if (logs) gf_fclose(logs); return e; }
Description: A Double Free vulnerability exists in filedump.c in GPAC 1.0.1, which could cause a Denail of Service via a crafted file in the MP4Box command.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: WebstoreInlineInstaller::WebstoreInlineInstaller( content::WebContents* web_contents, const std::string& webstore_item_id, const GURL& requestor_url, const Callback& callback) : WebstoreStandaloneInstaller( webstore_item_id, Profile::FromBrowserContext(web_contents->GetBrowserContext()), callback), content::WebContentsObserver(web_contents), requestor_url_(requestor_url) { }
Description: The Web Store inline-installer implementation in the Extensions UI in Google Chrome before 49.0.2623.75 does not block installations upon deletion of an installation frame, which makes it easier for remote attackers to trick a user into believing that an installation request originated from the user's next navigation target via a crafted web site.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int check_entry_size_and_hooks(struct ip6t_entry *e, struct xt_table_info *newinfo, const unsigned char *base, const unsigned char *limit, const unsigned int *hook_entries, const unsigned int *underflows, unsigned int valid_hooks) { unsigned int h; int err; if ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 || (unsigned char *)e + sizeof(struct ip6t_entry) >= limit) { duprintf(""Bad offset %p\n"", e); return -EINVAL; } if (e->next_offset < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) { duprintf(""checking: element %p size %u\n"", e, e->next_offset); return -EINVAL; } err = check_entry(e); if (err) return err; for (h = 0; h < NF_INET_NUMHOOKS; h++) { if (!(valid_hooks & (1 << h))) continue; if ((unsigned char *)e - base == hook_entries[h]) newinfo->hook_entry[h] = hook_entries[h]; if ((unsigned char *)e - base == underflows[h]) { if (!check_underflow(e)) { pr_err(""Underflows must be unconditional and "" ""use the STANDARD target with "" ""ACCEPT/DROP\n""); return -EINVAL; } newinfo->underflow[h] = underflows[h]; } } e->counters = ((struct xt_counters) { 0, 0 }); e->comefrom = 0; return 0; }
Description: The IPT_SO_SET_REPLACE setsockopt implementation in the netfilter subsystem in the Linux kernel before 4.6 allows local users to cause a denial of service (out-of-bounds read) or possibly obtain sensitive information from kernel heap memory by leveraging in-container root access to provide a crafted offset value that leads to crossing a ruleset blob boundary.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: XDevice * XOpenDevice( register Display*dpy, register XID id) { register long rlen; xOpenDeviceReq *req; xOpenDeviceReply rep; XDevice *dev; XExtDisplayInfo *info = XInput_find_display(dpy); LockDisplay(dpy); if (_XiCheckExtInit(dpy, XInput_Initial_Release, info) == -1) return NULL; GetReq(OpenDevice, req); req->reqType = info->codes->major_opcode; req->ReqType = X_OpenDevice; req->deviceid = id; if (!_XReply(dpy, (xReply *) & rep, 0, xFalse)) { UnlockDisplay(dpy); SyncHandle(); return (XDevice *) NULL; } rlen = rep.length << 2; dev = (XDevice *) Xmalloc(sizeof(XDevice) + rep.num_classes * sizeof(XInputClassInfo)); if (dev) { int dlen; dev->device_id = req->deviceid; dev->num_classes = rep.num_classes; dev->classes = (XInputClassInfo *) ((char *)dev + sizeof(XDevice)); dlen = rep.num_classes * sizeof(xInputClassInfo); _XRead(dpy, (char *)dev->classes, dlen); if (rlen - dlen > 0) _XEatData(dpy, (unsigned long)rlen - dlen); } else _XEatDataWords(dpy, rep.length); UnlockDisplay(dpy); SyncHandle(); return (dev); }
Description: Multiple integer overflows in X.org libXi before 1.7.7 allow remote X servers to cause a denial of service (out-of-bounds memory access or infinite loop) via vectors involving length fields.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: AP4_UnknownUuidAtom::AP4_UnknownUuidAtom(AP4_UI64 size, AP4_ByteStream& stream) :  AP4_UuidAtom(size, false, stream) { m_Data.SetDataSize((AP4_Size)size-GetHeaderSize()); stream.Read(m_Data.UseData(), m_Data.GetDataSize()); }
Description: Buffer overflow vulnerability in function AP4_MemoryByteStream::WritePartial in mp42aac in Bento4 v1.6.0-639, allows attackers to cause a denial of service via a crafted file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: WORD32 ih264d_start_of_pic(dec_struct_t *ps_dec, WORD32 i4_poc, pocstruct_t *ps_temp_poc, UWORD16 u2_frame_num, dec_pic_params_t *ps_pps) { pocstruct_t *ps_prev_poc = &ps_dec->s_cur_pic_poc; pocstruct_t *ps_cur_poc = ps_temp_poc; pic_buffer_t *pic_buf; ivd_video_decode_op_t * ps_dec_output = (ivd_video_decode_op_t *)ps_dec->pv_dec_out; dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice; dec_seq_params_t *ps_seq = ps_pps->ps_sps; UWORD8 u1_bottom_field_flag = ps_cur_slice->u1_bottom_field_flag; UWORD8 u1_field_pic_flag = ps_cur_slice->u1_field_pic_flag; high_profile_tools_t s_high_profile; WORD32 ret; H264_MUTEX_LOCK(&ps_dec->process_disp_mutex); ps_prev_poc->i4_pic_order_cnt_lsb = ps_cur_poc->i4_pic_order_cnt_lsb; ps_prev_poc->i4_pic_order_cnt_msb = ps_cur_poc->i4_pic_order_cnt_msb; ps_prev_poc->i4_delta_pic_order_cnt_bottom = ps_cur_poc->i4_delta_pic_order_cnt_bottom; ps_prev_poc->i4_delta_pic_order_cnt[0] = ps_cur_poc->i4_delta_pic_order_cnt[0]; ps_prev_poc->i4_delta_pic_order_cnt[1] = ps_cur_poc->i4_delta_pic_order_cnt[1]; ps_prev_poc->u1_bot_field = ps_dec->ps_cur_slice->u1_bottom_field_flag; ps_prev_poc->i4_prev_frame_num_ofst = ps_cur_poc->i4_prev_frame_num_ofst; ps_prev_poc->u2_frame_num = u2_frame_num; ps_dec->i1_prev_mb_qp_delta = 0; ps_dec->i1_next_ctxt_idx = 0; ps_dec->u4_nmb_deblk = 0; if(ps_dec->u4_num_cores == 1) ps_dec->u4_nmb_deblk = 1; if(ps_seq->u1_mb_aff_flag == 1) { ps_dec->u4_nmb_deblk = 0; if(ps_dec->u4_num_cores > 2) ps_dec->u4_num_cores = 2; } ps_dec->u4_use_intrapred_line_copy = 0; if (ps_seq->u1_mb_aff_flag == 0) { ps_dec->u4_use_intrapred_line_copy = 1; } ps_dec->u4_app_disable_deblk_frm = 0; if(ps_dec->i4_degrade_type && ps_dec->i4_degrade_pics) { WORD32 degrade_pic; ps_dec->i4_degrade_pic_cnt++; degrade_pic = 0; switch(ps_dec->i4_degrade_pics) { case 4: { degrade_pic = 1; break; } case 3: { if(ps_cur_slice->u1_slice_type != I_SLICE) degrade_pic = 1; break; } case 2: { if((ps_cur_slice->u1_slice_type != I_SLICE) && (ps_dec->i4_degrade_pic_cnt != ps_dec->i4_nondegrade_interval)) degrade_pic = 1; break; } case 1: { if(0 == ps_cur_slice->u1_nal_ref_idc) { degrade_pic = 1; } break; } } if(degrade_pic) { if(ps_dec->i4_degrade_type & 0x2) ps_dec->u4_app_disable_deblk_frm = 1; if(0 == ps_cur_slice->u1_nal_ref_idc) { if(ps_dec->i4_degrade_type & 0x4) ps_dec->i4_mv_frac_mask = 0; if(ps_dec->i4_degrade_type & 0x8) ps_dec->i4_mv_frac_mask = 0; } } else ps_dec->i4_degrade_pic_cnt = 0; } { dec_err_status_t * ps_err = ps_dec->ps_dec_err_status; if(ps_dec->u1_sl_typ_5_9 && ((ps_cur_slice->u1_slice_type == I_SLICE) || (ps_cur_slice->u1_slice_type == SI_SLICE))) ps_err->u1_cur_pic_type = PIC_TYPE_I; else ps_err->u1_cur_pic_type = PIC_TYPE_UNKNOWN; if(ps_err->u1_pic_aud_i == PIC_TYPE_I) { ps_err->u1_cur_pic_type = PIC_TYPE_I; ps_err->u1_pic_aud_i = PIC_TYPE_UNKNOWN; } if(ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL) { if(ps_err->u1_err_flag) ih264d_reset_ref_bufs(ps_dec->ps_dpb_mgr); ps_err->u1_err_flag = ACCEPT_ALL_PICS; } } if(ps_dec->u1_init_dec_flag && ps_dec->s_prev_seq_params.u1_eoseq_pending) { WORD32 j; for(j = 0; j < MAX_DISP_BUFS_NEW; j++) { ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, j, BUF_MGR_REF); ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr, ps_dec->au1_pic_buf_id_mv_buf_id_map[j], BUF_MGR_REF); ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, j, BUF_MGR_IO); } ps_dec->u1_second_field = 0; ps_dec->i4_cur_display_seq = 0; ps_dec->s_prev_seq_params.u1_eoseq_pending = 0; } ret = ih264d_init_pic(ps_dec, u2_frame_num, i4_poc, ps_pps); if(ret != OK) return ret; ps_dec->pv_parse_tu_coeff_data = ps_dec->pv_pic_tu_coeff_data; ps_dec->pv_proc_tu_coeff_data  = ps_dec->pv_pic_tu_coeff_data; ps_dec->ps_nmb_info = ps_dec->ps_frm_mb_info; if(ps_dec->u1_separate_parse) { UWORD16 pic_wd = ps_dec->u4_width_at_init; UWORD16 pic_ht = ps_dec->u4_height_at_init; UWORD32 num_mbs; if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid))) { pic_wd = ps_dec->u2_pic_wd; pic_ht = ps_dec->u2_pic_ht; } num_mbs = (pic_wd * pic_ht) >> 8; if(ps_dec->pu1_dec_mb_map) { memset((void *)ps_dec->pu1_dec_mb_map, 0, num_mbs); } if(ps_dec->pu1_recon_mb_map) { memset((void *)ps_dec->pu1_recon_mb_map, 0, num_mbs); } if(ps_dec->pu2_slice_num_map) { memset((void *)ps_dec->pu2_slice_num_map, 0, (num_mbs * sizeof(UWORD16))); } } ps_dec->ps_parse_cur_slice = &(ps_dec->ps_dec_slice_buf[0]); ps_dec->ps_decode_cur_slice = &(ps_dec->ps_dec_slice_buf[0]); ps_dec->ps_computebs_cur_slice = &(ps_dec->ps_dec_slice_buf[0]); ps_dec->u2_cur_slice_num = 0; ps_dec->s_high_profile.u1_scaling_present = 0; ps_dec->s_high_profile.u1_transform8x8_present = 0; if(1 == ps_dec->u4_share_disp_buf) { UWORD32 i; for(i = 0; i < MAX_DISP_BUFS_NEW; i++) { if(0 == ps_dec->u4_disp_buf_to_be_freed[i]) continue; ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, i, BUF_MGR_IO); ps_dec->u4_disp_buf_to_be_freed[i] = 0; ps_dec->u4_disp_buf_mapping[i] = 0; } } if(!(u1_field_pic_flag && 0 != ps_dec->u1_top_bottom_decoded))     { pic_buffer_t *ps_cur_pic; WORD32 cur_pic_buf_id, cur_mv_buf_id; col_mv_buf_t *ps_col_mv; while(1) { ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free( (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &cur_pic_buf_id); if(ps_cur_pic == NULL) { ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T; return ERROR_UNAVAIL_PICBUF_T; } if(0 == ps_dec->u4_disp_buf_mapping[cur_pic_buf_id]) { break; } } ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr, &cur_mv_buf_id); if(ps_col_mv == NULL) { ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T; return ERROR_UNAVAIL_MVBUF_T; } ps_dec->ps_cur_pic = ps_cur_pic; ps_dec->u1_pic_buf_id = cur_pic_buf_id; ps_cur_pic->u4_ts = ps_dec->u4_ts; ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id; ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id; ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag; ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv; ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0; if(ps_dec->u1_first_slice_in_stream) { ps_dec->ps_ref_pic_buf_lx[0] = ps_dec->ps_dpb_mgr->ps_init_dpb[0]; *(ps_dec->ps_dpb_mgr->ps_init_dpb[0][0]) = *ps_cur_pic; *(ps_dec->ps_dpb_mgr->ps_init_dpb[0][MAX_REF_BUFS]) = *ps_cur_pic; } if(!ps_dec->ps_cur_pic) { WORD32 j; H264_DEC_DEBUG_PRINT(""------- Display Buffers Reset --------\n""); for(j = 0; j < MAX_DISP_BUFS_NEW; j++) { ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, j, BUF_MGR_REF); ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_mv_buf_mgr, ps_dec->au1_pic_buf_id_mv_buf_id_map[j], BUF_MGR_REF); ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr, j, BUF_MGR_IO); } ps_dec->i4_cur_display_seq = 0; ps_dec->i4_prev_max_display_seq = 0; ps_dec->i4_max_poc = 0; ps_cur_pic = (pic_buffer_t *)ih264_buf_mgr_get_next_free( (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &cur_pic_buf_id); if(ps_cur_pic == NULL) { ps_dec->i4_error_code = ERROR_UNAVAIL_PICBUF_T; return ERROR_UNAVAIL_PICBUF_T; } ps_col_mv = (col_mv_buf_t *)ih264_buf_mgr_get_next_free((buf_mgr_t *)ps_dec->pv_mv_buf_mgr, &cur_mv_buf_id); if(ps_col_mv == NULL) { ps_dec->i4_error_code = ERROR_UNAVAIL_MVBUF_T; return ERROR_UNAVAIL_MVBUF_T; } ps_dec->ps_cur_pic = ps_cur_pic; ps_dec->u1_pic_buf_id = cur_pic_buf_id; ps_cur_pic->u4_ts = ps_dec->u4_ts; ps_dec->apv_buf_id_pic_buf_map[cur_pic_buf_id] = (void *)ps_cur_pic; ps_cur_pic->u1_mv_buf_id = cur_mv_buf_id; ps_dec->au1_pic_buf_id_mv_buf_id_map[cur_pic_buf_id] = cur_mv_buf_id; ps_cur_pic->pu1_col_zero_flag = (UWORD8 *)ps_col_mv->pv_col_zero_flag; ps_cur_pic->ps_mv = (mv_pred_t *)ps_col_mv->pv_mv; ps_dec->au1_pic_buf_ref_flag[cur_pic_buf_id] = 0; } ps_dec->ps_cur_pic->u1_picturetype = u1_field_pic_flag; ps_dec->ps_cur_pic->u4_pack_slc_typ = SKIP_NONE; H264_DEC_DEBUG_PRINT(""got a buffer\n""); } else { H264_DEC_DEBUG_PRINT(""did not get a buffer\n""); } ps_dec->u4_pic_buf_got = 1; ps_dec->ps_cur_pic->i4_poc = i4_poc; ps_dec->ps_cur_pic->i4_frame_num = u2_frame_num; ps_dec->ps_cur_pic->i4_pic_num = u2_frame_num; ps_dec->ps_cur_pic->i4_top_field_order_cnt = ps_pps->i4_top_field_order_cnt; ps_dec->ps_cur_pic->i4_bottom_field_order_cnt = ps_pps->i4_bottom_field_order_cnt; ps_dec->ps_cur_pic->i4_avg_poc = ps_pps->i4_avg_poc; ps_dec->ps_cur_pic->u4_time_stamp = ps_dec->u4_pts; ps_dec->s_cur_pic = *(ps_dec->ps_cur_pic); if(u1_field_pic_flag && u1_bottom_field_flag) { WORD32 i4_temp_poc; WORD32 i4_top_field_order_poc, i4_bot_field_order_poc; ps_dec->s_cur_pic.pu1_buf1 += ps_dec->s_cur_pic.u2_frm_wd_y; ps_dec->s_cur_pic.pu1_buf2 += ps_dec->s_cur_pic.u2_frm_wd_uv; ps_dec->s_cur_pic.pu1_buf3 += ps_dec->s_cur_pic.u2_frm_wd_uv; ps_dec->s_cur_pic.ps_mv += ((ps_dec->u2_pic_ht * ps_dec->u2_pic_wd) >> 5); ps_dec->s_cur_pic.pu1_col_zero_flag += ((ps_dec->u2_pic_ht * ps_dec->u2_pic_wd) >> 5); ps_dec->ps_cur_pic->u1_picturetype |= BOT_FLD; i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt; i4_bot_field_order_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt; i4_temp_poc = MIN(i4_top_field_order_poc, i4_bot_field_order_poc); ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc; } ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag && (!u1_field_pic_flag); ps_dec->ps_cur_pic->u1_picturetype |= (ps_cur_slice->u1_mbaff_frame_flag << 2); ps_dec->ps_cur_mb_row = ps_dec->ps_nbr_mb_row;     ps_dec->ps_cur_mb_row++;     ps_dec->ps_top_mb_row = ps_dec->ps_nbr_mb_row + ((ps_dec->u2_frm_wd_in_mbs + 1) << (1 - ps_dec->ps_cur_sps->u1_frame_mbs_only_flag)); ps_dec->ps_top_mb_row++;  ps_dec->pu1_y = ps_dec->pu1_y_scratch[0]; ps_dec->pu1_u = ps_dec->pu1_u_scratch[0]; ps_dec->pu1_v = ps_dec->pu1_v_scratch[0]; ps_dec->u1_yuv_scratch_idx = 0; ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv; ps_dec->ps_mv_top = ps_dec->ps_mv_top_p[0]; ps_dec->u1_mv_top_p = 0; ps_dec->u1_mb_idx = 0; ps_dec->ps_mv_left = ps_dec->s_cur_pic.ps_mv; ps_dec->pu1_yleft = 0; ps_dec->pu1_uleft = 0; ps_dec->pu1_vleft = 0; ps_dec->u1_not_wait_rec = 2; ps_dec->u2_total_mbs_coded = 0; ps_dec->i4_submb_ofst = -(SUB_BLK_SIZE); ps_dec->u4_pred_info_idx = 0; ps_dec->u4_pred_info_pkd_idx = 0; ps_dec->u4_dma_buf_idx = 0; ps_dec->ps_mv = ps_dec->s_cur_pic.ps_mv; ps_dec->ps_mv_bank_cur = ps_dec->s_cur_pic.ps_mv; ps_dec->pu1_col_zero_flag = ps_dec->s_cur_pic.pu1_col_zero_flag; ps_dec->ps_part = ps_dec->ps_parse_part_params; ps_dec->i2_prev_slice_mbx = -1; ps_dec->i2_prev_slice_mby = 0; ps_dec->u2_mv_2mb[0] = 0; ps_dec->u2_mv_2mb[1] = 0; ps_dec->u1_last_pic_not_decoded = 0; ps_dec->u2_cur_slice_num_dec_thread = 0; ps_dec->u2_cur_slice_num_bs = 0; ps_dec->u4_intra_pred_line_ofst = 0; ps_dec->pu1_cur_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line; ps_dec->pu1_cur_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line; ps_dec->pu1_cur_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line; ps_dec->pu1_cur_y_intra_pred_line_base = ps_dec->pu1_y_intra_pred_line; ps_dec->pu1_cur_u_intra_pred_line_base = ps_dec->pu1_u_intra_pred_line; ps_dec->pu1_cur_v_intra_pred_line_base = ps_dec->pu1_v_intra_pred_line; ps_dec->pu1_prev_y_intra_pred_line = ps_dec->pu1_y_intra_pred_line + (ps_dec->u2_frm_wd_in_mbs * MB_SIZE); ps_dec->pu1_prev_u_intra_pred_line = ps_dec->pu1_u_intra_pred_line + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE * YUV420SP_FACTOR; ps_dec->pu1_prev_v_intra_pred_line = ps_dec->pu1_v_intra_pred_line + ps_dec->u2_frm_wd_in_mbs * BLK8x8SIZE; ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic; ps_dec->ps_deblk_mbn_curr = ps_dec->ps_deblk_mbn; ps_dec->ps_deblk_mbn_prev = ps_dec->ps_deblk_mbn + ps_dec->u1_recon_mb_grp; { if(ps_cur_slice->u1_mbaff_frame_flag) { ps_dec->pf_compute_bs = ih264d_compute_bs_mbaff; ps_dec->pf_mvpred = ih264d_mvpred_mbaff; } else { ps_dec->pf_compute_bs = ih264d_compute_bs_non_mbaff; ps_dec->u1_cur_mb_fld_dec_flag = ps_cur_slice->u1_field_pic_flag; } } { UWORD8 u1_field_pic_flag = ps_dec->ps_cur_slice->u1_field_pic_flag; UWORD8 u1_mbaff = ps_cur_slice->u1_mbaff_frame_flag; UWORD8 uc_lastmbs = (((ps_dec->u2_pic_wd) >> 4) % (ps_dec->u1_recon_mb_grp >> u1_mbaff)); UWORD16 ui16_lastmbs_widthY = (uc_lastmbs ? (uc_lastmbs << 4) : ((ps_dec->u1_recon_mb_grp >> u1_mbaff) << 4)); UWORD16 ui16_lastmbs_widthUV = uc_lastmbs ? (uc_lastmbs << 3) : ((ps_dec->u1_recon_mb_grp >> u1_mbaff) << 3); ps_dec->s_tran_addrecon.pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1; ps_dec->s_tran_addrecon.pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2; ps_dec->s_tran_addrecon.pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3; ps_dec->s_tran_addrecon.u2_frm_wd_y = ps_dec->u2_frm_wd_y << u1_field_pic_flag; ps_dec->s_tran_addrecon.u2_frm_wd_uv = ps_dec->u2_frm_wd_uv << u1_field_pic_flag; if(u1_field_pic_flag) { ui16_lastmbs_widthY += ps_dec->u2_frm_wd_y; ui16_lastmbs_widthUV += ps_dec->u2_frm_wd_uv; } ps_dec->s_tran_addrecon.u4_inc_y[0] = ((ps_dec->u1_recon_mb_grp << 4) >> u1_mbaff); ps_dec->s_tran_addrecon.u4_inc_uv[0] = ((ps_dec->u1_recon_mb_grp << 4) >> u1_mbaff); ps_dec->s_tran_addrecon.u4_inc_y[1] = (ui16_lastmbs_widthY + (PAD_LEN_Y_H << 1) + ps_dec->s_tran_addrecon.u2_frm_wd_y * ((15 << u1_mbaff) + u1_mbaff)); ps_dec->s_tran_addrecon.u4_inc_uv[1] = (ui16_lastmbs_widthUV + (PAD_LEN_UV_H << 2) + ps_dec->s_tran_addrecon.u2_frm_wd_uv * ((15 << u1_mbaff) + u1_mbaff)); ih264d_assign_pic_num(ps_dec); ps_dec->s_tran_addrecon.u2_mv_top_left_inc = (ps_dec->u1_recon_mb_grp << 2) - 1 - (u1_mbaff << 2); ps_dec->s_tran_addrecon.u2_mv_left_inc = ((ps_dec->u1_recon_mb_grp >> u1_mbaff) - 1) << (4 + u1_mbaff); } if(ps_seq->u1_profile_idc == HIGH_PROFILE_IDC) { if((ps_seq->i4_seq_scaling_matrix_present_flag) || (ps_pps->i4_pic_scaling_matrix_present_flag)) { ih264d_form_scaling_matrix_picture(ps_seq, ps_pps, ps_dec); ps_dec->s_high_profile.u1_scaling_present = 1; } else { ih264d_form_default_scaling_matrix(ps_dec); } if(ps_pps->i4_transform_8x8_mode_flag) { ps_dec->s_high_profile.u1_transform8x8_present = 1; } } else { ih264d_form_default_scaling_matrix(ps_dec); } ps_dec->s_high_profile.u1_direct_8x8_inference_flag = ps_seq->u1_direct_8x8_inference_flag; ps_dec->s_high_profile.s_cavlc_ctxt = ps_dec->s_cavlc_ctxt; ps_dec->i1_recon_in_thread3_flag = 1; ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_addrecon; if(ps_dec->u1_separate_parse) { memcpy(&ps_dec->s_tran_addrecon_parse, &ps_dec->s_tran_addrecon, sizeof(tfr_ctxt_t)); if(ps_dec->u4_num_cores >= 3 && ps_dec->i1_recon_in_thread3_flag) { memcpy(&ps_dec->s_tran_iprecon, &ps_dec->s_tran_addrecon, sizeof(tfr_ctxt_t)); ps_dec->ps_frame_buf_ip_recon = &ps_dec->s_tran_iprecon; } } ih264d_init_deblk_tfr_ctxt(ps_dec,&(ps_dec->s_pad_mgr), &(ps_dec->s_tran_addrecon), ps_dec->u2_frm_wd_in_mbs, 0); ps_dec->ps_cur_deblk_mb = ps_dec->ps_deblk_pic; ps_dec->u4_cur_deblk_mb_num = 0; ps_dec->u4_deblk_mb_x = 0; ps_dec->u4_deblk_mb_y = 0; ps_dec->pu4_wt_ofsts = ps_dec->pu4_wts_ofsts_mat; H264_MUTEX_UNLOCK(&ps_dec->process_disp_mutex); return OK; }
Description: A remote code execution vulnerability in libavc in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-34097866.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: MagickExport MagickBooleanType SetQuantumDepth(const Image *image, QuantumInfo *quantum_info,const size_t depth) { size_t extent, quantum; assert(image != (Image *) NULL); assert(image->signature == MagickCoreSignature); if (image->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename); assert(quantum_info != (QuantumInfo *) NULL); assert(quantum_info->signature == MagickCoreSignature); quantum_info->depth=depth; if (quantum_info->format == FloatingPointQuantumFormat) { if (quantum_info->depth > 32) quantum_info->depth=64; else if (quantum_info->depth > 16) quantum_info->depth=32; else quantum_info->depth=16; } if (quantum_info->pixels != (unsigned char **) NULL) DestroyQuantumPixels(quantum_info); quantum=(quantum_info->pad+6)*(quantum_info->depth+7)/8; extent=image->columns*quantum; if ((image->columns != 0) && (quantum != (extent/image->columns))) return(MagickFalse); return(AcquireQuantumPixels(quantum_info,extent)); }
Description: The quantum handling code in ImageMagick allows remote attackers to cause a denial of service (divide-by-zero error or out-of-bounds write) via a crafted file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void rxrpc_put_bundle(struct rxrpc_bundle *bundle) { unsigned int d = bundle->debug_id; bool dead; int r; dead = __refcount_dec_and_test(&bundle->ref, &r); _debug(""PUT B=%x %d"", d, r); if (dead) rxrpc_free_bundle(bundle); }
Description: A race condition was found in the Linux kernel's RxRPC network protocol, within the processing of RxRPC bundles. This issue results from the lack of proper locking when performing operations on an object. This may allow an attacker to escalate privileges and execute arbitrary code in the context of the kernel.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static unsigned int nsvg__parseColorHex(const char* str) { unsigned int c = 0, r = 0, g = 0, b = 0; int n = 0; str++; while(str[n] && !nsvg__isspace(str[n])) n++; if (n == 6) { sscanf(str, ""%x"", &c); } else if (n == 3) { sscanf(str, ""%x"", &c); c = (c&0xf) | ((c&0xf0) << 4) | ((c&0xf00) << 8); c |= c<<4; } r = (c >> 16) & 0xff; g = (c >> 8) & 0xff; b = c & 0xff; return NSVG_RGB(r,g,b); }
Description: nanosvg library nanosvg after commit c1f6e209c16b18b46aa9f45d7e619acf42c29726 is affected by: Buffer Overflow. The impact is: Memory corruption leading to at least DoS. More severe impact vectors need more investigation. The component is: it's part of a svg processing library. function nsvg__parseColorRGB in src/nanosvg.h / line 1227. The attack vector is: It depends library usage. If input is passed from the network, then network connectivity is enough. Most likely an attack will require opening a specially crafted .svg file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int HevcVpsUnit::deserialize() { int rez = HevcUnit::deserialize(); if (rez) return rez; try { vps_id = m_reader.getBits(4); m_reader.skipBits(2);          vps_max_layers = m_reader.getBits(6) + 1; vps_max_sub_layers = m_reader.getBits(3) + 1; int vps_temporal_id_nesting_flag = m_reader.getBit(); m_reader.skipBits(16);          profile_tier_level(vps_max_sub_layers); bool vps_sub_layer_ordering_info_present_flag = m_reader.getBit(); for (int i = (vps_sub_layer_ordering_info_present_flag ? 0 : vps_max_sub_layers - 1); i <= vps_max_sub_layers - 1; i++) { unsigned vps_max_dec_pic_buffering_minus1 = extractUEGolombCode(); unsigned vps_max_num_reorder_pics = extractUEGolombCode(); if (vps_max_num_reorder_pics > vps_max_dec_pic_buffering_minus1) return 1; unsigned vps_max_latency_increase_plus1 = extractUEGolombCode(); if (vps_max_latency_increase_plus1 == 0xffffffff) return 1; } int vps_max_layer_id = m_reader.getBits(6); unsigned vps_num_layer_sets_minus1 = extractUEGolombCode(); if (vps_num_layer_sets_minus1 > 1023) return 1; for (size_t i = 1; i <= vps_num_layer_sets_minus1; i++) { for (int j = 0; j <= vps_max_layer_id; j++) m_reader.skipBit();          } bool vps_timing_info_present_flag = m_reader.getBit(); if (vps_timing_info_present_flag) { num_units_in_tick_bit_pos = m_reader.getBitsCount(); num_units_in_tick = m_reader.getBits(32); time_scale = m_reader.getBits(32); } return rez; } catch (VodCoreException& e) { return NOT_ENOUGH_BUFFER; } }
Description: An integer overflow in DTSStreamReader::findFrame() of tsMuxer git-2678966 allows attackers to cause a Denial of Service (DoS) via a crafted file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void lexer_process_char_literal (parser_context_t *context_p,  const uint8_t *char_p,  size_t length,  uint8_t literal_type,  bool has_escape)  { parser_list_iterator_t literal_iterator; lexer_literal_t *literal_p; uint32_t literal_index = 0; JERRY_ASSERT (literal_type == LEXER_IDENT_LITERAL || literal_type == LEXER_STRING_LITERAL); JERRY_ASSERT (literal_type != LEXER_IDENT_LITERAL || length <= PARSER_MAXIMUM_IDENT_LENGTH); JERRY_ASSERT (literal_type != LEXER_STRING_LITERAL || length <= PARSER_MAXIMUM_STRING_LENGTH); parser_list_iterator_init (&context_p->literal_pool, &literal_iterator); while ((literal_p = (lexer_literal_t *) parser_list_iterator_next (&literal_iterator)) != NULL) { if (literal_p->type == literal_type && literal_p->prop.length == length && memcmp (literal_p->u.char_p, char_p, length) == 0) { context_p->lit_object.literal_p = literal_p; context_p->lit_object.index = (uint16_t) literal_index; literal_p->status_flags = (uint8_t) (literal_p->status_flags & ~LEXER_FLAG_UNUSED_IDENT); return; } literal_index++; } JERRY_ASSERT (literal_index == context_p->literal_count); if (literal_index >= PARSER_MAXIMUM_NUMBER_OF_LITERALS) { parser_raise_error (context_p, PARSER_ERR_LITERAL_LIMIT_REACHED); } literal_p = (lexer_literal_t *) parser_list_append (context_p, &context_p->literal_pool); literal_p->prop.length = (uint16_t) length; literal_p->type = literal_type; literal_p->status_flags = has_escape ? 0 : LEXER_FLAG_SOURCE_PTR; if (has_escape) { literal_p->u.char_p = (uint8_t *) jmem_heap_alloc_block (length); memcpy ((uint8_t *) literal_p->u.char_p, char_p, length); } else { literal_p->u.char_p = char_p; } context_p->lit_object.literal_p = literal_p; context_p->lit_object.index = (uint16_t) literal_index; context_p->literal_count++; }
Description: The lexer_process_char_literal function in jerry-core/parser/js/js-lexer.c in JerryScript 1.0 does not skip memory allocation for empty strings, which allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) via malformed JavaScript source code, related to the jmem_heap_free_block function.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void send_v2N_spi_response_from_state(struct ike_sa *ike, struct msg_digest *md, enum ikev2_sec_proto_id protoid, ipsec_spi_t *spi, v2_notification_t ntype, const chunk_t *ndata ) { passert(v2_msg_role(md) == MESSAGE_REQUEST);  const char *const notify_name = enum_short_name(&ikev2_notify_names, ntype); enum isakmp_xchg_types exchange_type = md->hdr.isa_xchg; const char *const exchange_name = enum_short_name(&ikev2_exchange_names, exchange_type); ipstr_buf b; libreswan_log(""responding to %s message (ID %u) from %s:%u with encrypted notification %s"", exchange_name, md->hdr.isa_msgid, sensitive_ipstr(&ike->sa.st_remoteaddr, &b), ike->sa.st_remoteport, notify_name); switch (exchange_type) { case ISAKMP_v2_IKE_SA_INIT: PEXPECT_LOG(""exchange type %s invalid for encrypted notification"", exchange_name); return; default: break; } uint8_t buf[MIN_OUTPUT_UDP_SIZE]; pb_stream reply = open_out_pbs(""encrypted notification"", buf, sizeof(buf)); pb_stream rbody = open_v2_message(&reply, ike, md , exchange_type); if (!pbs_ok(&rbody)) { libreswan_log(""error initializing hdr for encrypted notification""); return; } v2SK_payload_t sk = open_v2SK_payload(&rbody, ike); if (!pbs_ok(&sk.pbs)) { return; } switch (ntype) { case v2N_INVALID_SELECTORS: PEXPECT_LOG(""trying to send unimplemented %s notification"", notify_name); return; case v2N_REKEY_SA: PEXPECT_LOG(""%s notification cannot be part of a response"", notify_name); return; default: break; } pb_stream n_pbs; if (!emit_v2Nsa_pl(ntype, protoid, spi, &sk.pbs, &n_pbs) || (ndata != NULL && !out_chunk(*ndata, &n_pbs, ""Notify data""))) { return; } close_output_pbs(&n_pbs); if (!close_v2SK_payload(&sk)) { return; } close_output_pbs(&rbody); close_output_pbs(&reply); stf_status ret = encrypt_v2SK_payload(&sk); if (ret != STF_OK) { libreswan_log(""error encrypting notify message""); return; } send_chunk_using_state(&ike->sa, ""v2 notify"", same_out_pbs_as_chunk(&reply)); pstat(ikev2_sent_notifies_e, ntype); }
Description: In Libreswan 3.27 an assertion failure can lead to a pluto IKE daemon restart. An attacker can trigger a NULL pointer dereference by initiating an IKEv2 IKE_SA_INIT exchange, followed by a bogus INFORMATIONAL exchange instead of the normallly expected IKE_AUTH exchange. This affects send_v2N_spi_response_from_state() in programs/pluto/ikev2_send.c that will then trigger a NULL pointer dereference leading to a restart of libreswan.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void pdf_set_signature_appearance(fz_context *ctx, pdf_document *doc, pdf_annot *annot, char *name, const char *dn, char *date) { pdf_obj *obj = annot->obj; pdf_obj *dr = pdf_dict_getl(ctx, pdf_trailer(ctx, doc), PDF_NAME_Root, PDF_NAME_AcroForm, PDF_NAME_DR, NULL); fz_display_list *dlist = NULL; fz_device *dev = NULL; font_info font_rec; fz_text *text = NULL; fz_colorspace *cs = NULL; fz_path *path = NULL; fz_buffer *fzbuf = NULL; fz_matrix page_ctm; pdf_page_transform(ctx, annot->page, NULL, &page_ctm); if (!dr) pdf_dict_putl_drop(ctx, pdf_trailer(ctx, doc), pdf_new_dict(ctx, doc, 1), PDF_NAME_Root, PDF_NAME_AcroForm, PDF_NAME_DR, NULL); memset(&font_rec, 0, sizeof(font_rec)); fz_var(path); fz_var(dlist); fz_var(dev); fz_var(text); fz_var(cs); fz_var(fzbuf); fz_try(ctx) { char *da = pdf_to_str_buf(ctx, pdf_dict_get(ctx, obj, PDF_NAME_DA)); fz_rect annot_rect; fz_rect logo_bounds; fz_matrix logo_tm; fz_rect rect; pdf_to_rect(ctx, pdf_dict_get(ctx, annot->obj, PDF_NAME_Rect), &annot_rect); rect = annot_rect; dlist = fz_new_display_list(ctx, NULL); dev = fz_new_list_device(ctx, dlist); path = fz_new_path(ctx); draw_logo(ctx, path); fz_bound_path(ctx, path, NULL, &fz_identity, &logo_bounds); center_rect_within_rect(&logo_bounds, &rect, &logo_tm); fz_concat(&logo_tm, &logo_tm, &page_ctm); cs = fz_device_rgb(ctx);  fz_fill_path(ctx, dev, path, 0, &logo_tm, cs, logo_color, 1.0f, NULL); get_font_info(ctx, doc, dr, da, &font_rec); switch (font_rec.da_rec.col_size) { case 1: cs = fz_device_gray(ctx); break; case 3: cs = fz_device_rgb(ctx); break; case 4: cs = fz_device_cmyk(ctx); break; } rect.x1 = (rect.x0 + rect.x1)/2.0f; text = fit_text(ctx, &font_rec, name, &rect); fz_fill_text(ctx, dev, text, &page_ctm, cs, font_rec.da_rec.col, 1.0f, NULL); fz_drop_text(ctx, text); text = NULL; fzbuf = fz_new_buffer(ctx, 256); fz_append_printf(ctx, fzbuf, ""Digitally signed by %s"", name); fz_append_printf(ctx, fzbuf, ""\nDN: %s"", dn); if (date) fz_append_printf(ctx, fzbuf, ""\nDate: %s"", date); rect = annot_rect; rect.x0 = (rect.x0 + rect.x1)/2.0f; text = fit_text(ctx, &font_rec, fz_string_from_buffer(ctx, fzbuf), &rect); fz_fill_text(ctx, dev, text, &page_ctm, cs, font_rec.da_rec.col, 1.0f, NULL); fz_close_device(ctx, dev); rect = annot_rect; fz_transform_rect(&rect, &page_ctm); pdf_set_annot_appearance(ctx, doc, annot, &rect, dlist); pdf_drop_xobject(ctx, annot->ap); annot->ap = NULL; insert_signature_appearance_layers(ctx, doc, annot); } fz_always(ctx) { fz_drop_device(ctx, dev); fz_drop_display_list(ctx, dlist); font_info_fin(ctx, &font_rec); fz_drop_path(ctx, path); fz_drop_text(ctx, text); fz_drop_buffer(ctx, fzbuf); } fz_catch(ctx) { fz_rethrow(ctx); } }
Description: Artifex Mupdf version 1.12.0 contains a Use After Free vulnerability in fz_keep_key_storable that can result in DOS / Possible code execution. This attack appear to be exploitable via Victim opens a specially crafted PDF.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: PointerHolder<QPDFObject> QPDF::resolve(int objid, int generation) { QPDFObjGen og(objid, generation); if (! this->obj_cache.count(og)) { if (! this->xref_table.count(og)) { return new QPDF_Null; } QPDFXRefEntry const& entry = this->xref_table[og]; switch (entry.getType()) { case 1: { qpdf_offset_t offset = entry.getOffset(); int aobjid; int ageneration; QPDFObjectHandle oh = readObjectAtOffset(true, offset, """", objid, generation, aobjid, ageneration); } break; case 2: resolveObjectsInStream(entry.getObjStreamNumber()); break; default: throw QPDFExc(qpdf_e_damaged_pdf, this->file->getName(), """", 0, ""object "" + QUtil::int_to_string(objid) + ""/"" + QUtil::int_to_string(generation) + "" has unexpected xref entry type""); } } return this->obj_cache[og].object; }
Description: An issue was discovered in QPDF before 7.0.0. Endless recursion causes stack exhaustion in QPDFTokenizer::resolveLiteral() in QPDFTokenizer.cc, related to the QPDF::resolve function in QPDF.cc.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int wg_dissect_handshake_response(tvbuff_t *tvb, packet_info *pinfo, proto_tree *wg_tree, wg_packet_info_t *wg_pinfo) { guint32 sender_id, receiver_id; proto_item *ti; wg_session_t *session; #ifdef WG_DECRYPTION_SUPPORTED wg_keylog_read(); const wg_skey_t *skey_i = wg_mac1_key_probe(tvb, FALSE); #endif  proto_tree_add_item_ret_uint(wg_tree, hf_wg_sender, tvb, 4, 4, ENC_LITTLE_ENDIAN, &sender_id); col_append_fstr(pinfo->cinfo, COL_INFO, "", sender=0x%08X"", sender_id); proto_tree_add_item_ret_uint(wg_tree, hf_wg_receiver, tvb, 8, 4, ENC_LITTLE_ENDIAN, &receiver_id); col_append_fstr(pinfo->cinfo, COL_INFO, "", receiver=0x%08X"", receiver_id); if (!PINFO_FD_VISITED(pinfo)) { session = wg_sessions_lookup_initiation(pinfo, receiver_id); #ifdef WG_DECRYPTION_SUPPORTED if (session && session->hs) { wg_prepare_handshake_responder_keys(session->hs, tvb); wg_process_response(tvb, session->hs); } #endif  } else { session = wg_pinfo->session; } wg_dissect_pubkey(wg_tree, tvb, 12, TRUE); proto_tree_add_item(wg_tree, hf_wg_encrypted_empty, tvb, 44, 16, ENC_NA); #ifdef WG_DECRYPTION_SUPPORTED if (session && session->hs) { ti = proto_tree_add_boolean(wg_tree, hf_wg_handshake_ok, tvb, 0, 0, !!session->hs->empty_ok); proto_item_set_generated(ti); } #endif  proto_tree_add_item(wg_tree, hf_wg_mac1, tvb, 60, 16, ENC_NA); #ifdef WG_DECRYPTION_SUPPORTED wg_dissect_mac1_pubkey(wg_tree, tvb, skey_i); #endif  proto_tree_add_item(wg_tree, hf_wg_mac2, tvb, 76, 16, ENC_NA); if (!PINFO_FD_VISITED(pinfo)) { if (session) { session->response_frame = pinfo->num; wg_session_update_address(session, pinfo, FALSE); wg_sessions_insert(sender_id, session); wg_pinfo->session = session; } } if (session) { ti = proto_tree_add_uint(wg_tree, hf_wg_stream, tvb, 0, 0, session->stream); proto_item_set_generated(ti); ti = proto_tree_add_uint(wg_tree, hf_wg_response_to, tvb, 0, 0, session->initiator_frame); proto_item_set_generated(ti); } return 92; }
Description: In Wireshark 3.2.0 to 3.2.1, the WireGuard dissector could crash. This was addressed in epan/dissectors/packet-wireguard.c by handling the situation where a certain data structure intentionally has a NULL value.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int flv_write_packet(AVFormatContext *s, AVPacket *pkt) { AVIOContext *pb      = s->pb; AVCodecParameters *par = s->streams[pkt->stream_index]->codecpar; FLVContext *flv      = s->priv_data; FLVStreamContext *sc = s->streams[pkt->stream_index]->priv_data; unsigned ts; int size = pkt->size; uint8_t *data = NULL; int flags = -1, flags_size, ret; int64_t cur_offset = avio_tell(pb); if (par->codec_id == AV_CODEC_ID_VP6F || par->codec_id == AV_CODEC_ID_VP6A || par->codec_id == AV_CODEC_ID_VP6  || par->codec_id == AV_CODEC_ID_AAC) flags_size = 2; else if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4) flags_size = 5; else flags_size = 1; if (par->codec_id == AV_CODEC_ID_AAC || par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4) { int side_size = 0; uint8_t *side = av_packet_get_side_data(pkt, AV_PKT_DATA_NEW_EXTRADATA, &side_size); if (side && side_size > 0 && (side_size != par->extradata_size || memcmp(side, par->extradata, side_size))) { av_free(par->extradata); par->extradata = av_mallocz(side_size + AV_INPUT_BUFFER_PADDING_SIZE); if (!par->extradata) { par->extradata_size = 0; return AVERROR(ENOMEM); } memcpy(par->extradata, side, side_size); par->extradata_size = side_size; flv_write_codec_header(s, par, pkt->dts); } } if (flv->delay == AV_NOPTS_VALUE) flv->delay = -pkt->dts; if (pkt->dts < -flv->delay) { av_log(s, AV_LOG_WARNING, ""Packets are not in the proper order with respect to DTS\n""); return AVERROR(EINVAL); } ts = pkt->dts; if (s->event_flags & AVSTREAM_EVENT_FLAG_METADATA_UPDATED) { write_metadata(s, ts); s->event_flags &= ~AVSTREAM_EVENT_FLAG_METADATA_UPDATED; } avio_write_marker(pb, av_rescale(ts, AV_TIME_BASE, 1000), pkt->flags & AV_PKT_FLAG_KEY && (flv->video_par ? par->codec_type == AVMEDIA_TYPE_VIDEO : 1) ? AVIO_DATA_MARKER_SYNC_POINT : AVIO_DATA_MARKER_BOUNDARY_POINT); switch (par->codec_type) { case AVMEDIA_TYPE_VIDEO: avio_w8(pb, FLV_TAG_TYPE_VIDEO); flags = ff_codec_get_tag(flv_video_codec_ids, par->codec_id); flags |= pkt->flags & AV_PKT_FLAG_KEY ? FLV_FRAME_KEY : FLV_FRAME_INTER; break; case AVMEDIA_TYPE_AUDIO: flags = get_audio_flags(s, par); av_assert0(size); avio_w8(pb, FLV_TAG_TYPE_AUDIO); break; case AVMEDIA_TYPE_SUBTITLE: case AVMEDIA_TYPE_DATA: avio_w8(pb, FLV_TAG_TYPE_META); break; default: return AVERROR(EINVAL); } if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4) { if (par->extradata_size > 0 && *(uint8_t*)par->extradata != 1) if ((ret = ff_avc_parse_nal_units_buf(pkt->data, &data, &size)) < 0) return ret; } else if (par->codec_id == AV_CODEC_ID_AAC && pkt->size > 2 && (AV_RB16(pkt->data) & 0xfff0) == 0xfff0) { if (!s->streams[pkt->stream_index]->nb_frames) { av_log(s, AV_LOG_ERROR, ""Malformed AAC bitstream detected: "" ""use the audio bitstream filter 'aac_adtstoasc' to fix it "" ""('-bsf:a aac_adtstoasc' option with ffmpeg)\n""); return AVERROR_INVALIDDATA; } av_log(s, AV_LOG_WARNING, ""aac bitstream error\n""); } if (par->codec_id == AV_CODEC_ID_SPEEX && ts - sc->last_ts > 160) av_log(s, AV_LOG_WARNING, ""Warning: Speex stream has more than "" ""8 frames per packet. Adobe Flash "" ""Player cannot handle this!\n""); if (sc->last_ts < ts) sc->last_ts = ts; if (size + flags_size >= 1<<24) { av_log(s, AV_LOG_ERROR, ""Too large packet with size %u >= %u\n"", size + flags_size, 1<<24); return AVERROR(EINVAL); } avio_wb24(pb, size + flags_size); put_timestamp(pb, ts); avio_wb24(pb, flv->reserved); if (par->codec_type == AVMEDIA_TYPE_DATA || par->codec_type == AVMEDIA_TYPE_SUBTITLE ) { int data_size; int64_t metadata_size_pos = avio_tell(pb); if (par->codec_id == AV_CODEC_ID_TEXT) { avio_w8(pb, AMF_DATA_TYPE_STRING); put_amf_string(pb, ""onTextData""); avio_w8(pb, AMF_DATA_TYPE_MIXEDARRAY); avio_wb32(pb, 2); put_amf_string(pb, ""type""); avio_w8(pb, AMF_DATA_TYPE_STRING); put_amf_string(pb, ""Text""); put_amf_string(pb, ""text""); avio_w8(pb, AMF_DATA_TYPE_STRING); put_amf_string(pb, pkt->data); put_amf_string(pb, """"); avio_w8(pb, AMF_END_OF_OBJECT); } else { avio_write(pb, data ? data : pkt->data, size); } data_size = avio_tell(pb) - metadata_size_pos; avio_seek(pb, metadata_size_pos - 10, SEEK_SET); avio_wb24(pb, data_size); avio_seek(pb, data_size + 10 - 3, SEEK_CUR); avio_wb32(pb, data_size + 11); } else { av_assert1(flags>=0); avio_w8(pb,flags); if (par->codec_id == AV_CODEC_ID_VP6) avio_w8(pb,0); if (par->codec_id == AV_CODEC_ID_VP6F || par->codec_id == AV_CODEC_ID_VP6A) { if (par->extradata_size) avio_w8(pb, par->extradata[0]); else avio_w8(pb, ((FFALIGN(par->width,  16) - par->width) << 4) | (FFALIGN(par->height, 16) - par->height)); } else if (par->codec_id == AV_CODEC_ID_AAC) avio_w8(pb, 1);         else if (par->codec_id == AV_CODEC_ID_H264 || par->codec_id == AV_CODEC_ID_MPEG4) { avio_w8(pb, 1);             avio_wb24(pb, pkt->pts - pkt->dts); } avio_write(pb, data ? data : pkt->data, size); avio_wb32(pb, size + flags_size + 11);         flv->duration = FFMAX(flv->duration, pkt->pts + flv->delay + pkt->duration); } if (flv->flags & FLV_ADD_KEYFRAME_INDEX) { switch (par->codec_type) { case AVMEDIA_TYPE_VIDEO: flv->videosize += (avio_tell(pb) - cur_offset); flv->lasttimestamp = flv->acurframeindex / flv->framerate; if (pkt->flags & AV_PKT_FLAG_KEY) { double ts = flv->acurframeindex / flv->framerate; int64_t pos = cur_offset; flv->lastkeyframetimestamp = flv->acurframeindex / flv->framerate; flv->lastkeyframelocation = pos; flv_append_keyframe_info(s, flv, ts, pos); } flv->acurframeindex++; break; case AVMEDIA_TYPE_AUDIO: flv->audiosize += (avio_tell(pb) - cur_offset); break; default: av_log(s, AV_LOG_WARNING, ""par->codec_type is type = [%d]\n"", par->codec_type); break; } } av_free(data); return pb->error; }
Description: The flv_write_packet function in libavformat/flvenc.c in FFmpeg through 2.8 does not check for an empty audio packet, leading to an assertion failure.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int HevcUnit::deserialize() { m_reader.setBuffer(m_nalBuffer, m_nalBuffer + m_nalBufferLen); try { m_reader.skipBit(); nal_unit_type = m_reader.getBits(6); nuh_layer_id = m_reader.getBits(6); nuh_temporal_id_plus1 = m_reader.getBits(3); if (nuh_temporal_id_plus1 == 0) return 1; return 0; } catch (BitStreamException& e) { return NOT_ENOUGH_BUFFER; } }
Description: tsMuxer v2.6.16 was discovered to contain a heap-based buffer overflow via the function HevcSpsUnit::short_term_ref_pic_set(int) in hevc.cpp.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static bool pb_release_union_field(pb_istream_t *stream, pb_field_iter_t *field) { pb_field_iter_t old_field = *field; pb_size_t old_tag = *(pb_size_t*)field->pSize;  pb_size_t new_tag = field->tag;  if (old_tag == 0) return true;  if (old_tag == new_tag) return true;  if (!pb_field_iter_find(&old_field, old_tag)) PB_RETURN_ERROR(stream, ""invalid union tag""); pb_release_single_field(&old_field); return true; }
Description: Nanopb is a small code-size Protocol Buffers implementation in ansi C. In Nanopb before versions 0.3.9.8 and 0.4.5, decoding a specifically formed message can cause invalid `free()` or `realloc()` calls if the message type contains an `oneof` field, and the `oneof` directly contains both a pointer field and a non-pointer field. If the message data first contains the non-pointer field and then the pointer field, the data of the non-pointer field is incorrectly treated as if it was a pointer value. Such message data rarely occurs in normal messages, but it is a concern when untrusted data is parsed. This has been fixed in versions 0.3.9.8 and 0.4.5. See referenced GitHub Security Advisory for more information including workarounds.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool get(unsigned index) const { ASSERT_WITH_SECURITY_IMPLICATION(index < arraySize); return !!(m_data[index / 8] & (1 << (index & 7))); }
Description: Blink, as used in Google Chrome before 50.0.2661.94, mishandles assertions in the WTF::BitArray and WTF::double_conversion::Vector classes, which allows remote attackers to cause a denial of service (out-of-bounds write) or possibly have unspecified other impact via a crafted web site.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int smtp_mailaddr(struct mailaddr *maddr, char *line, int mailfrom, char **args, const char *domain) { char   *p, *e; if (line == NULL) return (0); if (*line != '<') return (0); e = strchr(line, '>'); if (e == NULL) return (0); *e++ = '\0'; while (*e == ' ') e++; *args = e; if (!text_to_mailaddr(maddr, line + 1)) return (0); p = strchr(maddr->user, ':'); if (p != NULL) { p++; memmove(maddr->user, p, strlen(p) + 1); } if (!valid_localpart(maddr->user) || !valid_domainpart(maddr->domain)) { if (mailfrom && maddr->user[0] == '\0' && maddr->domain[0] == '\0') return (1); if (maddr->user[0] == '\0') return (0); if (maddr->domain[0] == '\0') { (void)strlcpy(maddr->domain, domain, sizeof(maddr->domain)); return (1); } return (0); } return (1); }
Description: smtp_mailaddr in smtp_session.c in OpenSMTPD 6.6, as used in OpenBSD 6.6 and other products, allows remote attackers to execute arbitrary commands as root via a crafted SMTP session, as demonstrated by shell metacharacters in a MAIL FROM field. This affects the ""uncommented"" default configuration. The issue exists because of an incorrect return value upon failure of input validation.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void decompress_directory(string extract_dir, bool std_out) { char c; string curdir; size_t r = 0; unsigned int chunk_size; curdir = string(extract_dir); for(;;) { r = aread(&c, 1); if (r == 0) return; if(c == 'D') { chunk_size = fread32(); try_aread(tmp, chunk_size + 1); curdir = curdir + DELIM_STR + tmp; PRINT(FILES_PROCESSED, ""%s%s%s\n"", BLANK_LINE, remove_leading_curdir(curdir).c_str(), DELIM_STR); if(!std_out) { #ifdef WINDOWS CreateDirectory(curdir.c_str(), 0); #else mkdir(curdir.c_str(), 509); #endif } } else if(c == 'U') curdir = curdir.substr(0, curdir.find_last_of(DELIM_STR));         else if(c == 'F') { chunk_size = fread32();             try_aread(tmp, chunk_size + 1);             string buf2 = curdir + DELIM_STR + tmp; PRINT(FILES_PROCESSED, ""%s    %s\n"", BLANK_LINE, tmp); if(!std_out) { if(exists(buf2) && !force_flag) abort(""Destination file '%s' already exists - aborted"", buf2.c_str()); else decompress_file(buf2); } else decompress_file(""<stdout>""); } else abort(""Source file is corrupted - try the -R flag to recover""); } }
Description: qpress before PierreLvx/qpress 20220819 and before version 11.3, as used in Percona XtraBackup and other products, allows directory traversal via ../ in a .qp file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Maybe<bool> Object::SetPropertyInternal(LookupIterator* it, Handle<Object> value, LanguageMode language_mode, StoreFromKeyed store_mode, bool* found) { it->UpdateProtector(); DCHECK(it->IsFound()); ShouldThrow should_throw = is_sloppy(language_mode) ? DONT_THROW : THROW_ON_ERROR; AssertNoContextChange ncc(it->isolate()); do { switch (it->state()) { case LookupIterator::NOT_FOUND: UNREACHABLE(); case LookupIterator::ACCESS_CHECK: if (it->HasAccess()) break; return JSObject::SetPropertyWithFailedAccessCheck(it, value, should_throw); case LookupIterator::JSPROXY: return JSProxy::SetProperty(it->GetHolder<JSProxy>(), it->GetName(), value, it->GetReceiver(), language_mode); case LookupIterator::INTERCEPTOR: if (it->HolderIsReceiverOrHiddenPrototype()) { Maybe<bool> result = JSObject::SetPropertyWithInterceptor(it, should_throw, value); if (result.IsNothing() || result.FromJust()) return result; } else { Maybe<PropertyAttributes> maybe_attributes = JSObject::GetPropertyAttributesWithInterceptor(it); if (!maybe_attributes.IsJust()) return Nothing<bool>(); if (maybe_attributes.FromJust() == ABSENT) break; if ((maybe_attributes.FromJust() & READ_ONLY) != 0) { return WriteToReadOnlyProperty(it, value, should_throw); } *found = false; return Nothing<bool>(); } break; case LookupIterator::ACCESSOR: { if (it->IsReadOnly()) { return WriteToReadOnlyProperty(it, value, should_throw); } Handle<Object> accessors = it->GetAccessors(); if (accessors->IsAccessorInfo() && !it->HolderIsReceiverOrHiddenPrototype() && AccessorInfo::cast(*accessors)->is_special_data_property()) { *found = false; return Nothing<bool>(); } return SetPropertyWithAccessor(it, value, should_throw); } case LookupIterator::INTEGER_INDEXED_EXOTIC: return Just(true); case LookupIterator::DATA: if (it->IsReadOnly()) { return WriteToReadOnlyProperty(it, value, should_throw); } if (it->HolderIsReceiverOrHiddenPrototype()) { return SetDataProperty(it, value); } case LookupIterator::TRANSITION: *found = false; return Nothing<bool>(); } it->Next(); } while (it->IsFound()); *found = false; return Nothing<bool>(); }
Description: objects.cc in Google V8 before 5.2.361.27, as used in Google Chrome before 52.0.2743.82, does not prevent API interceptors from modifying a store target without setting a property, which allows remote attackers to bypass the Same Origin Policy via a crafted web site.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: xmlXPathObjectPtr xmlXPtrNewRange(xmlNodePtr start, int startindex, xmlNodePtr end, int endindex) { xmlXPathObjectPtr ret; if (start == NULL) return(NULL); if (end == NULL) return(NULL); if (startindex < 0) return(NULL); if (endindex < 0) return(NULL); ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject)); if (ret == NULL) { xmlXPtrErrMemory(""allocating range""); return(NULL); } memset(ret, 0 , (size_t) sizeof(xmlXPathObject)); ret->type = XPATH_RANGE; ret->user = start; ret->index = startindex; ret->user2 = end; ret->index2 = endindex; xmlXPtrRangeCheckOrder(ret); return(ret); }
Description: xpointer.c in libxml2 before 2.9.5 (as used in Apple iOS before 10, OS X before 10.12, tvOS before 10, and watchOS before 3, and other products) does not forbid namespace nodes in XPointer ranges, which allows remote attackers to execute arbitrary code or cause a denial of service (use-after-free and memory corruption) via a crafted XML document.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static bool file_asynch_zero (struct rw *rw, struct command *command, nbd_completion_callback cb, bool allocate) { int dummy = 0; if (!file_synch_zero (rw, command->offset, command->slice.len, allocate)) return false; if (cb.callback (cb.user_data, &dummy) == -1) { perror (rw->name); exit (EXIT_FAILURE); } return true; }
Description: A flaw was found in the copying tool `nbdcopy` of libnbd. When performing multi-threaded copies using asynchronous nbd calls, nbdcopy was blindly treating the completion of an asynchronous command as successful, rather than checking the *error parameter. This could result in the silent creation of a corrupted destination image.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int md_is_link_label(MD_CTX* ctx, const MD_LINE* lines, int n_lines, OFF beg, OFF* p_end, int* p_beg_line_index, int* p_end_line_index, OFF* p_contents_beg, OFF* p_contents_end) { OFF off = beg; OFF contents_beg = 0; OFF contents_end = 0; int line_index = 0; int len = 0; if(CH(off) != _T('[')) return FALSE; off++; while(line_index < n_lines) { OFF line_end = lines[line_index].end; while(off < line_end) { if(CH(off) == _T('\\')  &&  off+1 < ctx->size  &&  (ISPUNCT(off+1) || ISNEWLINE(off+1))) { if(contents_end == 0) { contents_beg = off; *p_beg_line_index = line_index; } contents_end = off + 2; off += 2; } else if(CH(off) == _T('[')) { return FALSE; } else if(CH(off) == _T(']')) { if(contents_beg < contents_end) { *p_contents_beg = contents_beg; *p_contents_end = contents_end; *p_end = off+1; *p_end_line_index = line_index; return TRUE; } else { return FALSE; } } else { int codepoint; SZ char_size; codepoint = md_decode_unicode(ctx->text, off, ctx->size, &char_size); if(!ISUNICODEWHITESPACE_(codepoint)) { if(contents_end == 0) { contents_beg = off; *p_beg_line_index = line_index; } contents_end = off + char_size; } off += char_size; } len++; if(len > 999) return FALSE; } line_index++; len++; off = lines[line_index].beg; } return FALSE; }
Description: md_is_link_reference_definition_helper in md4c 0.2.5 has a heap-based buffer over-read because md_is_link_label mishandles loop termination.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static ssize_t vcs_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos) { struct inode *inode = file_inode(file); struct vc_data *vc; long pos; long attr, size, written; char *con_buf0; int col, maxcol, viewed; u16 *org0 = NULL, *org = NULL; size_t ret; char *con_buf; con_buf = (char *) __get_free_page(GFP_KERNEL); if (!con_buf) return -ENOMEM; pos = *ppos; console_lock(); attr = use_attributes(inode); ret = -ENXIO; vc = vcs_vc(inode, &viewed); if (!vc) goto unlock_out; size = vcs_size(inode); ret = -EINVAL; if (pos < 0 || pos > size) goto unlock_out; if (count > size - pos) count = size - pos; written = 0; while (count) { long this_round = count; size_t orig_count; long p; if (this_round > CON_BUF_SIZE) this_round = CON_BUF_SIZE; console_unlock(); ret = copy_from_user(con_buf, buf, this_round); console_lock(); if (ret) { this_round -= ret; if (!this_round) { if (written) break; ret = -EFAULT; goto unlock_out; } } size = vcs_size(inode); if (size < 0) { if (written) break; ret = size; goto unlock_out; } if (pos >= size) break; if (this_round > size - pos) this_round = size - pos; con_buf0 = con_buf; orig_count = this_round; maxcol = vc->vc_cols; p = pos; if (!attr) { org0 = org = screen_pos(vc, p, viewed); col = p % maxcol; p += maxcol - col; while (this_round > 0) { unsigned char c = *con_buf0++; this_round--; vcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff00) | c, org); org++; if (++col == maxcol) { org = screen_pos(vc, p, viewed); col = 0; p += maxcol; } } } else { if (p < HEADER_SIZE) { char header[HEADER_SIZE]; getconsxy(vc, header + 2); while (p < HEADER_SIZE && this_round > 0) { this_round--; header[p++] = *con_buf0++; } if (!viewed) putconsxy(vc, header + 2); } p -= HEADER_SIZE; col = (p/2) % maxcol; if (this_round > 0) { org0 = org = screen_pos(vc, p/2, viewed); if ((p & 1) && this_round > 0) { char c; this_round--; c = *con_buf0++; #ifdef __BIG_ENDIAN vcs_scr_writew(vc, c | (vcs_scr_readw(vc, org) & 0xff00), org); #else vcs_scr_writew(vc, (c << 8) | (vcs_scr_readw(vc, org) & 0xff), org); #endif org++; p++; if (++col == maxcol) { org = screen_pos(vc, p/2, viewed); col = 0; } } p /= 2; p += maxcol - col; } while (this_round > 1) { unsigned short w; w = get_unaligned(((unsigned short *)con_buf0)); vcs_scr_writew(vc, w, org++); con_buf0 += 2; this_round -= 2; if (++col == maxcol) { org = screen_pos(vc, p, viewed); col = 0; p += maxcol; } } if (this_round > 0) { unsigned char c; c = *con_buf0++; #ifdef __BIG_ENDIAN vcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff) | (c << 8), org); #else vcs_scr_writew(vc, (vcs_scr_readw(vc, org) & 0xff00) | c, org); #endif } } count -= orig_count; written += orig_count; buf += orig_count; pos += orig_count; if (org0) update_region(vc, (unsigned long)(org0), org - org0); } *ppos += written; ret = written; if (written) vcs_scr_updated(vc); unlock_out: console_unlock(); free_page((unsigned long) con_buf); return ret; }
Description: vcs_write in drivers/tty/vt/vc_screen.c in the Linux kernel through 5.3.13 does not prevent write access to vcsu devices, aka CID-0c9acb1af77a.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: GF_Err ctts_box_read(GF_Box *s, GF_BitStream *bs) { u32 i; u32 sampleCount; GF_CompositionOffsetBox *ptr = (GF_CompositionOffsetBox *)s; ISOM_DECREASE_SIZE(ptr, 4); ptr->nb_entries = gf_bs_read_u32(bs); if (ptr->nb_entries > ptr->size / 8 || (u64)ptr->nb_entries > (u64)SIZE_MAX/sizeof(GF_DttsEntry) ) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Invalid number of entries %d in ctts\n"", ptr->nb_entries)); return GF_ISOM_INVALID_FILE; } ptr->alloc_size = ptr->nb_entries; ptr->entries = (GF_DttsEntry *)gf_malloc(sizeof(GF_DttsEntry)*ptr->alloc_size); if (!ptr->entries) return GF_OUT_OF_MEM; sampleCount = 0; for (i=0; i<ptr->nb_entries; i++) { ISOM_DECREASE_SIZE(ptr, 8); ptr->entries[i].sampleCount = gf_bs_read_u32(bs); if (ptr->version) ptr->entries[i].decodingOffset = gf_bs_read_int(bs, 32); else ptr->entries[i].decodingOffset = (s32) gf_bs_read_u32(bs); if (ptr->max_cts_delta <= ABS(ptr->entries[i].decodingOffset)) { ptr->max_cts_delta = ABS(ptr->entries[i].decodingOffset); } sampleCount += ptr->entries[i].sampleCount; } #ifndef GPAC_DISABLE_ISOM_WRITE ptr->w_LastSampleNumber = sampleCount; #endif return GF_OK; }
Description: An issue in GPAC v.2.2.1 and before allows a local attacker to cause a denial of service (DoS) via the ctts_box_read function of file src/isomedia/box_code_base.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void bpf_map_mmap_open(struct vm_area_struct *vma) { struct bpf_map *map = vma->vm_file->private_data; if (vma->vm_flags & VM_MAYWRITE) { mutex_lock(&map->freeze_mutex); map->writecnt++; mutex_unlock(&map->freeze_mutex); } }
Description: A race condition was found in the Linux kernel's ebpf verifier between bpf_map_update_elem and bpf_map_freeze due to a missing lock in kernel/bpf/syscall.c. In this flaw, a local user with a special privilege (cap_sys_admin or cap_bpf) can modify the frozen mapped address space. This flaw affects kernel versions prior to 5.16 rc2.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void cfile_open_failure_message(const char *progname, const char *filename, int err, gchar *err_info) { if (err < 0) { char *file_description = input_file_description(filename); switch (err) { case WTAP_ERR_NOT_REGULAR_FILE: cmdarg_err(""The %s is a \""special file\"" or socket or other non-regular file."", file_description); break; case WTAP_ERR_RANDOM_OPEN_PIPE: cmdarg_err(""The %s is a pipe or FIFO; %s can't read pipe or FIFO files in two-pass mode."", file_description, progname); break; case WTAP_ERR_FILE_UNKNOWN_FORMAT: cmdarg_err(""The %s isn't a capture file in a format %s understands."", file_description, progname); break; case WTAP_ERR_UNSUPPORTED: cmdarg_err(""The %s contains record data that %s doesn't support.\n"" ""(%s)"", file_description, progname, err_info != NULL ? err_info : ""no information supplied""); g_free(err_info); break; case WTAP_ERR_ENCAP_PER_PACKET_UNSUPPORTED: cmdarg_err(""The %s is a capture for a network type that %s doesn't support."", file_description, progname); break; case WTAP_ERR_BAD_FILE: cmdarg_err(""The %s appears to be damaged or corrupt.\n"" ""(%s)"", file_description, err_info != NULL ? err_info : ""no information supplied""); g_free(err_info); break; case WTAP_ERR_CANT_OPEN: cmdarg_err(""The %s could not be opened for some unknown reason."", file_description); break; case WTAP_ERR_SHORT_READ: cmdarg_err(""The %s appears to have been cut short in the middle of a packet or other data."", file_description); break; case WTAP_ERR_DECOMPRESS: cmdarg_err(""The %s cannot be decompressed; it may be damaged or corrupt."" ""(%s)"", file_description, err_info != NULL ? err_info : ""no information supplied""); g_free(err_info); break; case WTAP_ERR_DECOMPRESSION_NOT_SUPPORTED: cmdarg_err(""The %s cannot be decompressed; it is compressed in a way that we don't support."" ""(%s)"", file_description, err_info != NULL ? err_info : ""no information supplied""); g_free(err_info); break; default: cmdarg_err(""The %s could not be opened: %s."", file_description, wtap_strerror(err)); break; } g_free(file_description); } else cmdarg_err(file_open_error_message(err, FALSE), filename); }
Description: In Wireshark 2.4.0 to 2.4.5 and 2.2.0 to 2.2.13, ui/failure_message.c has a memory leak.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: uint8_t ethereum_extractThorchainData(const EthereumSignTx *msg, char *buffer) { uint16_t offset = 4 + (5 * 32); int16_t len = msg->data_length - offset; if (msg->has_data_length && len > 0) { memcpy(buffer, msg->data_initial_chunk.bytes + offset, len); return len < 256 ? (uint8_t)len : 0; } return 0; }
Description: Insufficient length checks in the ShapeShift KeepKey hardware wallet firmware before 7.1.0 allow a stack buffer overflow via crafted messages. The overflow in ethereum_extractThorchainSwapData() in ethereum.c can circumvent stack protections and lead to code execution. The vulnerable interface is reachable remotely over WebUSB.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int srs_timestamp_check(srs_t *srs, const char *stamp) { const char*sp; char*bp; int off; time_t now; time_t then; then = 0; for (sp = stamp; *sp; sp++) { bp = strchr(SRS_TIME_BASECHARS, toupper(*sp)); if (bp == NULL) return SRS_EBADTIMESTAMPCHAR; off = bp - SRS_TIME_BASECHARS; then = (then << SRS_TIME_BASEBITS) | off; } time(&now); now = (now / SRS_TIME_PRECISION) % SRS_TIME_SLOTS; while (now < then) now = now + SRS_TIME_SLOTS; if (now <= then + srs->maxage) return SRS_SUCCESS; return SRS_ETIMESTAMPOUTOFDATE; }
Description: srs2.c in PostSRSd before 1.10 allows remote attackers to cause a denial of service (CPU consumption) via a long timestamp tag in an SRS address.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int XSetIconName ( register Display *dpy, Window w, _Xconst char *icon_name) { return XChangeProperty(dpy, w, XA_WM_ICON_NAME, XA_STRING, 8, PropModeReplace, (_Xconst unsigned char *)icon_name, icon_name ? (int) strlen(icon_name) : 0); }
Description: LookupCol.c in X.Org X through X11R7.7 and libX11 before 1.7.1 might allow remote attackers to execute arbitrary code. The libX11 XLookupColor request (intended for server-side color lookup) contains a flaw allowing a client to send color-name requests with a name longer than the maximum size allowed by the protocol (and also longer than the maximum packet size for normal-sized packets). The user-controlled data exceeding the maximum size is then interpreted by the server as additional X protocol requests and executed, e.g., to disable X server authorization completely. For example, if the victim encounters malicious terminal control sequences for color codes, then the attacker may be able to take full control of the running graphical session.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: zmq::ws_engine_t::ws_engine_t (fd_t fd_, const options_t &options_, const endpoint_uri_pair_t &endpoint_uri_pair_, const ws_address_t &address_, bool client_) : stream_engine_base_t (fd_, options_, endpoint_uri_pair_), _client (client_), _address (address_), _client_handshake_state (client_handshake_initial), _server_handshake_state (handshake_initial), _header_name_position (0), _header_value_position (0), _header_upgrade_websocket (false), _header_connection_upgrade (false), _heartbeat_timeout (0) { memset (_websocket_key, 0, MAX_HEADER_VALUE_LENGTH + 1); memset (_websocket_accept, 0, MAX_HEADER_VALUE_LENGTH + 1); memset (_websocket_protocol, 0, 256); _next_msg = &ws_engine_t::next_handshake_command; _process_msg = &ws_engine_t::process_handshake_command; _close_msg.init (); if (_options.heartbeat_interval > 0) { _heartbeat_timeout = _options.heartbeat_timeout; if (_heartbeat_timeout == -1) _heartbeat_timeout = _options.heartbeat_interval; } }
Description: In ZeroMQ before version 4.3.3, there is a denial-of-service vulnerability. Users with TCP transport public endpoints, even with CURVE/ZAP enabled, are impacted. If a raw TCP socket is opened and connected to an endpoint that is fully configured with CURVE/ZAP, legitimate clients will not be able to exchange any message. Handshakes complete successfully, and messages are delivered to the library, but the server application never receives them. This is patched in version 4.3.3.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static s32 avc_parse_slice(GF_BitStream *bs, AVCState *avc, Bool svc_idr_flag, AVCSliceInfo *si) { s32 pps_id, num_ref_idx_l0_active_minus1 = 0, num_ref_idx_l1_active_minus1 = 0; gf_bs_read_ue_log(bs, ""first_mb_in_slice""); si->slice_type = gf_bs_read_ue_log(bs, ""slice_type""); if (si->slice_type > 9) return -1; pps_id = gf_bs_read_ue_log(bs, ""pps_id""); if (pps_id > 255) return -1; si->pps = &avc->pps[pps_id]; if (!si->pps->slice_group_count) return -2; si->sps = &avc->sps[si->pps->sps_id]; if (!si->sps->log2_max_frame_num) return -2; avc->sps_active_idx = si->pps->sps_id; avc->pps_active_idx = pps_id; si->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, ""frame_num""); si->field_pic_flag = 0; si->bottom_field_flag = 0; if (!si->sps->frame_mbs_only_flag) { si->field_pic_flag = gf_bs_read_int_log(bs, 1, ""field_pic_flag""); if (si->field_pic_flag) si->bottom_field_flag = gf_bs_read_int_log(bs, 1, ""bottom_field_flag""); } if ((si->nal_unit_type == GF_AVC_NALU_IDR_SLICE) || svc_idr_flag) si->idr_pic_id = gf_bs_read_ue_log(bs, ""idr_pic_id""); if (si->sps->poc_type == 0) { si->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, ""poc_lsb""); if (si->pps->pic_order_present && !si->field_pic_flag) { si->delta_poc_bottom = gf_bs_read_se_log(bs, ""poc_lsb""); } } else if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) { si->delta_poc[0] = gf_bs_read_se_log(bs, ""delta_poc0""); if ((si->pps->pic_order_present == 1) && !si->field_pic_flag) si->delta_poc[1] = gf_bs_read_se_log(bs, ""delta_poc1""); } if (si->pps->redundant_pic_cnt_present) { si->redundant_pic_cnt = gf_bs_read_ue_log(bs, ""redundant_pic_cnt""); } if (si->slice_type % 5 == GF_AVC_TYPE_B) { gf_bs_read_int_log(bs, 1, ""direct_spatial_mv_pred_flag""); } num_ref_idx_l0_active_minus1 = si->pps->num_ref_idx_l0_default_active_minus1; num_ref_idx_l1_active_minus1 = si->pps->num_ref_idx_l1_default_active_minus1; if (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_B) { Bool num_ref_idx_active_override_flag = gf_bs_read_int_log(bs, 1, ""num_ref_idx_active_override_flag""); if (num_ref_idx_active_override_flag) { num_ref_idx_l0_active_minus1 = gf_bs_read_ue_log(bs, ""num_ref_idx_l0_active_minus1""); if (si->slice_type % 5 == GF_AVC_TYPE_B) { num_ref_idx_l1_active_minus1 = gf_bs_read_ue_log(bs, ""num_ref_idx_l1_active_minus1""); } } } if (si->nal_unit_type == 20 || si->nal_unit_type == 21) { GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[avc-h264] unimplemented ref_pic_list_mvc_modification() in slide header\n"")); assert(0); return -1; } else { ref_pic_list_modification(bs, si->slice_type); } if ((si->pps->weighted_pred_flag && (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP)) || (si->pps->weighted_bipred_idc == 1 && si->slice_type % 5 == GF_AVC_TYPE_B)) { pred_weight_table(bs, si->slice_type, si->sps->ChromaArrayType, num_ref_idx_l0_active_minus1, num_ref_idx_l1_active_minus1); } if (si->nal_ref_idc != 0) { dec_ref_pic_marking(bs, (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE)); } if (si->pps->entropy_coding_mode_flag && si->slice_type % 5 != GF_AVC_TYPE_I && si->slice_type % 5 != GF_AVC_TYPE_SI) { gf_bs_read_ue_log(bs, ""cabac_init_idc""); } gf_bs_read_se(bs); if (si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_SI) { if (si->slice_type % 5 == GF_AVC_TYPE_SP) { gf_bs_read_int_log(bs, 1, ""sp_for_switch_flag""); } gf_bs_read_se_log(bs, ""slice_qs_delta""); } if (si->pps->deblocking_filter_control_present_flag) { if (gf_bs_read_ue_log(bs, ""disable_deblocking_filter_idc"") != 1) { gf_bs_read_se_log(bs, ""slice_alpha_c0_offset_div2""); gf_bs_read_se_log(bs, ""slice_beta_offset_div2""); } } if (si->pps->slice_group_count > 1 && si->pps->mb_slice_group_map_type >= 3 && si->pps->mb_slice_group_map_type <= 5) { gf_bs_read_int_log(bs, (u32)ceil(log1p((si->pps->pic_size_in_map_units_minus1 + 1) / (si->pps->slice_group_change_rate_minus1 + 1) ) / log(2)), ""slice_group_change_cycle""); } return 0; }
Description: A Segmentation fault caused by null pointer dereference vulnerability eists in Gpac through 1.0.2 via the avc_parse_slice function in av_parsers.c when using mp4box, which causes a denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static lpae_t *p2m_get_root_pointer(struct p2m_domain *p2m, gfn_t gfn) { unsigned int root_table; if ( P2M_ROOT_PAGES == 1 ) return __map_domain_page(p2m->root); ASSERT(P2M_ROOT_LEVEL > 0); root_table = gfn_x(gfn) >> (level_orders[P2M_ROOT_LEVEL - 1]); root_table &= LPAE_ENTRY_MASK; if ( root_table >= P2M_ROOT_PAGES ) return NULL; return __map_domain_page(p2m->root + root_table); }
Description: An issue was discovered in Xen through 4.12.x allowing ARM guest OS users to cause a denial of service via a XENMEM_add_to_physmap hypercall. p2m->max_mapped_gfn is used by the functions p2m_resolve_translation_fault() and p2m_get_entry() to sanity check guest physical frame. The rest of the code in the two functions will assume that there is a valid root table and check that with BUG_ON(). The function p2m_get_root_pointer() will ignore the unused top bits of a guest physical frame. This means that the function p2m_set_entry() will alias the frame. However, p2m->max_mapped_gfn will be updated using the original frame. It would be possible to set p2m->max_mapped_gfn high enough to cover a frame that would lead p2m_get_root_pointer() to return NULL in p2m_get_entry() and p2m_resolve_translation_fault(). Additionally, the sanity check on p2m->max_mapped_gfn is off-by-one allowing ""highest mapped + 1"" to be considered valid. However, p2m_get_root_pointer() will return NULL. The problem could be triggered with a specially crafted hypercall XENMEM_add_to_physmap{, _batch} followed by an access to an address (via hypercall or direct access) that passes the sanity check but cause p2m_get_root_pointer() to return NULL. A malicious guest administrator may cause a hypervisor crash, resulting in a Denial of Service (DoS). Xen version 4.8 and newer are vulnerable. Only Arm systems are vulnerable. x86 systems are not affected.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool RenderFrameHostImpl::OnMessageReceived(const IPC::Message &msg) { if (is_swapped_out()) { if (!SwappedOutMessages::CanHandleWhileSwappedOut(msg)) { if (msg.is_sync()) { IPC::Message* reply = IPC::SyncMessage::GenerateReply(&msg); reply->set_reply_error(); Send(reply); } return true; } } bool handled = true; IPC_BEGIN_MESSAGE_MAP(RenderFrameHostImpl, msg) IPC_MESSAGE_HANDLER(FrameHostMsg_RenderProcessGone, OnRenderProcessGone) IPC_MESSAGE_UNHANDLED(handled = false) IPC_END_MESSAGE_MAP() if (handled) return true; if (delegate_->OnMessageReceived(this, msg)) return true; RenderFrameProxyHost* proxy = frame_tree_node_->render_manager()->GetProxyToParent(); if (proxy && proxy->cross_process_frame_connector() && proxy->cross_process_frame_connector()->OnMessageReceived(msg)) return true; handled = true; IPC_BEGIN_MESSAGE_MAP(RenderFrameHostImpl, msg) IPC_MESSAGE_HANDLER(FrameHostMsg_AddMessageToConsole, OnAddMessageToConsole) IPC_MESSAGE_HANDLER(FrameHostMsg_Detach, OnDetach) IPC_MESSAGE_HANDLER(FrameHostMsg_FrameFocused, OnFrameFocused) IPC_MESSAGE_HANDLER(FrameHostMsg_DidStartProvisionalLoad, OnDidStartProvisionalLoad) IPC_MESSAGE_HANDLER(FrameHostMsg_DidFailProvisionalLoadWithError, OnDidFailProvisionalLoadWithError) IPC_MESSAGE_HANDLER(FrameHostMsg_DidFailLoadWithError, OnDidFailLoadWithError) IPC_MESSAGE_HANDLER_GENERIC(FrameHostMsg_DidCommitProvisionalLoad, OnDidCommitProvisionalLoad(msg)) IPC_MESSAGE_HANDLER(FrameHostMsg_DidDropNavigation, OnDidDropNavigation) IPC_MESSAGE_HANDLER(FrameHostMsg_UpdateState, OnUpdateState) IPC_MESSAGE_HANDLER(FrameHostMsg_OpenURL, OnOpenURL) IPC_MESSAGE_HANDLER(FrameHostMsg_DocumentOnLoadCompleted, OnDocumentOnLoadCompleted) IPC_MESSAGE_HANDLER(FrameHostMsg_BeforeUnload_ACK, OnBeforeUnloadACK) IPC_MESSAGE_HANDLER(FrameHostMsg_SwapOut_ACK, OnSwapOutACK) IPC_MESSAGE_HANDLER(FrameHostMsg_ContextMenu, OnContextMenu) IPC_MESSAGE_HANDLER(FrameHostMsg_JavaScriptExecuteResponse, OnJavaScriptExecuteResponse) IPC_MESSAGE_HANDLER(FrameHostMsg_VisualStateResponse, OnVisualStateResponse) IPC_MESSAGE_HANDLER_DELAY_REPLY(FrameHostMsg_RunJavaScriptMessage, OnRunJavaScriptMessage) IPC_MESSAGE_HANDLER_DELAY_REPLY(FrameHostMsg_RunBeforeUnloadConfirm, OnRunBeforeUnloadConfirm) IPC_MESSAGE_HANDLER(FrameHostMsg_DidAccessInitialDocument, OnDidAccessInitialDocument) IPC_MESSAGE_HANDLER(FrameHostMsg_DidChangeOpener, OnDidChangeOpener) IPC_MESSAGE_HANDLER(FrameHostMsg_DidChangeName, OnDidChangeName) IPC_MESSAGE_HANDLER(FrameHostMsg_EnforceStrictMixedContentChecking, OnEnforceStrictMixedContentChecking) IPC_MESSAGE_HANDLER(FrameHostMsg_DidAssignPageId, OnDidAssignPageId) IPC_MESSAGE_HANDLER(FrameHostMsg_DidChangeSandboxFlags, OnDidChangeSandboxFlags) IPC_MESSAGE_HANDLER(FrameHostMsg_DidChangeFrameOwnerProperties, OnDidChangeFrameOwnerProperties) IPC_MESSAGE_HANDLER(FrameHostMsg_UpdateTitle, OnUpdateTitle) IPC_MESSAGE_HANDLER(FrameHostMsg_UpdateEncoding, OnUpdateEncoding) IPC_MESSAGE_HANDLER(FrameHostMsg_BeginNavigation, OnBeginNavigation) IPC_MESSAGE_HANDLER(FrameHostMsg_DispatchLoad, OnDispatchLoad) IPC_MESSAGE_HANDLER(FrameHostMsg_TextSurroundingSelectionResponse, OnTextSurroundingSelectionResponse) IPC_MESSAGE_HANDLER(AccessibilityHostMsg_Events, OnAccessibilityEvents) IPC_MESSAGE_HANDLER(AccessibilityHostMsg_LocationChanges, OnAccessibilityLocationChanges) IPC_MESSAGE_HANDLER(AccessibilityHostMsg_FindInPageResult, OnAccessibilityFindInPageResult) IPC_MESSAGE_HANDLER(AccessibilityHostMsg_SnapshotResponse, OnAccessibilitySnapshotResponse) IPC_MESSAGE_HANDLER(FrameHostMsg_ToggleFullscreen, OnToggleFullscreen) IPC_MESSAGE_HANDLER(FrameHostMsg_DidStartLoading, OnDidStartLoading) IPC_MESSAGE_HANDLER(FrameHostMsg_DidStopLoading, OnDidStopLoading) IPC_MESSAGE_HANDLER(FrameHostMsg_DidChangeLoadProgress, OnDidChangeLoadProgress) IPC_MESSAGE_HANDLER(FrameHostMsg_SerializeAsMHTMLResponse, OnSerializeAsMHTMLResponse) #if defined(OS_MACOSX) || defined(OS_ANDROID) IPC_MESSAGE_HANDLER(FrameHostMsg_ShowPopup, OnShowPopup) IPC_MESSAGE_HANDLER(FrameHostMsg_HidePopup, OnHidePopup) #endif IPC_END_MESSAGE_MAP() return handled; }
Description: Google Chrome before 53.0.2785.113 does not ensure that the recipient of a certain IPC message is a valid RenderFrame or RenderWidget, which allows remote attackers to cause a denial of service (invalid pointer dereference and application crash) or possibly have unspecified other impact by leveraging access to a renderer process, related to render_frame_host_impl.cc and render_widget_host_impl.cc, as demonstrated by a Password Manager message.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int rsi_send_beacon(struct rsi_common *common) { struct sk_buff *skb = NULL; u8 dword_align_bytes = 0; skb = dev_alloc_skb(MAX_MGMT_PKT_SIZE); if (!skb) return -ENOMEM; memset(skb->data, 0, MAX_MGMT_PKT_SIZE); dword_align_bytes = ((unsigned long)skb->data & 0x3f); if (dword_align_bytes) skb_pull(skb, (64 - dword_align_bytes)); if (rsi_prepare_beacon(common, skb)) { rsi_dbg(ERR_ZONE, ""Failed to prepare beacon\n""); return -EINVAL; } skb_queue_tail(&common->tx_queue[MGMT_BEACON_Q], skb); rsi_set_event(&common->tx_thread.event); rsi_dbg(DATA_TX_ZONE, ""%s: Added to beacon queue\n"", __func__); return 0; }
Description: A memory leak in the rsi_send_beacon() function in drivers/net/wireless/rsi/rsi_91x_mgmt.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering rsi_prepare_beacon() failures, aka CID-d563131ef23c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static Image *ReadAVSImage(const ImageInfo *image_info,ExceptionInfo *exception) { Image *image; MagickBooleanType status; MemoryInfo *pixel_info; register Quantum *q; register ssize_t x; register unsigned char *p; size_t height, length, width; ssize_t count, y; unsigned char *pixels; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); image=AcquireImage(image_info,exception); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } width=ReadBlobMSBLong(image); height=ReadBlobMSBLong(image); if (EOFBlob(image) != MagickFalse) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); if ((width == 0UL) || (height == 0UL)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); do { image->columns=width; image->rows=height; image->depth=8; if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0)) if (image->scene >= (image_info->scene+image_info->number_scenes-1)) break; status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) return(DestroyImageList(image)); pixel_info=AcquireVirtualMemory(image->columns,4*sizeof(*pixels)); if (pixel_info == (MemoryInfo *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info); length=(size_t) 4*image->columns; for (y=0; y < (ssize_t) image->rows; y++) { count=ReadBlob(image,length,pixels); if ((size_t) count != length) ThrowReaderException(CorruptImageError,""UnableToReadImageData""); p=pixels; q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { SetPixelAlpha(image,ScaleCharToQuantum(*p++),q); SetPixelRed(image,ScaleCharToQuantum(*p++),q); SetPixelGreen(image,ScaleCharToQuantum(*p++),q); SetPixelBlue(image,ScaleCharToQuantum(*p++),q); if (GetPixelAlpha(image,q) != OpaqueAlpha) image->alpha_trait=BlendPixelTrait; q+=GetPixelChannels(image); } if (SyncAuthenticPixels(image,exception) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } } pixel_info=RelinquishVirtualMemory(pixel_info); if (EOFBlob(image) != MagickFalse) { ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"", image->filename); break; } if (image_info->number_scenes != 0) if (image->scene >= (image_info->scene+image_info->number_scenes-1)) break; width=ReadBlobMSBLong(image); height=ReadBlobMSBLong(image); if ((width != 0UL) && (height != 0UL)) { AcquireNextImage(image_info,image,exception); if (GetNextImageInList(image) == (Image *) NULL) { image=DestroyImageList(image); return((Image *) NULL); } image=SyncNextImageInList(image); status=SetImageProgress(image,LoadImagesTag,TellBlob(image), GetBlobSize(image)); if (status == MagickFalse) break; } } while ((width != 0UL) && (height != 0UL)); (void) CloseBlob(image); return(GetFirstImageInList(image)); }
Description: The ReadAVSImage function in avs.c in ImageMagick 7.0.5-4 allows remote attackers to consume an amount of available memory via a crafted file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void nego_process_negotiation_request(rdpNego* nego, wStream* s) { BYTE flags; UINT16 length; Stream_Read_UINT8(s, flags); Stream_Read_UINT16(s, length); Stream_Read_UINT32(s, nego->RequestedProtocols); WLog_DBG(TAG, ""RDP_NEG_REQ: RequestedProtocol: 0x%08"" PRIX32 """", nego->RequestedProtocols); nego->state = NEGO_STATE_FINAL; }
Description: In FreeRDP before 2.1.0, there is an out-of-bound read in irp functions (parallel_process_irp_create, serial_process_irp_create, drive_process_irp_write, printer_process_irp_write, rdpei_recv_pdu, serial_process_irp_write). This has been fixed in 2.1.0.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void CalculateOutputIndexValueRowID( const RowPartitionTensor& value_rowids, const vector<INDEX_TYPE>& parent_output_index, INDEX_TYPE output_index_multiplier, INDEX_TYPE output_size, vector<INDEX_TYPE>* result) { const INDEX_TYPE index_size = value_rowids.size(); result->reserve(index_size); if (index_size == 0) { return; } INDEX_TYPE current_output_column = 0; INDEX_TYPE current_value_rowid = value_rowids(0); DCHECK_LT(current_value_rowid, parent_output_index.size()); INDEX_TYPE current_output_index = parent_output_index[current_value_rowid]; result->push_back(current_output_index); for (INDEX_TYPE i = 1; i < index_size; ++i) { INDEX_TYPE next_value_rowid = value_rowids(i); if (next_value_rowid == current_value_rowid) { if (current_output_index >= 0) { ++current_output_column; if (current_output_column < output_size) { current_output_index += output_index_multiplier; } else { current_output_index = -1; } } } else { current_output_column = 0; current_value_rowid = next_value_rowid; DCHECK_LT(next_value_rowid, parent_output_index.size()); current_output_index = parent_output_index[next_value_rowid]; } result->push_back(current_output_index); } DCHECK_EQ(result->size(), value_rowids.size()); }
Description: TensorFlow is an end-to-end open source platform for machine learning. Due to lack of validation in `tf.raw_ops.RaggedTensorToTensor`, an attacker can exploit an undefined behavior if input arguments are empty. The implementation(https://github.com/tensorflow/tensorflow/blob/656e7673b14acd7835dc778867f84916c6d1cac2/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L356-L360) only checks that one of the tensors is not empty, but does not check for the other ones. There are multiple `DCHECK` validations to prevent heap OOB, but these are no-op in release builds, hence they don't prevent anything. The fix will be included in TensorFlow 2.5.0. We will also cherrypick these commits on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static bool list_exec (gravity_vm *vm, gravity_value_t *args, uint16_t nargs, uint32_t rindex) { if ((nargs != 2) || (!VALUE_ISA_INT(GET_VALUE(1)))) RETURN_ERROR(""An Int value is expected as argument of List allocate.""); uint32_t n = (uint32_t)VALUE_AS_INT(GET_VALUE(1)); gravity_list_t *list = gravity_list_new(vm, n); for (uint32_t i=0; i<n; ++i) marray_push(gravity_value_t, list->array, VALUE_FROM_NULL); RETURN_VALUE(VALUE_FROM_OBJECT(list), rindex); }
Description: Creolabs Gravity version 1.0 is vulnerable to a stack overflow in the string_repeat() function.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int sas_discover_sata(struct domain_device *dev) { int res; if (dev->dev_type == SAS_SATA_PM) return -ENODEV; dev->sata_dev.class = sas_get_ata_command_set(dev); sas_fill_in_rphy(dev, dev->rphy); res = sas_notify_lldd_dev_found(dev); if (res) return res; sas_discover_event(dev->port, DISCE_PROBE); return 0; }
Description: The Serial Attached SCSI (SAS) implementation in the Linux kernel through 4.15.9 mishandles a mutex within libsas, which allows local users to cause a denial of service (deadlock) by triggering certain error-handling code.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int LoadEXR(float **out_rgba, int *width, int *height, const char *filename, const char **err) { if (out_rgba == NULL) { tinyexr::SetErrorMessage(""Invalid argument for LoadEXR()"", err); return TINYEXR_ERROR_INVALID_ARGUMENT; } EXRVersion exr_version; EXRImage exr_image; EXRHeader exr_header; InitEXRHeader(&exr_header); InitEXRImage(&exr_image); { int ret = ParseEXRVersionFromFile(&exr_version, filename); if (ret != TINYEXR_SUCCESS) { return ret; } if (exr_version.multipart || exr_version.non_image) { tinyexr::SetErrorMessage(""Loading multipart or DeepImage is not supported  in LoadEXR() API"", err); return TINYEXR_ERROR_INVALID_DATA;      } } { int ret = ParseEXRHeaderFromFile(&exr_header, &exr_version, filename, err); if (ret != TINYEXR_SUCCESS) { FreeEXRHeader(&exr_header); return ret; } } for (int i = 0; i < exr_header.num_channels; i++) { if (exr_header.pixel_types[i] == TINYEXR_PIXELTYPE_HALF) { exr_header.requested_pixel_types[i] = TINYEXR_PIXELTYPE_FLOAT; } } { int ret = LoadEXRImageFromFile(&exr_image, &exr_header, filename, err); if (ret != TINYEXR_SUCCESS) { return ret; } } int idxR = -1; int idxG = -1; int idxB = -1; int idxA = -1; for (int c = 0; c < exr_header.num_channels; c++) { if (strcmp(exr_header.channels[c].name, ""R"") == 0) { idxR = c; } else if (strcmp(exr_header.channels[c].name, ""G"") == 0) { idxG = c; } else if (strcmp(exr_header.channels[c].name, ""B"") == 0) { idxB = c; } else if (strcmp(exr_header.channels[c].name, ""A"") == 0) { idxA = c; } } if ((idxA == 0) && (idxR == -1) && (idxG == -1) && (idxB == -1)) { if (exr_header.tiled) { } (*out_rgba) = reinterpret_cast<float *>( malloc(4 * sizeof(float) * static_cast<size_t>(exr_image.width) * static_cast<size_t>(exr_image.height))); for (int i = 0; i < exr_image.width * exr_image.height; i++) { const float val = reinterpret_cast<float **>(exr_image.images)[0][i]; (*out_rgba)[4 * i + 0] = val; (*out_rgba)[4 * i + 1] = val; (*out_rgba)[4 * i + 2] = val; (*out_rgba)[4 * i + 3] = val; } } else { if (idxR == -1) { tinyexr::SetErrorMessage(""R channel not found"", err); return TINYEXR_ERROR_INVALID_DATA; } if (idxG == -1) { tinyexr::SetErrorMessage(""G channel not found"", err); return TINYEXR_ERROR_INVALID_DATA; } if (idxB == -1) { tinyexr::SetErrorMessage(""B channel not found"", err); return TINYEXR_ERROR_INVALID_DATA; } (*out_rgba) = reinterpret_cast<float *>( malloc(4 * sizeof(float) * static_cast<size_t>(exr_image.width) * static_cast<size_t>(exr_image.height))); if (exr_header.tiled) { for (int it = 0; it < exr_image.num_tiles; it++) { for (int j = 0; j < exr_header.tile_size_y; j++) for (int i = 0; i < exr_header.tile_size_x; i++) { const int ii = exr_image.tiles[it].offset_x * exr_header.tile_size_x + i; const int jj = exr_image.tiles[it].offset_y * exr_header.tile_size_y + j; const int idx = ii + jj * exr_image.width; if (ii >= exr_image.width) { continue; } if (jj >= exr_image.height) { continue; } const int srcIdx = i + j * exr_header.tile_size_x; unsigned char **src = exr_image.tiles[it].images; (*out_rgba)[4 * idx + 0] = reinterpret_cast<float **>(src)[idxR][srcIdx]; (*out_rgba)[4 * idx + 1] = reinterpret_cast<float **>(src)[idxG][srcIdx]; (*out_rgba)[4 * idx + 2] = reinterpret_cast<float **>(src)[idxB][srcIdx]; if (idxA != -1) { (*out_rgba)[4 * idx + 3] = reinterpret_cast<float **>(src)[idxA][srcIdx]; } else { (*out_rgba)[4 * idx + 3] = 1.0; } } } } else { for (int i = 0; i < exr_image.width * exr_image.height; i++) { (*out_rgba)[4 * i + 0] = reinterpret_cast<float **>(exr_image.images)[idxR][i]; (*out_rgba)[4 * i + 1] = reinterpret_cast<float **>(exr_image.images)[idxG][i]; (*out_rgba)[4 * i + 2] = reinterpret_cast<float **>(exr_image.images)[idxB][i]; if (idxA != -1) { (*out_rgba)[4 * i + 3] = reinterpret_cast<float **>(exr_image.images)[idxA][i]; } else { (*out_rgba)[4 * i + 3] = 1.0; } } } } (*width) = exr_image.width; (*height) = exr_image.height; FreeEXRHeader(&exr_header); FreeEXRImage(&exr_image); return TINYEXR_SUCCESS; }
Description: tinyexr 0.9.5 has an assertion failure in ComputeChannelLayout in tinyexr.h.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int zset_outputintent(i_ctx_t * i_ctx_p) { os_ptr                  op = osp; int                     code = 0; gx_device *dev = gs_currentdevice(igs); cmm_dev_profile_t       *dev_profile; stream *                s = 0L; ref *                   pnval; ref *                   pstrmval; int                     ncomps, dev_comps; cmm_profile_t           *picc_profile; int                     expected = 0; gs_color_space_index    index; gsicc_manager_t         *icc_manager = igs->icc_manager; cmm_profile_t           *source_profile = NULL; check_type(*op, t_dictionary); check_dict_read(*op); if_debug0m(gs_debug_flag_icc, imemory, ""[icc] Using OutputIntent\n""); code = dev_proc(dev, get_profile)(dev,  &dev_profile); if (code < 0) return code; if (dev_profile == NULL) { code = gsicc_init_device_profile_struct(dev, NULL, 0); if (code < 0) return code; code = dev_proc(dev, get_profile)(dev,  &dev_profile); if (code < 0) return code; } if (dev_profile->oi_profile != NULL) { return 0;   } code = dict_find_string(op, ""N"", &pnval); if (code < 0) return code; if (code == 0) return_error(gs_error_undefined); ncomps = pnval->value.intval; if (dict_find_string(op, ""DataSource"", &pstrmval) <= 0) return_error(gs_error_undefined); check_read_file(i_ctx_p, s, pstrmval); picc_profile = gsicc_profile_new(s, gs_gstate_memory(igs), NULL, 0); if (picc_profile == NULL) return gs_throw(gs_error_VMerror, ""Creation of ICC profile failed""); picc_profile->num_comps = ncomps; picc_profile->profile_handle = gsicc_get_profile_handle_buffer(picc_profile->buffer, picc_profile->buffer_size, gs_gstate_memory(igs)); if (picc_profile->profile_handle == NULL) { rc_decrement(picc_profile,""zset_outputintent""); return -1; } picc_profile->data_cs = gscms_get_profile_data_space(picc_profile->profile_handle, picc_profile->memory); switch (picc_profile->data_cs) { case gsCIEXYZ: case gsCIELAB: case gsRGB: expected = 3; source_profile = icc_manager->default_rgb; break; case gsGRAY: expected = 1; source_profile = icc_manager->default_gray; break; case gsCMYK: expected = 4; source_profile = icc_manager->default_cmyk; break; case gsNCHANNEL: expected = 0; break; case gsNAMED: case gsUNDEFINED: break; } if (expected && ncomps != expected) { rc_decrement(picc_profile,""zset_outputintent""); return_error(gs_error_rangecheck); } gsicc_init_hash_cs(picc_profile, igs); dev_profile->oi_profile = picc_profile; picc_profile->name = (char *) gs_alloc_bytes(picc_profile->memory, MAX_DEFAULT_ICC_LENGTH, ""zset_outputintent""); strncpy(picc_profile->name, OI_PROFILE, strlen(OI_PROFILE)); picc_profile->name[strlen(OI_PROFILE)] = 0; picc_profile->name_length = strlen(OI_PROFILE); gsicc_set_icc_range(&picc_profile); dev_comps = dev_profile->device_profile[0]->num_comps; index = gsicc_get_default_type(dev_profile->device_profile[0]); if (ncomps == dev_comps && index < gs_color_space_index_DevicePixel) { rc_assign(dev_profile->device_profile[0], picc_profile, ""zset_outputintent""); if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used for device profile\n""); } else { if (dev_profile->proof_profile == NULL) { dev_profile->proof_profile = picc_profile; rc_increment(picc_profile); if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used for proof profile\n""); } } index = gsicc_get_default_type(source_profile); if (index < gs_color_space_index_DevicePixel) { switch (picc_profile->data_cs) { case gsGRAY: if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used source Gray\n""); rc_assign(icc_manager->default_gray, picc_profile, ""zset_outputintent""); break; case gsRGB: if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used source RGB\n""); rc_assign(icc_manager->default_rgb, picc_profile, ""zset_outputintent""); break; case gsCMYK: if_debug0m(gs_debug_flag_icc, imemory, ""[icc] OutputIntent used source CMYK\n""); rc_assign(icc_manager->default_cmyk, picc_profile, ""zset_outputintent""); break; default: break; } } pop(1); return code; }
Description: psi/zicc.c in Artifex Ghostscript before 9.26 allows remote attackers to bypass intended access restrictions because of a setcolorspace type confusion.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static krb5_error_code crypto_retrieve_X509_sans(krb5_context context, pkinit_plg_crypto_context plgctx, pkinit_req_crypto_context reqctx, X509 *cert, krb5_principal **princs_ret, krb5_principal **upn_ret, unsigned char ***dns_ret) { krb5_error_code retval = EINVAL; char buf[DN_BUF_LEN]; int p = 0, u = 0, d = 0, ret = 0, l; krb5_principal *princs = NULL; krb5_principal *upns = NULL; unsigned char **dnss = NULL; unsigned int i, num_found = 0, num_sans = 0; X509_EXTENSION *ext = NULL; GENERAL_NAMES *ialt = NULL; GENERAL_NAME *gen = NULL; if (princs_ret != NULL) *princs_ret = NULL; if (upn_ret != NULL) *upn_ret = NULL; if (dns_ret != NULL) *dns_ret = NULL; if (princs_ret == NULL && upn_ret == NULL && dns_ret == NULL) { pkiDebug(""%s: nowhere to return any values!\n"", __FUNCTION__); return retval; } if (cert == NULL) { pkiDebug(""%s: no certificate!\n"", __FUNCTION__); return retval; } X509_NAME_oneline(X509_get_subject_name(cert), buf, sizeof(buf)); pkiDebug(""%s: looking for SANs in cert = %s\n"", __FUNCTION__, buf); l = X509_get_ext_by_NID(cert, NID_subject_alt_name, -1); if (l < 0) return 0; if (!(ext = X509_get_ext(cert, l)) || !(ialt = X509V3_EXT_d2i(ext))) { pkiDebug(""%s: found no subject alt name extensions\n"", __FUNCTION__); retval = ENOENT; goto cleanup; } num_sans = sk_GENERAL_NAME_num(ialt); pkiDebug(""%s: found %d subject alt name extension(s)\n"", __FUNCTION__, num_sans); if (princs_ret != NULL) { princs = calloc(num_sans + 1, sizeof(krb5_principal)); if (princs == NULL) { retval = ENOMEM; goto cleanup; } } if (upn_ret != NULL) { upns = calloc(num_sans + 1, sizeof(krb5_principal)); if (upns == NULL) { retval = ENOMEM; goto cleanup; } } if (dns_ret != NULL) { dnss = calloc(num_sans + 1, sizeof(*dnss)); if (dnss == NULL) { retval = ENOMEM; goto cleanup; } } for (i = 0; i < num_sans; i++) { krb5_data name = { 0, 0, NULL }; gen = sk_GENERAL_NAME_value(ialt, i); switch (gen->type) { case GEN_OTHERNAME: name.length = gen->d.otherName->value->value.sequence->length; name.data = (char *)gen->d.otherName->value->value.sequence->data; if (princs != NULL && OBJ_cmp(plgctx->id_pkinit_san, gen->d.otherName->type_id) == 0) { #ifdef DEBUG_ASN1 print_buffer_bin((unsigned char *)name.data, name.length, ""/tmp/pkinit_san""); #endif ret = k5int_decode_krb5_principal_name(&name, &princs[p]); if (ret) { pkiDebug(""%s: failed decoding pkinit san value\n"", __FUNCTION__); } else { p++; num_found++; } } else if (upns != NULL && OBJ_cmp(plgctx->id_ms_san_upn, gen->d.otherName->type_id) == 0) { if (memchr(name.data, '\0', name.length)) break; ret = krb5_parse_name_flags(context, name.data, KRB5_PRINCIPAL_PARSE_ENTERPRISE, &upns[u]); if (ret) { pkiDebug(""%s: failed parsing ms-upn san value\n"", __FUNCTION__); } else { u++; num_found++; } } else { pkiDebug(""%s: unrecognized othername oid in SAN\n"", __FUNCTION__); continue; } break; case GEN_DNS: if (dnss != NULL) { if (memchr(gen->d.dNSName->data, '\0', gen->d.dNSName->length)) break; pkiDebug(""%s: found dns name = %s\n"", __FUNCTION__, gen->d.dNSName->data); dnss[d] = (unsigned char *) strdup((char *)gen->d.dNSName->data); if (dnss[d] == NULL) { pkiDebug(""%s: failed to duplicate dns name\n"", __FUNCTION__); } else { d++; num_found++; } } break; default: pkiDebug(""%s: SAN type = %d expecting %d\n"", __FUNCTION__, gen->type, GEN_OTHERNAME); } } sk_GENERAL_NAME_pop_free(ialt, GENERAL_NAME_free); retval = 0; if (princs) *princs_ret = princs; if (upns) *upn_ret = upns; if (dnss) *dns_ret = dnss; cleanup: if (retval) { if (princs != NULL) { for (i = 0; princs[i] != NULL; i++) krb5_free_principal(context, princs[i]); free(princs); } if (upns != NULL) { for (i = 0; upns[i] != NULL; i++) krb5_free_principal(context, upns[i]); free(upns); } if (dnss != NULL) { for (i = 0; dnss[i] != NULL; i++) free(dnss[i]); free(dnss); } } return retval; }
Description: An authentication bypass flaw was found in the way krb5's certauth interface before 1.16.1 handled the validation of client certificates. A remote attacker able to communicate with the KDC could potentially use this flaw to impersonate arbitrary principals under rare and erroneous circumstances.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int WebContentsImpl::DownloadImage( const GURL& url, bool is_favicon, uint32_t max_bitmap_size, bool bypass_cache, const WebContents::ImageDownloadCallback& callback) { DCHECK_CURRENTLY_ON(BrowserThread::UI); static int next_image_download_id = 0; const image_downloader::ImageDownloaderPtr& mojo_image_downloader = GetMainFrame()->GetMojoImageDownloader(); const int download_id = ++next_image_download_id; if (!mojo_image_downloader) { BrowserThread::PostTask( BrowserThread::UI, FROM_HERE, base::Bind(&WebContents::ImageDownloadCallback::Run, base::Owned(new ImageDownloadCallback(callback)), download_id, 400, url, std::vector<SkBitmap>(), std::vector<gfx::Size>())); return download_id; } image_downloader::DownloadRequestPtr req = image_downloader::DownloadRequest::New(); req->url = mojo::String::From(url); req->is_favicon = is_favicon; req->max_bitmap_size = max_bitmap_size; req->bypass_cache = bypass_cache; mojo_image_downloader->DownloadImage( std::move(req), base::Bind(&DidDownloadImage, callback, download_id, url)); return download_id; }
Description: Use-after-free vulnerability in content/browser/web_contents/web_contents_impl.cc in Google Chrome before 49.0.2623.75 allows remote attackers to cause a denial of service or possibly have unspecified other impact by triggering an image download after a certain data structure is deleted, as demonstrated by a favicon.ico download.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void handle_global(void *data, struct wl_registry *registry, uint32_t name, const char *interface, uint32_t version) { struct swaylock_state *state = data; if (strcmp(interface, wl_compositor_interface.name) == 0) { state->compositor = wl_registry_bind(registry, name, &wl_compositor_interface, 4); } else if (strcmp(interface, wl_subcompositor_interface.name) == 0) { state->subcompositor = wl_registry_bind(registry, name, &wl_subcompositor_interface, 1); } else if (strcmp(interface, wl_shm_interface.name) == 0) { state->shm = wl_registry_bind(registry, name, &wl_shm_interface, 1); } else if (strcmp(interface, wl_seat_interface.name) == 0) { struct wl_seat *seat = wl_registry_bind( registry, name, &wl_seat_interface, 4); struct swaylock_seat *swaylock_seat = calloc(1, sizeof(struct swaylock_seat)); swaylock_seat->state = state; wl_seat_add_listener(seat, &seat_listener, swaylock_seat); } else if (strcmp(interface, zwlr_layer_shell_v1_interface.name) == 0) { state->layer_shell = wl_registry_bind( registry, name, &zwlr_layer_shell_v1_interface, 1); } else if (strcmp(interface, zwlr_input_inhibit_manager_v1_interface.name) == 0) { state->input_inhibit_manager = wl_registry_bind( registry, name, &zwlr_input_inhibit_manager_v1_interface, 1); } else if (strcmp(interface, zxdg_output_manager_v1_interface.name) == 0) { state->zxdg_output_manager = wl_registry_bind( registry, name, &zxdg_output_manager_v1_interface, 2); } else if (strcmp(interface, wl_output_interface.name) == 0) { struct swaylock_surface *surface = calloc(1, sizeof(struct swaylock_surface)); surface->state = state; surface->output = wl_registry_bind(registry, name, &wl_output_interface, 3); surface->output_global_name = name; wl_output_add_listener(surface->output, &_wl_output_listener, surface); wl_list_insert(&state->surfaces, &surface->link); if (state->run_display) { create_layer_surface(surface); wl_display_roundtrip(state->display); } } }
Description: swaylock before 1.6 allows attackers to trigger a crash and achieve unlocked access to a Wayland compositor.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: WORD32 ih264d_parse_inter_slice_data_cavlc(dec_struct_t * ps_dec, dec_slice_params_t * ps_slice, UWORD16 u2_first_mb_in_slice) { UWORD32 uc_more_data_flag; WORD32 i2_cur_mb_addr; UWORD32 u1_num_mbs, u1_num_mbsNby2, u1_mb_idx; UWORD32 i2_mb_skip_run; UWORD32 u1_read_mb_type; UWORD32 u1_mbaff; UWORD32 u1_num_mbs_next, u1_end_of_row; const UWORD32 i2_pic_wdin_mbs = ps_dec->u2_frm_wd_in_mbs; UWORD32 u1_slice_end = 0; UWORD32 u1_tfr_n_mb = 0; UWORD32 u1_decode_nmb = 0; dec_bit_stream_t * const ps_bitstrm = ps_dec->ps_bitstrm; UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer; UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst; deblk_mb_t *ps_cur_deblk_mb; dec_mb_info_t *ps_cur_mb_info; parse_pmbarams_t *ps_parse_mb_data = ps_dec->ps_parse_mb_data; UWORD32 u1_inter_mb_type; UWORD32 u1_deblk_mb_type; UWORD32 u1_mb_threshold; WORD32 ret = OK; if(ps_slice->u1_slice_type == P_SLICE) { u1_inter_mb_type = P_MB; u1_deblk_mb_type = D_INTER_MB; u1_mb_threshold = 5; } else     { u1_inter_mb_type = B_MB; u1_deblk_mb_type = D_B_SLICE; u1_mb_threshold = 23; } ps_dec->u1_qp = ps_slice->u1_slice_qp; ih264d_update_qp(ps_dec, 0); u1_mb_idx = ps_dec->u1_mb_idx; u1_num_mbs = u1_mb_idx; u1_num_mbsNby2 = 0; u1_mbaff = ps_slice->u1_mbaff_frame_flag; i2_cur_mb_addr = u2_first_mb_in_slice << u1_mbaff; i2_mb_skip_run = 0; uc_more_data_flag = 1; u1_read_mb_type = 0; while(!u1_slice_end) { UWORD8 u1_mb_type; ps_dec->pv_prev_mb_parse_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data; if(i2_cur_mb_addr > ps_dec->ps_cur_sps->u2_max_mb_addr) { ret = ERROR_MB_ADDRESS_T; break; } ps_cur_mb_info = ps_dec->ps_nmb_info + u1_num_mbs; ps_dec->u4_num_mbs_cur_nmb = u1_num_mbs; ps_cur_mb_info->u1_Mux = 0; ps_dec->u4_num_pmbair = (u1_num_mbs >> u1_mbaff); ps_cur_deblk_mb = ps_dec->ps_deblk_mbn + u1_num_mbs; ps_cur_mb_info->u1_end_of_slice = 0; ps_parse_mb_data->u1_num_part = 1; ps_parse_mb_data->u1_isI_mb = 0; if((!i2_mb_skip_run) && (!u1_read_mb_type)) { UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst; UWORD32 u4_word, u4_ldz; NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf); u4_ldz = CLZ(u4_word); u4_bitstream_offset += (u4_ldz + 1); u4_word = 0; if(u4_ldz) { GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf, u4_ldz); } *pu4_bitstrm_ofst = u4_bitstream_offset; i2_mb_skip_run = ((1 << u4_ldz) + u4_word - 1); COPYTHECONTEXT(""mb_skip_run"", i2_mb_skip_run); uc_more_data_flag = MORE_RBSP_DATA(ps_bitstrm); u1_read_mb_type = uc_more_data_flag; } ps_dec->pf_get_mb_info(ps_dec, i2_cur_mb_addr, ps_cur_mb_info, i2_mb_skip_run); if(ps_dec->u4_app_disable_deblk_frm == 0) ih264d_set_deblocking_parameters(ps_cur_deblk_mb, ps_slice, ps_dec->u1_mb_ngbr_availablity, ps_dec->u1_cur_mb_fld_dec_flag); if(i2_mb_skip_run) { ps_dec->i1_prev_mb_qp_delta = 0; ps_dec->u1_sub_mb_num = 0; ps_cur_mb_info->u1_mb_type = MB_SKIP; ps_cur_mb_info->u1_mb_mc_mode = PRED_16x16; ps_cur_mb_info->u1_cbp = 0; { parse_part_params_t *ps_part_info = ps_dec->ps_part; ps_part_info->u1_is_direct = PART_DIRECT_16x16; ps_part_info->u1_sub_mb_num = 0; ps_dec->ps_part++; } ih264d_update_nnz_for_skipmb(ps_dec, ps_cur_mb_info, CAVLC); ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type; ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type; i2_mb_skip_run--; } else { u1_read_mb_type = 0; { UWORD32 u4_bitstream_offset = *pu4_bitstrm_ofst; UWORD32 u4_word, u4_ldz, u4_temp; NEXTBITS_32(u4_word, u4_bitstream_offset, pu4_bitstrm_buf); u4_ldz = CLZ(u4_word); u4_bitstream_offset += (u4_ldz + 1); u4_word = 0; if(u4_ldz) GETBITS(u4_word, u4_bitstream_offset, pu4_bitstrm_buf, u4_ldz); *pu4_bitstrm_ofst = u4_bitstream_offset; u4_temp = ((1 << u4_ldz) + u4_word - 1); if(u4_temp > (UWORD32)(25 + u1_mb_threshold)) return ERROR_MB_TYPE; u1_mb_type = u4_temp; COPYTHECONTEXT(""u1_mb_type"", u1_mb_type); } ps_cur_mb_info->u1_mb_type = u1_mb_type; if(u1_mb_type < u1_mb_threshold) { ps_cur_mb_info->ps_curmb->u1_mb_type = u1_inter_mb_type; ret = ps_dec->pf_parse_inter_mb(ps_dec, ps_cur_mb_info, u1_num_mbs, u1_num_mbsNby2); if(ret != OK) return ret; ps_cur_deblk_mb->u1_mb_type |= u1_deblk_mb_type; } else { ps_parse_mb_data->u1_num_part = 0; ps_parse_mb_data->u1_isI_mb = 1; if((25 + u1_mb_threshold) == u1_mb_type) { ps_cur_mb_info->ps_curmb->u1_mb_type = I_PCM_MB; ret = ih264d_parse_ipcm_mb(ps_dec, ps_cur_mb_info, u1_num_mbs); if(ret != OK) return ret; ps_dec->u1_qp = 0; } else { ret = ih264d_parse_imb_cavlc( ps_dec, ps_cur_mb_info, u1_num_mbs, (UWORD8)(u1_mb_type - u1_mb_threshold)); if(ret != OK) return ret; } ps_cur_deblk_mb->u1_mb_type |= D_INTRA_MB; } uc_more_data_flag = MORE_RBSP_DATA(ps_bitstrm); } ps_cur_deblk_mb->u1_mb_qp = ps_dec->u1_qp; if(u1_mbaff) { ih264d_update_mbaff_left_nnz(ps_dec, ps_cur_mb_info); } i2_cur_mb_addr++; u1_num_mbs++; ps_dec->u2_total_mbs_coded++; u1_num_mbsNby2++; ps_parse_mb_data++; u1_num_mbs_next = i2_pic_wdin_mbs - ps_dec->u2_mbx - 1; u1_end_of_row = (!u1_num_mbs_next) && (!(u1_mbaff && (u1_num_mbs & 0x01))); u1_slice_end = (!(uc_more_data_flag || i2_mb_skip_run)); u1_tfr_n_mb = (u1_num_mbs == ps_dec->u1_recon_mb_grp) || u1_end_of_row || u1_slice_end; u1_decode_nmb = u1_tfr_n_mb || u1_slice_end; ps_cur_mb_info->u1_end_of_slice = u1_slice_end; if(u1_decode_nmb) { ps_dec->pf_mvpred_ref_tfr_nby2mb(ps_dec, u1_mb_idx, u1_num_mbs); u1_num_mbsNby2 = 0; { ps_parse_mb_data = ps_dec->ps_parse_mb_data; ps_dec->ps_part = ps_dec->ps_parse_part_params; } } if(u1_decode_nmb) { if(ps_dec->u1_separate_parse) { ih264d_parse_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row); ps_dec->ps_nmb_info +=  u1_num_mbs; } else { ih264d_decode_recon_tfr_nmb(ps_dec, u1_mb_idx, u1_num_mbs, u1_num_mbs_next, u1_tfr_n_mb, u1_end_of_row); } if(u1_tfr_n_mb) u1_num_mbs = 0; u1_mb_idx = u1_num_mbs; ps_dec->u1_mb_idx = u1_num_mbs; } } ps_dec->u4_num_mbs_cur_nmb = 0; ps_dec->ps_cur_slice->u4_mbs_in_slice = i2_cur_mb_addr - (u2_first_mb_in_slice << u1_mbaff); return ret; }
Description: mediaserver in Android 6.x before 2016-03-01 allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, related to decoder/ih264d_parse_islice.c and decoder/ih264d_parse_pslice.c, aka internal bug 25928803.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: BOOL SQLWriteFileDSN(LPCSTRpszFileName, LPCSTRpszAppName, LPCSTRpszKeyName, LPCSTRpszString ) { HINIhIni; charszFileName[ODBC_FILENAME_MAX+1]; if ( pszFileName[0] == '/' ) { strncpy( szFileName, sizeof(szFileName) - 5, pszFileName ); } else { char szPath[ODBC_FILENAME_MAX+1]; *szPath = '\0'; _odbcinst_FileINI( szPath ); snprintf( szFileName, sizeof(szFileName) - 5, ""%s/%s"", szPath, pszFileName ); } if ( strlen( szFileName ) < 4 || strcmp( szFileName + strlen( szFileName ) - 4, "".dsn"" )) { strcat( szFileName, "".dsn"" ); } #ifdef __OS2__ if ( iniOpen( &hIni, szFileName, ""#;"", '[', ']', '=', TRUE, 0L ) != INI_SUCCESS ) #else if ( iniOpen( &hIni, szFileName, ""#;"", '[', ']', '=', TRUE ) != INI_SUCCESS ) #endif { inst_logPushMsg( __FILE__, __FILE__, __LINE__, LOG_CRITICAL, ODBC_ERROR_INVALID_PATH, """" ); return FALSE; } if ( pszString == NULL && pszKeyName == NULL ) { if ( iniObjectSeek( hIni, (char *)pszAppName ) == INI_SUCCESS ) { iniObjectDelete( hIni ); } } else if( pszString == NULL ) { if ( iniPropertySeek( hIni, (char *)pszAppName, (char *)pszKeyName, """" ) == INI_SUCCESS ) { iniPropertyDelete( hIni ); } } else { if ( iniObjectSeek( hIni, (char *)pszAppName ) != INI_SUCCESS ) { iniObjectInsert( hIni, (char *)pszAppName ); } if ( iniPropertySeek( hIni, (char *)pszAppName, (char *)pszKeyName, """" ) == INI_SUCCESS ) { iniObjectSeek( hIni, (char *)pszAppName ); iniPropertyUpdate( hIni, (char *)pszKeyName, (char *)pszString ); } else { iniObjectSeek( hIni, (char *)pszAppName ); iniPropertyInsert( hIni, (char *)pszKeyName, (char *)pszString ); } } if ( iniCommit( hIni ) != INI_SUCCESS ) { iniClose( hIni ); inst_logPushMsg( __FILE__, __FILE__, __LINE__, LOG_CRITICAL, ODBC_ERROR_REQUEST_FAILED, """" ); return FALSE; } iniClose( hIni ); return TRUE; }
Description: The SQLWriteFileDSN function in odbcinst/SQLWriteFileDSN.c in unixODBC 2.3.5 has strncpy arguments in the wrong order, which allows attackers to cause a denial of service or possibly have unspecified other impact.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: WORD32 ihevcd_decode(iv_obj_t *ps_codec_obj, void *pv_api_ip, void *pv_api_op) { WORD32 ret = IV_SUCCESS; codec_t *ps_codec = (codec_t *)(ps_codec_obj->pv_codec_handle); ivd_video_decode_ip_t *ps_dec_ip; ivd_video_decode_op_t *ps_dec_op; WORD32 proc_idx = 0; WORD32 prev_proc_idx = 0; ps_codec->i4_error_code = 0; ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip; ps_dec_op = (ivd_video_decode_op_t *)pv_api_op; { UWORD32 u4_size = ps_dec_op->u4_size; memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t)); ps_dec_op->u4_size = u4_size;     } if(ps_codec->i4_init_done != 1) { ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR; ps_dec_op->u4_error_code |= IHEVCD_INIT_NOT_DONE; return IV_FAIL; } if(ps_codec->u4_pic_cnt >= NUM_FRAMES_LIMIT) { ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR; ps_dec_op->u4_error_code |= IHEVCD_NUM_FRAMES_LIMIT_REACHED; return IV_FAIL; } if(ps_codec->i4_reset_flag) { ps_codec->i4_flush_mode = 1; } if(0 == ps_codec->i4_flush_mode) { if(ps_dec_ip->pv_stream_buffer == NULL) { ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM; ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL; return IV_FAIL; } if(ps_dec_ip->u4_num_Bytes <= MIN_START_CODE_LEN) { if((WORD32)ps_dec_ip->u4_num_Bytes > 0) ps_dec_op->u4_num_bytes_consumed = ps_dec_ip->u4_num_Bytes; else ps_dec_op->u4_num_bytes_consumed = 0; ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM; ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV; return IV_FAIL; } } #ifdef APPLY_CONCEALMENT { WORD32 num_mbs; num_mbs = (ps_codec->i4_wd * ps_codec->i4_ht + 255) >> 8; ps_codec->mb_count = 0; memset(ps_codec->mb_map, 0, ((num_mbs + 7) >> 3)); } #endif if(0 == ps_codec->i4_share_disp_buf && ps_codec->i4_header_mode == 0) { UWORD32 i; if(ps_dec_ip->s_out_buffer.u4_num_bufs == 0) { ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM; ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS; return IV_FAIL; } for(i = 0; i < ps_dec_ip->s_out_buffer.u4_num_bufs; i++) { if(ps_dec_ip->s_out_buffer.pu1_bufs[i] == NULL) { ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM; ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL; return IV_FAIL; } if(ps_dec_ip->s_out_buffer.u4_min_out_buf_size[i] == 0) { ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM; ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUF_SIZE; return IV_FAIL; } } } ps_codec->ps_out_buffer = &ps_dec_ip->s_out_buffer; ps_codec->u4_ts = ps_dec_ip->u4_ts; if(ps_codec->i4_flush_mode) { ps_dec_op->u4_pic_wd = ps_codec->i4_disp_wd; ps_dec_op->u4_pic_ht = ps_codec->i4_disp_ht; ps_dec_op->u4_new_seq = 0; ps_codec->ps_disp_buf = (pic_buf_t *)ihevc_disp_mgr_get( (disp_mgr_t *)ps_codec->pv_disp_buf_mgr, &ps_codec->i4_disp_buf_id); if((ps_codec->ps_disp_buf) && ((0 == ps_codec->i4_share_disp_buf) || (IV_YUV_420P == ps_codec->e_chroma_fmt))) { process_ctxt_t *ps_proc = &ps_codec->as_process[prev_proc_idx]; if(0 == ps_proc->i4_init_done) { ihevcd_init_proc_ctxt(ps_proc, 0); } ret = ihevcd_check_out_buf_size(ps_codec); RETURN_IF((ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS), ret); ret = ihevcd_fmt_conv(ps_codec, &ps_codec->as_process[prev_proc_idx], ps_dec_ip->s_out_buffer.pu1_bufs[0], ps_dec_ip->s_out_buffer.pu1_bufs[1], ps_dec_ip->s_out_buffer.pu1_bufs[2], 0, ps_codec->i4_disp_ht); ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_pic_buf_mgr, ps_codec->i4_disp_buf_id, BUF_MGR_DISP); } ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op); if(1 == ps_dec_op->u4_output_present) { WORD32 xpos = ps_codec->i4_disp_wd - 32 - LOGO_WD; WORD32 ypos = ps_codec->i4_disp_ht - 32 - LOGO_HT; if(ypos < 0) ypos = 0; if(xpos < 0) xpos = 0; INSERT_LOGO(ps_dec_ip->s_out_buffer.pu1_bufs[0], ps_dec_ip->s_out_buffer.pu1_bufs[1], ps_dec_ip->s_out_buffer.pu1_bufs[2], ps_codec->i4_disp_strd, xpos, ypos, ps_codec->e_chroma_fmt, ps_codec->i4_disp_wd, ps_codec->i4_disp_ht); } if(NULL == ps_codec->ps_disp_buf) { if(ps_codec->i4_reset_flag) { ihevcd_init(ps_codec); } return (IV_FAIL); } return (IV_SUCCESS); } if((0 == ps_codec->i4_header_mode) && (1 == ps_codec->i4_share_disp_buf)) { WORD32 buf_status; buf_status = 1; if(ps_codec->pv_pic_buf_mgr) buf_status = ihevc_buf_mgr_check_free((buf_mgr_t *)ps_codec->pv_pic_buf_mgr); if(0 == buf_status) { ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL; ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM); return IV_FAIL; } } ps_codec->i4_bytes_remaining = ps_dec_ip->u4_num_Bytes; ps_codec->pu1_inp_bitsbuf = (UWORD8 *)ps_dec_ip->pv_stream_buffer; ps_codec->s_parse.i4_end_of_frame = 0; ps_codec->i4_pic_present = 0; ps_codec->i4_slice_error = 0; ps_codec->ps_disp_buf = NULL; if(ps_codec->i4_num_cores > 1) { ithread_set_affinity(0); } while(MIN_START_CODE_LEN < ps_codec->i4_bytes_remaining) { WORD32 nal_len; WORD32 nal_ofst; WORD32 bits_len; if(ps_codec->i4_slice_error) { slice_header_t *ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + (ps_codec->s_parse.i4_cur_slice_idx & (MAX_SLICE_HDR_CNT - 1)); WORD32 next_slice_addr = ps_slice_hdr_next->i2_ctb_x + ps_slice_hdr_next->i2_ctb_y * ps_codec->s_parse.ps_sps->i2_pic_wd_in_ctb; if(ps_codec->s_parse.i4_next_ctb_indx == next_slice_addr) ps_codec->i4_slice_error = 0; } if(ps_codec->pu1_bitsbuf_dynamic) { ps_codec->pu1_bitsbuf = ps_codec->pu1_bitsbuf_dynamic; ps_codec->u4_bitsbuf_size = ps_codec->u4_bitsbuf_size_dynamic; } else { ps_codec->pu1_bitsbuf = ps_codec->pu1_bitsbuf_static; ps_codec->u4_bitsbuf_size = ps_codec->u4_bitsbuf_size_static; } nal_ofst = ihevcd_nal_search_start_code(ps_codec->pu1_inp_bitsbuf, ps_codec->i4_bytes_remaining); ps_codec->i4_nal_ofst = nal_ofst; { WORD32 bytes_remaining = ps_codec->i4_bytes_remaining - nal_ofst; bytes_remaining = MIN((UWORD32)bytes_remaining, ps_codec->u4_bitsbuf_size); ihevcd_nal_remv_emuln_bytes(ps_codec->pu1_inp_bitsbuf + nal_ofst, ps_codec->pu1_bitsbuf, bytes_remaining, &nal_len, &bits_len); if(bits_len < (WORD32)(ps_codec->u4_bitsbuf_size - 8)) { memset(ps_codec->pu1_bitsbuf + bits_len, 0, 2 * sizeof(UWORD32)); } } ps_codec->i4_num_emln_bytes = nal_len - bits_len; ps_codec->i4_nal_len = nal_len; ihevcd_bits_init(&ps_codec->s_parse.s_bitstrm, ps_codec->pu1_bitsbuf, bits_len); ret = ihevcd_nal_unit(ps_codec); if(ps_codec->i4_pic_present && (ps_codec->s_parse.i4_next_ctb_indx != ps_codec->s_parse.ps_sps->i4_pic_size_in_ctb)) { if((ps_codec->i4_bytes_remaining - (nal_len + nal_ofst) <= MIN_START_CODE_LEN) || (ps_codec->i4_header_in_slice_mode)) { slice_header_t *ps_slice_hdr_next; ps_codec->s_parse.i4_cur_slice_idx--; if(ps_codec->s_parse.i4_cur_slice_idx < 0) ps_codec->s_parse.i4_cur_slice_idx = 0; ps_slice_hdr_next = ps_codec->s_parse.ps_slice_hdr_base + ((ps_codec->s_parse.i4_cur_slice_idx + 1) & (MAX_SLICE_HDR_CNT - 1)); ps_slice_hdr_next->i2_ctb_x = 0; ps_slice_hdr_next->i2_ctb_y = ps_codec->s_parse.ps_sps->i2_pic_ht_in_ctb; ps_codec->i4_slice_error = 1; continue; } } if(IHEVCD_IGNORE_SLICE == ret) { ps_codec->s_parse.i4_cur_slice_idx = MAX(0, (ps_codec->s_parse.i4_cur_slice_idx - 1)); ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len); ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len); continue; } if((IVD_RES_CHANGED == ret) || (IVD_STREAM_WIDTH_HEIGHT_NOT_SUPPORTED == ret)) { break; } if(ret != IHEVCD_SLICE_IN_HEADER_MODE) { if((0 == ps_codec->i4_slice_error) || (ps_codec->i4_bytes_remaining - (nal_len + nal_ofst) <= MIN_START_CODE_LEN)) { ps_codec->pu1_inp_bitsbuf += (nal_ofst + nal_len); ps_codec->i4_bytes_remaining -= (nal_ofst + nal_len); } if(ret != IHEVCD_SUCCESS) break; if(ps_codec->s_parse.i4_end_of_frame) break; } else { ret = IHEVCD_SUCCESS; break; } if((ps_codec->u4_allocate_dynamic_done == 0) && ps_codec->i4_sps_done) { WORD32 ret; ret = ihevcd_allocate_dynamic_bufs(ps_codec); if(ret != IV_SUCCESS) { ihevcd_free_dynamic_bufs(ps_codec); ps_codec->i4_error_code = IVD_MEM_ALLOC_FAILED; ps_dec_op->u4_error_code |= 1 << IVD_FATALERROR; ps_dec_op->u4_error_code |= IVD_MEM_ALLOC_FAILED; return IV_FAIL; } } BREAK_AFTER_SLICE_NAL(); } if((ps_codec->u4_pic_cnt == 0) && (ret != IHEVCD_SUCCESS)) { ps_codec->i4_error_code = ret; ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op); return IV_FAIL; } if(1 == ps_codec->i4_pic_present) { WORD32 i; sps_t *ps_sps = ps_codec->s_parse.ps_sps; ps_codec->i4_first_pic_done = 1; if(ps_codec->i4_num_cores > 1 && ps_codec->s_parse.i4_end_of_frame) { process_ctxt_t *ps_proc; ps_proc = &ps_codec->as_process[ps_codec->i4_num_cores - 1]; if((ps_codec->ps_disp_buf) && ((0 == ps_codec->i4_share_disp_buf) || (IV_YUV_420P == ps_codec->e_chroma_fmt))) { if((0 == ps_codec->u4_enable_fmt_conv_ahead) || (ps_codec->i4_disp_buf_id == ps_proc->i4_cur_pic_buf_id)) for(i = 0; i < ps_sps->i2_pic_ht_in_ctb; i++) { proc_job_t s_job; IHEVCD_ERROR_T ret; s_job.i4_cmd = CMD_FMTCONV; s_job.i2_ctb_cnt = 0; s_job.i2_ctb_x = 0; s_job.i2_ctb_y = i; s_job.i2_slice_idx = 0; s_job.i4_tu_coeff_data_ofst = 0; ret = ihevcd_jobq_queue((jobq_t *)ps_codec->s_parse.pv_proc_jobq, &s_job, sizeof(proc_job_t), 1); if(ret != (IHEVCD_ERROR_T)IHEVCD_SUCCESS) return (WORD32)ret; } } ret = ihevcd_jobq_terminate((jobq_t *)ps_codec->s_parse.pv_proc_jobq); while(1) { IHEVCD_ERROR_T ret; proc_job_t s_job; process_ctxt_t *ps_proc; ps_proc = &ps_codec->as_process[ps_codec->i4_num_cores - 1]; ret = ihevcd_jobq_dequeue((jobq_t *)ps_proc->pv_proc_jobq, &s_job, sizeof(proc_job_t), 1); if((IHEVCD_ERROR_T)IHEVCD_SUCCESS != ret) break; ps_proc->i4_ctb_cnt = s_job.i2_ctb_cnt; ps_proc->i4_ctb_x = s_job.i2_ctb_x; ps_proc->i4_ctb_y = s_job.i2_ctb_y; ps_proc->i4_cur_slice_idx = s_job.i2_slice_idx; if(CMD_PROCESS == s_job.i4_cmd) { ihevcd_init_proc_ctxt(ps_proc, s_job.i4_tu_coeff_data_ofst); ihevcd_process(ps_proc); } else if(CMD_FMTCONV == s_job.i4_cmd) { sps_t *ps_sps = ps_codec->s_parse.ps_sps; WORD32 num_rows = 1 << ps_sps->i1_log2_ctb_size; if(0 == ps_proc->i4_init_done) { ihevcd_init_proc_ctxt(ps_proc, 0); } num_rows = MIN(num_rows, (ps_codec->i4_disp_ht - (s_job.i2_ctb_y << ps_sps->i1_log2_ctb_size))); if(num_rows < 0) num_rows = 0; ihevcd_fmt_conv(ps_codec, ps_proc, ps_dec_ip->s_out_buffer.pu1_bufs[0], ps_dec_ip->s_out_buffer.pu1_bufs[1], ps_dec_ip->s_out_buffer.pu1_bufs[2], s_job.i2_ctb_y << ps_sps->i1_log2_ctb_size, num_rows); } } } else if((ps_codec->ps_disp_buf) && ((0 == ps_codec->i4_share_disp_buf) || (IV_YUV_420P == ps_codec->e_chroma_fmt)) && (ps_codec->s_parse.i4_end_of_frame)) { process_ctxt_t *ps_proc = &ps_codec->as_process[proc_idx]; ps_codec->s_fmt_conv.i4_num_rows = ps_codec->i4_disp_ht - ps_codec->s_fmt_conv.i4_cur_row; if(0 == ps_proc->i4_init_done) { ihevcd_init_proc_ctxt(ps_proc, 0); } if(ps_codec->s_fmt_conv.i4_num_rows < 0) ps_codec->s_fmt_conv.i4_num_rows = 0; ret = ihevcd_fmt_conv(ps_codec, ps_proc, ps_dec_ip->s_out_buffer.pu1_bufs[0], ps_dec_ip->s_out_buffer.pu1_bufs[1], ps_dec_ip->s_out_buffer.pu1_bufs[2], ps_codec->s_fmt_conv.i4_cur_row, ps_codec->s_fmt_conv.i4_num_rows); ps_codec->s_fmt_conv.i4_cur_row += ps_codec->s_fmt_conv.i4_num_rows; } DEBUG_DUMP_MV_MAP(ps_codec); ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_mv_buf_mgr, ps_codec->as_process[proc_idx].i4_cur_mv_bank_buf_id, BUF_MGR_REF); ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_pic_buf_mgr, ps_codec->as_process[proc_idx].i4_cur_pic_buf_id, BUF_MGR_REF); ihevc_buf_mgr_set_status((buf_mgr_t *)ps_codec->pv_pic_buf_mgr, ps_codec->as_process[proc_idx].i4_cur_pic_buf_id, BUF_MGR_DISP); ihevc_dpb_mgr_insert_ref((dpb_mgr_t *)ps_codec->pv_dpb_mgr, ps_codec->as_process[proc_idx].ps_cur_pic, ps_codec->as_process[proc_idx].i4_cur_pic_buf_id); if((0 == ps_codec->i4_share_disp_buf) && (ps_codec->ps_disp_buf)) ihevc_buf_mgr_release((buf_mgr_t *)ps_codec->pv_pic_buf_mgr, ps_codec->i4_disp_buf_id, BUF_MGR_DISP); for(i = 0; i < (ps_codec->i4_num_cores - 1); i++) { if(ps_codec->ai4_process_thread_created[i]) { ithread_join(ps_codec->apv_process_thread_handle[i], NULL); ps_codec->ai4_process_thread_created[i] = 0; } } DEBUG_VALIDATE_PADDED_REGION(&ps_codec->as_process[proc_idx]); if(ps_codec->u4_pic_cnt > 0) { DEBUG_DUMP_PIC_PU(ps_codec); } DEBUG_DUMP_PIC_BUFFERS(ps_codec); ps_codec->u4_pic_cnt++; } ihevcd_fill_outargs(ps_codec, ps_dec_ip, ps_dec_op); if(1 == ps_dec_op->u4_output_present) { WORD32 xpos = ps_codec->i4_disp_wd - 32 - LOGO_WD; WORD32 ypos = ps_codec->i4_disp_ht - 32 - LOGO_HT; if(ypos < 0) ypos = 0; if(xpos < 0) xpos = 0; INSERT_LOGO(ps_dec_ip->s_out_buffer.pu1_bufs[0], ps_dec_ip->s_out_buffer.pu1_bufs[1], ps_dec_ip->s_out_buffer.pu1_bufs[2], ps_codec->i4_disp_strd, xpos, ypos, ps_codec->e_chroma_fmt, ps_codec->i4_disp_wd, ps_codec->i4_disp_ht); } return ret; }
Description: A vulnerability in the Android media framework (n/a). Product: Android. Versions: 7.0, 7.1.1, 7.1.2, 8.0. Android ID: A-63045918.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: at_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data) { FILE *fd; unsigned char buffer[64]; int ColormapSize, rowbytes, Maps, Grey; unsigned char ColorMap[256][3]; at_bitmap image = at_bitmap_init(0, 0, 0, 1); unsigned char *image_storage; at_exception_type exp = at_exception_new(msg_func, msg_data); fd = fopen(filename, ""rb""); if (!fd) { LOG(""Can't open \""%s\""\n"", filename); at_exception_fatal(&exp, ""bmp: cannot open input file""); return image; } if (!ReadOK(fd, buffer, 18) || (strncmp((const char *)buffer, ""BM"", 2))) { LOG(""Not a valid BMP file %s\n"", filename); at_exception_fatal(&exp, ""bmp: invalid input file""); goto cleanup; } Bitmap_File_Head.bfSize = ToL(&buffer[0x02]); Bitmap_File_Head.zzHotX = ToS(&buffer[0x06]); Bitmap_File_Head.zzHotY = ToS(&buffer[0x08]); Bitmap_File_Head.bfOffs = ToL(&buffer[0x0a]); Bitmap_File_Head.biSize = ToL(&buffer[0x0e]); if (Bitmap_File_Head.biSize == 12) {   if (!ReadOK(fd, buffer, 8)) { LOG(""Error reading BMP file header\n""); at_exception_fatal(&exp, ""Error reading BMP file header""); goto cleanup; } Bitmap_Head.biWidth = ToS(&buffer[0x00]);  Bitmap_Head.biHeight = ToS(&buffer[0x02]);   Bitmap_Head.biPlanes = ToS(&buffer[0x04]);   Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);   Bitmap_Head.biCompr = 0; Bitmap_Head.biSizeIm = 0; Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0; Bitmap_Head.biClrUsed = 0; Maps = 3; } else if (Bitmap_File_Head.biSize == 40) {  if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4)) { LOG(""Error reading BMP file header\n""); at_exception_fatal(&exp, ""Error reading BMP file header""); goto cleanup; } Bitmap_Head.biWidth = ToL(&buffer[0x00]);  Bitmap_Head.biHeight = ToL(&buffer[0x04]);   Bitmap_Head.biPlanes = ToS(&buffer[0x08]);   Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);   Bitmap_Head.biCompr = ToL(&buffer[0x0C]);  Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);   Bitmap_Head.biXPels = ToL(&buffer[0x14]);  Bitmap_Head.biYPels = ToL(&buffer[0x18]);  Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]);  Bitmap_Head.biClrImp = ToL(&buffer[0x20]);   Maps = 4; } else if (Bitmap_File_Head.biSize >= 40 && Bitmap_File_Head.biSize <= 64) {   if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4)) { LOG(""Error reading BMP file header\n""); at_exception_fatal(&exp, ""Error reading BMP file header""); goto cleanup; } Bitmap_Head.biWidth = ToL(&buffer[0x00]);  Bitmap_Head.biHeight = ToL(&buffer[0x04]);   Bitmap_Head.biPlanes = ToS(&buffer[0x08]);   Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);   Bitmap_Head.biCompr = ToL(&buffer[0x0C]);  Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);   Bitmap_Head.biXPels = ToL(&buffer[0x14]);  Bitmap_Head.biYPels = ToL(&buffer[0x18]);  Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]);  Bitmap_Head.biClrImp = ToL(&buffer[0x20]);   Maps = 3; } else { LOG(""Error reading BMP file header\n""); at_exception_fatal(&exp, ""Error reading BMP file header""); goto cleanup; } ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps; if ((Bitmap_Head.biClrUsed == 0) && (Bitmap_Head.biBitCnt <= 8)) Bitmap_Head.biClrUsed = ColormapSize; if ((Bitmap_Head.biHeight == 0 || Bitmap_Head.biWidth == 0) || (Bitmap_Head.biPlanes != 1) || (ColormapSize > 256 || Bitmap_Head.biClrUsed > 256)) { LOG(""Error reading BMP file header\n""); at_exception_fatal(&exp, ""Error reading BMP file header""); goto cleanup; } rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4; #ifdef DEBUG printf(""\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\n"", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes); #endif ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp); if (at_exception_got_fatal(&exp)) goto cleanup; #ifdef DEBUG printf(""Colormap read\n""); #endif image_storage = ReadImage(fd, Bitmap_Head.biWidth, Bitmap_Head.biHeight, ColorMap, Bitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes, Grey); image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3); cleanup: fclose(fd); return (image); }
Description: A biWidth*biBitCnt integer overflow in input-bmp.c in autotrace 0.31.1 allows attackers to provide an unexpected input value to malloc via a malformed bitmap image.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void FilterManager::maybeEndEncode(bool end_stream) { if (end_stream) { filter_manager_callbacks_.endStream(); } }
Description: Envoy is an open source edge and service proxy, designed for cloud-native applications. Sending a locally generated response must stop further processing of request or response data. Envoy tracks the amount of buffered request and response data and aborts the request if the amount of buffered data is over the limit by sending 413 or 500 responses. However when the buffer overflows while response is processed by the filter chain the operation may not be aborted correctly and result in accessing a freed memory block. If this happens Envoy will crash resulting in a denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static inline void arista_print_date_hms_time(netdissect_options *ndo, uint32_t seconds, uint32_t nanoseconds) { time_t ts; struct tm *tm; char buf[BUFSIZE]; ts = seconds + (nanoseconds / 1000000000); nanoseconds %= 1000000000; if (NULL == (tm = gmtime(&ts))) ND_PRINT(""gmtime() error""); else if (0 == strftime(buf, sizeof(buf), ""%Y-%m-%d %H:%M:%S"", tm)) ND_PRINT(""strftime() error""); else ND_PRINT(""%s.%09u"", buf, nanoseconds); }
Description: The SMB protocol decoder in tcpdump version 4.99.3 can perform an out-of-bounds write when decoding a crafted network packet.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: status_t SoundTriggerHwService::Module::loadSoundModel(const sp<IMemory>& modelMemory, sound_model_handle_t *handle) { ALOGV(""loadSoundModel() handle""); if (!captureHotwordAllowed()) { return PERMISSION_DENIED; } if (modelMemory == 0 || modelMemory->pointer() == NULL) { ALOGE(""loadSoundModel() modelMemory is 0 or has NULL pointer()""); return BAD_VALUE; } struct sound_trigger_sound_model *sound_model = (struct sound_trigger_sound_model *)modelMemory->pointer(); AutoMutex lock(mLock); if (mModels.size() >= mDescriptor.properties.max_sound_models) { ALOGW(""loadSoundModel(): Not loading, max number of models (%d) would be exceeded"", mDescriptor.properties.max_sound_models); return INVALID_OPERATION; } status_t status = mHwDevice->load_sound_model(mHwDevice, sound_model, SoundTriggerHwService::soundModelCallback, this, handle); if (status != NO_ERROR) { return status; } audio_session_t session; audio_io_handle_t ioHandle; audio_devices_t device; status = AudioSystem::acquireSoundTriggerSession(&session, &ioHandle, &device); if (status != NO_ERROR) { return status; } sp<Model> model = new Model(*handle, session, ioHandle, device, sound_model->type); mModels.replaceValueFor(*handle, model); return status; }
Description: services/soundtrigger/SoundTriggerHwService.cpp in mediaserver in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 allows attackers to gain privileges via a crafted application, aka internal bug 30148546.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: TSReturnCode TSHttpTxnConfigFind(const char *name, int length, TSOverridableConfigKey *conf, TSRecordDataType *type) { sdk_assert(sdk_sanity_check_null_ptr((void *)name) == TS_SUCCESS); sdk_assert(sdk_sanity_check_null_ptr((void *)conf) == TS_SUCCESS); TSOverridableConfigKey cnf = TS_CONFIG_NULL; TSRecordDataType typ       = TS_RECORDDATATYPE_INT; if (length == -1) { length = strlen(name); } switch (length) { case 24: if (!strncmp(name, ""proxy.config.srv_enabled"", length)) { cnf = TS_CONFIG_SRV_ENABLED; } break; case 28: if (!strncmp(name, ""proxy.config.http.cache.http"", length)) { cnf = TS_CONFIG_HTTP_CACHE_HTTP; } break; case 29: if (!strncmp(name, ""proxy.config.ssl.hsts_max_age"", length)) { cnf = TS_CONFIG_SSL_HSTS_MAX_AGE; } break; case 30: if (!strncmp(name, ""proxy.config.http.normalize_ae"", length)) { cnf = TS_CONFIG_HTTP_NORMALIZE_AE; } break; case 31: if (!strncmp(name, ""proxy.config.http.chunking.size"", length)) { cnf = TS_CONFIG_HTTP_CHUNKING_SIZE; } break; case 33: if (!strncmp(name, ""proxy.config.ssl.client.cert.path"", length)) { cnf = TS_CONFIG_SSL_CERT_FILEPATH; typ = TS_RECORDDATATYPE_STRING; } break; case 34: if (!strncmp(name, ""proxy.config.http.chunking_enabled"", length)) { cnf = TS_CONFIG_HTTP_CHUNKING_ENABLED; } else if (!strncmp(name, ""proxy.config.http.cache.generation"", length)) { cnf = TS_CONFIG_HTTP_CACHE_GENERATION; } else if (!strncmp(name, ""proxy.config.http.insert_client_ip"", length)) { cnf = TS_CONFIG_HTTP_ANONYMIZE_INSERT_CLIENT_IP; } else if (!strncmp(name, ""proxy.config.http.insert_forwarded"", length)) { cnf = TS_CONFIG_HTTP_INSERT_FORWARDED; typ = TS_RECORDDATATYPE_STRING; } break; case 35: if (!strncmp(name, ""proxy.config.http.cache.range.write"", length)) { cnf = TS_CONFIG_HTTP_CACHE_RANGE_WRITE; } break; case 36: switch (name[length - 1]) { case 'p': if (!strncmp(name, ""proxy.config.http.cache.range.lookup"", length)) { cnf = TS_CONFIG_HTTP_CACHE_RANGE_LOOKUP; } break; case 't': if (!strncmp(name, ""proxy.config.net.sock_packet_tos_out"", length)) { cnf = TS_CONFIG_NET_SOCK_PACKET_TOS_OUT; } break; case 'd': if (!strncmp(name, ""proxy.config.http.slow.log.threshold"", length)) { cnf = TS_CONFIG_HTTP_SLOW_LOG_THRESHOLD; } break; } break; case 37: switch (name[length - 1]) { case 'e': if (!strncmp(name, ""proxy.config.http.cache.max_stale_age"", length)) { cnf = TS_CONFIG_HTTP_CACHE_MAX_STALE_AGE; } else if (!strncmp(name, ""proxy.config.http.default_buffer_size"", length)) { cnf = TS_CONFIG_HTTP_DEFAULT_BUFFER_SIZE; } else if (!strncmp(name, ""proxy.config.ssl.client.cert.filename"", length)) { cnf = TS_CONFIG_SSL_CERT_FILENAME; typ = TS_RECORDDATATYPE_STRING; } break; case 'r': if (!strncmp(name, ""proxy.config.http.response_server_str"", length)) { cnf = TS_CONFIG_HTTP_RESPONSE_SERVER_STR; typ = TS_RECORDDATATYPE_STRING; } else if (!strncmp(name, ""proxy.config.ssl.client.verify.server"", length)) { cnf = TS_CONFIG_SSL_CLIENT_VERIFY_SERVER; } break; case 't': if (!strncmp(name, ""proxy.config.http.keep_alive_post_out"", length)) { cnf = TS_CONFIG_HTTP_KEEP_ALIVE_POST_OUT; } else if (!strncmp(name, ""proxy.config.net.sock_option_flag_out"", length)) { cnf = TS_CONFIG_NET_SOCK_OPTION_FLAG_OUT; } else if (!strncmp(name, ""proxy.config.net.sock_packet_mark_out"", length)) { cnf = TS_CONFIG_NET_SOCK_PACKET_MARK_OUT; } else if (!strncmp(name, ""proxy.config.websocket.active_timeout"", length)) { cnf = TS_CONFIG_WEBSOCKET_ACTIVE_TIMEOUT; } break; } break; case 38: switch (name[length - 1]) { case 'd': if (!strncmp(name, ""proxy.config.http.server_tcp_init_cwnd"", length)) { cnf = TS_CONFIG_HTTP_SERVER_TCP_INIT_CWND; } else if (!strncmp(name, ""proxy.config.http.flow_control.enabled"", length)) { cnf = TS_CONFIG_HTTP_FLOW_CONTROL_ENABLED; } break; case 's': if (!strncmp(name, ""proxy.config.http.send_http11_requests"", length)) { cnf = TS_CONFIG_HTTP_SEND_HTTP11_REQUESTS; } break; } break; case 39: switch (name[length - 1]) { case 'e': if (!strncmp(name, ""proxy.config.body_factory.template_base"", length)) { cnf = TS_CONFIG_BODY_FACTORY_TEMPLATE_BASE; typ = TS_RECORDDATATYPE_STRING; } break; case 'm': if (!strncmp(name, ""proxy.config.http.anonymize_remove_from"", length)) { cnf = TS_CONFIG_HTTP_ANONYMIZE_REMOVE_FROM; } break; case 'n': if (!strncmp(name, ""proxy.config.http.keep_alive_enabled_in"", length)) { cnf = TS_CONFIG_HTTP_KEEP_ALIVE_ENABLED_IN; } break; case 's': if (!strncmp(name, ""proxy.config.http.doc_in_cache_skip_dns"", length)) { cnf = TS_CONFIG_HTTP_DOC_IN_CACHE_SKIP_DNS; } break; } break; case 40: switch (name[length - 1]) { case 'd': if (!strncmp(name, ""proxy.config.http.forward_connect_method"", length)) { cnf = TS_CONFIG_HTTP_FORWARD_CONNECT_METHOD; } break; case 'e': if (!strncmp(name, ""proxy.config.http.down_server.cache_time"", length)) { cnf = TS_CONFIG_HTTP_DOWN_SERVER_CACHE_TIME; } else if (!strncmp(name, ""proxy.config.http.insert_age_in_response"", length)) { cnf = TS_CONFIG_HTTP_INSERT_AGE_IN_RESPONSE; } break; case 'r': if (!strncmp(name, ""proxy.config.url_remap.pristine_host_hdr"", length)) { cnf = TS_CONFIG_URL_REMAP_PRISTINE_HOST_HDR; } else if (!strncmp(name, ""proxy.config.http.insert_request_via_str"", length)) { cnf = TS_CONFIG_HTTP_INSERT_REQUEST_VIA_STR; } else if (!strncmp(name, ""proxy.config.http.flow_control.low_water"", length)) { cnf = TS_CONFIG_HTTP_FLOW_CONTROL_LOW_WATER_MARK; } break; case 's': if (!strncmp(name, ""proxy.config.http.origin_max_connections"", length)) { cnf = TS_CONFIG_HTTP_ORIGIN_MAX_CONNECTIONS; } else if (!strncmp(name, ""proxy.config.http.cache.required_headers"", length)) { cnf = TS_CONFIG_HTTP_CACHE_REQUIRED_HEADERS; } else if (!strncmp(name, ""proxy.config.ssl.hsts_include_subdomains"", length)) { cnf = TS_CONFIG_SSL_HSTS_INCLUDE_SUBDOMAINS; } else if (!strncmp(name, ""proxy.config.http.number_of_redirections"", length)) { cnf = TS_CONFIG_HTTP_NUMBER_OF_REDIRECTIONS; } break; case 't': if (!strncmp(name, ""proxy.config.http.keep_alive_enabled_out"", length)) { cnf = TS_CONFIG_HTTP_KEEP_ALIVE_ENABLED_OUT; } break; } break; case 41: switch (name[length - 1]) { case 'd': if (!strncmp(name, ""proxy.config.http.response_server_enabled"", length)) { cnf = TS_CONFIG_HTTP_RESPONSE_SERVER_ENABLED; } break; case 'e': if (!strncmp(name, ""proxy.config.http.anonymize_remove_cookie"", length)) { cnf = TS_CONFIG_HTTP_ANONYMIZE_REMOVE_COOKIE; } else if (!strncmp(name, ""proxy.config.http.request_header_max_size"", length)) { cnf = TS_CONFIG_HTTP_REQUEST_HEADER_MAX_SIZE; } else if (!strncmp(name, ""proxy.config.http.parent_proxy.retry_time"", length)) { cnf = TS_CONFIG_HTTP_PARENT_PROXY_RETRY_TIME; } break; case 'r': if (!strncmp(name, ""proxy.config.http.insert_response_via_str"", length)) { cnf = TS_CONFIG_HTTP_INSERT_RESPONSE_VIA_STR; } else if (!strncmp(name, ""proxy.config.http.flow_control.high_water"", length)) { cnf = TS_CONFIG_HTTP_FLOW_CONTROL_HIGH_WATER_MARK; } break; case 't': if (!strncmp(name, ""proxy.config.http.cache.vary_default_text"", length)) { cnf = TS_CONFIG_HTTP_CACHE_VARY_DEFAULT_TEXT; typ = TS_RECORDDATATYPE_STRING; } break; } break; case 42: switch (name[length - 1]) { case 'd': if (!strncmp(name, ""proxy.config.http.negative_caching_enabled"", length)) { cnf = TS_CONFIG_HTTP_NEGATIVE_CACHING_ENABLED; } break; case 'e': if (!strncmp(name, ""proxy.config.http.cache.when_to_revalidate"", length)) { cnf = TS_CONFIG_HTTP_CACHE_WHEN_TO_REVALIDATE; } else if (!strncmp(name, ""proxy.config.http.response_header_max_size"", length)) { cnf = TS_CONFIG_HTTP_RESPONSE_HEADER_MAX_SIZE; } break; case 'r': if (!strncmp(name, ""proxy.config.http.anonymize_remove_referer"", length)) { cnf = TS_CONFIG_HTTP_ANONYMIZE_REMOVE_REFERER; } else if (!strncmp(name, ""proxy.config.http.global_user_agent_header"", length)) { cnf = TS_CONFIG_HTTP_GLOBAL_USER_AGENT_HEADER; typ = TS_RECORDDATATYPE_STRING; } else if (!strncmp(name, ""proxy.config.http.cache.vary_default_other"", length)) { cnf = TS_CONFIG_HTTP_CACHE_VARY_DEFAULT_OTHER; typ = TS_RECORDDATATYPE_STRING; } break; case 't': if (!strncmp(name, ""proxy.config.net.sock_recv_buffer_size_out"", length)) { cnf = TS_CONFIG_NET_SOCK_RECV_BUFFER_SIZE_OUT; } else if (!strncmp(name, ""proxy.config.net.sock_send_buffer_size_out"", length)) { cnf = TS_CONFIG_NET_SOCK_SEND_BUFFER_SIZE_OUT; } else if (!strncmp(name, ""proxy.config.http.connect_attempts_timeout"", length)) { cnf = TS_CONFIG_HTTP_CONNECT_ATTEMPTS_TIMEOUT; } else if (!strncmp(name, ""proxy.config.websocket.no_activity_timeout"", length)) { cnf = TS_CONFIG_WEBSOCKET_NO_ACTIVITY_TIMEOUT; } break; } break; case 43: switch (name[length - 1]) { case 'e': if (!strncmp(name, ""proxy.config.http.negative_caching_lifetime"", length)) { cnf = TS_CONFIG_HTTP_NEGATIVE_CACHING_LIFETIME; } break; case 'k': if (!strncmp(name, ""proxy.config.http.default_buffer_water_mark"", length)) { cnf = TS_CONFIG_HTTP_DEFAULT_BUFFER_WATER_MARK; } break; case 'r': if (!strncmp(name, ""proxy.config.http.cache.heuristic_lm_factor"", length)) { typ = TS_RECORDDATATYPE_FLOAT; cnf = TS_CONFIG_HTTP_CACHE_HEURISTIC_LM_FACTOR; } break; case 's': if (!strncmp(name, ""proxy.config.http.cache.vary_default_images"", length)) { cnf = TS_CONFIG_HTTP_CACHE_VARY_DEFAULT_IMAGES; typ = TS_RECORDDATATYPE_STRING; } break; } break; case 44: switch (name[length - 1]) { case 'p': if (!strncmp(name, ""proxy.config.http.anonymize_remove_client_ip"", length)) { cnf = TS_CONFIG_HTTP_ANONYMIZE_REMOVE_CLIENT_IP; } break; case 'e': if (!strncmp(name, ""proxy.config.http.cache.open_read_retry_time"", length)) { cnf = TS_CONFIG_HTTP_CACHE_OPEN_READ_RETRY_TIME; } break; } break; case 45: switch (name[length - 1]) { case 'd': if (!strncmp(name, ""proxy.config.http.down_server.abort_threshold"", length)) { cnf = TS_CONFIG_HTTP_DOWN_SERVER_ABORT_THRESHOLD; } else if (!strncmp(name, ""proxy.config.http.parent_proxy.fail_threshold"", length)) { cnf = TS_CONFIG_HTTP_PARENT_PROXY_FAIL_THRESHOLD; } break; case 'n': if (!strncmp(name, ""proxy.config.http.cache.ignore_authentication"", length)) { cnf = TS_CONFIG_HTTP_CACHE_IGNORE_AUTHENTICATION; } break; case 't': if (!strncmp(name, ""proxy.config.http.anonymize_remove_user_agent"", length)) { cnf = TS_CONFIG_HTTP_ANONYMIZE_REMOVE_USER_AGENT; } break; case 's': if (!strncmp(name, ""proxy.config.http.connect_attempts_rr_retries"", length)) { cnf = TS_CONFIG_HTTP_CONNECT_ATTEMPTS_RR_RETRIES; } else if (!strncmp(name, ""proxy.config.http.cache.max_open_read_retries"", length)) { cnf = TS_CONFIG_HTTP_CACHE_MAX_OPEN_READ_RETRIES; } break; case 'e': if (0 == strncmp(name, ""proxy.config.http.auth_server_session_private"", length)) { cnf = TS_CONFIG_HTTP_AUTH_SERVER_SESSION_PRIVATE; } break; case 'y': if (!strncmp(name, ""proxy.config.http.redirect_use_orig_cache_key"", length)) { cnf = TS_CONFIG_HTTP_REDIRECT_USE_ORIG_CACHE_KEY; } break; } break; case 46: switch (name[length - 1]) { case 'e': if (!strncmp(name, ""proxy.config.http.cache.ignore_client_no_cache"", length)) { cnf = TS_CONFIG_HTTP_CACHE_IGNORE_CLIENT_NO_CACHE; } else if (!strncmp(name, ""proxy.config.http.cache.ims_on_client_no_cache"", length)) { cnf = TS_CONFIG_HTTP_CACHE_IMS_ON_CLIENT_NO_CACHE; } else if (!strncmp(name, ""proxy.config.http.cache.ignore_server_no_cache"", length)) { cnf = TS_CONFIG_HTTP_CACHE_IGNORE_SERVER_NO_CACHE; } else if (!strncmp(name, ""proxy.config.http.cache.heuristic_min_lifetime"", length)) { cnf = TS_CONFIG_HTTP_CACHE_HEURISTIC_MIN_LIFETIME; } else if (!strncmp(name, ""proxy.config.http.cache.heuristic_max_lifetime"", length)) { cnf = TS_CONFIG_HTTP_CACHE_HEURISTIC_MAX_LIFETIME; } else if (!strncmp(name, ""proxy.config.http.origin_max_connections_queue"", length)) { cnf = TS_CONFIG_HTTP_ORIGIN_MAX_CONNECTIONS_QUEUE; } break; case 'h': if (0 == strncmp(name, ""proxy.config.http.server_session_sharing.match"", length)) { cnf = TS_CONFIG_HTTP_SERVER_SESSION_SHARING_MATCH; } else if (!strncmp(name, ""proxy.config.http.cache.ignore_accept_mismatch"", length)) { cnf = TS_CONFIG_HTTP_CACHE_IGNORE_ACCEPT_MISMATCH; } break; case 'n': if (!strncmp(name, ""proxy.config.http.cache.open_write_fail_action"", length)) { cnf = TS_CONFIG_HTTP_CACHE_OPEN_WRITE_FAIL_ACTION; } break; case 'r': if (!strncmp(name, ""proxy.config.http.insert_squid_x_forwarded_for"", length)) { cnf = TS_CONFIG_HTTP_INSERT_SQUID_X_FORWARDED_FOR; } break; case 's': if (!strncmp(name, ""proxy.config.http.connect_attempts_max_retries"", length)) { cnf = TS_CONFIG_HTTP_CONNECT_ATTEMPTS_MAX_RETRIES; } else if (!strncmp(name, ""proxy.config.http.cache.max_open_write_retries"", length)) { cnf = TS_CONFIG_HTTP_CACHE_MAX_OPEN_WRITE_RETRIES; } break; case 't': if (!strncmp(name, ""proxy.config.http.forward.proxy_auth_to_parent"", length)) { cnf = TS_CONFIG_HTTP_FORWARD_PROXY_AUTH_TO_PARENT; } break; } break; case 47: switch (name[length - 1]) { case 'b': if (!strncmp(name, ""proxy.config.http.parent_proxy.mark_down_hostdb"", length)) { cnf = TS_CONFIG_PARENT_FAILURES_UPDATE_HOSTDB; } break; case 'd': if (!strncmp(name, ""proxy.config.http.negative_revalidating_enabled"", length)) { cnf = TS_CONFIG_HTTP_NEGATIVE_REVALIDATING_ENABLED; } break; case 'e': if (!strncmp(name, ""proxy.config.http.cache.guaranteed_min_lifetime"", length)) { cnf = TS_CONFIG_HTTP_CACHE_GUARANTEED_MIN_LIFETIME; } else if (!strncmp(name, ""proxy.config.http.cache.guaranteed_max_lifetime"", length)) { cnf = TS_CONFIG_HTTP_CACHE_GUARANTEED_MAX_LIFETIME; } break; case 'n': if (!strncmp(name, ""proxy.config.http.transaction_active_timeout_in"", length)) { cnf = TS_CONFIG_HTTP_TRANSACTION_ACTIVE_TIMEOUT_IN; } break; case 't': if (!strncmp(name, ""proxy.config.http.post_connect_attempts_timeout"", length)) { cnf = TS_CONFIG_HTTP_POST_CONNECT_ATTEMPTS_TIMEOUT; } break; } break; case 48: switch (name[length - 1]) { case 'e': if (!strncmp(name, ""proxy.config.http.cache.ignore_client_cc_max_age"", length)) { cnf = TS_CONFIG_HTTP_CACHE_IGNORE_CLIENT_CC_MAX_AGE; } else if (!strncmp(name, ""proxy.config.http.negative_revalidating_lifetime"", length)) { cnf = TS_CONFIG_HTTP_NEGATIVE_REVALIDATING_LIFETIME; } break; case 't': switch (name[length - 4]) { case '_': if (!strncmp(name, ""proxy.config.http.transaction_active_timeout_out"", length)) { cnf = TS_CONFIG_HTTP_TRANSACTION_ACTIVE_TIMEOUT_OUT; } break; case 'e': if (!strncmp(name, ""proxy.config.http.background_fill_active_timeout"", length)) { cnf = TS_CONFIG_HTTP_BACKGROUND_FILL_ACTIVE_TIMEOUT; } break; } break; } break; case 49: if (!strncmp(name, ""proxy.config.http.attach_server_session_to_client"", length)) { cnf = TS_CONFIG_HTTP_ATTACH_SERVER_SESSION_TO_CLIENT; } break; case 50: if (!strncmp(name, ""proxy.config.http.cache.cache_responses_to_cookies"", length)) { cnf = TS_CONFIG_HTTP_CACHE_CACHE_RESPONSES_TO_COOKIES; } break; case 51: switch (name[length - 1]) { case 'n': if (!strncmp(name, ""proxy.config.http.keep_alive_no_activity_timeout_in"", length)) { cnf = TS_CONFIG_HTTP_KEEP_ALIVE_NO_ACTIVITY_TIMEOUT_IN; } break; case 'd': if (!strncmp(name, ""proxy.config.http.post.check.content_length.enabled"", length)) { cnf = TS_CONFIG_HTTP_POST_CHECK_CONTENT_LENGTH_ENABLED; } break; case 's': if (!strncmp(name, ""proxy.config.http.cache.enable_default_vary_headers"", length)) { cnf = TS_CONFIG_HTTP_CACHE_ENABLE_DEFAULT_VARY_HEADER; } break; } break; case 52: switch (name[length - 1]) { case 'c': if (!strncmp(name, ""proxy.config.http.cache.cache_urls_that_look_dynamic"", length)) { cnf = TS_CONFIG_HTTP_CACHE_CACHE_URLS_THAT_LOOK_DYNAMIC; } break; case 'n': if (!strncmp(name, ""proxy.config.http.transaction_no_activity_timeout_in"", length)) { cnf = TS_CONFIG_HTTP_TRANSACTION_NO_ACTIVITY_TIMEOUT_IN; } break; case 't': if (!strncmp(name, ""proxy.config.http.keep_alive_no_activity_timeout_out"", length)) { cnf = TS_CONFIG_HTTP_KEEP_ALIVE_NO_ACTIVITY_TIMEOUT_OUT; } else if (!strncmp(name, ""proxy.config.http.uncacheable_requests_bypass_parent"", length)) { cnf = TS_CONFIG_HTTP_UNCACHEABLE_REQUESTS_BYPASS_PARENT; } break; } break; case 53: switch (name[length - 1]) { case 't': if (!strncmp(name, ""proxy.config.http.transaction_no_activity_timeout_out"", length)) { cnf = TS_CONFIG_HTTP_TRANSACTION_NO_ACTIVITY_TIMEOUT_OUT; } break; case 'd': if (!strncmp(name, ""proxy.config.http.background_fill_completed_threshold"", length)) { typ = TS_RECORDDATATYPE_FLOAT; cnf = TS_CONFIG_HTTP_BACKGROUND_FILL_COMPLETED_THRESHOLD; } break; case 's': if (!strncmp(name, ""proxy.config.http.parent_proxy.total_connect_attempts"", length)) { cnf = TS_CONFIG_HTTP_PARENT_PROXY_TOTAL_CONNECT_ATTEMPTS; } break; } break; case 54: if (!strncmp(name, ""proxy.config.http.cache.ignore_accept_charset_mismatch"", length)) { cnf = TS_CONFIG_HTTP_CACHE_IGNORE_ACCEPT_CHARSET_MISMATCH; } break; case 55: if (!strncmp(name, ""proxy.config.http.cache.ignore_accept_language_mismatch"", length)) { cnf = TS_CONFIG_HTTP_CACHE_IGNORE_ACCEPT_LANGUAGE_MISMATCH; } else if (!strncmp(name, ""proxy.config.http.cache.ignore_accept_encoding_mismatch"", length)) { cnf = TS_CONFIG_HTTP_CACHE_IGNORE_ACCEPT_ENCODING_MISMATCH; } else if (!strncmp(name, ""proxy.config.http.parent_proxy.connect_attempts_timeout"", length)) { cnf = TS_CONFIG_HTTP_PARENT_CONNECT_ATTEMPT_TIMEOUT; } break; case 58: if (!strncmp(name, ""proxy.config.http.connect_attempts_max_retries_dead_server"", length)) { cnf = TS_CONFIG_HTTP_CONNECT_ATTEMPTS_MAX_RETRIES_DEAD_SERVER; } else if (!strncmp(name, ""proxy.config.http.parent_proxy.per_parent_connect_attempts"", length)) { cnf = TS_CONFIG_HTTP_PER_PARENT_CONNECT_ATTEMPTS; } break; } *conf = cnf; if (type) { *type = typ; } return ((cnf != TS_CONFIG_NULL) ? TS_SUCCESS : TS_ERROR); }
Description: When there are multiple ranges in a range request, Apache Traffic Server (ATS) will read the entire object from cache. This can cause performance problems with large objects in cache. This affects versions 6.0.0 to 6.2.2 and 7.0.0 to 7.1.3. To resolve this issue users running 6.x users should upgrade to 6.2.3 or later versions and 7.x users should upgrade to 7.1.4 or later versions.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Supports_Condition_Obj Parser::parse_supports_condition_in_parens() { Supports_Condition_Obj interp = parse_supports_interpolation(); if (interp != 0) return interp; if (!lex < exactly <'('> >()) return {}; lex < css_whitespace >(); Supports_Condition_Obj cond = parse_supports_condition(); if (cond != 0) { if (!lex < exactly <')'> >()) error(""unclosed parenthesis in @supports declaration""); } else { cond = parse_supports_declaration(); if (!lex < exactly <')'> >()) error(""unclosed parenthesis in @supports declaration""); } lex < css_whitespace >(); return cond; }
Description: In LibSass 3.5.5, a NULL Pointer Dereference in the function Sass::Eval::operator()(Sass::Supports_Operator*) in eval.cpp may cause a Denial of Service (application crash) via a crafted sass input file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: mp_err mp_2expt(mp_int *a, int b) { mp_err    err; mp_zero(a); if ((err = mp_grow(a, (b / MP_DIGIT_BIT) + 1)) != MP_OKAY) { return err; } a->used = (b / MP_DIGIT_BIT) + 1; a->dp[b / MP_DIGIT_BIT] = (mp_digit)1 << (mp_digit)(b % MP_DIGIT_BIT); return MP_OKAY; }
Description: Integer Overflow vulnerability in mp_grow in libtom libtommath before commit beba892bc0d4e4ded4d667ab1d2a94f4d75109a9, allows attackers to execute arbitrary code and cause a denial of service (DoS).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int instance_rmdir(struct inode *inode, struct dentry *dentry) { struct dentry *parent; int ret; parent = hlist_entry(inode->i_dentry.first, struct dentry, d_alias); if (WARN_ON_ONCE(parent != trace_instance_dir)) return -ENOENT; mutex_unlock(&dentry->d_inode->i_mutex); mutex_unlock(&inode->i_mutex); ret = instance_delete(dentry->d_iname); mutex_lock_nested(&inode->i_mutex, I_MUTEX_PARENT); mutex_lock(&dentry->d_inode->i_mutex); return ret; }
Description: The d_walk function in fs/dcache.c in the Linux kernel through 3.17.2 does not properly maintain the semantics of rename_lock, which allows local users to cause a denial of service (deadlock and system hang) via a crafted application.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int vvalue_tvb_vector_internal(tvbuff_t *tvb, int offset, struct vt_vector *val, struct vtype_data *type, guint num) { const int offset_in = offset; const gboolean varsize = (type->size == -1); const guint elsize = varsize ? (guint)sizeof(struct data_blob) : (guint)type->size; guint8 *data; int len; guint i; if ((guint64)elsize * (guint64)num > G_MAXUINT) { THROW(ReportedBoundsError); } tvb_ensure_bytes_exist(tvb, offset, elsize * num); data = (guint8*)wmem_alloc(wmem_packet_scope(), elsize * num); val->len = num; val->u.vt_ui1 = data; DISSECTOR_ASSERT((void*)&val->u == ((void*)&val->u.vt_ui1)); for (i=0; i<num; i++) { DISSECTOR_ASSERT_HINT(type->tvb_get != 0, ""type that we don't know yet how to handle, please submit a bug with trace""); len = type->tvb_get(tvb, offset, data); data += elsize; offset += len; if (varsize && (offset % 4) ) {  int padding = 4 - (offset % 4); offset += padding; } } return offset - offset_in; }
Description: Excessive memory consumption in MS-WSP dissector in Wireshark 3.4.0 to 3.4.4 and 3.2.0 to 3.2.12 allows denial of service via packet injection or crafted capture file
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: TfLiteStatus EvalFloat(TfLiteContext* context, TfLiteNode* node, TfLiteFullyConnectedParams* params, OpData* data, const TfLiteTensor* input, const TfLiteTensor* filter, const TfLiteTensor* bias, TfLiteTensor* output) { float output_activation_min, output_activation_max; CalculateActivationRange(params->activation, &output_activation_min, &output_activation_max); if (kernel_type == kReference) { FullyConnectedParams op_params; op_params.float_activation_min = output_activation_min; op_params.float_activation_max = output_activation_max; if (filter->sparsity != nullptr) { const auto& sparsity = *filter->sparsity; reference_ops::FullyConnectedSparseWeight( sparsity, op_params, GetTensorShape(input), GetTensorData<float>(input), GetTensorShape(filter), GetTensorData<float>(filter), GetTensorShape(bias), GetTensorData<float>(bias), GetTensorShape(output), GetTensorData<float>(output)); } else { reference_ops::FullyConnected( op_params, GetTensorShape(input), GetTensorData<float>(input), GetTensorShape(filter), GetTensorData<float>(filter), GetTensorShape(bias), GetTensorData<float>(bias), GetTensorShape(output), GetTensorData<float>(output)); } } else if (kernel_type == kLegacyPie) { return EvalPie(context, node, params, data, input, filter, bias, output); } else { FullyConnectedParams op_params; op_params.float_activation_min = output_activation_min; op_params.float_activation_max = output_activation_max; if (filter->sparsity != nullptr) { const auto& sparsity = *filter->sparsity; if (!SupportedSparsityFormat(sparsity)) { TF_LITE_KERNEL_LOG(context, ""Unsupported sparse fully-connected weight format.""); return kTfLiteError; } if (sparsity.dim_metadata_size == kDimMetadataSizeRandomSparse) { optimized_ops::FullyConnectedSparseWeight( sparsity, op_params, GetTensorShape(input), GetTensorData<float>(input), GetTensorShape(filter), GetTensorData<float>(filter), GetTensorShape(bias), GetTensorData<float>(bias), GetTensorShape(output), GetTensorData<float>(output)); } else if (sparsity.dim_metadata_size == kDimMetadataSizeBlockSparse && sparsity.dim_metadata[2].dense_size == 4) { optimized_ops::FullyConnectedSparseWeight1x4( sparsity, op_params, GetTensorShape(input), GetTensorData<float>(input), GetTensorShape(filter), GetTensorData<float>(filter), GetTensorShape(bias), GetTensorData<float>(bias), GetTensorShape(output), GetTensorData<float>(output), CpuBackendContext::GetFromContext(context)); } else { TF_LITE_KERNEL_LOG(context, ""Unsupported sparse fully-connected weight format.""); return kTfLiteError; } } else { op_params.lhs_cacheable = IsConstantTensor(filter); op_params.rhs_cacheable = IsConstantTensor(input); optimized_ops::FullyConnected( op_params, GetTensorShape(input), GetTensorData<float>(input), GetTensorShape(filter), GetTensorData<float>(filter), GetTensorShape(bias), GetTensorData<float>(bias), GetTensorShape(output), GetTensorData<float>(output), CpuBackendContext::GetFromContext(context)); } } return kTfLiteOk; }
Description: Tensorflow is an Open Source Machine Learning Framework. An attacker can craft a TFLite model that would cause a write outside of bounds of an array in TFLite. In fact, the attacker can override the linked list used by the memory allocator. This can be leveraged for an arbitrary write primitive under certain conditions. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int dissect_dcom_BSTR(tvbuff_t *tvb, gint offset, packet_info *pinfo, proto_tree *tree, dcerpc_info *di, guint8 *drep, int hfindex, gchar *pszStr, guint32 u32MaxStr) { guint32 u32MaxCount; guint32 u32ArraySize; gint strStart, subStart, realOffset; proto_item *sub_item; proto_tree *sub_tree; guint32 u32ByteLength; gboolean isPrintable; if (offset % 4) { offset += 4 - (offset % 4); } sub_item = proto_tree_add_string(tree, hfindex, tvb, offset, 0, """"); sub_tree = proto_item_add_subtree(sub_item, ett_dcom_lpwstr); subStart = offset; offset = dissect_dcom_DWORD(tvb, offset, pinfo, sub_tree, di, drep, hf_dcom_max_count, &u32MaxCount); offset = dissect_dcom_DWORD(tvb, offset, pinfo, sub_tree, di, drep, hf_dcom_byte_length, &u32ByteLength); offset = dissect_dcom_dcerpc_array_size(tvb, offset, pinfo, sub_tree, di, drep, &u32ArraySize); if ((guint32)offset + u32ArraySize*2 > G_MAXINT) return offset; realOffset = offset + u32ArraySize*2; strStart = offset; offset = dcom_tvb_get_nwstringz0(tvb, offset, u32ArraySize*2, pszStr, u32MaxStr, &isPrintable); proto_tree_add_string(sub_tree, hfindex, tvb, strStart, offset - strStart, pszStr); proto_item_append_text(sub_item, ""%s%s%s"", isPrintable ? ""\"""" : """", pszStr, isPrintable ? ""\"""" : """"); if (realOffset <= subStart) { return offset; } proto_item_set_len(sub_item, realOffset - subStart); return realOffset; }
Description: In Wireshark 2.6.0 to 2.6.4 and 2.4.0 to 2.4.10, the DCOM dissector could crash. This was addressed in epan/dissectors/packet-dcom.c by adding '\0' termination.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Image::SampledInfo::~SampledInfo() { delete img; if (imgs!=NULLP) { Image::Indexed::delete_separated(imgs); delete imgs; } }
Description: The DGifDecompressLine function in dgif_lib.c in GIFLIB (possibly version 3.0.x), as later shipped in cgif.c in sam2p 0.49.4, has a heap-based buffer overflow because a certain CrntCode array index is not checked. This will lead to a denial of service or possibly unspecified other impact.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int find_next_quote( char_u*line, intcol, intquotechar, char_u*escape){ intc; for (;;) { c = line[col]; if (c == NUL) return -1; else if (escape != NULL && vim_strchr(escape, c)) ++col; else if (c == quotechar) break; if (has_mbyte) col += (*mb_ptr2len)(line + col); else ++col; } return col; }
Description: Buffer Over-read in function find_next_quote in GitHub repository vim/vim prior to 8.2.4925. This vulnerabilities are capable of crashing software, Modify Memory, and possible remote execution
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: FixedArrayBase* Heap::LeftTrimFixedArray(FixedArrayBase* object, int elements_to_trim) { DCHECK(!object->IsFixedTypedArrayBase()); DCHECK(!object->IsByteArray()); const int element_size = object->IsFixedArray() ? kPointerSize : kDoubleSize; const int bytes_to_trim = elements_to_trim * element_size; Map* map = object->map(); DCHECK(!lo_space()->Contains(object)); DCHECK(object->map() != fixed_cow_array_map()); SLOW_DCHECK(CountHandlesForObject(object) <= 1); STATIC_ASSERT(FixedArrayBase::kMapOffset == 0); STATIC_ASSERT(FixedArrayBase::kLengthOffset == kPointerSize); STATIC_ASSERT(FixedArrayBase::kHeaderSize == 2 * kPointerSize); const int len = object->length(); DCHECK(elements_to_trim <= len); Address new_start = object->address() + bytes_to_trim; CreateFillerObjectAt(object->address(), bytes_to_trim, ClearRecordedSlots::kYes); DCHECK(CanMoveObjectStart(object)); Object** former_start = HeapObject::RawField(object, 0); int new_start_index = elements_to_trim * (element_size / kPointerSize); former_start[new_start_index] = map; former_start[new_start_index + 1] = Smi::FromInt(len - elements_to_trim); FixedArrayBase* new_object = FixedArrayBase::cast(HeapObject::FromAddress(new_start)); ClearRecordedSlot(new_object, HeapObject::RawField(new_object, 0)); ClearRecordedSlot(new_object, HeapObject::RawField( new_object, FixedArrayBase::kLengthOffset)); Marking::TransferMark(this, object->address(), new_start); AdjustLiveBytes(new_object, -bytes_to_trim, Heap::CONCURRENT_TO_SWEEPER); OnMoveEvent(new_object, object, new_object->Size()); return new_object; }
Description: Google V8 before 5.2.361.32, as used in Google Chrome before 52.0.2743.82, does not properly process left-trimmed objects, which allows remote attackers to cause a denial of service (memory corruption) or possibly have unspecified other impact via crafted JavaScript code.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: ACPI_STATUS AcpiNsEvaluate ( ACPI_EVALUATE_INFO      *Info) { ACPI_STATUS             Status; ACPI_FUNCTION_TRACE (NsEvaluate); if (!Info) { return_ACPI_STATUS (AE_BAD_PARAMETER); } if (!Info->Node) { Status = AcpiNsGetNode (Info->PrefixNode, Info->RelativePathname, ACPI_NS_NO_UPSEARCH, &Info->Node); if (ACPI_FAILURE (Status)) { return_ACPI_STATUS (Status); } } if (AcpiNsGetType (Info->Node) == ACPI_TYPE_LOCAL_METHOD_ALIAS) { Info->Node = ACPI_CAST_PTR ( ACPI_NAMESPACE_NODE, Info->Node->Object); } Info->ReturnObject = NULL; Info->NodeFlags = Info->Node->Flags; Info->ObjDesc = AcpiNsGetAttachedObject (Info->Node); ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, ""%s [%p] Value %p\n"", Info->RelativePathname, Info->Node, AcpiNsGetAttachedObject (Info->Node))); Info->Predefined = AcpiUtMatchPredefinedMethod (Info->Node->Name.Ascii); Info->FullPathname = AcpiNsGetNormalizedPathname (Info->Node, TRUE); if (!Info->FullPathname) { return_ACPI_STATUS (AE_NO_MEMORY); } Info->ParamCount = 0; if (Info->Parameters) { while (Info->Parameters[Info->ParamCount]) { Info->ParamCount++; } if (Info->ParamCount > ACPI_METHOD_NUM_ARGS) { ACPI_WARN_PREDEFINED ((AE_INFO, Info->FullPathname, ACPI_WARN_ALWAYS, ""Excess arguments (%u) - using only %u"", Info->ParamCount, ACPI_METHOD_NUM_ARGS)); Info->ParamCount = ACPI_METHOD_NUM_ARGS; } } AcpiNsCheckAcpiCompliance (Info->FullPathname, Info->Node, Info->Predefined); AcpiNsCheckArgumentCount (Info->FullPathname, Info->Node, Info->ParamCount, Info->Predefined); AcpiNsCheckArgumentTypes (Info); switch (AcpiNsGetType (Info->Node)) { case ACPI_TYPE_DEVICE: case ACPI_TYPE_EVENT: case ACPI_TYPE_MUTEX: case ACPI_TYPE_REGION: case ACPI_TYPE_THERMAL: case ACPI_TYPE_LOCAL_SCOPE: ACPI_ERROR ((AE_INFO, ""%s: Evaluation of object type [%s] is not supported"", Info->FullPathname, AcpiUtGetTypeName (Info->Node->Type))); Status = AE_TYPE; goto Cleanup; case ACPI_TYPE_METHOD: if (!Info->ObjDesc) { ACPI_ERROR ((AE_INFO, ""%s: Method has no attached sub-object"", Info->FullPathname)); Status = AE_NULL_OBJECT; goto Cleanup; } ACPI_DEBUG_PRINT ((ACPI_DB_EXEC, ""**** Execute method [%s] at AML address %p length %X\n"", Info->FullPathname, Info->ObjDesc->Method.AmlStart + 1, Info->ObjDesc->Method.AmlLength - 1)); AcpiExEnterInterpreter (); Status = AcpiPsExecuteMethod (Info); AcpiExExitInterpreter (); break; default: AcpiExEnterInterpreter (); Info->ReturnObject = ACPI_CAST_PTR (ACPI_OPERAND_OBJECT, Info->Node); Status = AcpiExResolveNodeToValue (ACPI_CAST_INDIRECT_PTR ( ACPI_NAMESPACE_NODE, &Info->ReturnObject), NULL); AcpiExExitInterpreter (); if (ACPI_FAILURE (Status)) { Info->ReturnObject = NULL; goto Cleanup; } ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, ""Returned object %p [%s]\n"", Info->ReturnObject, AcpiUtGetObjectTypeName (Info->ReturnObject))); Status = AE_CTRL_RETURN_VALUE;  break; } (void) AcpiNsCheckReturnValue (Info->Node, Info, Info->ParamCount, Status, &Info->ReturnObject); if (Status == AE_CTRL_RETURN_VALUE) { if (Info->Flags & ACPI_IGNORE_RETURN_VALUE) { AcpiUtRemoveReference (Info->ReturnObject); Info->ReturnObject = NULL; } Status = AE_OK; } ACPI_DEBUG_PRINT ((ACPI_DB_NAMES, ""*** Completed evaluation of object %s ***\n"", Info->RelativePathname)); Cleanup: ACPI_FREE (Info->FullPathname); Info->FullPathname = NULL; return_ACPI_STATUS (Status); }
Description: The acpi_ns_evaluate() function in drivers/acpi/acpica/nseval.c in the Linux kernel through 4.12.9 does not flush the operand cache and causes a kernel stack dump, which allows local users to obtain sensitive information from kernel memory and bypass the KASLR protection mechanism (in the kernel through 4.9) via a crafted ACPI table.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void append_command(char_u *cmd) { char_u *s = cmd; char_u *d; STRCAT(IObuff, "": ""); d = IObuff + STRLEN(IObuff); while (*s != NUL && d - IObuff < IOSIZE - 7) { if (enc_utf8 ? (s[0] == 0xc2 && s[1] == 0xa0) : *s == 0xa0) { s += enc_utf8 ? 2 : 1; STRCPY(d, ""<a0>""); d += 4; } else MB_COPY_CHAR(s, d); } *d = NUL; }
Description: Use after free in append_command in GitHub repository vim/vim prior to 8.2.4895. This vulnerability is capable of crashing software, Bypass Protection Mechanism, Modify Memory, and possible remote execution
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int parse_config(char *filename, bridge_t **bridges) { dictionary *ubridge_config = NULL; const char *value; const char *bridge_name; int i, nsec; if ((ubridge_config = iniparser_load(filename)) == NULL) { return FALSE; } nsec = iniparser_getnsec(ubridge_config); for (i = 0; i < nsec; i++) { bridge_t *bridge; nio_t *source_nio = NULL; nio_t *destination_nio = NULL; bridge_name = iniparser_getsecname(ubridge_config, i); printf(""Parsing %s\n"", bridge_name); if (getstr(ubridge_config, bridge_name, ""source_udp"", &value)) source_nio = create_udp_tunnel(value); else if (getstr(ubridge_config, bridge_name, ""source_unix"", &value)) source_nio = create_unix_socket(value); else if (getstr(ubridge_config, bridge_name, ""source_ethernet"", &value)) source_nio = open_ethernet_device(value); else if (getstr(ubridge_config, bridge_name, ""source_tap"", &value)) source_nio = open_tap_device(value); #ifdef LINUX_RAW else if (getstr(ubridge_config, bridge_name, ""source_linux_raw"", &value)) source_nio = open_linux_raw(value); #endif #ifdef __APPLE__ else if (getstr(ubridge_config, bridge_name, ""source_fusion_vmnet"", &value)) source_nio = open_fusion_vmnet(value); #endif else fprintf(stderr, ""source NIO not found\n""); if (getstr(ubridge_config, bridge_name, ""destination_udp"", &value)) destination_nio = create_udp_tunnel(value); else if (getstr(ubridge_config, bridge_name, ""destination_unix"", &value)) destination_nio = create_unix_socket(value); else if (getstr(ubridge_config, bridge_name, ""destination_ethernet"", &value)) destination_nio = open_ethernet_device(value); else if (getstr(ubridge_config, bridge_name, ""destination_tap"", &value)) destination_nio = open_tap_device(value); #ifdef LINUX_RAW else if (getstr(ubridge_config, bridge_name, ""destination_linux_raw"", &value)) source_nio = open_linux_raw(value); #endif #ifdef __APPLE__ else if (getstr(ubridge_config, bridge_name, ""destination_fusion_vmnet"", &value)) destination_nio = open_fusion_vmnet(value); #endif else fprintf(stderr, ""destination NIO not found\n""); if (source_nio && destination_nio) { bridge = add_bridge(bridges); bridge->source_nio = source_nio; bridge->destination_nio = destination_nio; if (!(bridge->name = strdup(bridge_name))) { fprintf(stderr, ""bridge creation: insufficient memory\n""); return FALSE; } parse_capture(ubridge_config, bridge_name, bridge); parse_filter(ubridge_config, bridge_name, bridge); } else if (source_nio != NULL) free_nio(source_nio); else if (destination_nio != NULL) free_nio(destination_nio); } iniparser_freedict(ubridge_config); return TRUE; }
Description: GNS3 ubridge through 0.9.18 on macOS, as used in GNS3 server before 2.1.17, allows a local attacker to read arbitrary files because it handles configuration-file errors by printing the configuration file while executing in a setuid root context.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static inline int process_nested_data(UNSERIALIZE_PARAMETER, HashTable *ht, long elements, int objprops) { while (elements-- > 0) { zval *key, *data, **old_data; ALLOC_INIT_ZVAL(key); if (!php_var_unserialize(&key, p, max, NULL TSRMLS_CC)) { zval_dtor(key); FREE_ZVAL(key); return 0; } if (Z_TYPE_P(key) != IS_LONG && Z_TYPE_P(key) != IS_STRING) { zval_dtor(key); FREE_ZVAL(key); return 0; } ALLOC_INIT_ZVAL(data); if (!php_var_unserialize(&data, p, max, var_hash TSRMLS_CC)) { zval_dtor(key); FREE_ZVAL(key); zval_dtor(data); FREE_ZVAL(data); return 0; } if (!objprops) { switch (Z_TYPE_P(key)) { case IS_LONG: if (zend_hash_index_find(ht, Z_LVAL_P(key), (void **)&old_data)==SUCCESS) { var_push_dtor(var_hash, old_data); } zend_hash_index_update(ht, Z_LVAL_P(key), &data, sizeof(data), NULL); break; case IS_STRING: if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) { var_push_dtor(var_hash, old_data); } zend_symtable_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data, sizeof(data), NULL); break; } } else { convert_to_string(key); if (zend_hash_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) { var_push_dtor(var_hash, old_data); } zend_hash_update(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, &data, sizeof data, NULL); } var_push_dtor(var_hash, &data); zval_dtor(key); FREE_ZVAL(key); if (elements && *(*p-1) != ';' && *(*p-1) != '}') { (*p)--; return 0; } } return 1; }
Description: The session deserializer in PHP before 5.4.45, 5.5.x before 5.5.29, and 5.6.x before 5.6.13 mishandles multiple php_var_unserialize calls, which allow remote attackers to execute arbitrary code or cause a denial of service (use-after-free) via crafted session content.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int fuse_dev_fasync(int fd, struct file *file, int on) { struct fuse_conn *fc = fuse_get_conn(file); if (!fc) return -EPERM; return fasync_helper(fd, file, on, &fc->iq.fasync); }
Description: Memory leak in the cuse_channel_release function in fs/fuse/cuse.c in the Linux kernel before 4.4 allows local users to cause a denial of service (memory consumption) or possibly have unspecified other impact by opening /dev/cuse many times.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int fbcon_set_font(struct vc_data *vc, struct console_font *font, unsigned int flags) { struct fb_info *info = fbcon_info_from_console(vc->vc_num); unsigned charcount = font->charcount; int w = font->width; int h = font->height; int size; int i, csum; u8 *new_data, *data = font->data; int pitch = PITCH(font->width); if (charcount != 256 && charcount != 512) return -EINVAL; if (w > FBCON_SWAP(info->var.rotate, info->var.xres, info->var.yres) || h > FBCON_SWAP(info->var.rotate, info->var.yres, info->var.xres)) return -EINVAL; if (!(info->pixmap.blit_x & (1 << (font->width - 1))) || !(info->pixmap.blit_y & (1 << (font->height - 1)))) return -EINVAL; if (fbcon_invalid_charcount(info, charcount)) return -EINVAL; size = CALC_FONTSZ(h, pitch, charcount); new_data = kmalloc(FONT_EXTRA_WORDS * sizeof(int) + size, GFP_USER); if (!new_data) return -ENOMEM; memset(new_data, 0, FONT_EXTRA_WORDS * sizeof(int)); new_data += FONT_EXTRA_WORDS * sizeof(int); FNTSIZE(new_data) = size; REFCOUNT(new_data) = 0; for (i=0; i< charcount; i++) { memcpy(new_data + i*h*pitch, data +  i*32*pitch, h*pitch); } csum = crc32(0, new_data, size); FNTSUM(new_data) = csum; for (i = first_fb_vc; i <= last_fb_vc; i++) { struct vc_data *tmp = vc_cons[i].d; if (fb_display[i].userfont && fb_display[i].fontdata && FNTSUM(fb_display[i].fontdata) == csum && FNTSIZE(fb_display[i].fontdata) == size && tmp->vc_font.width == w && !memcmp(fb_display[i].fontdata, new_data, size)) { kfree(new_data - FONT_EXTRA_WORDS * sizeof(int)); new_data = (u8 *)fb_display[i].fontdata; break; } } return fbcon_do_set_font(vc, font->width, font->height, charcount, new_data, 1); }
Description: A flaw was found in the Framebuffer Console (fbcon) in the Linux Kernel. When providing font->width and font->height greater than 32 to fbcon_set_font, since there are no checks in place, a shift-out-of-bounds occurs leading to undefined behavior and possible denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: SplashError Splash::blitTransparent(SplashBitmap *src, int xSrc, int ySrc, int xDest, int yDest, int w, int h) { SplashColorPtr p, sp; unsigned char *q; int x, y, mask, srcMask; if (src->mode != bitmap->mode) { return splashErrModeMismatch; } if (unlikely(!bitmap->data)) { return splashErrZeroImage; } switch (bitmap->mode) { case splashModeMono1: for (y = 0; y < h; ++y) { p = &bitmap->data[(yDest + y) * bitmap->rowSize + (xDest >> 3)]; mask = 0x80 >> (xDest & 7); sp = &src->data[(ySrc + y) * src->rowSize + (xSrc >> 3)]; srcMask = 0x80 >> (xSrc & 7); for (x = 0; x < w; ++x) { if (*sp & srcMask) { *p |= mask; } else { *p &= ~mask; } if (!(mask >>= 1)) { mask = 0x80; ++p; } if (!(srcMask >>= 1)) { srcMask = 0x80; ++sp; } } } break; case splashModeMono8: for (y = 0; y < h; ++y) { p = &bitmap->data[(yDest + y) * bitmap->rowSize + xDest]; sp = &src->data[(ySrc + y) * bitmap->rowSize + xSrc]; for (x = 0; x < w; ++x) { *p++ = *sp++; } } break; case splashModeRGB8: case splashModeBGR8: for (y = 0; y < h; ++y) { p = &bitmap->data[(yDest + y) * bitmap->rowSize + 3 * xDest]; sp = &src->data[(ySrc + y) * src->rowSize + 3 * xSrc]; for (x = 0; x < w; ++x) { *p++ = *sp++; *p++ = *sp++; *p++ = *sp++; } } break; case splashModeXBGR8: for (y = 0; y < h; ++y) { p = &bitmap->data[(yDest + y) * bitmap->rowSize + 4 * xDest]; sp = &src->data[(ySrc + y) * src->rowSize + 4 * xSrc]; for (x = 0; x < w; ++x) { *p++ = *sp++; *p++ = *sp++; *p++ = *sp++; *p++ = 255; sp++; } } break; #ifdef SPLASH_CMYK case splashModeCMYK8: for (y = 0; y < h; ++y) { p = &bitmap->data[(yDest + y) * bitmap->rowSize + 4 * xDest]; sp = &src->data[(ySrc + y) * src->rowSize + 4 * xSrc]; for (x = 0; x < w; ++x) { *p++ = *sp++; *p++ = *sp++; *p++ = *sp++; *p++ = *sp++; } } break; case splashModeDeviceN8: for (y = 0; y < h; ++y) { p = &bitmap->data[(yDest + y) * bitmap->rowSize + (SPOT_NCOMPS+4) * xDest]; sp = &src->data[(ySrc + y) * src->rowSize + (SPOT_NCOMPS+4) * xSrc]; for (x = 0; x < w; ++x) { for (int cp=0; cp < SPOT_NCOMPS+4; cp++) *p++ = *sp++; } } break; #endif } if (bitmap->alpha) { for (y = 0; y < h; ++y) { q = &bitmap->alpha[(yDest + y) * bitmap->width + xDest]; memset(q, 0x00, w); } } return splashOk; }
Description: An issue was discovered in Poppler 0.74.0. There is a heap-based buffer over-read in the function Splash::blitTransparent at splash/Splash.cc.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int extract_status_code(char *buffer, size_t size) { char *buf_code; char *begin; char *end = buffer + size; size_t inc = 0; int code; buf_code = (char *)MALLOC(10); while (buffer < end && *buffer++ != ' ') ; begin = buffer; while (buffer < end && *buffer++ != ' ') inc++; strncat(buf_code, begin, inc); code = atoi(buf_code); FREE(buf_code); return code; }
Description: keepalived before 2.0.7 has a heap-based buffer overflow when parsing HTTP status codes resulting in DoS or possibly unspecified other impact, because extract_status_code in lib/html.c has no validation of the status code and instead writes an unlimited amount of data to the heap.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Elf64_Sym const *PackLinuxElf64::elf_lookup(char const *name) const { if (hashtab && dynsym && dynstr) { unsigned const nbucket = get_te32(&hashtab[0]); unsigned const *const buckets = &hashtab[2]; unsigned const *const chains = &buckets[nbucket]; unsigned const m = elf_hash(name) % nbucket; unsigned si; for (si= get_te32(&buckets[m]); 0!=si; si= get_te32(&chains[si])) { char const *const p= get_dynsym_name(si, (unsigned)-1); if (0==strcmp(name, p)) { return &dynsym[si]; } } } if (gashtab && dynsym && dynstr) { unsigned const n_bucket = get_te32(&gashtab[0]); unsigned const symbias  = get_te32(&gashtab[1]); unsigned const n_bitmask = get_te32(&gashtab[2]); unsigned const gnu_shift = get_te32(&gashtab[3]); upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4]; unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask]; unsigned     const *const hasharr = &buckets[n_bucket]; unsigned const h = gnu_hash(name); unsigned const hbit1 = 077& h; unsigned const hbit2 = 077& (h>>gnu_shift); upx_uint64_t const w = get_te64(&bitmask[(n_bitmask -1) & (h>>6)]); if (1& (w>>hbit1) & (w>>hbit2)) { unsigned bucket = get_te32(&buckets[h % n_bucket]); if (n_bucket <= bucket) { char msg[80]; snprintf(msg, sizeof(msg), ""bad DT_GNU_HASH n_bucket{%#x} <= buckets[%d]{%#x}\n"", n_bucket, h % n_bucket, bucket); throwCantPack(msg); } if (0!=bucket) { Elf64_Sym const *dsp = &dynsym[bucket]; unsigned const *hp = &hasharr[bucket - symbias]; do if (0==((h ^ get_te32(hp))>>1)) { unsigned st_name = get_te32(&dsp->st_name); char const *const p = get_str_name(st_name, (unsigned)-1); if (0==strcmp(name, p)) { return dsp; } } while (++dsp, 0==(1u& get_te32(hp++))); } } } return 0; }
Description: A heap-based buffer overflow was discovered in upx, during the generic pointer 'p' points to an inaccessible address in func get_le32(). The problem is essentially caused in PackLinuxElf32::elf_lookup() at p_lx_elf.cpp:5382.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void Compute(OpKernelContext* ctx) override { try { const Tensor& input = ctx->input(kInputTensorIndex); const Tensor& input_min_vec = ctx->input(kInputMinVecIndex); float* input_min_vec_data = (float*)const_cast<void*>( static_cast<const void*>(input_min_vec.flat<float>().data())); const Tensor& input_max_vec = ctx->input(kInputMaxVecIndex); float* input_max_vec_data = (float*)const_cast<void*>( static_cast<const void*>(input_max_vec.flat<float>().data())); const Tensor& input_requested_min = ctx->input(this->kRequestMinIndex); const float input_requested_min_float = input_requested_min.flat<float>()(0); const Tensor& input_requested_max = ctx->input(this->kRequestMaxIndex); const float input_requested_max_float = input_requested_max.flat<float>()(0); size_t depth = input_min_vec.NumElements(); OP_REQUIRES( ctx, input.dims() == 4, errors::InvalidArgument(""Current RequantizePerChannel operator"" ""supports 4D tensors only."")); OP_REQUIRES( ctx, input_min_vec.dim_size(0) == depth, errors::InvalidArgument(""input_min has incorrect size, expected "", depth, "" was "", input_min_vec.dim_size(0))); OP_REQUIRES( ctx, input_max_vec.dim_size(0) == depth, errors::InvalidArgument(""input_max has incorrect size, expected "", depth, "" was "", input_max_vec.dim_size(0))); if (out_type_ == DT_QINT8) DCHECK(input_requested_min_float < 0.0f); const float factor = (out_type_ == DT_QINT8) ? 127.0f : 255.0f; const float requested_min_max = std::max(std::abs(input_requested_min_float), std::abs(input_requested_max_float)); Tensor* output = nullptr; OP_REQUIRES_OK(ctx, ctx->allocate_output(kOutputTensorIndex, input.shape(), &output)); std::vector<float> scales(depth); for (int i = 0; i < depth; ++i) { float min_max_from_vec = std::max(std::abs(input_min_vec_data[i]), std::abs(input_max_vec_data[i])); scales[i] = factor * (min_max_from_vec / requested_min_max / static_cast<float>(1L << 31)); } mkldnn::primitive_attr reorder_attr; reorder_attr.set_output_scales(2, scales); memory::dims dims_mkl_order = TFShapeToMklDnnDimsInNCHW(input.shape(), FORMAT_NHWC); memory::desc input_md = memory::desc(dims_mkl_order, MklDnnType<qint32>(), memory::format_tag::nhwc); memory::desc output_md = (out_type_ == DT_QINT8) ? memory::desc(dims_mkl_order, MklDnnType<qint8>(), memory::format_tag::nhwc) : memory::desc(dims_mkl_order, MklDnnType<quint8>(), memory::format_tag::nhwc); void* input_buf = static_cast<void*>(const_cast<qint32*>(input.flat<qint32>().data())); void* output_buf; if (out_type_ == DT_QINT8) { output_buf = static_cast<void*>( const_cast<qint8*>(output->flat<qint8>().data())); } else { output_buf = static_cast<void*>( const_cast<quint8*>(output->flat<quint8>().data())); } std::unique_ptr<memory> input_mem_prim( new memory(input_md, cpu_engine_, input_buf)); std::unique_ptr<memory> output_mem_prim( new memory(output_md, cpu_engine_, output_buf)); mkldnn::reorder::primitive_desc reorder_pd = ReorderPd(cpu_engine_, input_mem_prim->get_desc(), cpu_engine_, output_mem_prim->get_desc(), reorder_attr); std::shared_ptr<stream> reorder_stream; MklDnnThreadPool eigen_tp(ctx); reorder_stream.reset(CreateStream(&eigen_tp, cpu_engine_)); std::unordered_map<int, mkldnn::memory> reorder_args = { {MKLDNN_ARG_FROM, *input_mem_prim}, {MKLDNN_ARG_TO, *output_mem_prim}}; std::unique_ptr<mkldnn::primitive> reorder_prim( new mkldnn::reorder(reorder_pd)); reorder_prim->execute(*reorder_stream, reorder_args); Tensor* output_min = nullptr; Tensor* output_max = nullptr; OP_REQUIRES_OK(ctx, ctx->allocate_output(kOutputMinIndex, {}, &output_min)); OP_REQUIRES_OK(ctx, ctx->allocate_output(kOutputMaxIndex, {}, &output_max)); output_min->flat<float>()(0) = input_requested_min_float; output_max->flat<float>()(0) = input_requested_max_float; } catch (mkldnn::error& e) { string error_msg = ""Status: "" + std::to_string(e.status) + "", message: "" + std::string(e.message) + "", in file "" + std::string(__FILE__) + "":"" + std::to_string(__LINE__); OP_REQUIRES_OK( ctx, errors::Aborted(""Operation received an exception:"", error_msg)); } }
Description: TensorFlow is an end-to-end open source platform for machine learning. In affected versions due to incomplete validation in MKL implementation of requantization, an attacker can trigger undefined behavior via binding a reference to a null pointer or can access data outside the bounds of heap allocated arrays. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/mkl/mkl_requantization_range_per_channel_op.cc) does not validate the dimensions of the `input` tensor. A similar issue occurs in `MklRequantizePerChannelOp`. The [implementation](https://github.com/tensorflow/tensorflow/blob/460e000de3a83278fb00b61a16d161b1964f15f4/tensorflow/core/kernels/mkl/mkl_requantize_per_channel_op.cc) does not perform full validation for all the input arguments. We have patched the issue in GitHub commit 9e62869465573cb2d9b5053f1fa02a81fce21d69 and in the Github commit 203214568f5bc237603dbab6e1fd389f1572f5c9. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: MagickExport MagickBooleanType AnnotateImage(Image *image, const DrawInfo *draw_info,ExceptionInfo *exception) { char *p, primitive[MagickPathExtent], *text, **textlist; DrawInfo *annotate, *annotate_info; GeometryInfo geometry_info; MagickBooleanType status; PointInfo offset; RectangleInfo geometry; register ssize_t i; TypeMetric metrics; size_t height, number_lines; assert(image != (Image *) NULL); assert(image->signature == MagickCoreSignature); if (image->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename); assert(draw_info != (DrawInfo *) NULL); assert(draw_info->signature == MagickCoreSignature); if (draw_info->text == (char *) NULL) return(MagickFalse); if (*draw_info->text == '\0') return(MagickTrue); annotate=CloneDrawInfo((ImageInfo *) NULL,draw_info); text=annotate->text; annotate->text=(char *) NULL; annotate_info=CloneDrawInfo((ImageInfo *) NULL,draw_info); number_lines=1; for (p=text; *p != '\0'; p++) if (*p == '\n') number_lines++; textlist=AcquireQuantumMemory(number_lines+1,sizeof(*textlist)); if (textlist == (char **) NULL) return(MagickFalse); p=text; for (i=0; i < number_lines; i++) { char *q; textlist[i]=p; for (q=p; *q != '\0'; q++) if ((*q == '\r') || (*q == '\n')) break; if (*q == '\r') { *q='\0'; q++; } *q='\0'; p=q+1; } textlist[i]=(char *) NULL; SetGeometry(image,&geometry); SetGeometryInfo(&geometry_info); if (annotate_info->geometry != (char *) NULL) { (void) ParsePageGeometry(image,annotate_info->geometry,&geometry, exception); (void) ParseGeometry(annotate_info->geometry,&geometry_info); } if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse) return(MagickFalse); if (IsGrayColorspace(image->colorspace) != MagickFalse) (void) SetImageColorspace(image,sRGBColorspace,exception); status=MagickTrue; (void) memset(&metrics,0,sizeof(metrics)); for (i=0; textlist[i] != (char *) NULL; i++) { if (*textlist[i] == '\0') continue; annotate_info->affine.tx=geometry_info.xi-image->page.x; annotate_info->affine.ty=geometry_info.psi-image->page.y; (void) CloneString(&annotate->text,textlist[i]); if ((metrics.width == 0) || (annotate->gravity != NorthWestGravity)) (void) GetTypeMetrics(image,annotate,&metrics,exception); height=(ssize_t) (metrics.ascent-metrics.descent+ draw_info->interline_spacing+0.5); switch (annotate->gravity) { case UndefinedGravity: default: { offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height; offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height; break; } case NorthWestGravity: { offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i* annotate_info->affine.ry*height+annotate_info->affine.ry* (metrics.ascent+metrics.descent); offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i* annotate_info->affine.sy*height+annotate_info->affine.sy* metrics.ascent; break; } case NorthGravity: { offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+ geometry.width/2.0+i*annotate_info->affine.ry*height- annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry* (metrics.ascent+metrics.descent); offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i* annotate_info->affine.sy*height+annotate_info->affine.sy* metrics.ascent-annotate_info->affine.rx*metrics.width/2.0; break; } case NorthEastGravity: { offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+ geometry.width+i*annotate_info->affine.ry*height- annotate_info->affine.sx*metrics.width+annotate_info->affine.ry* (metrics.ascent+metrics.descent)-1.0; offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+i* annotate_info->affine.sy*height+annotate_info->affine.sy* metrics.ascent-annotate_info->affine.rx*metrics.width; break; } case WestGravity: { offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i* annotate_info->affine.ry*height+annotate_info->affine.ry* (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0; offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+ geometry.height/2.0+i*annotate_info->affine.sy*height+ annotate_info->affine.sy*(metrics.ascent+metrics.descent- (number_lines-1.0)*height)/2.0; break; } case CenterGravity: { offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+ geometry.width/2.0+i*annotate_info->affine.ry*height- annotate_info->affine.sx*metrics.width/2.0+annotate_info->affine.ry* (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0; offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+ geometry.height/2.0+i*annotate_info->affine.sy*height- annotate_info->affine.rx*metrics.width/2.0+annotate_info->affine.sy* (metrics.ascent+metrics.descent-(number_lines-1.0)*height)/2.0; break; } case EastGravity: { offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+ geometry.width+i*annotate_info->affine.ry*height- annotate_info->affine.sx*metrics.width+ annotate_info->affine.ry*(metrics.ascent+metrics.descent- (number_lines-1.0)*height)/2.0-1.0; offset.y=(geometry.height == 0 ? -1.0 : 1.0)*annotate_info->affine.ty+ geometry.height/2.0+i*annotate_info->affine.sy*height- annotate_info->affine.rx*metrics.width+ annotate_info->affine.sy*(metrics.ascent+metrics.descent- (number_lines-1.0)*height)/2.0; break; } case SouthWestGravity: { offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+i* annotate_info->affine.ry*height-annotate_info->affine.ry* (number_lines-1.0)*height; offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+ geometry.height+i*annotate_info->affine.sy*height- annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent; break; } case SouthGravity: { offset.x=(geometry.width == 0 ? -1.0 : 1.0)*annotate_info->affine.tx+ geometry.width/2.0+i*annotate_info->affine.ry*height- annotate_info->affine.sx*metrics.width/2.0- annotate_info->affine.ry*(number_lines-1.0)*height/2.0; offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+ geometry.height+i*annotate_info->affine.sy*height- annotate_info->affine.rx*metrics.width/2.0- annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent; break; } case SouthEastGravity: { offset.x=(geometry.width == 0 ? 1.0 : -1.0)*annotate_info->affine.tx+ geometry.width+i*annotate_info->affine.ry*height- annotate_info->affine.sx*metrics.width- annotate_info->affine.ry*(number_lines-1.0)*height-1.0; offset.y=(geometry.height == 0 ? 1.0 : -1.0)*annotate_info->affine.ty+ geometry.height+i*annotate_info->affine.sy*height- annotate_info->affine.rx*metrics.width- annotate_info->affine.sy*(number_lines-1.0)*height+metrics.descent; break; } } switch (annotate->align) { case LeftAlign: { offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height; offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height; break; } case CenterAlign: { offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height- annotate_info->affine.sx*metrics.width/2.0; offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height- annotate_info->affine.rx*metrics.width/2.0; break; } case RightAlign: { offset.x=annotate_info->affine.tx+i*annotate_info->affine.ry*height- annotate_info->affine.sx*metrics.width; offset.y=annotate_info->affine.ty+i*annotate_info->affine.sy*height- annotate_info->affine.rx*metrics.width; break; } default: break; } if (draw_info->undercolor.alpha != TransparentAlpha) { DrawInfo *undercolor_info; undercolor_info=CloneDrawInfo((ImageInfo *) NULL,(DrawInfo *) NULL); undercolor_info->fill=draw_info->undercolor; undercolor_info->affine=draw_info->affine; undercolor_info->affine.tx=offset.x-draw_info->affine.ry*metrics.ascent; undercolor_info->affine.ty=offset.y-draw_info->affine.sy*metrics.ascent; (void) FormatLocaleString(primitive,MagickPathExtent, ""rectangle 0.0,0.0 %g,%g"",metrics.origin.x,(double) height); (void) CloneString(&undercolor_info->primitive,primitive); (void) DrawImage(image,undercolor_info,exception); (void) DestroyDrawInfo(undercolor_info); } annotate_info->affine.tx=offset.x; annotate_info->affine.ty=offset.y; (void) FormatLocaleString(primitive,MagickPathExtent,""stroke-width %g "" ""line 0,0 %g,0"",metrics.underline_thickness,metrics.width); if (annotate->decorate == OverlineDecoration) { annotate_info->affine.ty-=(draw_info->affine.sy*(metrics.ascent+ metrics.descent-metrics.underline_position)); (void) CloneString(&annotate_info->primitive,primitive); (void) DrawImage(image,annotate_info,exception); } else if (annotate->decorate == UnderlineDecoration) { annotate_info->affine.ty-=(draw_info->affine.sy* metrics.underline_position); (void) CloneString(&annotate_info->primitive,primitive); (void) DrawImage(image,annotate_info,exception); } status=RenderType(image,annotate,&offset,&metrics,exception); if (status == MagickFalse) break; if (annotate->decorate == LineThroughDecoration) { annotate_info->affine.ty-=(draw_info->affine.sy*(height+ metrics.underline_position+metrics.descent)/2.0); (void) CloneString(&annotate_info->primitive,primitive); (void) DrawImage(image,annotate_info,exception); } } annotate_info=DestroyDrawInfo(annotate_info); annotate=DestroyDrawInfo(annotate); textlist=(char **) RelinquishMagickMemory(textlist); return(status); }
Description: ImageMagick 7.0.8-50 Q16 has memory leaks in AcquireMagickMemory because of an AnnotateImage error.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static uint32_t readU16(const uint8_t* data, size_t offset) { return data[offset] << 8 | data[offset + 1]; }
Description: Integer overflow in the getCoverageFormat12 function in CmapCoverage.cpp in the Minikin library in Android 5.x before 5.1.1 LMY49G and 6.x before 2016-02-01 allows attackers to cause a denial of service (continuous rebooting) via an application that triggers loading of a crafted TTF font, aka internal bug 25645298.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: TfLiteStatus GatherStrings(TfLiteContext* context, const TfLiteTensor* input, const TfLiteTensor* positions, TfLiteTensor* output) { DynamicBuffer buffer; const PositionT* indexes = GetTensorData<PositionT>(positions); const PositionT num_strings = GetStringCount(input); const int num_indexes = NumElements(positions); for (int i = 0; i < num_indexes; ++i) { const PositionT pos = indexes[i]; TF_LITE_ENSURE(context, pos < num_strings); const auto string_ref = GetString(input, pos); buffer.AddString(string_ref.str, string_ref.len); } buffer.WriteToTensor(output, nullptr); return kTfLiteOk; }
Description: TensorFlow is an end-to-end open source platform for machine learning. In affected versions TFLite's [`GatherNd` implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/gather_nd.cc#L124) does not support negative indices but there are no checks for this situation. Hence, an attacker can read arbitrary data from the heap by carefully crafting a model with negative values in `indices`. Similar issue exists in [`Gather` implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/lite/kernels/gather.cc). We have patched the issue in GitHub commits bb6a0383ed553c286f87ca88c207f6774d5c4a8f and eb921122119a6b6e470ee98b89e65d721663179d. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int arch_domain_create(struct domain *d, struct xen_domctl_createdomain *config, unsigned int flags) { bool paging_initialised = false; uint32_t emflags; int rc; INIT_PAGE_LIST_HEAD(&d->arch.relmem_list); spin_lock_init(&d->arch.e820_lock); if ( unlikely(is_idle_domain(d)) ) { static const struct arch_csw idle_csw = { .from = paravirt_ctxt_switch_from, .to   = paravirt_ctxt_switch_to, .tail = idle_loop, }; d->arch.ctxt_switch = &idle_csw; d->arch.cpuid = ZERO_BLOCK_PTR;  d->arch.msr = ZERO_BLOCK_PTR; return 0; } if ( !config ) { ASSERT_UNREACHABLE(); return -EINVAL; } if ( d->domain_id && cpu_has_amd_erratum(&boot_cpu_data, AMD_ERRATUM_121) ) { if ( !opt_allow_unsafe ) { printk(XENLOG_G_ERR ""Xen does not allow DomU creation on this CPU"" "" for security reasons.\n""); return -EPERM; } printk(XENLOG_G_WARNING ""Dom%d may compromise security on this CPU.\n"", d->domain_id); } emflags = config->arch.emulation_flags; if ( is_hardware_domain(d) && is_pv_domain(d) ) emflags |= XEN_X86_EMU_PIT; if ( emflags & ~XEN_X86_EMU_ALL ) { printk(XENLOG_G_ERR ""d%d: Invalid emulation bitmap: %#x\n"", d->domain_id, emflags); return -EINVAL; } if ( !emulation_flags_ok(d, emflags) ) { printk(XENLOG_G_ERR ""d%d: Xen does not allow %s domain creation "" ""with the current selection of emulators: %#x\n"", d->domain_id, is_hvm_domain(d) ? ""HVM"" : ""PV"", emflags); return -EOPNOTSUPP; } d->arch.emulation_flags = emflags; #ifdef CONFIG_PV32 HYPERVISOR_COMPAT_VIRT_START(d) = is_pv_domain(d) ? __HYPERVISOR_COMPAT_VIRT_START : ~0u; #endif if ( (rc = paging_domain_init(d)) != 0 ) goto fail; paging_initialised = true; if ( (rc = init_domain_cpuid_policy(d)) ) goto fail; if ( (rc = init_domain_msr_policy(d)) ) goto fail; d->arch.ioport_caps = rangeset_new(d, ""I/O Ports"", RANGESETF_prettyprint_hex); rc = -ENOMEM; if ( d->arch.ioport_caps == NULL ) goto fail; if ( (d->shared_info = alloc_xenheap_pages(0, MEMF_bits(32))) == NULL ) goto fail; clear_page(d->shared_info); share_xen_page_with_guest(virt_to_page(d->shared_info), d, SHARE_rw); if ( (rc = init_domain_irq_mapping(d)) != 0 ) goto fail; if ( (rc = iommu_domain_init(d, config->iommu_opts)) != 0 ) goto fail; psr_domain_init(d); if ( is_hvm_domain(d) ) { if ( (rc = hvm_domain_initialise(d)) != 0 ) goto fail; } else if ( is_pv_domain(d) ) { mapcache_domain_init(d); if ( (rc = pv_domain_initialise(d)) != 0 ) goto fail; } else ASSERT_UNREACHABLE();  if ( (rc = tsc_set_info(d, TSC_MODE_DEFAULT, 0, 0, 0)) != 0 ) { ASSERT_UNREACHABLE(); goto fail; } pit_init(d, cpu_khz); d->arch.x87_fip_width = cpu_has_fpu_sel ? 0 : 8; domain_cpu_policy_changed(d); d->arch.msr_relaxed = config->arch.misc_flags & XEN_X86_MSR_RELAXED; return 0; fail: d->is_dying = DOMDYING_dead; psr_domain_free(d); iommu_domain_destroy(d); cleanup_domain_irq_mapping(d); free_xenheap_page(d->shared_info); xfree(d->arch.cpuid); xfree(d->arch.msr); if ( paging_initialised ) paging_final_teardown(d); free_perdomain_mappings(d); return rc; }
Description: Out-of-bounds write vulnerability in CX-Programmer v9.76.1 and earlier which is a part of CX-One (v4.60) suite allows an attacker to cause information disclosure and/or arbitrary code execution by having a user to open a specially crafted CXP file. This vulnerability is different from CVE-2022-25234.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int decode_nal_unit(HEVCContext *s, const uint8_t *nal, int length) { HEVCLocalContext *lc = &s->HEVClc; GetBitContext *gb    = &lc->gb; int ctb_addr_ts, ret; ret = init_get_bits8(gb, nal, length); if (ret < 0) return ret; ret = hls_nal_unit(s); if (ret < 0) { av_log(s->avctx, AV_LOG_ERROR, ""Invalid NAL unit %d, skipping.\n"", s->nal_unit_type); if (s->avctx->err_recognition & AV_EF_EXPLODE) return ret; return 0; } else if (!ret) return 0; switch (s->nal_unit_type) { case NAL_VPS: ret = ff_hevc_decode_nal_vps(s); if (ret < 0) return ret; break; case NAL_SPS: ret = ff_hevc_decode_nal_sps(s); if (ret < 0) return ret; break; case NAL_PPS: ret = ff_hevc_decode_nal_pps(s); if (ret < 0) return ret; break; case NAL_SEI_PREFIX: case NAL_SEI_SUFFIX: ret = ff_hevc_decode_nal_sei(s); if (ret < 0) return ret; break; case NAL_TRAIL_R: case NAL_TRAIL_N: case NAL_TSA_N: case NAL_TSA_R: case NAL_STSA_N: case NAL_STSA_R: case NAL_BLA_W_LP: case NAL_BLA_W_RADL: case NAL_BLA_N_LP: case NAL_IDR_W_RADL: case NAL_IDR_N_LP: case NAL_CRA_NUT: case NAL_RADL_N: case NAL_RADL_R: case NAL_RASL_N: case NAL_RASL_R: ret = hls_slice_header(s); if (ret < 0) return ret; if (s->max_ra == INT_MAX) { if (s->nal_unit_type == NAL_CRA_NUT || IS_BLA(s)) { s->max_ra = s->poc; } else { if (IS_IDR(s)) s->max_ra = INT_MIN; } } if ((s->nal_unit_type == NAL_RASL_R || s->nal_unit_type == NAL_RASL_N) && s->poc <= s->max_ra) { s->is_decoded = 0; break; } else { if (s->nal_unit_type == NAL_RASL_R && s->poc > s->max_ra) s->max_ra = INT_MIN; } if (s->sh.first_slice_in_pic_flag) { ret = hevc_frame_start(s); if (ret < 0) return ret; } else if (!s->ref) { av_log(s->avctx, AV_LOG_ERROR, ""First slice in a frame missing.\n""); return AVERROR_INVALIDDATA; } if (!s->sh.dependent_slice_segment_flag && s->sh.slice_type != I_SLICE) { ret = ff_hevc_slice_rpl(s); if (ret < 0) { av_log(s->avctx, AV_LOG_WARNING, ""Error constructing the reference lists for the current slice.\n""); if (s->avctx->err_recognition & AV_EF_EXPLODE) return ret; } } ctb_addr_ts = hls_slice_data(s); if (ctb_addr_ts >= (s->sps->ctb_width * s->sps->ctb_height)) { s->is_decoded = 1; if ((s->pps->transquant_bypass_enable_flag || (s->sps->pcm.loop_filter_disable_flag && s->sps->pcm_enabled_flag)) && s->sps->sao_enabled) restore_tqb_pixels(s); } if (ctb_addr_ts < 0) return ctb_addr_ts; break; case NAL_EOS_NUT: case NAL_EOB_NUT: s->seq_decode = (s->seq_decode + 1) & 0xff; s->max_ra     = INT_MAX; break; case NAL_AUD: case NAL_FD_NUT: break; default: av_log(s->avctx, AV_LOG_INFO, ""Skipping NAL unit %d\n"", s->nal_unit_type); } return 0; }
Description: A vulnerability, which was classified as problematic, was found in FFmpeg 2.0. This affects the function decode_nal_unit of the component Slice Segment Handler. The manipulation leads to memory corruption. It is possible to initiate the attack remotely. It is recommended to apply a patch to fix this issue.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr(dec_state_t *ps_dec) { stream_t *ps_stream; ps_stream = &ps_dec->s_bit_stream; UWORD16 u2_height; UWORD16 u2_width; if (impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != SEQUENCE_HEADER_CODE) { impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN); return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND; } impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN); u2_width    = impeg2d_bit_stream_get(ps_stream,12); u2_height   = impeg2d_bit_stream_get(ps_stream,12); if ((u2_width != ps_dec->u2_horizontal_size) || (u2_height != ps_dec->u2_vertical_size)) { if (0 == ps_dec->u2_header_done) { ps_dec->u2_horizontal_size = u2_width; ps_dec->u2_vertical_size = u2_height; if (0 == ps_dec->u4_frm_buf_stride) { ps_dec->u4_frm_buf_stride  = (UWORD32) ALIGN16(u2_width); } } else { if((u2_width > ps_dec->u2_create_max_width) || (u2_height > ps_dec->u2_create_max_height)) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS; ps_dec->u2_reinit_max_height   = u2_height; ps_dec->u2_reinit_max_width    = u2_width; return e_error; } else { return (IMPEG2D_ERROR_CODES_T)IVD_RES_CHANGED; } } } if((ps_dec->u2_horizontal_size > ps_dec->u2_create_max_width) || (ps_dec->u2_vertical_size > ps_dec->u2_create_max_height)) { IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS; return SET_IVD_FATAL_ERROR(e_error); } ps_dec->u2_aspect_ratio_info = impeg2d_bit_stream_get(ps_stream,4); ps_dec->u2_frame_rate_code = impeg2d_bit_stream_get(ps_stream,4); impeg2d_bit_stream_flush(ps_stream,18); GET_MARKER_BIT(ps_dec,ps_stream); impeg2d_bit_stream_flush(ps_stream,11); if(impeg2d_bit_stream_get_bit(ps_stream) == 1) { UWORD16 i; for(i = 0; i < NUM_PELS_IN_BLOCK; i++) { ps_dec->au1_intra_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] =  (UWORD8)impeg2d_bit_stream_get(ps_stream,8); } } else { memcpy(ps_dec->au1_intra_quant_matrix,gau1_impeg2_intra_quant_matrix_default, NUM_PELS_IN_BLOCK); } if(impeg2d_bit_stream_get_bit(ps_stream) == 1) { UWORD16 i; for(i = 0; i < NUM_PELS_IN_BLOCK; i++) { ps_dec->au1_inter_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] =   (UWORD8)impeg2d_bit_stream_get(ps_stream,8); } } else { memcpy(ps_dec->au1_inter_quant_matrix,gau1_impeg2_inter_quant_matrix_default, NUM_PELS_IN_BLOCK); } impeg2d_next_start_code(ps_dec); return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE; }
Description: An information disclosure vulnerability in libmpeg2 in Mediaserver could enable a local malicious application to access data outside of its permission levels. This issue is rated as Moderate because it could be used to access data without permission. Product: Android. Versions: 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-34093952.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void MCFilesEvalShell(MCExecContext& ctxt, MCStringRef p_command, MCStringRef& r_output) { if (MCsecuremode & MC_SECUREMODE_PROCESS) { MCeerror->add(EE_SHELL_NOPERM, 0, 0, p_command); ctxt . Throw(); return; } if (MCS_runcmd(p_command, r_output) != IO_NORMAL) { MCeerror->add(EE_SHELL_BADCOMMAND, 0, 0, p_command); ctxt . Throw(); return; } }
Description: LiveCode v9.6.1 on Windows allows local, low-privileged users to gain privileges by creating a malicious ""cmd.exe"" in the folder of the vulnerable LiveCode application. If the application is using LiveCode's ""shell()"" function, it will attempt to search for ""cmd.exe"" in the folder of the current application and run the malicious ""cmd.exe"".
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void build_ntlmssp_negotiate_blob(unsigned char *pbuffer, struct cifs_ses *ses) { NEGOTIATE_MESSAGE *sec_blob = (NEGOTIATE_MESSAGE *)pbuffer; __u32 flags; memset(pbuffer, 0, sizeof(NEGOTIATE_MESSAGE)); memcpy(sec_blob->Signature, NTLMSSP_SIGNATURE, 8); sec_blob->MessageType = NtLmNegotiate; flags = NTLMSSP_NEGOTIATE_56 |NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_128 | NTLMSSP_NEGOTIATE_UNICODE | NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_EXTENDED_SEC; if (ses->server->sign) { flags |= NTLMSSP_NEGOTIATE_SIGN; if (!ses->server->session_estab || ses->ntlmssp->sesskey_per_smbsess) flags |= NTLMSSP_NEGOTIATE_KEY_XCH; } sec_blob->NegotiateFlags = cpu_to_le32(flags); sec_blob->WorkstationName.BufferOffset = 0; sec_blob->WorkstationName.Length = 0; sec_blob->WorkstationName.MaximumLength = 0; sec_blob->DomainName.BufferOffset = 0; sec_blob->DomainName.Length = 0; sec_blob->DomainName.MaximumLength = 0; }
Description: The Linux kernel before version 4.11 is vulnerable to a NULL pointer dereference in fs/cifs/cifsencrypt.c:setup_ntlmv2_rsp() that allows an attacker controlling a CIFS server to kernel panic a client that has this server mounted, because an empty TargetInfo field in an NTLMSSP setup negotiation response is mishandled during session recovery.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void Gobby::EditCommands::on_sync_complete() { g_assert(m_current_view != NULL); InfTextSession* session = m_current_view->get_session(); InfAdoptedAlgorithm* algorithm = inf_adopted_session_get_algorithm( INF_ADOPTED_SESSION(session)); m_can_undo_changed_handler = g_signal_connect( G_OBJECT(algorithm), ""can-undo-changed"", G_CALLBACK(&on_can_undo_changed_static), this); m_can_redo_changed_handler = g_signal_connect( G_OBJECT(algorithm), ""can-redo-changed"", G_CALLBACK(&on_can_redo_changed_static), this); if(m_synchronization_complete_handler != 0) { g_signal_handler_disconnect( G_OBJECT(session), m_synchronization_complete_handler); m_synchronization_complete_handler = 0; } }
Description: Gobby 0.4.11 allows a NULL pointer dereference in the D-Bus handler for certain set_language calls.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: struct buffer_head * ext4_read_block_bitmap_nowait(struct super_block *sb, ext4_group_t block_group) { struct ext4_group_desc *desc; struct buffer_head *bh; ext4_fsblk_t bitmap_blk; int err; desc = ext4_get_group_desc(sb, block_group, NULL); if (!desc) return ERR_PTR(-EFSCORRUPTED); bitmap_blk = ext4_block_bitmap(sb, desc); bh = sb_getblk(sb, bitmap_blk); if (unlikely(!bh)) { ext4_error(sb, ""Cannot get buffer for block bitmap - "" ""block_group = %u, block_bitmap = %llu"", block_group, bitmap_blk); return ERR_PTR(-ENOMEM); } if (bitmap_uptodate(bh)) goto verify; lock_buffer(bh); if (bitmap_uptodate(bh)) { unlock_buffer(bh); goto verify; } ext4_lock_group(sb, block_group); if (desc->bg_flags & cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) { err = ext4_init_block_bitmap(sb, bh, block_group, desc); set_bitmap_uptodate(bh); set_buffer_uptodate(bh); set_buffer_verified(bh); ext4_unlock_group(sb, block_group); unlock_buffer(bh); if (err) { ext4_error(sb, ""Failed to init block bitmap for group "" ""%u: %d"", block_group, err); goto out; } goto verify; } ext4_unlock_group(sb, block_group); if (buffer_uptodate(bh)) { set_bitmap_uptodate(bh); unlock_buffer(bh); goto verify; } set_buffer_new(bh); trace_ext4_read_block_bitmap_load(sb, block_group); bh->b_end_io = ext4_end_bitmap_read; get_bh(bh); submit_bh(REQ_OP_READ, REQ_META | REQ_PRIO, bh); return bh; verify: err = ext4_validate_block_bitmap(sb, desc, block_group, bh); if (err) goto out; return bh; out: put_bh(bh); return ERR_PTR(err); }
Description: The ext4_valid_block_bitmap function in fs/ext4/balloc.c in the Linux kernel through 4.15.15 allows attackers to cause a denial of service (out-of-bounds read and system crash) via a crafted ext4 image because balloc.c and ialloc.c do not validate bitmap block numbers.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int net_bind(short unsigned *port, int type, const char *log_service_name) { struct addrinfo hints = { 0 }; struct addrinfo *servinfo; struct addrinfo *ptr; const char *cfgaddr; char addr[INET6_ADDRSTRLEN]; char strport[8]; int yes = 1; int no = 0; int fd; int ret; cfgaddr = cfg_getstr(cfg_getsec(cfg, ""general""), ""bind_address""); hints.ai_socktype = (type & (SOCK_STREAM | SOCK_DGRAM));   hints.ai_family = (cfg_getbool(cfg_getsec(cfg, ""general""), ""ipv6"")) ? AF_INET6 : AF_INET; hints.ai_flags = cfgaddr ? 0 : AI_PASSIVE; snprintf(strport, sizeof(strport), ""%hu"", *port); ret = getaddrinfo(cfgaddr, strport, &hints, &servinfo); if (ret < 0) { DPRINTF(E_LOG, L_MISC, ""Failure creating '%s' service, could not resolve '%s' (port %s): %s\n"", log_service_name, cfgaddr ? cfgaddr : ""(ANY)"", strport, gai_strerror(ret)); return -1; } for (ptr = servinfo, fd = -1; ptr != NULL; ptr = ptr->ai_next) { if (fd >= 0) close(fd); fd = socket(ptr->ai_family, type | SOCK_CLOEXEC, ptr->ai_protocol); if (fd < 0) continue; ret = setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &yes, sizeof(yes)); if (ret < 0) continue; ret = setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes)); if (ret < 0) continue; if (ptr->ai_family == AF_INET6) { ret = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, &no, sizeof(no)); if (ret < 0) continue; } ret = bind(fd, ptr->ai_addr, ptr->ai_addrlen); if (ret < 0) continue; break; } freeaddrinfo(servinfo); if (!ptr) { DPRINTF(E_LOG, L_MISC, ""Could not create service '%s' with address %s, port %hu: %s\n"", log_service_name, cfgaddr ? cfgaddr : ""(ANY)"", *port, strerror(errno)); goto error; } ret = getsockname(fd, ptr->ai_addr, &ptr->ai_addrlen); if (ret < 0) { DPRINTF(E_LOG, L_MISC, ""Could not find address of service '%s': %s\n"", log_service_name, strerror(errno)); goto error; } net_port_get(port, (union net_sockaddr *)ptr->ai_addr); net_address_get(addr, sizeof(addr), (union net_sockaddr *)ptr->ai_addr); DPRINTF(E_DBG, L_MISC, ""Service '%s' bound to %s, port %hu, socket %d\n"", log_service_name, addr, *port, fd); return fd; error: close(fd); return -1; }
Description: OwnTone (aka owntone-server) through 28.1 has a use-after-free in net_bind() in misc.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int32_t *enc_untrusted_create_wait_queue() { MessageWriter input; MessageReader output; input.Push<uint64_t>(sizeof(int32_t)); const auto status = NonSystemCallDispatcher( ::asylo::host_call::kLocalLifetimeAllocHandler, &input, &output); CheckStatusAndParamCount(status, output, ""enc_untrusted_create_wait_queue"", 2); int32_t *queue = reinterpret_cast<int32_t *>(output.next<uintptr_t>()); int klinux_errno = output.next<int>(); if (queue == nullptr) { errno = FromkLinuxErrorNumber(klinux_errno); } enc_untrusted_disable_waiting(queue); return queue; }
Description: An arbitrary memory overwrite vulnerability in Asylo versions up to 0.6.0 allows an attacker to make a host call to enc_untrusted_create_wait_queue that uses a pointer queue that relies on UntrustedLocalMemcpy, which fails to validate where the pointer is located. This allows an attacker to write memory values from within the enclave. We recommend upgrading past commit a37fb6a0e7daf30134dbbf357c9a518a1026aa02
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: zip_int64_t _zip_dirent_read(zip_dirent_t *zde, zip_source_t *src, zip_buffer_t *buffer, bool local, zip_error_t *error) { zip_uint8_t buf[CDENTRYSIZE]; zip_uint16_t dostime, dosdate; zip_uint32_t size, variable_size; zip_uint16_t filename_len, comment_len, ef_len; bool from_buffer = (buffer != NULL); size = local ? LENTRYSIZE : CDENTRYSIZE; if (buffer) { if (_zip_buffer_left(buffer) < size) { zip_error_set(error, ZIP_ER_NOZIP, 0); return -1; } } else { if ((buffer = _zip_buffer_new_from_source(src, size, buf, error)) == NULL) { return -1; } } if (memcmp(_zip_buffer_get(buffer, 4), (local ? LOCAL_MAGIC : CENTRAL_MAGIC), 4) != 0) { zip_error_set(error, ZIP_ER_NOZIP, 0); if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } _zip_dirent_init(zde); if (!local) zde->version_madeby = _zip_buffer_get_16(buffer); else zde->version_madeby = 0; zde->version_needed = _zip_buffer_get_16(buffer); zde->bitflags = _zip_buffer_get_16(buffer); zde->comp_method = _zip_buffer_get_16(buffer); dostime = _zip_buffer_get_16(buffer); dosdate = _zip_buffer_get_16(buffer); zde->last_mod = _zip_d2u_time(dostime, dosdate); zde->crc = _zip_buffer_get_32(buffer); zde->comp_size = _zip_buffer_get_32(buffer); zde->uncomp_size = _zip_buffer_get_32(buffer); filename_len = _zip_buffer_get_16(buffer); ef_len = _zip_buffer_get_16(buffer); if (local) { comment_len = 0; zde->disk_number = 0; zde->int_attrib = 0; zde->ext_attrib = 0; zde->offset = 0; } else { comment_len = _zip_buffer_get_16(buffer); zde->disk_number = _zip_buffer_get_16(buffer); zde->int_attrib = _zip_buffer_get_16(buffer); zde->ext_attrib = _zip_buffer_get_32(buffer); zde->offset = _zip_buffer_get_32(buffer); } if (!_zip_buffer_ok(buffer)) { zip_error_set(error, ZIP_ER_INTERNAL, 0); if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } if (zde->bitflags & ZIP_GPBF_ENCRYPTED) { if (zde->bitflags & ZIP_GPBF_STRONG_ENCRYPTION) { zde->encryption_method = ZIP_EM_UNKNOWN; } else { zde->encryption_method = ZIP_EM_TRAD_PKWARE; } } else { zde->encryption_method = ZIP_EM_NONE; } zde->filename = NULL; zde->extra_fields = NULL; zde->comment = NULL; variable_size = (zip_uint32_t)filename_len+(zip_uint32_t)ef_len+(zip_uint32_t)comment_len; if (from_buffer) { if (_zip_buffer_left(buffer) < variable_size) { zip_error_set(error, ZIP_ER_INCONS, 0); return -1; } } else { _zip_buffer_free(buffer); if ((buffer = _zip_buffer_new_from_source(src, variable_size, NULL, error)) == NULL) { return -1; } } if (filename_len) { zde->filename = _zip_read_string(buffer, src, filename_len, 1, error); if (!zde->filename) { if (zip_error_code_zip(error) == ZIP_ER_EOF) { zip_error_set(error, ZIP_ER_INCONS, 0); } if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } if (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) { if (_zip_guess_encoding(zde->filename, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) { zip_error_set(error, ZIP_ER_INCONS, 0); if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } } } if (ef_len) { zip_uint8_t *ef = _zip_read_data(buffer, src, ef_len, 0, error); if (ef == NULL) { if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } if (!_zip_ef_parse(ef, ef_len, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, &zde->extra_fields, error)) { free(ef); if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } free(ef); if (local) zde->local_extra_fields_read = 1; } if (comment_len) { zde->comment = _zip_read_string(buffer, src, comment_len, 0, error); if (!zde->comment) { if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } if (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) { if (_zip_guess_encoding(zde->comment, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) { zip_error_set(error, ZIP_ER_INCONS, 0); if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } } } zde->filename = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_NAME, zde->filename); zde->comment = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_COMMENT, zde->comment); if (zde->uncomp_size == ZIP_UINT32_MAX || zde->comp_size == ZIP_UINT32_MAX || zde->offset == ZIP_UINT32_MAX) { zip_uint16_t got_len; zip_buffer_t *ef_buffer; const zip_uint8_t *ef = _zip_ef_get_by_id(zde->extra_fields, &got_len, ZIP_EF_ZIP64, 0, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, error); if (ef == NULL) { if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } if ((ef_buffer = _zip_buffer_new((zip_uint8_t *)ef, got_len)) == NULL) { zip_error_set(error, ZIP_ER_MEMORY, 0); if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } if (zde->uncomp_size == ZIP_UINT32_MAX) zde->uncomp_size = _zip_buffer_get_64(ef_buffer); else if (local) { (void)_zip_buffer_skip(ef_buffer, 8);  } if (zde->comp_size == ZIP_UINT32_MAX) zde->comp_size = _zip_buffer_get_64(ef_buffer); if (!local) { if (zde->offset == ZIP_UINT32_MAX) zde->offset = _zip_buffer_get_64(ef_buffer); if (zde->disk_number == ZIP_UINT16_MAX) zde->disk_number = _zip_buffer_get_32(buffer); } if (!_zip_buffer_eof(ef_buffer)) { zip_error_set(error, ZIP_ER_INCONS, 0); _zip_buffer_free(ef_buffer); if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } _zip_buffer_free(ef_buffer); } if (!_zip_buffer_ok(buffer)) { zip_error_set(error, ZIP_ER_INTERNAL, 0); if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } if (!from_buffer) { _zip_buffer_free(buffer); } if (zde->offset > ZIP_INT64_MAX) { zip_error_set(error, ZIP_ER_SEEK, EFBIG); return -1; } if (!_zip_dirent_process_winzip_aes(zde, error)) { if (!from_buffer) { _zip_buffer_free(buffer); } return -1; } zde->extra_fields = _zip_ef_remove_internal(zde->extra_fields); return (zip_int64_t)(size + variable_size); }
Description: Double free vulnerability in the _zip_dirent_read function in zip_dirent.c in libzip allows attackers to have unspecified impact via unknown vectors.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int base64url_encode(const void *data_in, size_t data_in_size, unsigned char *base64_out, size_t *base64_out_size) { return base64_encode_base(data_in, data_in_size, base64_out, base64_out_size, true); }
Description: RIOT 2020.04 has a buffer overflow in the base64 decoder. The decoding function base64_decode() uses an output buffer estimation function to compute the required buffer capacity and validate against the provided buffer size. The base64_estimate_decode_size() function calculates the expected decoded size with an arithmetic round-off error and does not take into account possible padding bytes. Due to this underestimation, it may be possible to craft base64 input that causes a buffer overflow.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static inline void _write_unlock(rwlock_t *lock) { ASSERT(_is_write_locked_by_me(atomic_read(&lock->cnts))); atomic_and(~(_QW_CPUMASK | _QW_WMASK), &lock->cnts); preempt_enable(); }
Description: An issue was discovered in Xen through 4.13.x, allowing guest OS users to cause a denial of service or possibly gain privileges because of missing memory barriers in read-write unlock paths. The read-write unlock paths don't contain a memory barrier. On Arm, this means a processor is allowed to re-order the memory access with the preceding ones. In other words, the unlock may be seen by another processor before all the memory accesses within the ""critical"" section. As a consequence, it may be possible to have a writer executing a critical section at the same time as readers or another writer. In other words, many of the assumptions (e.g., a variable cannot be modified after a check) in the critical sections are not safe anymore. The read-write locks are used in hypercalls (such as grant-table ones), so a malicious guest could exploit the race. For instance, there is a small window where Xen can leak memory if XENMAPSPACE_grant_table is used concurrently. A malicious guest may be able to leak memory, or cause a hypervisor crash resulting in a Denial of Service (DoS). Information leak and privilege escalation cannot be excluded.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static ssize_t rbd_config_info_show(struct device *dev, struct device_attribute *attr, char *buf) { struct rbd_device *rbd_dev = dev_to_rbd_dev(dev); return sprintf(buf, ""%s\n"", rbd_dev->config_info); }
Description: The rbd block device driver in drivers/block/rbd.c in the Linux kernel through 5.8.9 used incomplete permission checking for access to rbd devices, which could be leveraged by local attackers to map or unmap rbd block devices, aka CID-f44d04e696fe.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int vfs_rename(struct inode *old_dir, struct dentry *old_dentry, struct inode *new_dir, struct dentry *new_dentry, struct inode **delegated_inode, unsigned int flags) { int error; bool is_dir = d_is_dir(old_dentry); const unsigned char *old_name; struct inode *source = old_dentry->d_inode; struct inode *target = new_dentry->d_inode; bool new_is_dir = false; unsigned max_links = new_dir->i_sb->s_max_links; if (source == target) return 0; error = may_delete(old_dir, old_dentry, is_dir); if (error) return error; if (!target) { error = may_create(new_dir, new_dentry); } else { new_is_dir = d_is_dir(new_dentry); if (!(flags & RENAME_EXCHANGE)) error = may_delete(new_dir, new_dentry, is_dir); else error = may_delete(new_dir, new_dentry, new_is_dir); } if (error) return error; if (!old_dir->i_op->rename && !old_dir->i_op->rename2) return -EPERM; if (flags && !old_dir->i_op->rename2) return -EINVAL; if (new_dir != old_dir) { if (is_dir) { error = inode_permission(source, MAY_WRITE); if (error) return error; } if ((flags & RENAME_EXCHANGE) && new_is_dir) { error = inode_permission(target, MAY_WRITE); if (error) return error; } } error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry, flags); if (error) return error; old_name = fsnotify_oldname_init(old_dentry->d_name.name); dget(new_dentry); if (!is_dir || (flags & RENAME_EXCHANGE)) lock_two_nondirectories(source, target); else if (target) inode_lock(target); error = -EBUSY; if (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry)) goto out; if (max_links && new_dir != old_dir) { error = -EMLINK; if (is_dir && !new_is_dir && new_dir->i_nlink >= max_links) goto out; if ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir && old_dir->i_nlink >= max_links) goto out; } if (is_dir && !(flags & RENAME_EXCHANGE) && target) shrink_dcache_parent(new_dentry); if (!is_dir) { error = try_break_deleg(source, delegated_inode); if (error) goto out; } if (target && !new_is_dir) { error = try_break_deleg(target, delegated_inode); if (error) goto out; } if (!old_dir->i_op->rename2) { error = old_dir->i_op->rename(old_dir, old_dentry, new_dir, new_dentry); } else { WARN_ON(old_dir->i_op->rename != NULL); error = old_dir->i_op->rename2(old_dir, old_dentry, new_dir, new_dentry, flags); } if (error) goto out; if (!(flags & RENAME_EXCHANGE) && target) { if (is_dir) target->i_flags |= S_DEAD; dont_mount(new_dentry); detach_mounts(new_dentry); } if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) { if (!(flags & RENAME_EXCHANGE)) d_move(old_dentry, new_dentry); else d_exchange(old_dentry, new_dentry); } out: if (!is_dir || (flags & RENAME_EXCHANGE)) unlock_two_nondirectories(source, target); else if (target) inode_unlock(target); dput(new_dentry); if (!error) { fsnotify_move(old_dir, new_dir, old_name, is_dir, !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry); if (flags & RENAME_EXCHANGE) { fsnotify_move(new_dir, old_dir, old_dentry->d_name.name, new_is_dir, NULL, new_dentry); } } fsnotify_oldname_free(old_name); return error; }
Description: The filesystem layer in the Linux kernel before 4.5.5 proceeds with post-rename operations after an OverlayFS file is renamed to a self-hardlink, which allows local users to cause a denial of service (system crash) via a rename system call, related to fs/namei.c and fs/open.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: char *LibRaw_buffer_datastream::gets(char *s, int sz) { unsigned char *psrc, *pdest, *str; str = (unsigned char *)s; psrc = buf + streampos; pdest = str; if(streampos >= streamsize) return NULL; while ((size_t(psrc - buf) < streamsize) && ((pdest - str) < (sz-1))) { *pdest = *psrc; if (*psrc == '\n') break; psrc++; pdest++; } if (size_t(psrc - buf) < streamsize) psrc++; if ((pdest - str) < sz-1) *(++pdest) = 0; else s[sz - 1] = 0;  streampos = psrc - buf; return s; }
Description: Buffer Overflow vulnerability in LibRaw linux/unix v0.20.0 allows attacker to escalate privileges via the LibRaw_buffer_datastream::gets(char*, int) in /src/libraw/src/libraw_datastream.cpp.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void extract_archive (void) { char typeflag; tar_extractor_t fun; fatal_exit_hook = extract_finish; set_next_block_after (current_header); if (!current_stat_info.file_name[0] || (interactive_option && !confirm (""extract"", current_stat_info.file_name))) { skip_member (); return; } if (verbose_option) print_header (&current_stat_info, current_header, -1); if (!delay_directory_restore_option) { int dir = chdir_current; apply_nonancestor_delayed_set_stat (current_stat_info.file_name, 0); chdir_do (dir); } if (backup_option) if (!maybe_backup_file (current_stat_info.file_name, 0)) { int e = errno; ERROR ((0, e, _(""%s: Was unable to backup this file""), quotearg_colon (current_stat_info.file_name))); skip_member (); return; } typeflag = sparse_member_p (&current_stat_info) ? GNUTYPE_SPARSE : current_header->header.typeflag; if (prepare_to_extract (current_stat_info.file_name, typeflag, &fun)) { if (fun && (*fun) (current_stat_info.file_name, typeflag) && backup_option) undo_last_backup (); } else skip_member (); }
Description: Directory traversal vulnerability in the safer_name_suffix function in GNU tar 1.14 through 1.29 might allow remote attackers to bypass an intended protection mechanism and write to arbitrary files via vectors related to improper sanitization of the file_name parameter, aka POINTYFEATHER.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int main(int argc, char **argv) { #ifdef Q_OS_WIN SetDllDirectory(L""""); #endif QCoreApplication app(argc, argv); #ifdef Q_OS_WIN QString opensslConf = QCoreApplication::applicationDirPath() + QString(""/openssl.cnf""); qputenv(""OPENSSL_CONF"", opensslConf.toLocal8Bit()); #endif CmdOptions options; options.silent = false; options.trustSSL = false; options.useNetrc = false; options.interactive = true; options.ignoreHiddenFiles = false;     options.restartTimes = 3; options.uplimit = 0; options.downlimit = 0; parseOptions(app.arguments(), &options); if (options.silent) { qInstallMessageHandler(nullMessageHandler); } else { qSetMessagePattern(""%{time MM-dd hh:mm:ss:zzz} [ %{type} %{category} ]%{if-debug}\t[ %{function} ]%{endif}:\t%{message}""); } AccountPtr account = Account::create(); if (!account) { qFatal(""Could not initialize account!""); return EXIT_FAILURE; } if (options.target_url.contains(""/webdav"", Qt::CaseInsensitive) || options.target_url.contains(""/dav"", Qt::CaseInsensitive)) { qWarning(""Dav or webdav in server URL.""); std::cerr << ""Error! Please specify only the base URL of your host with username and password. Example:"" << std::endl << ""http(s):        return EXIT_FAILURE; } QUrl hostUrl = QUrl::fromUserInput((options.target_url.endsWith(QLatin1Char('/')) || options.target_url.endsWith(QLatin1Char('\\'))) ? options.target_url.chopped(1) : options.target_url); QString user = hostUrl.userName(); QString password = hostUrl.password(); if (!options.user.isEmpty()) { user = options.user; } if (!options.password.isEmpty()) { password = options.password; } if (options.useNetrc) { NetrcParser parser; if (parser.parse()) { NetrcParser::LoginPair pair = parser.find(hostUrl.host()); user = pair.first; password = pair.second; } } if (options.interactive) { if (user.isEmpty()) { std::cout << ""Please enter username: ""; std::string s; std::getline(std::cin, s); user = QString::fromStdString(s); } if (password.isEmpty()) { password = queryPassword(user); } } hostUrl.setScheme(hostUrl.scheme().replace(""owncloud"", ""http"")); QUrl credentialFreeUrl = hostUrl; credentialFreeUrl.setUserName(QString()); credentialFreeUrl.setPassword(QString()); const QString folder = options.remotePath; if (!options.proxy.isNull()) { QString host; int port = 0; bool ok = false; QStringList pList = options.proxy.split(':'); if (pList.count() == 3) { host = pList.at(1); if (host.startsWith(""                host.remove(0, 2); port = pList.at(2).toInt(&ok); QNetworkProxyFactory::setUseSystemConfiguration(false); QNetworkProxy::setApplicationProxy(QNetworkProxy(QNetworkProxy::HttpProxy, host, port)); } else { qFatal(""Could not read httpproxy. The proxy should have the format \""http:        } } auto *sslErrorHandler = new SimpleSslErrorHandler; #ifdef TOKEN_AUTH_ONLY auto *cred = new TokenCredentials(user, password, """"); account->setCredentials(cred); #else auto *cred = new HttpCredentialsText(user, password); account->setCredentials(cred); if (options.trustSSL) { cred->setSSLTrusted(true); } #endif account->setUrl(hostUrl); account->setSslErrorHandler(sslErrorHandler); QEventLoop loop; auto *job = new JsonApiJob(account, QLatin1String(""ocs/v1.php/cloud/capabilities"")); QObject::connect(job, &JsonApiJob::jsonReceived, [&](const QJsonDocument &json) { auto caps = json.object().value(""ocs"").toObject().value(""data"").toObject().value(""capabilities"").toObject(); qDebug() << ""Server capabilities"" << caps; account->setCapabilities(caps.toVariantMap()); account->setServerVersion(caps[""core""].toObject()[""status""].toObject()[""version""].toString()); loop.quit(); }); job->start(); loop.exec(); if (job->reply()->error() != QNetworkReply::NoError){ std::cout<<""Error connecting to server\n""; return EXIT_FAILURE; } job = new JsonApiJob(account, QLatin1String(""ocs/v1.php/cloud/user"")); QObject::connect(job, &JsonApiJob::jsonReceived, [&](const QJsonDocument &json) { const QJsonObject data = json.object().value(""ocs"").toObject().value(""data"").toObject(); account->setDavUser(data.value(""id"").toString()); account->setDavDisplayName(data.value(""display-name"").toString()); loop.quit(); }); job->start(); loop.exec(); SyncEngine::minimumFileAgeForUpload = std::chrono::milliseconds(0); int restartCount = 0; restart_sync: opts = &options; QStringList selectiveSyncList; if (!options.unsyncedfolders.isEmpty()) { QFile f(options.unsyncedfolders); if (!f.open(QFile::ReadOnly)) { qCritical() << ""Could not open file containing the list of unsynced folders: "" << options.unsyncedfolders; } else { selectiveSyncList = QString::fromUtf8(f.readAll()).split('\n').filter(QRegularExpression(""\\S+"")).filter(QRegularExpression(""^[^#]"")); for (int i = 0; i < selectiveSyncList.count(); ++i) { if (!selectiveSyncList.at(i).endsWith(QLatin1Char('/'))) { selectiveSyncList[i].append(QLatin1Char('/')); } } } } Cmd cmd; QString dbPath = options.source_dir + SyncJournalDb::makeDbName(options.source_dir, credentialFreeUrl, folder, user); SyncJournalDb db(dbPath); if (!selectiveSyncList.empty()) { selectiveSyncFixup(&db, selectiveSyncList); } SyncOptions opt; opt.fillFromEnvironmentVariables(); opt.verifyChunkSizes(); SyncEngine engine(account, options.source_dir, opt, folder, &db); engine.setIgnoreHiddenFiles(options.ignoreHiddenFiles); engine.setNetworkLimits(options.uplimit, options.downlimit); QObject::connect(&engine, &SyncEngine::finished, [&app](bool result) { app.exit(result ? EXIT_SUCCESS : EXIT_FAILURE); }); QObject::connect(&engine, &SyncEngine::transmissionProgress, &cmd, &Cmd::transmissionProgressSlot); QObject::connect(&engine, &SyncEngine::syncError, [](const QString &error) { qWarning() << ""Sync error:"" << error; }); bool hasUserExcludeFile = !options.exclude.isEmpty(); QString systemExcludeFile = ConfigFile::excludeFileFromSystem(); if (hasUserExcludeFile) { engine.excludedFiles().addExcludeFilePath(options.exclude); } if (!hasUserExcludeFile || QFile::exists(systemExcludeFile)) { engine.excludedFiles().addExcludeFilePath(systemExcludeFile); } if (!engine.excludedFiles().reloadExcludeFiles()) { qFatal(""Cannot load system exclude list or list supplied via --exclude""); return EXIT_FAILURE; } QMetaObject::invokeMethod(&engine, ""startSync"", Qt::QueuedConnection); int resultCode = app.exec(); if (engine.isAnotherSyncNeeded() != NoFollowUpSync) { if (restartCount < options.restartTimes) { restartCount++; qDebug() << ""Restarting Sync, because another sync is needed"" << restartCount; goto restart_sync; } qWarning() << ""Another sync is needed, but not done because restart count is exceeded"" << restartCount; } return resultCode; }
Description: Nextcloud also ships a CLI utility called nextcloudcmd which is sometimes used for automated scripting and headless servers. Versions of nextcloudcmd prior to 3.6.1 would incorrectly trust invalid TLS certificates, which may enable a Man-in-the-middle attack that exposes sensitive data or credentials to a network attacker. This affects the CLI only. It does not affect the standard GUI desktop Nextcloud clients, and it does not affect the Nextcloud server.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void io_req_free_batch(struct req_batch *rb, struct io_kiocb *req) { if (unlikely(io_is_fallback_req(req))) { io_free_req(req); return; } if (req->flags & REQ_F_LINK_HEAD) io_queue_next(req); if (req->task != rb->task) { if (rb->task) put_task_struct_many(rb->task, rb->task_refs); rb->task = req->task; rb->task_refs = 0; } rb->task_refs++; WARN_ON_ONCE(io_dismantle_req(req)); rb->reqs[rb->to_free++] = req; if (unlikely(rb->to_free == ARRAY_SIZE(rb->reqs))) __io_req_free_batch_flush(req->ctx, rb); }
Description: An issue was discovered in the Linux kernel before 5.9.3. io_uring takes a non-refcounted reference to the files_struct of the process that submitted a request, causing execve() to incorrectly optimize unshare_fd(), aka CID-0f2122045b94.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int ipmi_si_mem_setup(struct si_sm_io *io) { unsigned long addr = io->addr_data; int           mapsize, idx; if (!addr) return -ENODEV; io->io_cleanup = mem_cleanup; switch (io->regsize) { case 1: io->inputb = intf_mem_inb; io->outputb = intf_mem_outb; break; case 2: io->inputb = intf_mem_inw; io->outputb = intf_mem_outw; break; case 4: io->inputb = intf_mem_inl; io->outputb = intf_mem_outl; break; #ifdef readq case 8: io->inputb = mem_inq; io->outputb = mem_outq; break; #endif default: dev_warn(io->dev, ""Invalid register size: %d\n"", io->regsize); return -EINVAL; } for (idx = 0; idx < io->io_size; idx++) { if (request_mem_region(addr + idx * io->regspacing, io->regsize, DEVICE_NAME) == NULL) { mem_region_cleanup(io, idx); return -EIO; } } mapsize = ((io->io_size * io->regspacing) - (io->regspacing - io->regsize)); io->addr = ioremap(addr, mapsize); if (io->addr == NULL) { mem_region_cleanup(io, io->io_size); return -EIO; } return 0; }
Description: An issue was discovered in the Linux kernel before 5.0.4. There is a use-after-free upon attempted read access to /proc/ioports after the ipmi_si module is removed, related to drivers/char/ipmi/ipmi_si_intf.c, drivers/char/ipmi/ipmi_si_mem_io.c, and drivers/char/ipmi/ipmi_si_port_io.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void __sock_recv_timestamp(struct msghdr *msg, struct sock *sk, struct sk_buff *skb) { int need_software_tstamp = sock_flag(sk, SOCK_RCVTSTAMP); struct scm_timestamping tss; int empty = 1; struct skb_shared_hwtstamps *shhwtstamps = skb_hwtstamps(skb); if (need_software_tstamp && skb->tstamp == 0) __net_timestamp(skb); if (need_software_tstamp) { if (!sock_flag(sk, SOCK_RCVTSTAMPNS)) { struct timeval tv; skb_get_timestamp(skb, &tv); put_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMP, sizeof(tv), &tv); } else { struct timespec ts; skb_get_timestampns(skb, &ts); put_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPNS, sizeof(ts), &ts); } } memset(&tss, 0, sizeof(tss)); if ((sk->sk_tsflags & SOF_TIMESTAMPING_SOFTWARE) && ktime_to_timespec_cond(skb->tstamp, tss.ts + 0)) empty = 0; if (shhwtstamps && (sk->sk_tsflags & SOF_TIMESTAMPING_RAW_HARDWARE) && ktime_to_timespec_cond(shhwtstamps->hwtstamp, tss.ts + 2)) empty = 0; if (!empty) { put_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPING, sizeof(tss), &tss); if (skb->len && (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_STATS)) put_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPING_OPT_STATS, skb->len, skb->data); } }
Description: The TCP stack in the Linux kernel through 4.10.6 mishandles the SCM_TIMESTAMPING_OPT_STATS feature, which allows local users to obtain sensitive information from the kernel's internal socket data structures or cause a denial of service (out-of-bounds read) via crafted system calls, related to net/core/skbuff.c and net/socket.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int kvaser_usb_leaf_flush_queue(struct kvaser_usb_net_priv *priv) { struct kvaser_cmd *cmd; int rc; cmd = kmalloc(sizeof(*cmd), GFP_KERNEL); if (!cmd) return -ENOMEM; cmd->id = CMD_FLUSH_QUEUE; cmd->len = CMD_HEADER_LEN + sizeof(struct kvaser_cmd_flush_queue); cmd->u.flush_queue.channel = priv->channel; cmd->u.flush_queue.flags = 0x00; rc = kvaser_usb_send_cmd(priv->dev, cmd, cmd->len); kfree(cmd); return rc; }
Description: In the Linux kernel through 5.4.6, there are information leaks of uninitialized memory to a USB device in the drivers/net/can/usb/kvaser_usb/kvaser_usb_leaf.c driver, aka CID-da2311a6385c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int LiSendMouseButtonEvent(char action, int button) { PPACKET_HOLDER holder; int err; if (!initialized) { return -2; } holder = malloc(sizeof(*holder)); if (holder == NULL) { return -1; } holder->packetLength = sizeof(NV_MOUSE_BUTTON_PACKET); holder->packet.mouseButton.header.packetType = htonl(PACKET_TYPE_MOUSE_BUTTON); holder->packet.mouseButton.action = action; if (ServerMajorVersion >= 5) { holder->packet.mouseButton.action++; } holder->packet.mouseButton.button = htonl(button); err = LbqOfferQueueItem(&packetQueue, holder, &holder->entry); if (err != LBQ_SUCCESS) { free(holder); } return err; }
Description: Moonlight-common-c contains the core GameStream client code shared between Moonlight clients. Moonlight-common-c is vulnerable to buffer overflow starting in commit f57bd745b4cbed577ea654fad4701bea4d38b44c. A malicious game streaming server could exploit a buffer overflow vulnerability to crash a moonlight client. Achieving RCE is possible but unlikely, due to stack canaries in use by modern compiler toolchains. The published binaries for official clients Qt, Android, iOS/tvOS, and Embedded are built with stack canaries, but some unofficial clients may not use stack canaries. This vulnerability takes place after the pairing process, so it requires the client to be tricked into pairing to a malicious host. It is not possible to perform using a man-in-the-middle due to public key pinning that takes place during the pairing process. The bug was addressed in commit b2497a3918a6d79808d9fd0c04734786e70d5954.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: struct mg_str *mg_get_http_header(struct http_message *hm, const char *name) { size_t i, len = strlen(name); for (i = 0; hm->header_names[i].len > 0; i++) { struct mg_str *h = &hm->header_names[i], *v = &hm->header_values[i]; if (h->p != NULL && h->len == len && !mg_ncasecmp(h->p, name, len)) return v; } return NULL; }
Description: A buffer overflow vulnerability exists in the mg_get_http_header function in Cesanta Mongoose 6.18 due to a lack of bounds checking. A crafted HTTP header can exploit this bug. NOTE: a committer has stated ""this will not happen in practice.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void __fscache_invalidate(struct fscache_cookie *cookie, const void *aux_data, loff_t new_size, unsigned int flags) { bool is_caching; _enter(""c=%x"", cookie->debug_id); fscache_stat(&fscache_n_invalidates); if (WARN(test_bit(FSCACHE_COOKIE_RELINQUISHED, &cookie->flags), ""Trying to invalidate relinquished cookie\n"")) return; if ((flags & FSCACHE_INVAL_DIO_WRITE) && test_and_set_bit(FSCACHE_COOKIE_DISABLED, &cookie->flags)) return; spin_lock(&cookie->lock); set_bit(FSCACHE_COOKIE_NO_DATA_TO_READ, &cookie->flags); fscache_update_aux(cookie, aux_data, &new_size); cookie->inval_counter++; trace_fscache_invalidate(cookie, new_size); switch (cookie->state) { case FSCACHE_COOKIE_STATE_INVALIDATING:  default: spin_unlock(&cookie->lock); _leave("" [no %u]"", cookie->state); return; case FSCACHE_COOKIE_STATE_LOOKING_UP: __fscache_begin_cookie_access(cookie, fscache_access_invalidate_cookie); set_bit(FSCACHE_COOKIE_DO_INVALIDATE, &cookie->flags); fallthrough; case FSCACHE_COOKIE_STATE_CREATING: spin_unlock(&cookie->lock); _leave("" [look %x]"", cookie->inval_counter); return; case FSCACHE_COOKIE_STATE_ACTIVE: is_caching = fscache_begin_cookie_access( cookie, fscache_access_invalidate_cookie); if (is_caching) __fscache_set_cookie_state(cookie, FSCACHE_COOKIE_STATE_INVALIDATING); spin_unlock(&cookie->lock); wake_up_cookie_state(cookie); if (is_caching) fscache_queue_cookie(cookie, fscache_cookie_get_inval_work); _leave("" [inv]""); return; } }
Description: A vulnerability was found in Linux Kernel. It has been rated as problematic. This issue affects some unknown processing of the file fs/fscache/cookie.c of the component IPsec. The manipulation leads to memory leak. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-211931.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static bool scan_unit_for_symbols (struct comp_unit *unit) { bfd *abfd = unit->abfd; bfd_byte *info_ptr = unit->first_child_die_ptr; bfd_byte *info_ptr_end = unit->end_ptr; int nesting_level = 0; struct nest_funcinfo { struct funcinfo *func; } *nested_funcs; int nested_funcs_size; struct funcinfo *last_func; struct varinfo *last_var; nested_funcs_size = 32; nested_funcs = (struct nest_funcinfo *) bfd_malloc (nested_funcs_size * sizeof (*nested_funcs)); if (nested_funcs == NULL) return false; nested_funcs[nesting_level].func = 0; while (nesting_level >= 0) { unsigned int abbrev_number, i; struct abbrev_info *abbrev; struct funcinfo *func; struct varinfo *var; uint64_t current_offset; if (info_ptr >= info_ptr_end) goto fail; current_offset = info_ptr - unit->info_ptr_unit; abbrev_number = _bfd_safe_read_leb128 (abfd, &info_ptr, false, info_ptr_end); if (abbrev_number == 0) { nesting_level--; continue; } abbrev = lookup_abbrev (abbrev_number, unit->abbrevs); if (! abbrev) { static unsigned int previous_failed_abbrev = -1U; if (abbrev_number != previous_failed_abbrev) { _bfd_error_handler (_(""DWARF error: could not find abbrev number %u""), abbrev_number); previous_failed_abbrev = abbrev_number; } bfd_set_error (bfd_error_bad_value); goto fail; } if (abbrev->tag == DW_TAG_subprogram || abbrev->tag == DW_TAG_entry_point || abbrev->tag == DW_TAG_inlined_subroutine) { size_t amt = sizeof (struct funcinfo); var = NULL; func = (struct funcinfo *) bfd_zalloc (abfd, amt); if (func == NULL) goto fail; func->tag = abbrev->tag; func->prev_func = unit->function_table; func->unit_offset = current_offset; unit->function_table = func; unit->number_of_functions++; BFD_ASSERT (!unit->cached); if (func->tag == DW_TAG_inlined_subroutine) for (i = nesting_level; i-- != 0; ) if (nested_funcs[i].func) { func->caller_func = nested_funcs[i].func; break; } nested_funcs[nesting_level].func = func; } else { func = NULL; if (abbrev->tag == DW_TAG_variable || abbrev->tag == DW_TAG_member) { size_t amt = sizeof (struct varinfo); var = (struct varinfo *) bfd_zalloc (abfd, amt); if (var == NULL) goto fail; var->tag = abbrev->tag; var->stack = true; var->prev_var = unit->variable_table; unit->variable_table = var; var->unit_offset = current_offset; } else var = NULL; nested_funcs[nesting_level].func = 0; } for (i = 0; i < abbrev->num_attrs; ++i) { struct attribute attr; info_ptr = read_attribute (&attr, &abbrev->attrs[i], unit, info_ptr, info_ptr_end); if (info_ptr == NULL) goto fail; } if (abbrev->has_children) { nesting_level++; if (nesting_level >= nested_funcs_size) { struct nest_funcinfo *tmp; nested_funcs_size *= 2; tmp = (struct nest_funcinfo *) bfd_realloc (nested_funcs, nested_funcs_size * sizeof (*nested_funcs)); if (tmp == NULL) goto fail; nested_funcs = tmp; } nested_funcs[nesting_level].func = 0; } } unit->function_table = reverse_funcinfo_list (unit->function_table); unit->variable_table = reverse_varinfo_list (unit->variable_table); info_ptr = unit->first_child_die_ptr; nesting_level = 0; last_func = NULL; last_var = NULL; while (nesting_level >= 0) { unsigned int abbrev_number, i; struct abbrev_info *abbrev; struct attribute attr; struct funcinfo *func; struct varinfo *var; bfd_vma low_pc = 0; bfd_vma high_pc = 0; bool high_pc_relative = false; uint64_t current_offset; if (info_ptr >= info_ptr_end) goto fail; current_offset = info_ptr - unit->info_ptr_unit; abbrev_number = _bfd_safe_read_leb128 (abfd, &info_ptr, false, info_ptr_end); if (! abbrev_number) { nesting_level--; continue; } abbrev = lookup_abbrev (abbrev_number, unit->abbrevs); BFD_ASSERT (abbrev != NULL); func = NULL; var = NULL; if (abbrev->tag == DW_TAG_subprogram || abbrev->tag == DW_TAG_entry_point || abbrev->tag == DW_TAG_inlined_subroutine) { if (last_func && last_func->prev_func && last_func->prev_func->unit_offset == current_offset) func = last_func->prev_func; else func = lookup_func_by_offset (current_offset, unit->function_table); if (func == NULL) goto fail; last_func = func; } else if (abbrev->tag == DW_TAG_variable || abbrev->tag == DW_TAG_member) { if (last_var && last_var->prev_var && last_var->prev_var->unit_offset == current_offset) var = last_var->prev_var; else var = lookup_var_by_offset (current_offset, unit->variable_table); if (var == NULL) goto fail; last_var = var; } for (i = 0; i < abbrev->num_attrs; ++i) { info_ptr = read_attribute (&attr, &abbrev->attrs[i], unit, info_ptr, info_ptr_end); if (info_ptr == NULL) goto fail; if (func) { switch (attr.name) { case DW_AT_call_file: if (is_int_form (&attr)) func->caller_file = concat_filename (unit->line_table, attr.u.val); break; case DW_AT_call_line: if (is_int_form (&attr)) func->caller_line = attr.u.val; break; case DW_AT_abstract_origin: case DW_AT_specification: if (is_int_form (&attr) && !find_abstract_instance (unit, &attr, 0, &func->name, &func->is_linkage, &func->file, &func->line)) goto fail; break; case DW_AT_name: if (func->name == NULL && is_str_form (&attr)) { func->name = attr.u.str; if (mangle_style (unit->lang) == 0) func->is_linkage = true; } break; case DW_AT_linkage_name: case DW_AT_MIPS_linkage_name: if (is_str_form (&attr)) { func->name = attr.u.str; func->is_linkage = true; } break; case DW_AT_low_pc: if (is_int_form (&attr)) low_pc = attr.u.val; break; case DW_AT_high_pc: if (is_int_form (&attr)) { high_pc = attr.u.val; high_pc_relative = attr.form != DW_FORM_addr; } break; case DW_AT_ranges: if (is_int_form (&attr) && !read_rangelist (unit, &func->arange, &unit->file->trie_root, attr.u.val)) goto fail; break; case DW_AT_decl_file: if (is_int_form (&attr)) func->file = concat_filename (unit->line_table, attr.u.val); break; case DW_AT_decl_line: if (is_int_form (&attr)) func->line = attr.u.val; break; default: break; } } else if (var) { switch (attr.name) { case DW_AT_specification: if (is_int_form (&attr) && attr.u.val) { bool is_linkage; if (!find_abstract_instance (unit, &attr, 0, &var->name, &is_linkage, &var->file, &var->line)) { _bfd_error_handler (_(""DWARF error: could not find "" ""variable specification "" ""at offset 0x%lx""), (unsigned long) attr.u.val); break; } } break; case DW_AT_name: if (is_str_form (&attr)) var->name = attr.u.str; break; case DW_AT_decl_file: if (is_int_form (&attr)) var->file = concat_filename (unit->line_table, attr.u.val); break; case DW_AT_decl_line: if (is_int_form (&attr)) var->line = attr.u.val; break; case DW_AT_external: if (is_int_form (&attr) && attr.u.val != 0) var->stack = false; break; case DW_AT_location: switch (attr.form) { case DW_FORM_block: case DW_FORM_block1: case DW_FORM_block2: case DW_FORM_block4: case DW_FORM_exprloc: if (attr.u.blk->data != NULL && *attr.u.blk->data == DW_OP_addr) { var->stack = false; if (attr.u.blk->size == unit->addr_size + 1U) var->addr = bfd_get (unit->addr_size * 8, unit->abfd, attr.u.blk->data + 1); } break; default: break; } break; default: break; } } } if (abbrev->has_children) nesting_level++; if (high_pc_relative) high_pc += low_pc; if (func && high_pc != 0) { if (!arange_add (unit, &func->arange, &unit->file->trie_root, low_pc, high_pc)) goto fail; } } unit->function_table = reverse_funcinfo_list (unit->function_table); unit->variable_table = reverse_varinfo_list (unit->variable_table); free (nested_funcs); return true; fail: free (nested_funcs); return false; }
Description: GNU Binutils before 2.40 was discovered to contain a memory leak vulnerability var the function find_abstract_instance in dwarf2.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void  SkippedMBMotionComp( VideoDecData *video ) { Vop *prev = video->prevVop; Vop *comp; int ypos, xpos; PIXEL *c_comp, *c_prev; PIXEL *cu_comp, *cu_prev; PIXEL *cv_comp, *cv_prev; int width, width_uv; int32 offset; #ifdef PV_POSTPROC_ON     int imv; int32 size = (int32) video->nTotalMB << 8; uint8 *pp_dec_y, *pp_dec_u; uint8 *pp_prev1; int mvwidth = video->nMBPerRow << 1; #endif width = video->width; width_uv  = width >> 1; ypos = video->mbnum_row << 4 ; xpos = video->mbnum_col << 4 ; offset = (int32)ypos * width + xpos; c_prev  = prev->yChan + offset; cu_prev = prev->uChan + (offset >> 2) + (xpos >> 2); cv_prev = prev->vChan + (offset >> 2) + (xpos >> 2); comp = video->currVop; c_comp  = comp->yChan + offset; cu_comp = comp->uChan + (offset >> 2) + (xpos >> 2); cv_comp = comp->vChan + (offset >> 2) + (xpos >> 2); PutSKIPPED_MB(c_comp,  c_prev, width); PutSKIPPED_B(cu_comp, cu_prev, width_uv); PutSKIPPED_B(cv_comp, cv_prev, width_uv); #ifdef PV_POSTPROC_ON     if (video->postFilterType != PV_NO_POST_PROC) { imv = (offset >> 6) - (xpos >> 6) + (xpos >> 3); pp_prev1 = video->pstprcTypPrv + imv; pp_dec_y = video->pstprcTypCur + imv; *pp_dec_y = *pp_prev1; *(pp_dec_y + 1) = *(pp_prev1 + 1); *(pp_dec_y + mvwidth) = *(pp_prev1 + mvwidth); *(pp_dec_y + mvwidth + 1) = *(pp_prev1 + mvwidth + 1); pp_prev1 = video->pstprcTypPrv + (size >> 6) + ((imv + (xpos >> 3)) >> 2); pp_dec_u = video->pstprcTypCur + (size >> 6) + ((imv + (xpos >> 3)) >> 2); *pp_dec_u = *pp_prev1; pp_dec_u[size>>8] = pp_prev1[size>>8]; } #endif return; }
Description: A remote denial of service vulnerability in libstagefright in Mediaserver could enable an attacker to use a specially crafted file to cause a device hang or reboot. This issue is rated as High severity due to the possibility of remote denial of service. Product: Android. Versions: 4.4.4, 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1, 7.1.2. Android ID: A-35269635.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void ehci_advance_state(EHCIState *ehci, int async) { EHCIQueue *q = NULL; int again; do { switch(ehci_get_state(ehci, async)) { case EST_WAITLISTHEAD: again = ehci_state_waitlisthead(ehci, async); break; case EST_FETCHENTRY: again = ehci_state_fetchentry(ehci, async); break; case EST_FETCHQH: q = ehci_state_fetchqh(ehci, async); if (q != NULL) { assert(q->async == async); again = 1; } else { again = 0; } break; case EST_FETCHITD: again = ehci_state_fetchitd(ehci, async); break; case EST_FETCHSITD: again = ehci_state_fetchsitd(ehci, async); break; case EST_ADVANCEQUEUE: assert(q != NULL); again = ehci_state_advqueue(q); break; case EST_FETCHQTD: assert(q != NULL); again = ehci_state_fetchqtd(q); break; case EST_HORIZONTALQH: assert(q != NULL); again = ehci_state_horizqh(q); break; case EST_EXECUTE: assert(q != NULL); again = ehci_state_execute(q); if (async) { ehci->async_stepdown = 0; } break; case EST_EXECUTING: assert(q != NULL); if (async) { ehci->async_stepdown = 0; } again = ehci_state_executing(q); break; case EST_WRITEBACK: assert(q != NULL); again = ehci_state_writeback(q); if (!async) { ehci->periodic_sched_active = PERIODIC_ACTIVE; } break; default: fprintf(stderr, ""Bad state!\n""); again = -1; g_assert_not_reached(); break; } if (again < 0) { fprintf(stderr, ""processing error - resetting ehci HC\n""); ehci_reset(ehci); again = 0; } } while (again); }
Description: The ehci_advance_state function in hw/usb/hcd-ehci.c in QEMU allows local guest OS administrators to cause a denial of service (infinite loop and CPU consumption) via a circular split isochronous transfer descriptor (siTD) list, a related issue to CVE-2015-8558.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int do_command (unsigned char c) { static int dtr_up = 0; int newbaud, newflow, newparity, newbits; const char *xfr_cmd; char *fname; int r; switch (c) { case KEY_EXIT: return 1; case KEY_QUIT: term_set_hupcl(tty_fd, 0); term_flush(tty_fd); term_apply(tty_fd); term_erase(tty_fd); return 1; case KEY_STATUS: show_status(dtr_up); break; case KEY_PULSE: fd_printf(STO, ""\r\n*** pulse DTR ***\r\n""); if ( term_pulse_dtr(tty_fd) < 0 ) fd_printf(STO, ""*** FAILED\r\n""); break; case KEY_TOGGLE: if ( dtr_up ) r = term_lower_dtr(tty_fd); else r = term_raise_dtr(tty_fd); if ( r >= 0 ) dtr_up = ! dtr_up; fd_printf(STO, ""\r\n*** DTR: %s ***\r\n"",  dtr_up ? ""up"" : ""down""); break; case KEY_BAUD_UP: case KEY_BAUD_DN: if (c == KEY_BAUD_UP) opts.baud = baud_up(opts.baud); else  opts.baud = baud_down(opts.baud); term_set_baudrate(tty_fd, opts.baud); tty_q.len = 0; term_flush(tty_fd); term_apply(tty_fd); newbaud = term_get_baudrate(tty_fd, NULL); if ( opts.baud != newbaud ) { fd_printf(STO, ""\r\n*** baud: %d (%d) ***\r\n"",  opts.baud, newbaud); } else { fd_printf(STO, ""\r\n*** baud: %d ***\r\n"", opts.baud); } set_tty_write_sz(newbaud); break; case KEY_FLOW: opts.flow = flow_next(opts.flow); term_set_flowcntrl(tty_fd, opts.flow); tty_q.len = 0; term_flush(tty_fd); term_apply(tty_fd); newflow = term_get_flowcntrl(tty_fd); if ( opts.flow != newflow ) { fd_printf(STO, ""\r\n*** flow: %s (%s) ***\r\n"",  flow_str[opts.flow], flow_str[newflow]); } else { fd_printf(STO, ""\r\n*** flow: %s ***\r\n"",  flow_str[opts.flow]); } break; case KEY_PARITY: opts.parity = parity_next(opts.parity); term_set_parity(tty_fd, opts.parity); tty_q.len = 0; term_flush(tty_fd); term_apply(tty_fd); newparity = term_get_parity(tty_fd); if (opts.parity != newparity ) { fd_printf(STO, ""\r\n*** parity: %s (%s) ***\r\n"", parity_str[opts.parity],  parity_str[newparity]); } else { fd_printf(STO, ""\r\n*** parity: %s ***\r\n"",  parity_str[opts.parity]); } break; case KEY_BITS: opts.databits = bits_next(opts.databits); term_set_databits(tty_fd, opts.databits); tty_q.len = 0; term_flush(tty_fd); term_apply(tty_fd); newbits = term_get_databits(tty_fd); if (opts.databits != newbits ) { fd_printf(STO, ""\r\n*** databits: %d (%d) ***\r\n"", opts.databits, newbits); } else { fd_printf(STO, ""\r\n*** databits: %d ***\r\n"",  opts.databits); } break; case KEY_LECHO: opts.lecho = ! opts.lecho; fd_printf(STO, ""\r\n*** local echo: %s ***\r\n"",  opts.lecho ? ""yes"" : ""no""); break; case KEY_SEND: case KEY_RECEIVE: xfr_cmd = (c == KEY_SEND) ? opts.send_cmd : opts.receive_cmd; if ( xfr_cmd[0] == '\0' ) { fd_printf(STO, ""\r\n*** command disabled ***\r\n""); break; } fname = read_filename(); if (fname == NULL) { fd_printf(STO, ""*** cannot read filename ***\r\n""); break; } run_cmd(tty_fd, xfr_cmd, fname, NULL); free(fname); break; case KEY_BREAK: term_break(tty_fd); fd_printf(STO, ""\r\n*** break sent ***\r\n""); break; default: break; } return 0; }
Description: picocom before 2.0 has a command injection vulnerability in the 'send and receive file' command because the command line is executed by /bin/sh unsafely.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len) { struct inet_sock *inet = inet_sk(sk); struct ipv6_pinfo *np = inet6_sk(sk); struct sockaddr_l2tpip6 *addr = (struct sockaddr_l2tpip6 *) uaddr; struct net *net = sock_net(sk); __be32 v4addr = 0; int addr_type; int err; if (!sock_flag(sk, SOCK_ZAPPED)) return -EINVAL; if (addr->l2tp_family != AF_INET6) return -EINVAL; if (addr_len < sizeof(*addr)) return -EINVAL; addr_type = ipv6_addr_type(&addr->l2tp_addr); if (addr_type == IPV6_ADDR_MAPPED) return -EADDRNOTAVAIL; if (addr_type & IPV6_ADDR_MULTICAST) return -EADDRNOTAVAIL; err = -EADDRINUSE; read_lock_bh(&l2tp_ip6_lock); if (__l2tp_ip6_bind_lookup(net, &addr->l2tp_addr, sk->sk_bound_dev_if, addr->l2tp_conn_id)) goto out_in_use; read_unlock_bh(&l2tp_ip6_lock); lock_sock(sk); err = -EINVAL; if (sk->sk_state != TCP_CLOSE) goto out_unlock; rcu_read_lock(); if (addr_type != IPV6_ADDR_ANY) { struct net_device *dev = NULL; if (addr_type & IPV6_ADDR_LINKLOCAL) { if (addr_len >= sizeof(struct sockaddr_in6) && addr->l2tp_scope_id) { sk->sk_bound_dev_if = addr->l2tp_scope_id; } if (!sk->sk_bound_dev_if) goto out_unlock_rcu; err = -ENODEV; dev = dev_get_by_index_rcu(sock_net(sk), sk->sk_bound_dev_if); if (!dev) goto out_unlock_rcu; } v4addr = LOOPBACK4_IPV6; err = -EADDRNOTAVAIL; if (!ipv6_chk_addr(sock_net(sk), &addr->l2tp_addr, dev, 0)) goto out_unlock_rcu; } rcu_read_unlock(); inet->inet_rcv_saddr = inet->inet_saddr = v4addr; sk->sk_v6_rcv_saddr = addr->l2tp_addr; np->saddr = addr->l2tp_addr; l2tp_ip6_sk(sk)->conn_id = addr->l2tp_conn_id; write_lock_bh(&l2tp_ip6_lock); sk_add_bind_node(sk, &l2tp_ip6_bind_table); sk_del_node_init(sk); write_unlock_bh(&l2tp_ip6_lock); sock_reset_flag(sk, SOCK_ZAPPED); release_sock(sk); return 0; out_unlock_rcu: rcu_read_unlock(); out_unlock: release_sock(sk); return err; out_in_use: read_unlock_bh(&l2tp_ip6_lock); return err; }
Description: Race condition in the L2TPv3 IP Encapsulation feature in the Linux kernel before 4.8.14 allows local users to gain privileges or cause a denial of service (use-after-free) by making multiple bind system calls without properly ascertaining whether a socket has the SOCK_ZAPPED status, related to net/l2tp/l2tp_ip.c and net/l2tp/l2tp_ip6.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb, netdev_features_t features) { struct sk_buff *segs = ERR_PTR(-EINVAL); unsigned int mss; unsigned int unfrag_ip6hlen, unfrag_len; struct frag_hdr *fptr; u8 *packet_start, *prevhdr; u8 nexthdr; u8 frag_hdr_sz = sizeof(struct frag_hdr); __wsum csum; int tnl_hlen; mss = skb_shinfo(skb)->gso_size; if (unlikely(skb->len <= mss)) goto out; if (skb_gso_ok(skb, features | NETIF_F_GSO_ROBUST)) { skb_shinfo(skb)->gso_segs = DIV_ROUND_UP(skb->len, mss); if (!skb_shinfo(skb)->ip6_frag_id) ipv6_proxy_select_ident(dev_net(skb->dev), skb); segs = NULL; goto out; } if (skb->encapsulation && skb_shinfo(skb)->gso_type & (SKB_GSO_UDP_TUNNEL|SKB_GSO_UDP_TUNNEL_CSUM)) segs = skb_udp_tunnel_segment(skb, features, true); else { const struct ipv6hdr *ipv6h; struct udphdr *uh; if (!pskb_may_pull(skb, sizeof(struct udphdr))) goto out; uh = udp_hdr(skb); ipv6h = ipv6_hdr(skb); uh->check = 0; csum = skb_checksum(skb, 0, skb->len, 0); uh->check = udp_v6_check(skb->len, &ipv6h->saddr, &ipv6h->daddr, csum); if (uh->check == 0) uh->check = CSUM_MANGLED_0; skb->ip_summed = CHECKSUM_NONE; if (!skb->encap_hdr_csum) features |= NETIF_F_HW_CSUM; tnl_hlen = skb_tnl_header_len(skb); if (skb->mac_header < (tnl_hlen + frag_hdr_sz)) { if (gso_pskb_expand_head(skb, tnl_hlen + frag_hdr_sz)) goto out; } unfrag_ip6hlen = ip6_find_1stfragopt(skb, &prevhdr); nexthdr = *prevhdr; *prevhdr = NEXTHDR_FRAGMENT; unfrag_len = (skb_network_header(skb) - skb_mac_header(skb)) + unfrag_ip6hlen + tnl_hlen; packet_start = (u8 *) skb->head + SKB_GSO_CB(skb)->mac_offset; memmove(packet_start-frag_hdr_sz, packet_start, unfrag_len); SKB_GSO_CB(skb)->mac_offset -= frag_hdr_sz; skb->mac_header -= frag_hdr_sz; skb->network_header -= frag_hdr_sz; fptr = (struct frag_hdr *)(skb_network_header(skb) + unfrag_ip6hlen); fptr->nexthdr = nexthdr; fptr->reserved = 0; if (!skb_shinfo(skb)->ip6_frag_id) ipv6_proxy_select_ident(dev_net(skb->dev), skb); fptr->identification = skb_shinfo(skb)->ip6_frag_id; segs = skb_segment(skb, features); } out: return segs; }
Description: The IPv6 fragmentation implementation in the Linux kernel through 4.11.1 does not consider that the nexthdr field may be associated with an invalid option, which allows local users to cause a denial of service (out-of-bounds read and BUG) or possibly have unspecified other impact via crafted socket and send system calls.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int read_image_tga( gdIOCtx *ctx, oTga *tga ) { int pixel_block_size = (tga->bits / 8); int image_block_size = (tga->width * tga->height) * pixel_block_size; uint8_t* decompression_buffer = NULL; unsigned char* conversion_buffer = NULL; int buffer_caret = 0; int bitmap_caret = 0; int i = 0; int j = 0; uint8_t encoded_pixels; if(overflow2(tga->width, tga->height)) { return -1; } if(overflow2(tga->width * tga->height, pixel_block_size)) { return -1; } if(overflow2(image_block_size, sizeof(int))) { return -1; } if (tga->imagetype != TGA_TYPE_RGB && tga->imagetype != TGA_TYPE_RGB_RLE) return -1; tga->bitmap = (int *) gdMalloc(image_block_size * sizeof(int)); if (tga->bitmap == NULL) return -1; switch (tga->imagetype) { case TGA_TYPE_RGB: conversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char)); if (conversion_buffer == NULL) { return -1; } gdGetBuf(conversion_buffer, image_block_size, ctx); while (buffer_caret < image_block_size) { tga->bitmap[buffer_caret] = (int) conversion_buffer[buffer_caret]; buffer_caret++; } gdFree(conversion_buffer); break; case TGA_TYPE_RGB_RLE: decompression_buffer = (uint8_t*) gdMalloc(image_block_size * sizeof(uint8_t)); if (decompression_buffer == NULL) { return -1; } conversion_buffer = (unsigned char *) gdMalloc(image_block_size * sizeof(unsigned char)); if (conversion_buffer == NULL) { gdFree( decompression_buffer ); return -1; } gdGetBuf( conversion_buffer, image_block_size, ctx ); buffer_caret = 0; while( buffer_caret < image_block_size) { decompression_buffer[buffer_caret] = (int)conversion_buffer[buffer_caret]; buffer_caret++; } buffer_caret = 0; while( bitmap_caret < image_block_size ) { if ((decompression_buffer[buffer_caret] & TGA_RLE_FLAG) == TGA_RLE_FLAG) { encoded_pixels = ( ( decompression_buffer[ buffer_caret ] & 127 ) + 1 ); buffer_caret++; for (i = 0; i < encoded_pixels; i++) { for (j = 0; j < pixel_block_size; j++, bitmap_caret++) { tga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ]; } } buffer_caret += pixel_block_size; } else { encoded_pixels = decompression_buffer[ buffer_caret ] + 1; buffer_caret++; for (i = 0; i < encoded_pixels; i++) { for( j = 0; j < pixel_block_size; j++, bitmap_caret++ ) { tga->bitmap[ bitmap_caret ] = decompression_buffer[ buffer_caret + j ]; } buffer_caret += pixel_block_size; } } } gdFree( decompression_buffer ); gdFree( conversion_buffer ); break; } return 1; }
Description: The gdImageCreateFromTgaCtx function in the GD Graphics Library (aka libgd) before 2.2.3 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted TGA file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static RAND_DRBG *rand_drbg_new(int secure, int type, unsigned int flags, RAND_DRBG *parent) { RAND_DRBG *drbg = secure ? OPENSSL_secure_zalloc(sizeof(*drbg)) : OPENSSL_zalloc(sizeof(*drbg)); if (drbg == NULL) { RANDerr(RAND_F_RAND_DRBG_NEW, ERR_R_MALLOC_FAILURE); return NULL; } drbg->secure = secure && CRYPTO_secure_allocated(drbg); drbg->fork_count = rand_fork_count; drbg->parent = parent; if (parent == NULL) { drbg->get_entropy = rand_drbg_get_entropy; drbg->cleanup_entropy = rand_drbg_cleanup_entropy; #ifndef RAND_DRBG_GET_RANDOM_NONCE drbg->get_nonce = rand_drbg_get_nonce; drbg->cleanup_nonce = rand_drbg_cleanup_nonce; #endif drbg->reseed_interval = master_reseed_interval; drbg->reseed_time_interval = master_reseed_time_interval; } else { drbg->get_entropy = rand_drbg_get_entropy; drbg->cleanup_entropy = rand_drbg_cleanup_entropy; drbg->reseed_interval = slave_reseed_interval; drbg->reseed_time_interval = slave_reseed_time_interval; } if (RAND_DRBG_set(drbg, type, flags) == 0) goto err; if (parent != NULL) { rand_drbg_lock(parent); if (drbg->strength > parent->strength) { rand_drbg_unlock(parent); RANDerr(RAND_F_RAND_DRBG_NEW, RAND_R_PARENT_STRENGTH_TOO_WEAK); goto err; } rand_drbg_unlock(parent); } return drbg; err: RAND_DRBG_free(drbg); return NULL; }
Description: OpenSSL 1.1.1 introduced a rewritten random number generator (RNG). This was intended to include protection in the event of a fork() system call in order to ensure that the parent and child processes did not share the same RNG state. However this protection was not being used in the default case. A partial mitigation for this issue is that the output from a high precision timer is mixed into the RNG state so the likelihood of a parent and child process sharing state is significantly reduced. If an application already calls OPENSSL_init_crypto() explicitly using OPENSSL_INIT_ATFORK then this problem does not occur at all. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: ecma_value_t ecma_proxy_object_set (ecma_object_t *obj_p,  ecma_string_t *prop_name_p,  ecma_value_t value,  ecma_value_t receiver)  { JERRY_ASSERT (ECMA_OBJECT_IS_PROXY (obj_p)); ecma_proxy_object_t *proxy_obj_p = (ecma_proxy_object_t *) obj_p; ecma_value_t handler = proxy_obj_p->handler; ecma_value_t trap = ecma_validate_proxy_object (handler, LIT_MAGIC_STRING_SET); if (ECMA_IS_VALUE_ERROR (trap)) { return trap; } ecma_value_t target = proxy_obj_p->target; ecma_object_t *target_obj_p = ecma_get_object_from_value (target); if (ecma_is_value_undefined (trap)) { return ecma_op_object_put_with_receiver (target_obj_p, prop_name_p, value, receiver, false); } ecma_object_t *func_obj_p = ecma_get_object_from_value (trap); ecma_value_t prop_name_value = ecma_make_prop_name_value (prop_name_p); ecma_value_t args[] = { target, prop_name_value, value, receiver }; ecma_value_t trap_result = ecma_op_function_call (func_obj_p, handler, args, 4); ecma_deref_object (func_obj_p); if (ECMA_IS_VALUE_ERROR (trap_result)) { return trap_result; } bool boolean_trap_result = ecma_op_to_boolean (trap_result); ecma_free_value (trap_result); if (!boolean_trap_result) { return ECMA_VALUE_FALSE; } ecma_property_descriptor_t target_desc; ecma_value_t status = ecma_op_object_get_own_property_descriptor (target_obj_p, prop_name_p, &target_desc); if (ECMA_IS_VALUE_ERROR (status)) { return status; } if (ecma_is_value_true (status)) { ecma_value_t ret_value = ECMA_VALUE_EMPTY; if ((target_desc.flags & ECMA_PROP_IS_VALUE_DEFINED) && !(target_desc.flags & ECMA_PROP_IS_CONFIGURABLE) && !(target_desc.flags & ECMA_PROP_IS_WRITABLE) && !ecma_op_same_value (value, target_desc.value)) { ret_value = ecma_raise_type_error (ECMA_ERR_MSG (""The property exists in the proxy target as a"" "" non-configurable and non-writable data property"" "" with a different value."")); } else if (!(target_desc.flags & ECMA_PROP_IS_CONFIGURABLE) && (target_desc.flags & (ECMA_PROP_IS_GET_DEFINED | ECMA_PROP_IS_SET_DEFINED)) && target_desc.set_p == NULL) { ret_value = ecma_raise_type_error (ECMA_ERR_MSG (""The property exists in the proxy target as a"" "" non-configurable accessor property whitout a setter."")); } ecma_free_property_descriptor (&target_desc); if (ECMA_IS_VALUE_ERROR (ret_value)) { return ret_value; } } return ECMA_VALUE_TRUE; }
Description: JerryScript 2.2.0 allows attackers to cause a denial of service (stack consumption) via a proxy operation.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static bool sanity_check_inode(struct inode *inode) { struct f2fs_sb_info *sbi = F2FS_I_SB(inode); if (f2fs_sb_has_flexible_inline_xattr(sbi->sb) && !f2fs_has_extra_attr(inode)) { set_sbi_flag(sbi, SBI_NEED_FSCK); f2fs_msg(sbi->sb, KERN_WARNING, ""%s: corrupted inode ino=%lx, run fsck to fix."", __func__, inode->i_ino); return false; } return true; }
Description: An issue was discovered in fs/f2fs/inode.c in the Linux kernel through 4.17.3. A denial of service (slab out-of-bounds read and BUG) can occur for a modified f2fs filesystem image in which FI_EXTRA_ATTR is set in an inode.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int amd_iommu_assign_device(struct domain *d, u8 devfn, struct pci_dev *pdev, u32 flag) { struct ivrs_mappings *ivrs_mappings = get_ivrs_mappings(pdev->seg); int bdf = PCI_BDF2(pdev->bus, devfn); int req_id = get_dma_requestor_id(pdev->seg, bdf); if ( ivrs_mappings[req_id].unity_map_enable ) { amd_iommu_reserve_domain_unity_map( d, ivrs_mappings[req_id].addr_range_start, ivrs_mappings[req_id].addr_range_length, ivrs_mappings[req_id].write_permission, ivrs_mappings[req_id].read_permission); } return reassign_device(hardware_domain, d, devfn, pdev); }
Description: An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void php_wddx_push_element(void *user_data, const XML_Char *name, const XML_Char **atts) { st_entry ent; wddx_stack *stack = (wddx_stack *)user_data; if (!strcmp(name, EL_PACKET)) { int i; if (atts) for (i=0; atts[i]; i++) { if (!strcmp(atts[i], EL_VERSION)) { } } } else if (!strcmp(name, EL_STRING)) { ent.type = ST_STRING; SET_STACK_VARNAME; ALLOC_ZVAL(ent.data); INIT_PZVAL(ent.data); Z_TYPE_P(ent.data) = IS_STRING; Z_STRVAL_P(ent.data) = STR_EMPTY_ALLOC(); Z_STRLEN_P(ent.data) = 0; wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry)); } else if (!strcmp(name, EL_BINARY)) { ent.type = ST_BINARY; SET_STACK_VARNAME; ALLOC_ZVAL(ent.data); INIT_PZVAL(ent.data); Z_TYPE_P(ent.data) = IS_STRING; Z_STRVAL_P(ent.data) = STR_EMPTY_ALLOC(); Z_STRLEN_P(ent.data) = 0; wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry)); } else if (!strcmp(name, EL_CHAR)) { int i; if (atts) for (i = 0; atts[i]; i++) { if (!strcmp(atts[i], EL_CHAR_CODE) && atts[++i] && atts[i][0]) { char tmp_buf[2]; snprintf(tmp_buf, sizeof(tmp_buf), ""%c"", (char)strtol(atts[i], NULL, 16)); php_wddx_process_data(user_data, tmp_buf, strlen(tmp_buf)); break; } } } else if (!strcmp(name, EL_NUMBER)) { ent.type = ST_NUMBER; SET_STACK_VARNAME; ALLOC_ZVAL(ent.data); INIT_PZVAL(ent.data); Z_TYPE_P(ent.data) = IS_LONG; Z_LVAL_P(ent.data) = 0; wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry)); } else if (!strcmp(name, EL_BOOLEAN)) { int i; if (atts) for (i = 0; atts[i]; i++) { if (!strcmp(atts[i], EL_VALUE) && atts[++i] && atts[i][0]) { ent.type = ST_BOOLEAN; SET_STACK_VARNAME; ALLOC_ZVAL(ent.data); INIT_PZVAL(ent.data); Z_TYPE_P(ent.data) = IS_BOOL; wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry)); php_wddx_process_data(user_data, atts[i], strlen(atts[i])); break; } } } else if (!strcmp(name, EL_NULL)) { ent.type = ST_NULL; SET_STACK_VARNAME; ALLOC_ZVAL(ent.data); INIT_PZVAL(ent.data); ZVAL_NULL(ent.data); wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry)); } else if (!strcmp(name, EL_ARRAY)) { ent.type = ST_ARRAY; SET_STACK_VARNAME; ALLOC_ZVAL(ent.data); array_init(ent.data); INIT_PZVAL(ent.data); wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry)); } else if (!strcmp(name, EL_STRUCT)) { ent.type = ST_STRUCT; SET_STACK_VARNAME; ALLOC_ZVAL(ent.data); array_init(ent.data); INIT_PZVAL(ent.data); wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry)); } else if (!strcmp(name, EL_VAR)) { int i; if (atts) for (i = 0; atts[i]; i++) { if (!strcmp(atts[i], EL_NAME) && atts[++i] && atts[i][0]) { if (stack->varname) efree(stack->varname); stack->varname = estrdup(atts[i]); break; } } } else if (!strcmp(name, EL_RECORDSET)) { int i; ent.type = ST_RECORDSET; SET_STACK_VARNAME; MAKE_STD_ZVAL(ent.data); array_init(ent.data); if (atts) for (i = 0; atts[i]; i++) { if (!strcmp(atts[i], ""fieldNames"") && atts[++i] && atts[i][0]) { zval *tmp; char *key; char *p1, *p2, *endp; endp = (char *)atts[i] + strlen(atts[i]); p1 = (char *)atts[i]; while ((p2 = php_memnstr(p1, "","", sizeof("","")-1, endp)) != NULL) { key = estrndup(p1, p2 - p1); MAKE_STD_ZVAL(tmp); array_init(tmp); add_assoc_zval_ex(ent.data, key, p2 - p1 + 1, tmp); p1 = p2 + sizeof("","")-1; efree(key); } if (p1 <= endp) { MAKE_STD_ZVAL(tmp); array_init(tmp); add_assoc_zval_ex(ent.data, p1, endp - p1 + 1, tmp); } break; } } wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry)); } else if (!strcmp(name, EL_FIELD)) { int i; st_entry ent; ent.type = ST_FIELD; ent.varname = NULL; ent.data = NULL; if (atts) for (i = 0; atts[i]; i++) { if (!strcmp(atts[i], EL_NAME) && atts[++i] && atts[i][0]) { st_entry *recordset; zval **field; if (wddx_stack_top(stack, (void**)&recordset) == SUCCESS && recordset->type == ST_RECORDSET && zend_hash_find(Z_ARRVAL_P(recordset->data), (char*)atts[i], strlen(atts[i])+1, (void**)&field) == SUCCESS) { ent.data = *field; } break; } } wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry)); } else if (!strcmp(name, EL_DATETIME)) { ent.type = ST_DATETIME; SET_STACK_VARNAME; ALLOC_ZVAL(ent.data); INIT_PZVAL(ent.data); Z_TYPE_P(ent.data) = IS_LONG; wddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry)); } }
Description: The php_wddx_push_element function in ext/wddx/wddx.c in PHP before 5.6.26 and 7.x before 7.0.11 allows remote attackers to cause a denial of service (invalid pointer access and out-of-bounds read) or possibly have unspecified other impact via an incorrect boolean element in a wddxPacket XML document, leading to mishandling in a wddx_deserialize call.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Status ModularFrameDecoder::DecodeGroup(const Rect& rect, BitReader* reader, int minShift, int maxShift, const ModularStreamId& stream, bool zerofill, PassesDecoderState* dec_state, ImageBundle* output) { JXL_DASSERT(stream.kind == ModularStreamId::kModularDC || stream.kind == ModularStreamId::kModularAC); const size_t xsize = rect.xsize(); const size_t ysize = rect.ysize(); Image gi(xsize, ysize, full_image.bitdepth, 0); size_t c = full_image.nb_meta_channels; for (; c < full_image.channel.size(); c++) { Channel& fc = full_image.channel[c]; if (fc.w > frame_dim.group_dim || fc.h > frame_dim.group_dim) break; } size_t beginc = c; for (; c < full_image.channel.size(); c++) { Channel& fc = full_image.channel[c]; int shift = std::min(fc.hshift, fc.vshift); if (shift > maxShift) continue; if (shift < minShift) continue; Rect r(rect.x0() >> fc.hshift, rect.y0() >> fc.vshift, rect.xsize() >> fc.hshift, rect.ysize() >> fc.vshift, fc.w, fc.h); if (r.xsize() == 0 || r.ysize() == 0) continue; Channel gc(r.xsize(), r.ysize()); gc.hshift = fc.hshift; gc.vshift = fc.vshift; gi.channel.emplace_back(std::move(gc)); } if (zerofill) { int gic = 0; for (c = beginc; c < full_image.channel.size(); c++) { Channel& fc = full_image.channel[c]; int shift = std::min(fc.hshift, fc.vshift); if (shift > maxShift) continue; if (shift < minShift) continue; Rect r(rect.x0() >> fc.hshift, rect.y0() >> fc.vshift, rect.xsize() >> fc.hshift, rect.ysize() >> fc.vshift, fc.w, fc.h); if (r.xsize() == 0 || r.ysize() == 0) continue; for (size_t y = 0; y < r.ysize(); ++y) { pixel_type* const JXL_RESTRICT row_out = r.Row(&fc.plane, y); memset(row_out, 0, r.xsize() * sizeof(*row_out)); } gic++; } return true; } ModularOptions options; if (!ModularGenericDecompress( reader, gi, nullptr, stream.ID(frame_dim), &options, -1, &tree, &code, &context_map)) return JXL_FAILURE(""Failed to decode modular group""); if (minShift == 0) { for (auto t : global_transform) { JXL_RETURN_IF_ERROR(t.Inverse(gi, global_header.wp_header)); } if (!use_full_image) { JXL_RETURN_IF_ERROR(ModularImageToDecodedRect( gi, dec_state, nullptr, output, rect.Crop(dec_state->decoded))); return true; } } int gic = 0; for (c = beginc; c < full_image.channel.size(); c++) { Channel& fc = full_image.channel[c]; int shift = std::min(fc.hshift, fc.vshift); if (shift > maxShift) continue; if (shift < minShift) continue; Rect r(rect.x0() >> fc.hshift, rect.y0() >> fc.vshift, rect.xsize() >> fc.hshift, rect.ysize() >> fc.vshift, fc.w, fc.h); if (r.xsize() == 0 || r.ysize() == 0) continue; CopyImageTo(Rect(0, 0, r.xsize(), r.ysize()), gi.channel[gic].plane, r, &fc.plane); gic++; } return true; }
Description: libjxl b02d6b9, as used in libvips 8.11 through 8.11.2 and other products, has an out-of-bounds write in jxl::ModularFrameDecoder::DecodeGroup (called from jxl::FrameDecoder::ProcessACGroup and jxl::ThreadPool::RunCallState<jxl::FrameDecoder::ProcessSections).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int DH_check(const DH *dh, int *ret) { #ifdef FIPS_MODULE return DH_check_params(dh, ret); #else int ok = 0, r; BN_CTX *ctx = NULL; BIGNUM *t1 = NULL, *t2 = NULL; int nid = DH_get_nid((DH *)dh); *ret = 0; if (nid != NID_undef) return 1; if (BN_num_bits(dh->params.p) > OPENSSL_DH_CHECK_MAX_MODULUS_BITS) { ERR_raise(ERR_LIB_DH, DH_R_MODULUS_TOO_LARGE); *ret = DH_MODULUS_TOO_LARGE | DH_CHECK_P_NOT_PRIME; return 0; } if (!DH_check_params(dh, ret)) return 0; ctx = BN_CTX_new_ex(dh->libctx); if (ctx == NULL) goto err; BN_CTX_start(ctx); t1 = BN_CTX_get(ctx); t2 = BN_CTX_get(ctx); if (t2 == NULL) goto err; if (dh->params.q != NULL) { if (BN_cmp(dh->params.g, BN_value_one()) <= 0) *ret |= DH_NOT_SUITABLE_GENERATOR; else if (BN_cmp(dh->params.g, dh->params.p) >= 0) *ret |= DH_NOT_SUITABLE_GENERATOR; else { if (!BN_mod_exp(t1, dh->params.g, dh->params.q, dh->params.p, ctx)) goto err; if (!BN_is_one(t1)) *ret |= DH_NOT_SUITABLE_GENERATOR; } r = BN_check_prime(dh->params.q, ctx, NULL); if (r < 0) goto err; if (!r) *ret |= DH_CHECK_Q_NOT_PRIME; if (!BN_div(t1, t2, dh->params.p, dh->params.q, ctx)) goto err; if (!BN_is_one(t2)) *ret |= DH_CHECK_INVALID_Q_VALUE; if (dh->params.j != NULL && BN_cmp(dh->params.j, t1)) *ret |= DH_CHECK_INVALID_J_VALUE; } r = BN_check_prime(dh->params.p, ctx, NULL); if (r < 0) goto err; if (!r) *ret |= DH_CHECK_P_NOT_PRIME; else if (dh->params.q == NULL) { if (!BN_rshift1(t1, dh->params.p)) goto err; r = BN_check_prime(t1, ctx, NULL); if (r < 0) goto err; if (!r) *ret |= DH_CHECK_P_NOT_SAFE_PRIME; } ok = 1; err: BN_CTX_end(ctx); BN_CTX_free(ctx); return ok; #endif  }
Description: Issue summary: Checking excessively long DH keys or parameters may be very slow.

Impact summary: Applications that use the functions DH_check(), DH_check_ex()
or EVP_PKEY_param_check() to check a DH key or DH parameters may experience long
delays. Where the key or parameters that are being checked have been obtained
from an untrusted source this may lead to a Denial of Service.

The function DH_check() performs various checks on DH parameters. After fixing
CVE-2023-3446 it was discovered that a large q parameter value can also trigger
an overly long computation during some of these checks. A correct q value,
if present, cannot be larger than the modulus p parameter, thus it is
unnecessary to perform these checks if q is larger than p.

An application that calls DH_check() and supplies a key or parameters obtained
from an untrusted source could be vulnerable to a Denial of Service attack.

The function DH_check() is itself called by a number of other OpenSSL functions.
An application calling any of those other functions may similarly be affected.
The other functions affected by this are DH_check_ex() and
EVP_PKEY_param_check().

Also vulnerable are the OpenSSL dhparam and pkeyparam command line applications
when using the ""-check"" option.

The OpenSSL SSL/TLS implementation is not affected by this issue.

The OpenSSL 3.0 and 3.1 FIPS providers are not affected by this issue.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void CL_Init( void ) { Com_Printf( ""----- Client Initialization -----\n"" ); Con_Init(); if(!com_fullyInitialized) { CL_ClearState(); clc.state = CA_DISCONNECTED;cl_oldGameSet = qfalse; } cls.realtime = 0; CL_InitInput(); cl_noprint = Cvar_Get( ""cl_noprint"", ""0"", 0 ); #ifdef UPDATE_SERVER_NAME cl_motd = Cvar_Get( ""cl_motd"", ""1"", 0 ); #endif cl_autoupdate = Cvar_Get( ""cl_autoupdate"", ""0"", CVAR_ARCHIVE ); cl_timeout = Cvar_Get( ""cl_timeout"", ""200"", 0 ); cl_wavefilerecord = Cvar_Get( ""cl_wavefilerecord"", ""0"", CVAR_TEMP ); cl_timeNudge = Cvar_Get( ""cl_timeNudge"", ""0"", CVAR_TEMP ); cl_shownet = Cvar_Get( ""cl_shownet"", ""0"", CVAR_TEMP ); cl_shownuments = Cvar_Get( ""cl_shownuments"", ""0"", CVAR_TEMP ); cl_visibleClients = Cvar_Get( ""cl_visibleClients"", ""0"", CVAR_TEMP ); cl_showServerCommands = Cvar_Get( ""cl_showServerCommands"", ""0"", 0 ); cl_showSend = Cvar_Get( ""cl_showSend"", ""0"", CVAR_TEMP ); cl_showTimeDelta = Cvar_Get( ""cl_showTimeDelta"", ""0"", CVAR_TEMP ); cl_freezeDemo = Cvar_Get( ""cl_freezeDemo"", ""0"", CVAR_TEMP ); rcon_client_password = Cvar_Get( ""rconPassword"", """", CVAR_TEMP ); cl_activeAction = Cvar_Get( ""activeAction"", """", CVAR_TEMP ); cl_timedemo = Cvar_Get( ""timedemo"", ""0"", 0 ); cl_timedemoLog = Cvar_Get (""cl_timedemoLog"", """", CVAR_ARCHIVE); cl_autoRecordDemo = Cvar_Get (""cl_autoRecordDemo"", ""0"", CVAR_ARCHIVE); cl_aviFrameRate = Cvar_Get (""cl_aviFrameRate"", ""25"", CVAR_ARCHIVE); cl_aviMotionJpeg = Cvar_Get (""cl_aviMotionJpeg"", ""1"", CVAR_ARCHIVE); cl_avidemo = Cvar_Get( ""cl_avidemo"", ""0"", 0 ); cl_forceavidemo = Cvar_Get( ""cl_forceavidemo"", ""0"", 0 ); rconAddress = Cvar_Get( ""rconAddress"", """", 0 ); cl_yawspeed = Cvar_Get( ""cl_yawspeed"", ""140"", CVAR_ARCHIVE ); cl_pitchspeed = Cvar_Get( ""cl_pitchspeed"", ""140"", CVAR_ARCHIVE ); cl_anglespeedkey = Cvar_Get( ""cl_anglespeedkey"", ""1.5"", 0 ); cl_maxpackets = Cvar_Get( ""cl_maxpackets"", ""38"", CVAR_ARCHIVE ); cl_packetdup = Cvar_Get( ""cl_packetdup"", ""1"", CVAR_ARCHIVE ); cl_showPing = Cvar_Get( ""cl_showPing"", ""0"", CVAR_ARCHIVE ); cl_run = Cvar_Get( ""cl_run"", ""1"", CVAR_ARCHIVE ); cl_sensitivity = Cvar_Get( ""sensitivity"", ""5"", CVAR_ARCHIVE ); cl_mouseAccel = Cvar_Get( ""cl_mouseAccel"", ""0"", CVAR_ARCHIVE ); cl_freelook = Cvar_Get( ""cl_freelook"", ""1"", CVAR_ARCHIVE ); cl_mouseAccelStyle = Cvar_Get( ""cl_mouseAccelStyle"", ""0"", CVAR_ARCHIVE ); cl_mouseAccelOffset = Cvar_Get( ""cl_mouseAccelOffset"", ""5"", CVAR_ARCHIVE ); Cvar_CheckRange(cl_mouseAccelOffset, 0.001f, 50000.0f, qfalse); cl_showMouseRate = Cvar_Get( ""cl_showmouserate"", ""0"", 0 ); cl_allowDownload = Cvar_Get( ""cl_allowDownload"", ""1"", CVAR_ARCHIVE ); #ifdef USE_CURL_DLOPEN cl_cURLLib = Cvar_Get(""cl_cURLLib"", DEFAULT_CURL_LIB, CVAR_ARCHIVE); #endif Cvar_Get( ""cg_autoswitch"", ""0"", CVAR_ARCHIVE ); Cvar_Get( ""cg_wolfparticles"", ""1"", CVAR_ARCHIVE ); cl_conXOffset = Cvar_Get( ""cl_conXOffset"", ""0"", 0 ); cl_inGameVideo = Cvar_Get( ""r_inGameVideo"", ""1"", CVAR_ARCHIVE ); cl_serverStatusResendTime = Cvar_Get( ""cl_serverStatusResendTime"", ""750"", 0 ); cl_recoilPitch = Cvar_Get( ""cg_recoilPitch"", ""0"", CVAR_ROM ); cl_bypassMouseInput = Cvar_Get( ""cl_bypassMouseInput"", ""0"", 0 );  m_pitch = Cvar_Get( ""m_pitch"", ""0.022"", CVAR_ARCHIVE ); m_yaw = Cvar_Get( ""m_yaw"", ""0.022"", CVAR_ARCHIVE ); m_forward = Cvar_Get( ""m_forward"", ""0.25"", CVAR_ARCHIVE ); m_side = Cvar_Get( ""m_side"", ""0.25"", CVAR_ARCHIVE ); m_filter = Cvar_Get( ""m_filter"", ""0"", CVAR_ARCHIVE ); j_pitch =        Cvar_Get (""j_pitch"",        ""0.022"", CVAR_ARCHIVE); j_yaw =          Cvar_Get (""j_yaw"",          ""-0.022"", CVAR_ARCHIVE); j_forward =      Cvar_Get (""j_forward"",      ""-0.25"", CVAR_ARCHIVE); j_side =         Cvar_Get (""j_side"",         ""0.25"", CVAR_ARCHIVE); j_up =           Cvar_Get (""j_up"",           ""0"", CVAR_ARCHIVE); j_pitch_axis =   Cvar_Get (""j_pitch_axis"",   ""3"", CVAR_ARCHIVE); j_yaw_axis =     Cvar_Get (""j_yaw_axis"",     ""2"", CVAR_ARCHIVE); j_forward_axis = Cvar_Get (""j_forward_axis"", ""1"", CVAR_ARCHIVE); j_side_axis =    Cvar_Get (""j_side_axis"",    ""0"", CVAR_ARCHIVE); j_up_axis =      Cvar_Get (""j_up_axis"",      ""4"", CVAR_ARCHIVE); Cvar_CheckRange(j_pitch_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue); Cvar_CheckRange(j_yaw_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue); Cvar_CheckRange(j_forward_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue); Cvar_CheckRange(j_side_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue); Cvar_CheckRange(j_up_axis, 0, MAX_JOYSTICK_AXIS-1, qtrue); cl_motdString = Cvar_Get( ""cl_motdString"", """", CVAR_ROM ); Cvar_Get( ""cl_maxPing"", ""800"", CVAR_ARCHIVE ); cl_lanForcePackets = Cvar_Get (""cl_lanForcePackets"", ""1"", CVAR_ARCHIVE); cl_guid = Cvar_Get( ""cl_guid"", ""unknown"", CVAR_USERINFO | CVAR_ROM ); cl_guidServerUniq = Cvar_Get (""cl_guidServerUniq"", ""1"", CVAR_ARCHIVE); cl_consoleKeys = Cvar_Get( ""cl_consoleKeys"", ""~ ` 0x7e 0x60"", CVAR_ARCHIVE); Cvar_Get( ""cg_drawCompass"", ""1"", CVAR_ARCHIVE ); Cvar_Get( ""cg_drawNotifyText"", ""1"", CVAR_ARCHIVE ); Cvar_Get( ""cg_quickMessageAlt"", ""1"", CVAR_ARCHIVE ); Cvar_Get( ""cg_popupLimboMenu"", ""1"", CVAR_ARCHIVE ); Cvar_Get( ""cg_descriptiveText"", ""1"", CVAR_ARCHIVE ); Cvar_Get( ""cg_drawTeamOverlay"", ""2"", CVAR_ARCHIVE ); Cvar_Get( ""cg_uselessNostalgia"", ""0"", CVAR_ARCHIVE ); Cvar_Get( ""cg_drawGun"", ""1"", CVAR_ARCHIVE ); Cvar_Get( ""cg_cursorHints"", ""1"", CVAR_ARCHIVE ); Cvar_Get( ""cg_voiceSpriteTime"", ""6000"", CVAR_ARCHIVE ); Cvar_Get( ""cg_teamChatsOnly"", ""0"", CVAR_ARCHIVE ); Cvar_Get( ""cg_noVoiceChats"", ""0"", CVAR_ARCHIVE ); Cvar_Get( ""cg_noVoiceText"", ""0"", CVAR_ARCHIVE ); Cvar_Get( ""cg_crosshairSize"", ""48"", CVAR_ARCHIVE ); Cvar_Get( ""cg_drawCrosshair"", ""1"", CVAR_ARCHIVE ); Cvar_Get( ""cg_zoomDefaultSniper"", ""20"", CVAR_ARCHIVE ); Cvar_Get( ""cg_zoomstepsniper"", ""2"", CVAR_ARCHIVE ); Cvar_Get( ""mp_playerType"", ""0"", 0 ); Cvar_Get( ""mp_currentPlayerType"", ""0"", 0 ); Cvar_Get( ""mp_weapon"", ""0"", 0 ); Cvar_Get( ""mp_team"", ""0"", 0 ); Cvar_Get( ""mp_currentTeam"", ""0"", 0 ); Cvar_Get( ""name"", ""WolfPlayer"", CVAR_USERINFO | CVAR_ARCHIVE ); cl_rate = Cvar_Get( ""rate"", ""25000"", CVAR_USERINFO | CVAR_ARCHIVE );     Cvar_Get( ""snaps"", ""20"", CVAR_USERINFO | CVAR_ARCHIVE ); Cvar_Get( ""model"", ""multi"", CVAR_USERINFO | CVAR_ARCHIVE ); Cvar_Get( ""head"", ""default"", CVAR_USERINFO | CVAR_ARCHIVE ); Cvar_Get( ""color"", ""4"", CVAR_USERINFO | CVAR_ARCHIVE ); Cvar_Get( ""handicap"", ""100"", CVAR_USERINFO | CVAR_ARCHIVE ); Cvar_Get( ""sex"", ""male"", CVAR_USERINFO | CVAR_ARCHIVE ); Cvar_Get( ""cl_anonymous"", ""0"", CVAR_USERINFO | CVAR_ARCHIVE ); Cvar_Get( ""password"", """", CVAR_USERINFO ); Cvar_Get( ""cg_predictItems"", ""1"", CVAR_USERINFO | CVAR_ARCHIVE ); #ifdef USE_MUMBLE cl_useMumble = Cvar_Get (""cl_useMumble"", ""0"", CVAR_ARCHIVE | CVAR_LATCH); cl_mumbleScale = Cvar_Get (""cl_mumbleScale"", ""0.0254"", CVAR_ARCHIVE); #endif #ifdef USE_VOIP cl_voipSend = Cvar_Get (""cl_voipSend"", ""0"", 0); cl_voipSendTarget = Cvar_Get (""cl_voipSendTarget"", ""spatial"", 0); cl_voipGainDuringCapture = Cvar_Get (""cl_voipGainDuringCapture"", ""0.2"", CVAR_ARCHIVE); cl_voipCaptureMult = Cvar_Get (""cl_voipCaptureMult"", ""2.0"", CVAR_ARCHIVE); cl_voipUseVAD = Cvar_Get (""cl_voipUseVAD"", ""0"", CVAR_ARCHIVE); cl_voipVADThreshold = Cvar_Get (""cl_voipVADThreshold"", ""0.25"", CVAR_ARCHIVE); cl_voipShowMeter = Cvar_Get (""cl_voipShowMeter"", ""1"", CVAR_ARCHIVE); cl_voip = Cvar_Get (""cl_voip"", ""1"", CVAR_ARCHIVE); Cvar_CheckRange( cl_voip, 0, 1, qtrue ); cl_voipProtocol = Cvar_Get (""cl_voipProtocol"", cl_voip->integer ? ""opus"" : """", CVAR_USERINFO | CVAR_ROM); #endif Cvar_Get( ""cg_autoactivate"", ""1"", CVAR_USERINFO | CVAR_ARCHIVE ); Cvar_Get( ""cg_viewsize"", ""100"", CVAR_ARCHIVE ); Cvar_Get (""cg_stereoSeparation"", ""0"", CVAR_ROM); Cvar_Get( ""cg_autoReload"", ""1"", CVAR_ARCHIVE | CVAR_USERINFO ); cl_missionStats = Cvar_Get( ""g_missionStats"", ""0"", CVAR_ROM ); cl_waitForFire = Cvar_Get( ""cl_waitForFire"", ""0"", CVAR_ROM ); cl_language = Cvar_Get( ""cl_language"", ""0"", CVAR_ARCHIVE ); cl_debugTranslation = Cvar_Get( ""cl_debugTranslation"", ""0"", 0 ); cl_updateavailable = Cvar_Get( ""cl_updateavailable"", ""0"", CVAR_ROM ); cl_updatefiles = Cvar_Get( ""cl_updatefiles"", """", CVAR_ROM ); Q_strncpyz( cls.autoupdateServerNames[0], AUTOUPDATE_SERVER1_NAME, MAX_QPATH ); Q_strncpyz( cls.autoupdateServerNames[1], AUTOUPDATE_SERVER2_NAME, MAX_QPATH ); Q_strncpyz( cls.autoupdateServerNames[2], AUTOUPDATE_SERVER3_NAME, MAX_QPATH ); Q_strncpyz( cls.autoupdateServerNames[3], AUTOUPDATE_SERVER4_NAME, MAX_QPATH ); Q_strncpyz( cls.autoupdateServerNames[4], AUTOUPDATE_SERVER5_NAME, MAX_QPATH ); Cmd_AddCommand( ""cmd"", CL_ForwardToServer_f ); Cmd_AddCommand( ""configstrings"", CL_Configstrings_f ); Cmd_AddCommand( ""clientinfo"", CL_Clientinfo_f ); Cmd_AddCommand( ""snd_restart"", CL_Snd_Restart_f ); Cmd_AddCommand( ""vid_restart"", CL_Vid_Restart_f ); Cmd_AddCommand( ""ui_restart"", CL_UI_Restart_f );          Cmd_AddCommand( ""disconnect"", CL_Disconnect_f ); Cmd_AddCommand( ""record"", CL_Record_f ); Cmd_AddCommand( ""demo"", CL_PlayDemo_f ); Cmd_SetCommandCompletionFunc( ""demo"", CL_CompleteDemoName ); Cmd_AddCommand( ""cinematic"", CL_PlayCinematic_f ); Cmd_AddCommand( ""stoprecord"", CL_StopRecord_f ); Cmd_AddCommand( ""connect"", CL_Connect_f ); Cmd_AddCommand( ""reconnect"", CL_Reconnect_f ); Cmd_AddCommand( ""localservers"", CL_LocalServers_f ); Cmd_AddCommand( ""globalservers"", CL_GlobalServers_f ); Cmd_AddCommand( ""rcon"", CL_Rcon_f ); Cmd_SetCommandCompletionFunc( ""rcon"", CL_CompleteRcon ); Cmd_AddCommand( ""ping"", CL_Ping_f ); Cmd_AddCommand( ""serverstatus"", CL_ServerStatus_f ); Cmd_AddCommand( ""showip"", CL_ShowIP_f ); Cmd_AddCommand( ""fs_openedList"", CL_OpenedPK3List_f ); Cmd_AddCommand( ""fs_referencedList"", CL_ReferencedPK3List_f ); Cmd_AddCommand (""video"", CL_Video_f ); Cmd_AddCommand (""stopvideo"", CL_StopVideo_f ); Cmd_AddCommand( ""cache_startgather"", CL_Cache_StartGather_f ); Cmd_AddCommand( ""cache_usedfile"", CL_Cache_UsedFile_f ); Cmd_AddCommand( ""cache_setindex"", CL_Cache_SetIndex_f ); Cmd_AddCommand( ""cache_mapchange"", CL_Cache_MapChange_f ); Cmd_AddCommand( ""cache_endgather"", CL_Cache_EndGather_f ); Cmd_AddCommand( ""updatehunkusage"", CL_UpdateLevelHunkUsage ); Cmd_AddCommand( ""updatescreen"", SCR_UpdateScreen ); Cmd_AddCommand( ""SaveTranslations"", CL_SaveTranslations_f );     Cmd_AddCommand( ""SaveNewTranslations"", CL_SaveNewTranslations_f );   Cmd_AddCommand( ""LoadTranslations"", CL_LoadTranslations_f );      Cmd_AddCommand( ""startSingleplayer"", CL_startSingleplayer_f );       Cmd_AddCommand( ""setRecommended"", CL_SetRecommended_f ); CL_InitRef(); SCR_Init(); Cvar_Set( ""cl_running"", ""1"" ); autoupdateChecked = qfalse; autoupdateStarted = qfalse; CL_InitTranslation();    CL_GenerateQKey(); CL_UpdateGUID( NULL, 0 ); Com_Printf( ""----- Client Initialization Complete -----\n"" ); }
Description: In ioquake3 before 2017-03-14, the auto-downloading feature has insufficient content restrictions. This also affects Quake III Arena, OpenArena, OpenJK, iortcw, and other id Tech 3 (aka Quake 3 engine) forks. A malicious auto-downloaded file can trigger loading of crafted auto-downloaded files as native code DLLs. A malicious auto-downloaded file can contain configuration defaults that override the user's. Executable bytecode in a malicious auto-downloaded file can set configuration variables to values that will result in unwanted native code DLLs being loaded, resulting in sandbox escape.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Token WastLexer::GetToken() { while (true) { token_start_ = cursor_; switch (PeekChar()) { case kEof: return BareToken(TokenType::Eof); case '(': if (MatchString(""(;"")) { if (ReadBlockComment()) { continue; } return BareToken(TokenType::Eof); } else if (MatchString(""(@"")) { GetIdToken(); return TextToken(TokenType::LparAnn, 2); } else { ReadChar(); return BareToken(TokenType::Lpar); } break; case ')': ReadChar(); return BareToken(TokenType::Rpar); case ';': if (MatchString("";;"")) { if (ReadLineComment()) { continue; } return BareToken(TokenType::Eof); } else { ReadChar(); ERROR(""unexpected char""); continue; } break; case ' ': case '\t': case '\r': case '\n': ReadWhitespace(); continue; case '""': return GetStringToken(); case '+': case '-': ReadChar(); switch (PeekChar()) { case 'i': return GetInfToken(); case 'n': return GetNanToken(); case '0': return MatchString(""0x"") ? GetHexNumberToken(TokenType::Int) : GetNumberToken(TokenType::Int); case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': return GetNumberToken(TokenType::Int); default: return GetReservedToken(); } break; case '0': return MatchString(""0x"") ? GetHexNumberToken(TokenType::Nat) : GetNumberToken(TokenType::Nat); case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': return GetNumberToken(TokenType::Nat); case '$': return GetIdToken(); case 'a': return GetNameEqNumToken(""align="", TokenType::AlignEqNat); case 'i': return GetInfToken(); case 'n': return GetNanToken(); case 'o': return GetNameEqNumToken(""offset="", TokenType::OffsetEqNat); default: if (IsKeyword(PeekChar())) { return GetKeywordToken(); } else if (IsIdChar(PeekChar())) { return GetReservedToken(); } else { ReadChar(); ERROR(""unexpected char""); continue; } } } }
Description: WebAssembly wat2wasm v1.0.32 allows attackers to cause a libc++abi.dylib crash by putting '@' before a quote ("").
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: ADDRESS *rfc822_parse_adrlist (ADDRESS *top, const char *s) { int ws_pending, nl; #ifdef EXACT_ADDRESS const char *begin; #endif const char *ps; char comment[LONG_STRING], phrase[LONG_STRING]; size_t phraselen = 0, commentlen = 0; ADDRESS *cur, *last = NULL; RFC822Error = 0; last = top; while (last && last->next) last = last->next; ws_pending = is_email_wsp (*s); if ((nl = mutt_strlen (s))) nl = s[nl - 1] == '\n'; s = skip_email_wsp(s); #ifdef EXACT_ADDRESS begin = s; #endif while (*s) { if (*s == ',') { if (phraselen) { terminate_buffer (phrase, phraselen); add_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1); } else if (commentlen && last && !last->personal) { terminate_buffer (comment, commentlen); last->personal = safe_strdup (comment); } #ifdef EXACT_ADDRESS if (last && !last->val) last->val = mutt_substrdup (begin, s); #endif commentlen = 0; phraselen = 0; s++; #ifdef EXACT_ADDRESS begin = skip_email_wsp(s); #endif } else if (*s == '(') { if (commentlen && commentlen < sizeof (comment) - 1) comment[commentlen++] = ' '; if ((ps = next_token (s, comment, &commentlen, sizeof (comment) - 1)) == NULL) { rfc822_free_address (&top); return NULL; } s = ps; } else if (*s == '""') { if (phraselen && phraselen < sizeof (phrase) - 1) phrase[phraselen++] = ' '; if ((ps = parse_quote (s + 1, phrase, &phraselen, sizeof (phrase) - 1)) == NULL) { rfc822_free_address (&top); return NULL; } s = ps; } else if (*s == '[') { if (phraselen && phraselen < sizeof (phrase) - 1 && ws_pending) phrase[phraselen++] = ' '; if (phraselen < sizeof (phrase) - 1) phrase[phraselen++] = '['; if ((ps = parse_literal (s + 1, phrase, &phraselen, sizeof (phrase) - 1)) == NULL) { rfc822_free_address (&top); return NULL; } s = ps; } else if (*s == ':') { cur = rfc822_new_address (); terminate_buffer (phrase, phraselen); cur->mailbox = safe_strdup (phrase); cur->group = 1; if (last) last->next = cur; else top = cur; last = cur; #ifdef EXACT_ADDRESS last->val = mutt_substrdup (begin, s); #endif phraselen = 0; commentlen = 0; s++; #ifdef EXACT_ADDRESS begin = skip_email_wsp(s); #endif } else if (*s == ';') { if (phraselen) { terminate_buffer (phrase, phraselen); add_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1); } else if (commentlen && last && !last->personal) { terminate_buffer (comment, commentlen); last->personal = safe_strdup (comment); } #ifdef EXACT_ADDRESS if (last && !last->val) last->val = mutt_substrdup (begin, s); #endif if (last) { last->next = rfc822_new_address (); last = last->next; } phraselen = 0; commentlen = 0; #ifdef EXACT_ADDRESS begin = s; #endif s++; } else if (*s == '<') { terminate_buffer (phrase, phraselen); cur = rfc822_new_address (); if (phraselen) cur->personal = safe_strdup (phrase); if ((ps = parse_route_addr (s + 1, comment, &commentlen, sizeof (comment) - 1, cur)) == NULL) { rfc822_free_address (&top); rfc822_free_address (&cur); return NULL; } if (last) last->next = cur; else top = cur; last = cur; phraselen = 0; commentlen = 0; s = ps; } else { if (phraselen && phraselen < sizeof (phrase) - 1 && ws_pending) phrase[phraselen++] = ' '; if ((ps = next_token (s, phrase, &phraselen, sizeof (phrase) - 1)) == NULL) { rfc822_free_address (&top); return NULL; } s = ps; } ws_pending = is_email_wsp(*s); s = skip_email_wsp(s); } if (phraselen) { terminate_buffer (phrase, phraselen); terminate_buffer (comment, commentlen); add_addrspec (&top, &last, phrase, comment, &commentlen, sizeof (comment) - 1); } else if (commentlen && last && !last->personal) { terminate_buffer (comment, commentlen); last->personal = safe_strdup (comment); } #ifdef EXACT_ADDRESS if (last && !last->val) last->val = mutt_substrdup (begin, s - nl < begin ? begin : s - nl); #endif return top; }
Description: rfc822.c in Mutt through 2.0.4 allows remote attackers to cause a denial of service (mailbox unavailability) by sending email messages with sequences of semicolon characters in RFC822 address fields (aka terminators of empty groups). A small email message from the attacker can cause large memory consumption, and the victim may then be unable to see email messages from other persons.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int guest_remove_page(struct domain *d, unsigned long gmfn) { struct page_info *page; #ifdef CONFIG_X86 p2m_type_t p2mt; #endif mfn_t mfn; int rc; #ifdef CONFIG_X86 mfn = get_gfn_query(d, gmfn, &p2mt); if ( unlikely(p2mt == p2m_invalid) || unlikely(p2mt == p2m_mmio_dm) ) { put_gfn(d, gmfn); return -ENOENT; } if ( unlikely(p2m_is_paging(p2mt)) ) { if ( p2mt == p2m_ram_paging_out ) { ASSERT(mfn_valid(mfn)); goto obtain_page; } rc = guest_physmap_remove_page(d, _gfn(gmfn), mfn, 0); if ( rc ) goto out_put_gfn; put_gfn(d, gmfn); p2m_mem_paging_drop_page(d, _gfn(gmfn), p2mt); return 0; } if ( p2mt == p2m_mmio_direct ) { rc = clear_mmio_p2m_entry(d, gmfn, mfn, PAGE_ORDER_4K); goto out_put_gfn; } #else mfn = gfn_to_mfn(d, _gfn(gmfn)); #endif if ( unlikely(!mfn_valid(mfn)) ) { #ifdef CONFIG_X86 put_gfn(d, gmfn); #endif gdprintk(XENLOG_INFO, ""Domain %u page number %lx invalid\n"", d->domain_id, gmfn); return -EINVAL; } #ifdef CONFIG_X86 if ( p2m_is_shared(p2mt) ) { rc = mem_sharing_unshare_page(d, gmfn); if ( rc ) { mem_sharing_notify_enomem(d, gmfn, false); goto out_put_gfn; } mfn = get_gfn_query_unlocked(d, gmfn, &p2mt); ASSERT(!p2m_is_shared(p2mt)); } #endif  obtain_page: __maybe_unused; page = mfn_to_page(mfn); if ( unlikely(!get_page(page, d)) ) { #ifdef CONFIG_X86 put_gfn(d, gmfn); if ( !p2m_is_paging(p2mt) ) #endif gdprintk(XENLOG_INFO, ""Bad page free for Dom%u GFN %lx\n"", d->domain_id, gmfn); return -ENXIO; } rc = guest_physmap_remove_page(d, _gfn(gmfn), mfn, 0); if ( !rc && !is_domain_direct_mapped(d) ) put_page_alloc_ref(page); put_page(page); #ifdef CONFIG_X86 out_put_gfn: put_gfn(d, gmfn); #endif return rc != -ENOENT ? rc : -EINVAL; }
Description: An issue was discovered in Xen through 4.14.x allowing x86 HVM and PVH guest OS users to cause a denial of service (data corruption), cause a data leak, or possibly gain privileges because coalescing of per-page IOMMU TLB flushes is mishandled.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static char * stub_charset () { char *locale, *s, *t; locale = get_locale_var (""LC_CTYPE""); if (locale == 0 || *locale == 0) return ""ASCII""; s = strrchr (locale, '.'); if (s) { t = strchr (s, '@'); if (t) *t = 0; return ++s; } else if (STREQ (locale, ""UTF-8"")) return ""UTF-8""; else return ""ASCII""; }
Description: A heap-based buffer overflow exists in GNU Bash before 4.3 when wide characters, not supported by the current locale set in the LC_CTYPE environment variable, are printed through the echo built-in function. A local attacker, who can provide data to print through the ""echo -e"" built-in function, may use this flaw to crash a script or execute code with the privileges of the bash process. This occurs because ansicstr() in lib/sh/strtrans.c mishandles u32cconv().
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void mbim_dissect_phonebook_read_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint offset) { proto_tree *subtree; gint base_offset; guint32 i, element_count; wmem_array_t *pair_list; struct mbim_pair_list pair_list_item, *p_pair_list_item; base_offset = offset; proto_tree_add_item_ret_uint(tree, hf_mbim_phonebook_read_info_element_count, tvb, offset, 4, ENC_LITTLE_ENDIAN, &element_count); offset += 4; if (element_count) { pair_list = wmem_array_sized_new(wmem_packet_scope(), sizeof(struct mbim_pair_list), element_count); subtree = proto_tree_add_subtree(tree, tvb, offset, 8*element_count, ett_mbim_pair_list, NULL, ""Phonebook Ref List""); for (i = 0; i < element_count; i++) { proto_tree_add_item_ret_uint(subtree, hf_mbim_phonebook_read_info_phonebook_offset, tvb, offset, 4, ENC_LITTLE_ENDIAN, &pair_list_item.offset); offset += 4; proto_tree_add_item_ret_uint(subtree, hf_mbim_phonebook_read_info_phonebook_size, tvb, offset, 4, ENC_LITTLE_ENDIAN, &pair_list_item.size); offset += 4; wmem_array_append_one(pair_list, pair_list_item); } for (i = 0; i < element_count; i++) { p_pair_list_item = (struct mbim_pair_list*)wmem_array_index(pair_list, i); if (p_pair_list_item->offset && p_pair_list_item->size) { subtree = proto_tree_add_subtree_format(tree, tvb, base_offset + p_pair_list_item->offset, p_pair_list_item->size, ett_mbim_pair_list, NULL, ""Phonebook Element #%u"", i+1); mbim_dissect_phonebook_entry(tvb, pinfo, subtree, base_offset + p_pair_list_item->offset); } } } }
Description: In Wireshark 2.4.0 to 2.4.1 and 2.2.0 to 2.2.9, the MBIM dissector could crash or exhaust system memory. This was addressed in epan/dissectors/packet-mbim.c by changing the memory-allocation approach.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int xenmem_add_to_physmap_batch(struct domain *d, struct xen_add_to_physmap_batch *xatpb, unsigned int extent) { if ( unlikely(xatpb->size < extent) ) return -EILSEQ; if ( unlikely(xatpb->size == extent) ) return extent ? -EILSEQ : 0; if ( !guest_handle_subrange_okay(xatpb->idxs, extent, xatpb->size - 1) || !guest_handle_subrange_okay(xatpb->gpfns, extent, xatpb->size - 1) || !guest_handle_subrange_okay(xatpb->errs, extent, xatpb->size - 1) ) return -EFAULT; while ( xatpb->size > extent ) { xen_ulong_t idx; xen_pfn_t gpfn; int rc; if ( unlikely(__copy_from_guest_offset(&idx, xatpb->idxs, extent, 1)) || unlikely(__copy_from_guest_offset(&gpfn, xatpb->gpfns, extent, 1)) ) return -EFAULT; rc = xenmem_add_to_physmap_one(d, xatpb->space, xatpb->u, idx, _gfn(gpfn)); if ( unlikely(__copy_to_guest_offset(xatpb->errs, extent, &rc, 1)) ) return -EFAULT; if ( xatpb->size > ++extent && hypercall_preempt_check() ) return extent; } return 0; }
Description: An issue was discovered in Xen through 4.14.x allowing x86 HVM and PVH guest OS users to cause a denial of service (data corruption), cause a data leak, or possibly gain privileges because coalescing of per-page IOMMU TLB flushes is mishandled.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: char *strstr(char *s1, char *s2) {                                char *p; int len = strlen(s2); if (*s2 == '\0')             return s1; for (p = s1; (p = strchr(p, *s2)) != NULL; p = strchr(p + 1, *s2)) { if (strncmp(p, s2, len) == 0) return (p); } return NULL; }
Description: Boa through 0.94.14rc21 allows remote attackers to trigger an out-of-memory (OOM) condition because malloc is mishandled.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void SVGEndElement(void *context,const xmlChar *name) { SVGInfo *svg_info; (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""  SAX.endElement(%s)"",name); svg_info=(SVGInfo *) context; if (strchr((char *) name,':') != (char *) NULL) { for ( ; *name != ':'; name++) ; name++; } switch (*name) { case 'C': case 'c': { if (LocaleCompare((const char *) name,""circle"") == 0) { (void) FormatLocaleFile(svg_info->file,""class \""circle\""\n""); (void) FormatLocaleFile(svg_info->file,""circle %g,%g %g,%g\n"", svg_info->element.cx,svg_info->element.cy,svg_info->element.cx, svg_info->element.cy+svg_info->element.minor); (void) FormatLocaleFile(svg_info->file,""pop graphic-context\n""); break; } if (LocaleCompare((const char *) name,""clipPath"") == 0) { (void) FormatLocaleFile(svg_info->file,""pop clip-path\n""); break; } break; } case 'D': case 'd': { if (LocaleCompare((const char *) name,""defs"") == 0) { (void) FormatLocaleFile(svg_info->file,""pop defs\n""); break; } if (LocaleCompare((const char *) name,""desc"") == 0) { register char *p; if (*svg_info->text == '\0') break; (void) fputc('#',svg_info->file); for (p=svg_info->text; *p != '\0'; p++) { (void) fputc(*p,svg_info->file); if (*p == '\n') (void) fputc('#',svg_info->file); } (void) fputc('\n',svg_info->file); *svg_info->text='\0'; break; } break; } case 'E': case 'e': { if (LocaleCompare((const char *) name,""ellipse"") == 0) { double angle; (void) FormatLocaleFile(svg_info->file,""class \""ellipse\""\n""); angle=svg_info->element.angle; (void) FormatLocaleFile(svg_info->file,""ellipse %g,%g %g,%g 0,360\n"", svg_info->element.cx,svg_info->element.cy, angle == 0.0 ? svg_info->element.major : svg_info->element.minor, angle == 0.0 ? svg_info->element.minor : svg_info->element.major); (void) FormatLocaleFile(svg_info->file,""pop graphic-context\n""); break; } break; } case 'F': case 'f': { if (LocaleCompare((const char *) name,""foreignObject"") == 0) { (void) FormatLocaleFile(svg_info->file,""pop graphic-context\n""); break; } break; } case 'G': case 'g': { if (LocaleCompare((const char *) name,""g"") == 0) { (void) FormatLocaleFile(svg_info->file,""pop graphic-context\n""); break; } break; } case 'I': case 'i': { if (LocaleCompare((const char *) name,""image"") == 0) { (void) FormatLocaleFile(svg_info->file, ""image Over %g,%g %g,%g \""%s\""\n"",svg_info->bounds.x, svg_info->bounds.y,svg_info->bounds.width,svg_info->bounds.height, svg_info->url); (void) FormatLocaleFile(svg_info->file,""pop graphic-context\n""); break; } break; } case 'L': case 'l': { if (LocaleCompare((const char *) name,""line"") == 0) { (void) FormatLocaleFile(svg_info->file,""class \""line\""\n""); (void) FormatLocaleFile(svg_info->file,""line %g,%g %g,%g\n"", svg_info->segment.x1,svg_info->segment.y1,svg_info->segment.x2, svg_info->segment.y2); (void) FormatLocaleFile(svg_info->file,""pop graphic-context\n""); break; } if (LocaleCompare((const char *) name,""linearGradient"") == 0) { (void) FormatLocaleFile(svg_info->file,""pop gradient\n""); break; } break; } case 'M': case 'm': { if (LocaleCompare((const char *) name,""mask"") == 0) { (void) FormatLocaleFile(svg_info->file,""pop mask\n""); break; } break; } case 'P': case 'p': { if (LocaleCompare((const char *) name,""pattern"") == 0) { (void) FormatLocaleFile(svg_info->file,""pop pattern\n""); break; } if (LocaleCompare((const char *) name,""path"") == 0) { (void) FormatLocaleFile(svg_info->file,""class \""path\""\n""); (void) FormatLocaleFile(svg_info->file,""path \""%s\""\n"", svg_info->vertices); (void) FormatLocaleFile(svg_info->file,""pop graphic-context\n""); break; } if (LocaleCompare((const char *) name,""polygon"") == 0) { (void) FormatLocaleFile(svg_info->file,""class \""polygon\""\n""); (void) FormatLocaleFile(svg_info->file,""polygon %s\n"", svg_info->vertices); (void) FormatLocaleFile(svg_info->file,""pop graphic-context\n""); break; } if (LocaleCompare((const char *) name,""polyline"") == 0) { (void) FormatLocaleFile(svg_info->file,""class \""polyline\""\n""); (void) FormatLocaleFile(svg_info->file,""polyline %s\n"", svg_info->vertices); (void) FormatLocaleFile(svg_info->file,""pop graphic-context\n""); break; } break; } case 'R': case 'r': { if (LocaleCompare((const char *) name,""radialGradient"") == 0) { (void) FormatLocaleFile(svg_info->file,""pop gradient\n""); break; } if (LocaleCompare((const char *) name,""rect"") == 0) { if ((svg_info->radius.x == 0.0) && (svg_info->radius.y == 0.0)) { (void) FormatLocaleFile(svg_info->file,""class \""rect\""\n""); if ((fabs(svg_info->bounds.width-1.0) < MagickEpsilon) && (fabs(svg_info->bounds.height-1.0) < MagickEpsilon)) (void) FormatLocaleFile(svg_info->file,""point %g,%g\n"", svg_info->bounds.x,svg_info->bounds.y); else (void) FormatLocaleFile(svg_info->file, ""rectangle %g,%g %g,%g\n"",svg_info->bounds.x, svg_info->bounds.y,svg_info->bounds.x+svg_info->bounds.width, svg_info->bounds.y+svg_info->bounds.height); (void) FormatLocaleFile(svg_info->file,""pop graphic-context\n""); break; } if (svg_info->radius.x == 0.0) svg_info->radius.x=svg_info->radius.y; if (svg_info->radius.y == 0.0) svg_info->radius.y=svg_info->radius.x; (void) FormatLocaleFile(svg_info->file, ""roundRectangle %g,%g %g,%g %g,%g\n"", svg_info->bounds.x,svg_info->bounds.y,svg_info->bounds.x+ svg_info->bounds.width,svg_info->bounds.y+svg_info->bounds.height, svg_info->radius.x,svg_info->radius.y); svg_info->radius.x=0.0; svg_info->radius.y=0.0; (void) FormatLocaleFile(svg_info->file,""pop graphic-context\n""); break; } break; } case 'S': case 's': { if (LocaleCompare((const char *) name,""stop"") == 0) { (void) FormatLocaleFile(svg_info->file,""stop-color \""%s\"" %s\n"", svg_info->stop_color,svg_info->offset); break; } if (LocaleCompare((char *) name,""style"") == 0) { char *keyword, **tokens, *value; register ssize_t j; size_t number_tokens; tokens=SVGKeyValuePairs(context,'{','}',svg_info->text, &number_tokens); if (tokens == (char **) NULL) break; for (j=0; j < (ssize_t) (number_tokens-1); j+=2) { keyword=(char *) tokens[j]; value=(char *) tokens[j+1]; (void) FormatLocaleFile(svg_info->file,""push class \""%s\""\n"", *keyword == '.' ? keyword+1 : keyword); SVGProcessStyleElement(context,name,value); (void) FormatLocaleFile(svg_info->file,""pop class\n""); } break; } if (LocaleCompare((const char *) name,""svg"") == 0) { (void) FormatLocaleFile(svg_info->file,""pop graphic-context\n""); svg_info->svgDepth--; break; } if (LocaleCompare((const char *) name,""symbol"") == 0) { (void) FormatLocaleFile(svg_info->file,""pop symbol\n""); break; } break; } case 'T': case 't': { if (LocaleCompare((const char *) name,""text"") == 0) { if (*svg_info->text != '\0') { char *text; SVGStripString(MagickTrue,svg_info->text); text=EscapeString(svg_info->text,'\""'); (void) FormatLocaleFile(svg_info->file,""text 0,0 \""%s\""\n"",text); text=DestroyString(text); *svg_info->text='\0'; svg_info->center.x=0.0; svg_info->center.y=0.0; } (void) FormatLocaleFile(svg_info->file,""pop graphic-context\n""); break; } if (LocaleCompare((const char *) name,""tspan"") == 0) { if (*svg_info->text != '\0') { char *text; (void) FormatLocaleFile(svg_info->file,""class \""tspan\""\n""); text=EscapeString(svg_info->text,'\""'); (void) FormatLocaleFile(svg_info->file,""text %g,%g \""%s\""\n"", svg_info->bounds.x-svg_info->center.x,svg_info->bounds.y- svg_info->center.y,text); text=DestroyString(text); *svg_info->text='\0'; } (void) FormatLocaleFile(svg_info->file,""pop graphic-context\n""); break; } if (LocaleCompare((const char *) name,""title"") == 0) { if (*svg_info->text == '\0') break; (void) CloneString(&svg_info->title,svg_info->text); *svg_info->text='\0'; break; } break; } case 'U': case 'u': { if (LocaleCompare((char *) name,""use"") == 0) { if ((svg_info->bounds.x != 0.0) || (svg_info->bounds.y != 0.0)) (void) FormatLocaleFile(svg_info->file,""translate %g,%g\n"", svg_info->bounds.x,svg_info->bounds.y); (void) FormatLocaleFile(svg_info->file,""use \""url(%s)\""\n"", svg_info->url); (void) FormatLocaleFile(svg_info->file,""pop graphic-context\n""); break; } break; } default: break; } *svg_info->text='\0'; (void) memset(&svg_info->element,0,sizeof(svg_info->element)); (void) memset(&svg_info->segment,0,sizeof(svg_info->segment)); svg_info->n--; }
Description: In ImageMagick 7.0.8-36 Q16, there is a memory leak in the function SVGKeyValuePairs of coders/svg.c, which allows an attacker to cause a denial of service via a crafted image file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int userauth_passwd(struct ssh *ssh) { Authctxt *authctxt = (Authctxt *)ssh->authctxt; authctxt->is_trivial_auth = 0; char *password, *prompt = NULL; const char *host = options.host_key_alias ?  options.host_key_alias : authctxt->host; int r; if (authctxt->attempt_passwd++ >= options.number_of_password_prompts) return 0; if (authctxt->attempt_passwd != 1) error(""Permission denied, please try again.""); xasprintf(&prompt, ""%s@%s's password: "", authctxt->server_user, host); password = read_passphrase(prompt, 0); if ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 || (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 || (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 || (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 || (r = sshpkt_put_u8(ssh, 0)) != 0 || (r = sshpkt_put_cstring(ssh, password)) != 0 || (r = sshpkt_add_padding(ssh, 64)) != 0 || (r = sshpkt_send(ssh)) != 0) fatal_fr(r, ""send packet""); free(prompt); if (password != NULL) freezero(password, strlen(password)); ssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ, &input_userauth_passwd_changereq); return 1; }
Description: An issue was discovered in OpenSSH before 8.9. If a client is using public-key authentication with agent forwarding but without -oLogLevel=verbose, and an attacker has silently modified the server to support the None authentication option, then the user cannot determine whether FIDO authentication is going to confirm that the user wishes to connect to that server, or that the user wishes to allow that server to connect to a different server on the user's behalf. NOTE: the vendor's position is ""this is not an authentication bypass, since nothing is being bypassed.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int vcpu_destroy_pagetables(struct vcpu *v) { unsigned long mfn = pagetable_get_pfn(v->arch.guest_table); struct page_info *page; l4_pgentry_t *l4tab = NULL; int rc = put_old_guest_table(v); if ( rc ) return rc; if ( is_pv_32bit_vcpu(v) ) { l4tab = map_domain_page(_mfn(mfn)); mfn = l4e_get_pfn(*l4tab); } if ( mfn ) { page = mfn_to_page(_mfn(mfn)); if ( paging_mode_refcounts(v->domain) ) put_page(page); else rc = put_page_and_type_preemptible(page); } if ( l4tab ) { if ( !rc ) l4e_write(l4tab, l4e_empty()); unmap_domain_page(l4tab); } else if ( !rc ) { v->arch.guest_table = pagetable_null(); mfn = pagetable_get_pfn(v->arch.guest_table_user); if ( mfn ) { page = mfn_to_page(_mfn(mfn)); if ( paging_mode_refcounts(v->domain) ) put_page(page); else rc = put_page_and_type_preemptible(page); } if ( !rc ) v->arch.guest_table_user = pagetable_null(); } v->arch.cr3 = 0; return rc != -EINTR ? rc : -ERESTART; }
Description: An issue was discovered in Xen through 4.12.x allowing x86 PV guest OS users to gain host OS privileges by leveraging race conditions in pagetable promotion and demotion operations, because of an incomplete fix for CVE-2019-18421. XSA-299 addressed several critical issues in restartable PV type change operations. Despite extensive testing and auditing, some corner cases were missed. A malicious PV guest administrator may be able to escalate their privilege to that of the host. All security-supported versions of Xen are vulnerable. Only x86 systems are affected. Arm systems are not affected. Only x86 PV guests can leverage the vulnerability. x86 HVM and PVH guests cannot leverage the vulnerability. Note that these attacks require very precise timing, which may be difficult to exploit in practice.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static MagickOffsetType TIFFSeekCustomStream(const MagickOffsetType offset, const int whence,void *user_data) { PhotoshopProfile *profile; profile=(PhotoshopProfile *) user_data; switch (whence) { case SEEK_SET: default: { if (offset < 0) return(-1); profile->offset=offset; break; } case SEEK_CUR: { if ((profile->offset+offset) < 0) return(-1); profile->offset+=offset; break; } case SEEK_END: { if (((MagickOffsetType) profile->length+offset) < 0) return(-1); profile->offset=profile->length+offset; break; } } return(profile->offset); }
Description: ImageMagick before 7.0.8-50 has an integer overflow vulnerability in the function TIFFSeekCustomStream in coders/tiff.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: virtual status_t configureVideoTunnelMode( node_id node, OMX_U32 portIndex, OMX_BOOL tunneled, OMX_U32 audioHwSync, native_handle_t **sidebandHandle ) { Parcel data, reply; data.writeInterfaceToken(IOMX::getInterfaceDescriptor()); data.writeInt32((int32_t)node); data.writeInt32(portIndex); data.writeInt32((int32_t)tunneled); data.writeInt32(audioHwSync); remote()->transact(CONFIGURE_VIDEO_TUNNEL_MODE, data, &reply); status_t err = reply.readInt32(); if (sidebandHandle) { *sidebandHandle = (native_handle_t *)reply.readNativeHandle(); } return err; }
Description: media/libmedia/IOMX.cpp in mediaserver in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 does not initialize a handle pointer, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26403627.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: utils::Status NgxEspRequest::AddHeaderToBackend(const std::string &key, const std::string &value) { ngx_table_elt_t *h = nullptr; for (auto &h_in : r_->headers_in) { if (key.size() == h_in.key.len && strncasecmp(key.c_str(), reinterpret_cast<const char *>(h_in.key.data), h_in.key.len) == 0) { h = &h_in; break; } } if (h == nullptr) { h = reinterpret_cast<ngx_table_elt_t *>( ngx_list_push(&r_->headers_in.headers)); if (h == nullptr) { return utils::Status(Code::INTERNAL, ""Out of memory""); } h->lowcase_key = reinterpret_cast<u_char *>(ngx_pcalloc(r_->pool, key.size())); if (h->lowcase_key == nullptr) { return utils::Status(Code::INTERNAL, ""Out of memory""); } h->hash = ngx_hash_strlow( h->lowcase_key, reinterpret_cast<u_char *>(const_cast<char *>(key.c_str())), key.size()); } if (ngx_str_copy_from_std(r_->pool, key, &h->key) != NGX_OK || ngx_str_copy_from_std(r_->pool, value, &h->value) != NGX_OK) { return utils::Status(Code::INTERNAL, ""Out of memory""); } ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r_->connection->log, 0, ""updates header to backend: \""%V: %V\"""", &h->key, &h->value); return utils::Status::OK; }
Description: Extensible Service Proxy, a.k.a. ESP is a proxy which enables API management capabilities for JSON/REST or gRPC API services. ESPv1 can be configured to authenticate a JWT token. Its verified JWT claim is passed to the application by HTTP header ""X-Endpoint-API-UserInfo"", the application can use it to do authorization. But if there are two ""X-Endpoint-API-UserInfo"" headers from the client, ESPv1 only replaces the first one, the 2nd one will be passed to the application. An attacker can send two ""X-Endpoint-API-UserInfo"" headers, the second one with a fake JWT claim. Application may use the fake JWT claim to do the authorization. This impacts following ESPv1 usages: 1) Users have configured ESPv1 to do JWT authentication with Google ID Token as described in the referenced google endpoint document. 2) Users backend application is using the info in the ""X-Endpoint-API-UserInfo"" header to do the authorization. It has been fixed by v1.58.0. You need to patch it in the following ways: * If your docker image is using tag "":1"", needs to re-start the container to pick up the new version. The tag "":1"" will automatically point to the latest version. * If your docker image tag pings to a specific minor version, e.g. "":1.57"". You need to update it to "":1.58"" and re-start the container. There are no workaround for this issue.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void blk_mq_sched_tags_teardown(struct request_queue *q) { struct blk_mq_tag_set *set = q->tag_set; struct blk_mq_hw_ctx *hctx; int i; queue_for_each_hw_ctx(q, hctx, i) blk_mq_sched_free_tags(set, hctx, i); }
Description: The block subsystem in the Linux kernel before 5.2 has a use-after-free that can lead to arbitrary code execution in the kernel context and privilege escalation, aka CID-c3e2219216c9. This is related to blk_mq_free_rqs and blk_cleanup_queue.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: CConnection::CConnection() : csecurity(0), is(0), os(0), reader_(0), writer_(0), shared(false), state_(RFBSTATE_UNINITIALISED), useProtocol3_3(false), framebuffer(NULL), decoder(this) { security = new SecurityClient(); }
Description: In TigerVNC 1.7.1 (CConnection.cxx CConnection::CConnection), an unauthenticated client can cause a small memory leak in the server.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void CrwMap::encode0x080a(const Image&      image, const CrwMapping* pCrwMapping, CiffHeader* pHead) { assert(pCrwMapping != 0); assert(pHead != 0); const ExifKey k1(""Exif.Image.Make""); const ExifKey k2(""Exif.Image.Model""); const ExifData::const_iterator ed1 = image.exifData().findKey(k1); const ExifData::const_iterator ed2 = image.exifData().findKey(k2); const ExifData::const_iterator edEnd = image.exifData().end(); long size = 0; if (ed1 != edEnd) size += ed1->size(); if (ed2 != edEnd) size += ed2->size(); if (size != 0) { DataBuf buf(size); if (ed1 != edEnd) ed1->copy(buf.pData_, pHead->byteOrder()); if (ed2 != edEnd) ed2->copy(buf.pData_ + ed1->size(), pHead->byteOrder()); pHead->add(pCrwMapping->crwTagId_, pCrwMapping->crwDir_, buf); } else { pHead->remove(pCrwMapping->crwTagId_, pCrwMapping->crwDir_); } }
Description: Exiv2 is a command-line utility and C++ library for reading, writing, deleting, and modifying the metadata of image files. A null pointer dereference was found in Exiv2 versions v0.27.4 and earlier. The null pointer dereference is triggered when Exiv2 is used to print the metadata of a crafted image file. An attacker could potentially exploit the vulnerability to cause a denial of service, if they can trick the victim into running Exiv2 on a crafted image file. Note that this bug is only triggered when printing the interpreted (translated) data, which is a less frequently used Exiv2 operation that requires an extra command line option (`-p t` or `-P t`). The bug is fixed in version v0.27.5.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int ZipStreamBuf::readFromDevice(char* buffer, std::streamsize length) { if (!_ptrBuf) return 0; _ptrBuf->read(buffer, length); int cnt = static_cast<int>(_ptrBuf->gcount()); if (cnt > 0) { _crc32.update(buffer, cnt); } else { if (_crc32.checksum() != _expectedCrc32) { if (_checkCRC) throw ZipException(""CRC failure""); else { ZipDataInfo nfo(*_pIstr, false); Poco::Int32 size = static_cast<Poco::Int32>(nfo.getFullHeaderSize()); _expectedCrc32 = nfo.getCRC32(); const char* rawHeader = nfo.getRawHeader(); _pIstr->seekg(-size, std::ios::cur); if (!_pIstr->good()) throw Poco::IOException(""Failed to seek on input stream""); if (!crcValid()) throw ZipException(""CRC failure""); } } } return cnt; }
Description: The ZipCommon::isValidPath() function in Zip/src/ZipCommon.cpp in POCO C++ Libraries before 1.8 does not properly restrict the filename value in the ZIP header, which allows attackers to conduct absolute path traversal attacks during the ZIP decompression, and possibly create or overwrite arbitrary files, via a crafted ZIP file, related to a ""file path injection vulnerability"".
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: struct nfc_llcp_local *nfc_llcp_find_local(struct nfc_dev *dev) { struct nfc_llcp_local *local; list_for_each_entry(local, &llcp_devices, list) if (local->dev == dev) return local; pr_debug(""No device found\n""); return NULL; }
Description: A use-after-free flaw was found in nfc_llcp_find_local in net/nfc/llcp_core.c in NFC in the Linux kernel. This flaw allows a local user with special privileges to impact a kernel information leak issue.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static gint rtps_util_add_rti_service_request(proto_tree * tree, packet_info *pinfo, tvbuff_t * tvb, gint offset, const guint encoding, guint32 service_id) { switch (service_id) { case RTI_SERVICE_REQUEST_ID_TOPIC_QUERY: offset = rtps_util_add_rti_topic_query_service_request(tree, tvb, offset + 4, encoding); break; case RTI_SERVICE_REQUEST_ID_LOCATOR_REACHABILITY: offset = rtps_util_add_rti_locator_reachability_service_request(tree, pinfo, tvb, offset + 4, encoding); break; case RTI_SERVICE_REQUEST_ID_UNKNOWN: { guint32 seq_length; seq_length = tvb_get_guint32(tvb, offset, encoding); proto_tree_add_item(tree, hf_rtps_srm_request_body, tvb, offset + 4, seq_length, ENC_NA); offset += (seq_length + 4); break; } } return offset; }
Description: Excessive loops in multiple dissectors in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void tcp_data_queue_ofo(struct sock *sk, struct sk_buff *skb) { struct tcp_sock *tp = tcp_sk(sk); struct rb_node **p, *parent; struct sk_buff *skb1; u32 seq, end_seq; bool fragstolen; tcp_ecn_check_ce(sk, skb); if (unlikely(tcp_try_rmem_schedule(sk, skb, skb->truesize))) { NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFODROP); tcp_drop(sk, skb); return; } tp->pred_flags = 0; inet_csk_schedule_ack(sk); NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFOQUEUE); seq = TCP_SKB_CB(skb)->seq; end_seq = TCP_SKB_CB(skb)->end_seq; SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X\n"", tp->rcv_nxt, seq, end_seq); p = &tp->out_of_order_queue.rb_node; if (RB_EMPTY_ROOT(&tp->out_of_order_queue)) { if (tcp_is_sack(tp)) { tp->rx_opt.num_sacks = 1; tp->selective_acks[0].start_seq = seq; tp->selective_acks[0].end_seq = end_seq; } rb_link_node(&skb->rbnode, NULL, p); rb_insert_color(&skb->rbnode, &tp->out_of_order_queue); tp->ooo_last_skb = skb; goto end; } if (tcp_try_coalesce(sk, tp->ooo_last_skb, skb, &fragstolen)) { coalesce_done: tcp_grow_window(sk, skb); kfree_skb_partial(skb, fragstolen); skb = NULL; goto add_sack; } if (!before(seq, TCP_SKB_CB(tp->ooo_last_skb)->end_seq)) { parent = &tp->ooo_last_skb->rbnode; p = &parent->rb_right; goto insert; } parent = NULL; while (*p) { parent = *p; skb1 = rb_to_skb(parent); if (before(seq, TCP_SKB_CB(skb1)->seq)) { p = &parent->rb_left; continue; } if (before(seq, TCP_SKB_CB(skb1)->end_seq)) { if (!after(end_seq, TCP_SKB_CB(skb1)->end_seq)) { NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFOMERGE); __kfree_skb(skb); skb = NULL; tcp_dsack_set(sk, seq, end_seq); goto add_sack; } if (after(seq, TCP_SKB_CB(skb1)->seq)) { tcp_dsack_set(sk, seq, TCP_SKB_CB(skb1)->end_seq); } else { rb_replace_node(&skb1->rbnode, &skb->rbnode, &tp->out_of_order_queue); tcp_dsack_extend(sk, TCP_SKB_CB(skb1)->seq, TCP_SKB_CB(skb1)->end_seq); NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFOMERGE); __kfree_skb(skb1); goto merge_right; } } else if (tcp_try_coalesce(sk, skb1, skb, &fragstolen)) { goto coalesce_done; } p = &parent->rb_right; } insert: rb_link_node(&skb->rbnode, parent, p); rb_insert_color(&skb->rbnode, &tp->out_of_order_queue); merge_right: while ((skb1 = skb_rb_next(skb)) != NULL) { if (!after(end_seq, TCP_SKB_CB(skb1)->seq)) break; if (before(end_seq, TCP_SKB_CB(skb1)->end_seq)) { tcp_dsack_extend(sk, TCP_SKB_CB(skb1)->seq, end_seq); break; } rb_erase(&skb1->rbnode, &tp->out_of_order_queue); tcp_dsack_extend(sk, TCP_SKB_CB(skb1)->seq, TCP_SKB_CB(skb1)->end_seq); NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPOFOMERGE); tcp_drop(sk, skb1); } if (!skb1) tp->ooo_last_skb = skb; add_sack: if (tcp_is_sack(tp)) tcp_sack_new_ofo_skb(sk, seq, end_seq); end: if (skb) { tcp_grow_window(sk, skb); skb_condense(skb); skb_set_owner_r(skb, sk); } }
Description: Linux kernel versions 4.9+ can be forced to make very expensive calls to tcp_collapse_ofo_queue() and tcp_prune_ofo_queue() for every incoming packet which can lead to a denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static Image *ReadICONImage(const ImageInfo *image_info, ExceptionInfo *exception) { IconFile icon_file; IconInfo icon_info; Image *image; MagickBooleanType status; register ssize_t i, x; register Quantum *q; register unsigned char *p; size_t bit, byte, bytes_per_line, one, scanline_pad; ssize_t count, offset, y; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); (void) LogMagickEvent(CoderEvent,GetMagickModule(),""%s"",image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickSignature); image=AcquireImage(image_info,exception); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } icon_file.reserved=(short) ReadBlobLSBShort(image); icon_file.resource_type=(short) ReadBlobLSBShort(image); icon_file.count=(short) ReadBlobLSBShort(image); if ((icon_file.reserved != 0) || ((icon_file.resource_type != 1) && (icon_file.resource_type != 2)) || (icon_file.count > MaxIcons)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); for (i=0; i < icon_file.count; i++) { icon_file.directory[i].width=(unsigned char) ReadBlobByte(image); icon_file.directory[i].height=(unsigned char) ReadBlobByte(image); icon_file.directory[i].colors=(unsigned char) ReadBlobByte(image); icon_file.directory[i].reserved=(unsigned char) ReadBlobByte(image); icon_file.directory[i].planes=(unsigned short) ReadBlobLSBShort(image); icon_file.directory[i].bits_per_pixel=(unsigned short) ReadBlobLSBShort(image); icon_file.directory[i].size=ReadBlobLSBLong(image); icon_file.directory[i].offset=ReadBlobLSBLong(image); if (EOFBlob(image) != MagickFalse) { ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"", image->filename); break; } } one=1; for (i=0; i < icon_file.count; i++) { offset=(ssize_t) SeekBlob(image,(MagickOffsetType) icon_file.directory[i].offset,SEEK_SET); if (offset < 0) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); icon_info.size=ReadBlobLSBLong(image); icon_info.width=(unsigned char) ((int) ReadBlobLSBLong(image)); icon_info.height=(unsigned char) ((int) ReadBlobLSBLong(image)/2); icon_info.planes=ReadBlobLSBShort(image); icon_info.bits_per_pixel=ReadBlobLSBShort(image); if (EOFBlob(image) != MagickFalse) { ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"", image->filename); break; } if (((icon_info.planes == 18505) && (icon_info.bits_per_pixel == 21060)) ||  (icon_info.size == 0x474e5089)) { Image *icon_image; ImageInfo *read_info; size_t length; unsigned char *png; length=icon_file.directory[i].size; png=(unsigned char *) AcquireQuantumMemory(length+16,sizeof(*png)); if (png == (unsigned char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); (void) CopyMagickMemory(png,""\211PNG\r\n\032\n\000\000\000\015"",12); png[12]=(unsigned char) icon_info.planes; png[13]=(unsigned char) (icon_info.planes >> 8); png[14]=(unsigned char) icon_info.bits_per_pixel; png[15]=(unsigned char) (icon_info.bits_per_pixel >> 8); count=ReadBlob(image,length-16,png+16); icon_image=(Image *) NULL; if (count > 0) { read_info=CloneImageInfo(image_info); (void) CopyMagickString(read_info->magick,""PNG"",MagickPathExtent); icon_image=BlobToImage(read_info,png,length+16,exception); read_info=DestroyImageInfo(read_info); } png=(unsigned char *) RelinquishMagickMemory(png); if (icon_image == (Image *) NULL) { if (count != (ssize_t) (length-16)) ThrowReaderException(CorruptImageError, ""InsufficientImageDataInFile""); image=DestroyImageList(image); return((Image *) NULL); } DestroyBlob(icon_image); icon_image->blob=ReferenceBlob(image->blob); ReplaceImageInList(&image,icon_image); } else { if (icon_info.bits_per_pixel > 32) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); icon_info.compression=ReadBlobLSBLong(image); icon_info.image_size=ReadBlobLSBLong(image); icon_info.x_pixels=ReadBlobLSBLong(image); icon_info.y_pixels=ReadBlobLSBLong(image); icon_info.number_colors=ReadBlobLSBLong(image); icon_info.colors_important=ReadBlobLSBLong(image); image->alpha_trait=BlendPixelTrait; image->columns=(size_t) icon_file.directory[i].width; if ((ssize_t) image->columns > icon_info.width) image->columns=(size_t) icon_info.width; if (image->columns == 0) image->columns=256; image->rows=(size_t) icon_file.directory[i].height; if ((ssize_t) image->rows > icon_info.height) image->rows=(size_t) icon_info.height; if (image->rows == 0) image->rows=256; image->depth=icon_info.bits_per_pixel; if (image->debug != MagickFalse) { (void) LogMagickEvent(CoderEvent,GetMagickModule(), "" scene    = %.20g"",(double) i); (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""   size   = %.20g"",(double) icon_info.size); (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""   width  = %.20g"",(double) icon_file.directory[i].width); (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""   height = %.20g"",(double) icon_file.directory[i].height); (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""   colors = %.20g"",(double ) icon_info.number_colors); (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""   planes = %.20g"",(double) icon_info.planes); (void) LogMagickEvent(CoderEvent,GetMagickModule(), ""   bpp    = %.20g"",(double) icon_info.bits_per_pixel); } if ((icon_info.number_colors != 0) || (icon_info.bits_per_pixel <= 16U)) { image->storage_class=PseudoClass; image->colors=icon_info.number_colors; if (image->colors == 0) image->colors=one << icon_info.bits_per_pixel; } if (image->storage_class == PseudoClass) { register ssize_t i; unsigned char *icon_colormap; if (AcquireImageColormap(image,image->colors,exception) == MagickFalse) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); icon_colormap=(unsigned char *) AcquireQuantumMemory((size_t) image->colors,4UL*sizeof(*icon_colormap)); if (icon_colormap == (unsigned char *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); count=ReadBlob(image,(size_t) (4*image->colors),icon_colormap); if (count != (ssize_t) (4*image->colors)) ThrowReaderException(CorruptImageError, ""InsufficientImageDataInFile""); p=icon_colormap; for (i=0; i < (ssize_t) image->colors; i++) { image->colormap[i].blue=(Quantum) ScaleCharToQuantum(*p++); image->colormap[i].green=(Quantum) ScaleCharToQuantum(*p++); image->colormap[i].red=(Quantum) ScaleCharToQuantum(*p++); p++; } icon_colormap=(unsigned char *) RelinquishMagickMemory(icon_colormap); } if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0)) if (image->scene >= (image_info->scene+image_info->number_scenes-1)) break; status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) return(DestroyImageList(image)); bytes_per_line=(((image->columns*icon_info.bits_per_pixel)+31) & ~31) >> 3; (void) bytes_per_line; scanline_pad=((((image->columns*icon_info.bits_per_pixel)+31) & ~31)- (image->columns*icon_info.bits_per_pixel)) >> 3; switch (icon_info.bits_per_pixel) { case 1: { for (y=(ssize_t) image->rows-1; y >= 0; y--) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) (image->columns-7); x+=8) { byte=(size_t) ReadBlobByte(image); for (bit=0; bit < 8; bit++) { SetPixelIndex(image,((byte & (0x80 >> bit)) != 0 ? 0x01 : 0x00),q); q+=GetPixelChannels(image); } } if ((image->columns % 8) != 0) { byte=(size_t) ReadBlobByte(image); for (bit=0; bit < (image->columns % 8); bit++) { SetPixelIndex(image,((byte & (0x80 >> bit)) != 0 ? 0x01 : 0x00),q); q+=GetPixelChannels(image); } } for (x=0; x < (ssize_t) scanline_pad; x++) (void) ReadBlobByte(image); if (SyncAuthenticPixels(image,exception) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,image->rows-y-1, image->rows); if (status == MagickFalse) break; } } break; } case 4: { for (y=(ssize_t) image->rows-1; y >= 0; y--) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < ((ssize_t) image->columns-1); x+=2) { byte=(size_t) ReadBlobByte(image); SetPixelIndex(image,((byte >> 4) & 0xf),q); q+=GetPixelChannels(image); SetPixelIndex(image,((byte) & 0xf),q); q+=GetPixelChannels(image); } if ((image->columns % 2) != 0) { byte=(size_t) ReadBlobByte(image); SetPixelIndex(image,((byte >> 4) & 0xf),q); q+=GetPixelChannels(image); } for (x=0; x < (ssize_t) scanline_pad; x++) (void) ReadBlobByte(image); if (SyncAuthenticPixels(image,exception) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,image->rows-y-1, image->rows); if (status == MagickFalse) break; } } break; } case 8: { for (y=(ssize_t) image->rows-1; y >= 0; y--) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { byte=(size_t) ReadBlobByte(image); SetPixelIndex(image,byte,q); q+=GetPixelChannels(image); } for (x=0; x < (ssize_t) scanline_pad; x++) (void) ReadBlobByte(image); if (SyncAuthenticPixels(image,exception) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,image->rows-y-1, image->rows); if (status == MagickFalse) break; } } break; } case 16: { for (y=(ssize_t) image->rows-1; y >= 0; y--) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { byte=(size_t) ReadBlobByte(image); byte|=(size_t) (ReadBlobByte(image) << 8); SetPixelIndex(image,byte,q); q+=GetPixelChannels(image); } for (x=0; x < (ssize_t) scanline_pad; x++) (void) ReadBlobByte(image); if (SyncAuthenticPixels(image,exception) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,image->rows-y-1, image->rows); if (status == MagickFalse) break; } } break; } case 24: case 32: { for (y=(ssize_t) image->rows-1; y >= 0; y--) { q=QueueAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { SetPixelBlue(image,ScaleCharToQuantum((unsigned char) ReadBlobByte(image)),q); SetPixelGreen(image,ScaleCharToQuantum((unsigned char) ReadBlobByte(image)),q); SetPixelRed(image,ScaleCharToQuantum((unsigned char) ReadBlobByte(image)),q); if (icon_info.bits_per_pixel == 32) SetPixelAlpha(image,ScaleCharToQuantum((unsigned char) ReadBlobByte(image)),q); q+=GetPixelChannels(image); } if (icon_info.bits_per_pixel == 24) for (x=0; x < (ssize_t) scanline_pad; x++) (void) ReadBlobByte(image); if (SyncAuthenticPixels(image,exception) == MagickFalse) break; if (image->previous == (Image *) NULL) { status=SetImageProgress(image,LoadImageTag,image->rows-y-1, image->rows); if (status == MagickFalse) break; } } break; } default: ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } if (image_info->ping == MagickFalse) (void) SyncImage(image,exception); if (icon_info.bits_per_pixel != 32) { image->storage_class=DirectClass; for (y=(ssize_t) image->rows-1; y >= 0; y--) { q=GetAuthenticPixels(image,0,y,image->columns,1,exception); if (q == (Quantum *) NULL) break; for (x=0; x < ((ssize_t) image->columns-7); x+=8) { byte=(size_t) ReadBlobByte(image); for (bit=0; bit < 8; bit++) { SetPixelAlpha(image,(((byte & (0x80 >> bit)) != 0) ? TransparentAlpha : OpaqueAlpha),q); q+=GetPixelChannels(image); } } if ((image->columns % 8) != 0) { byte=(size_t) ReadBlobByte(image); for (bit=0; bit < (image->columns % 8); bit++) { SetPixelAlpha(image,(((byte & (0x80 >> bit)) != 0) ? TransparentAlpha : OpaqueAlpha),q); q+=GetPixelChannels(image); } } if ((image->columns % 32) != 0) for (x=0; x < (ssize_t) ((32-(image->columns % 32))/8); x++) (void) ReadBlobByte(image); if (SyncAuthenticPixels(image,exception) == MagickFalse) break; } } if (EOFBlob(image) != MagickFalse) { ThrowFileException(exception,CorruptImageError, ""UnexpectedEndOfFile"",image->filename); break; } } if (image_info->number_scenes != 0) if (image->scene >= (image_info->scene+image_info->number_scenes-1)) break; if (i < (ssize_t) (icon_file.count-1)) { AcquireNextImage(image_info,image,exception); if (GetNextImageInList(image) == (Image *) NULL) { image=DestroyImageList(image); return((Image *) NULL); } image=SyncNextImageInList(image); status=SetImageProgress(image,LoadImagesTag,TellBlob(image), GetBlobSize(image)); if (status == MagickFalse) break; } } (void) CloseBlob(image); return(GetFirstImageInList(image)); }
Description: Integer overflow in coders/icon.c in ImageMagick 6.9.1-3 and later allows remote attackers to cause a denial of service (application crash) via a crafted length value, which triggers a buffer overflow.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void save_request(packet_info *pinfo, guint8 opcode, union request_parameters_union parameters, bluetooth_data_t *bluetooth_data) { wmem_tree_key_t  key[4]; guint32          frame_number; request_data_t  *request_data; frame_number = pinfo->num; key[0].length = 1; key[0].key    = &bluetooth_data->interface_id; key[1].length = 1; key[1].key    = &bluetooth_data->adapter_id; key[2].length = 1; key[2].key    = &frame_number; key[3].length = 0; key[3].key    = NULL; request_data = wmem_new(wmem_file_scope(), request_data_t); request_data->opcode = opcode; request_data->request_in_frame = frame_number; request_data->response_in_frame = 0; request_data->parameters = parameters; wmem_tree_insert32_array(requests, key, request_data); }
Description: In Wireshark 2.4.0 to 2.4.1 and 2.2.0 to 2.2.9, the BT ATT dissector could crash. This was addressed in epan/dissectors/packet-btatt.c by considering a case where not all of the BTATT packets have the same encapsulation level.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static struct net *get_target_net(struct sk_buff *skb, int netnsid) { struct net *net; net = get_net_ns_by_id(sock_net(skb->sk), netnsid); if (!net) return ERR_PTR(-EINVAL); if (!netlink_ns_capable(skb, net->user_ns, CAP_NET_ADMIN)) { put_net(net); return ERR_PTR(-EACCES); } return net; }
Description: The Linux kernel before 4.15-rc8 was found to be vulnerable to a NULL pointer dereference bug in the __netlink_ns_capable() function in the net/netlink/af_netlink.c file. A local attacker could exploit this when a net namespace with a netnsid is assigned to cause a kernel panic and a denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int sfq_change(struct Qdisc *sch, struct nlattr *opt) { struct sfq_sched_data *q = qdisc_priv(sch); struct tc_sfq_qopt *ctl = nla_data(opt); struct tc_sfq_qopt_v1 *ctl_v1 = NULL; unsigned int qlen, dropped = 0; struct red_parms *p = NULL; struct sk_buff *to_free = NULL; struct sk_buff *tail = NULL; if (opt->nla_len < nla_attr_size(sizeof(*ctl))) return -EINVAL; if (opt->nla_len >= nla_attr_size(sizeof(*ctl_v1))) ctl_v1 = nla_data(opt); if (ctl->divisor && (!is_power_of_2(ctl->divisor) || ctl->divisor > 65536)) return -EINVAL; if (ctl_v1 && !red_check_params(ctl_v1->qth_min, ctl_v1->qth_max, ctl_v1->Wlog)) return -EINVAL; if (ctl_v1 && ctl_v1->qth_min) { p = kmalloc(sizeof(*p), GFP_KERNEL); if (!p) return -ENOMEM; } sch_tree_lock(sch); if (ctl->quantum) { q->quantum = ctl->quantum; q->scaled_quantum = SFQ_ALLOT_SIZE(q->quantum); } q->perturb_period = ctl->perturb_period * HZ; if (ctl->flows) q->maxflows = min_t(u32, ctl->flows, SFQ_MAX_FLOWS); if (ctl->divisor) { q->divisor = ctl->divisor; q->maxflows = min_t(u32, q->maxflows, q->divisor); } if (ctl_v1) { if (ctl_v1->depth) q->maxdepth = min_t(u32, ctl_v1->depth, SFQ_MAX_DEPTH); if (p) { swap(q->red_parms, p); red_set_parms(q->red_parms, ctl_v1->qth_min, ctl_v1->qth_max, ctl_v1->Wlog, ctl_v1->Plog, ctl_v1->Scell_log, NULL, ctl_v1->max_P); } q->flags = ctl_v1->flags; q->headdrop = ctl_v1->headdrop; } if (ctl->limit) { q->limit = min_t(u32, ctl->limit, q->maxdepth * q->maxflows); q->maxflows = min_t(u32, q->maxflows, q->limit); } qlen = sch->q.qlen; while (sch->q.qlen > q->limit) { dropped += sfq_drop(sch, &to_free); if (!tail) tail = to_free; } rtnl_kfree_skbs(to_free, tail); qdisc_tree_reduce_backlog(sch, qlen - sch->q.qlen, dropped); del_timer(&q->perturb_timer); if (q->perturb_period) { mod_timer(&q->perturb_timer, jiffies + q->perturb_period); q->perturbation = prandom_u32(); } sch_tree_unlock(sch); kfree(p); return 0; }
Description: The flow_dissector feature in the Linux kernel 4.3 through 5.x before 5.3.10 has a device tracking vulnerability, aka CID-55667441c84f. This occurs because the auto flowlabel of a UDP IPv6 packet relies on a 32-bit hashrnd value as a secret, and because jhash (instead of siphash) is used. The hashrnd value remains the same starting from boot time, and can be inferred by an attacker. This affects net/core/flow_dissector.c and related code.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Result WastParser::ParseCodeMetadataAnnotation(ExprList* exprs) { WABT_TRACE(ParseCodeMetadataAnnotation); Token tk = Consume(); std::string_view name = tk.text(); name.remove_prefix(sizeof(""metadata.code."") - 1); std::string data_text; CHECK_RESULT(ParseQuotedText(&data_text, false)); std::vector<uint8_t> data(data_text.begin(), data_text.end()); exprs->push_back(std::make_unique<CodeMetadataExpr>(name, std::move(data))); TokenType rpar = Peek(); WABT_USE(rpar); assert(rpar == TokenType::Rpar); Consume(); return Result::Ok; }
Description: WebAssembly wat2wasm v1.0.32 allows attackers to cause a libc++abi.dylib crash by putting '@' before a quote ("").
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void vwid_box_del(GF_Box *s) { u32 i; GF_ViewIdentifierBox *ptr = (GF_ViewIdentifierBox *) s; if (ptr->num_views) { for (i=0; i<ptr->num_views; i++) { if (ptr->views[i].view_refs) gf_free(ptr->views[i].view_refs); } gf_free(ptr->views); } gf_free(ptr); }
Description: An issue was discovered in gpac through 20200801. A NULL pointer dereference exists in the function vwid_box_del located in box_code_base.c. It allows an attacker to cause Denial of Service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int on_message_begin(http_parser* self_) { HTTPParser* self = static_cast<HTTPParser*>(self_); self->clear(); return 0; }
Description: HTTP applications (servers) based on Crow through 1.0+4 may allow a Use-After-Free and code execution when HTTP pipelining is used. The HTTP parser supports HTTP pipelining, but the asynchronous Connection layer is unaware of HTTP pipelining. Specifically, the Connection layer is unaware that it has begun processing a later request before it has finished processing an earlier request.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: IByteReader*  DecryptionHelper::CreateDecryptionFilterForStream(PDFStreamInput* inStream, IByteReader* inToWrapStream, const std::string& inCryptName) { if (!IsEncrypted() || !CanDecryptDocument()) return inToWrapStream; void* savedEcnryptionKey = inStream->GetMetadata(scEcnryptionKeyMetadataKey); if (!savedEcnryptionKey) { return inToWrapStream; } XCryptionCommon* xcryption = GetFilterForName(mXcrypts, inCryptName); if (xcryption && savedEcnryptionKey) { return CreateDecryptionReader(inToWrapStream, *((ByteList*)savedEcnryptionKey), xcryption->IsUsingAES()); } else return inToWrapStream; }
Description: The package muhammara before 2.6.1, from 3.0.0 and before 3.1.1; all versions of package hummus are vulnerable to Denial of Service (DoS) when supplied with a maliciously crafted PDF file to be parsed.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int ocsp_verify_signer(X509 *signer, int response, X509_STORE *st, unsigned long flags, STACK_OF(X509) *untrusted, STACK_OF(X509) **chain) { X509_STORE_CTX *ctx = X509_STORE_CTX_new(); X509_VERIFY_PARAM *vp; int ret = -1; if (ctx == NULL) { ERR_raise(ERR_LIB_OCSP, ERR_R_MALLOC_FAILURE); goto end; } if (!X509_STORE_CTX_init(ctx, st, signer, untrusted)) { ERR_raise(ERR_LIB_OCSP, ERR_R_X509_LIB); goto end; } if ((vp = X509_STORE_CTX_get0_param(ctx)) == NULL) goto end; if ((flags & OCSP_PARTIAL_CHAIN) != 0) X509_VERIFY_PARAM_set_flags(vp, X509_V_FLAG_PARTIAL_CHAIN); if (response && X509_get_ext_by_NID(signer, NID_id_pkix_OCSP_noCheck, -1) >= 0) X509_VERIFY_PARAM_clear_flags(vp, X509_V_FLAG_CRL_CHECK); X509_STORE_CTX_set_purpose(ctx, X509_PURPOSE_OCSP_HELPER); X509_STORE_CTX_set_trust(ctx, X509_TRUST_OCSP_REQUEST); ret = X509_verify_cert(ctx); if (ret <= 0) { ret = X509_STORE_CTX_get_error(ctx); ERR_raise_data(ERR_LIB_OCSP, OCSP_R_CERTIFICATE_VERIFY_ERROR, ""Verify error: %s"", X509_verify_cert_error_string(ret)); goto end; } if (chain != NULL) *chain = X509_STORE_CTX_get1_chain(ctx); end: X509_STORE_CTX_free(ctx); return ret; }
Description: The function `OCSP_basic_verify` verifies the signer certificate on an OCSP response. In the case where the (non-default) flag OCSP_NOCHECKS is used then the response will be positive (meaning a successful verification) even in the case where the response signing certificate fails to verify. It is anticipated that most users of `OCSP_basic_verify` will not use the OCSP_NOCHECKS flag. In this case the `OCSP_basic_verify` function will return a negative value (indicating a fatal error) in the case of a certificate verification failure. The normal expected return value in this case would be 0. This issue also impacts the command line OpenSSL ""ocsp"" application. When verifying an ocsp response with the ""-no_cert_checks"" option the command line application will report that the verification is successful even though it has in fact failed. In this case the incorrect successful response will also be accompanied by error messages showing the failure and contradicting the apparently successful result. Fixed in OpenSSL 3.0.3 (Affected 3.0.0,3.0.1,3.0.2).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int epsc_print_page(gx_device_printer * pdev, gp_file * prn_stream) { static int graphics_modes_9[5] = { -1, 0  , 1  , -1, DD + 3   }; static int graphics_modes_24[7] = { -1, 32  , 33  , 39  , -1, -1, DD + 40          }; int y_24pin = pdev->y_pixels_per_inch > 72; int y_mult = (y_24pin ? 3 : 1); int line_size = (pdev->width + 7) >> 3;      int in_size = line_size * (8 * y_mult); byte *in = (byte *) gs_malloc(pdev->memory, in_size + 1, 1, ""epsc_print_page(in)""); int out_size = ((pdev->width + 7) & -8) * y_mult; byte *out = (byte *) gs_malloc(pdev->memory, out_size + 1, 1, ""epsc_print_page(out)""); int x_dpi = (int)pdev->x_pixels_per_inch; char start_graphics = (char) ((y_24pin ? graphics_modes_24 : graphics_modes_9)[x_dpi / 60]); int first_pass = (start_graphics & DD ? 1 : 0); int last_pass = first_pass * 2; int dots_per_space = x_dpi / 10;     int bytes_per_space = dots_per_space * y_mult; int skip = 0, lnum = 0, pass; byte *color_in; int color_line_size, color_in_size; int spare_bits = (pdev->width % 8);  int whole_bits = pdev->width - spare_bits; if (in == 0 || out == 0) { if (in) gs_free(pdev->memory, (char *)in, in_size + 1, 1, ""epsc_print_page(in)""); if (out) gs_free(pdev->memory, (char *)out, out_size + 1, 1, ""epsc_print_page(out)""); return -1; } gp_fwrite(""\033@\033P\033l\000\033Q\377\033U\001\r"", 1, 14, prn_stream); if (gx_device_has_color(pdev)) { color_line_size = gdev_mem_bytes_per_scan_line((gx_device *) pdev); color_in_size = color_line_size * (8 * y_mult); if ((color_in = (byte *) gs_malloc(pdev->memory, color_in_size + 1, 1, ""epsc_print_page(color)"")) == 0) { gs_free(pdev->memory, (char *)in, in_size + 1, 1, ""epsc_print_page(in)""); gs_free(pdev->memory, (char *)out, out_size + 1, 1, ""epsc_print_page(out)""); return (-1); } } else { color_in = in; color_in_size = in_size; color_line_size = line_size; } while (lnum < pdev->height) { int lcnt; byte *nextcolor = NULL;  byte *nextmono = NULL;   gdev_prn_copy_scan_lines(pdev, lnum, color_in, color_line_size); if (color_in[0] == 0 && !memcmp((char *)color_in, (char *)color_in + 1, color_line_size - 1) ) { lnum++; skip += 3 / y_mult; continue; } while (skip > 255) { gp_fputs(""\033J\377"", prn_stream); skip -= 255; } if (skip) gp_fprintf(prn_stream, ""\033J%c"", skip); lcnt = 1 + gdev_prn_copy_scan_lines(pdev, lnum + 1, color_in + color_line_size, color_in_size - color_line_size); if (lcnt < 8 * y_mult) { memset((char *)(color_in + lcnt * color_line_size), 0, color_in_size - lcnt * color_line_size); if (gx_device_has_color(pdev))       memset((char *)(in + lcnt * line_size), 0, in_size - lcnt * line_size); } do { byte *inp = in; byte *in_end = in + line_size; byte *out_end = out; byte *out_blk; register byte *outp; if (gx_device_has_color(pdev)) { register int i, j; register byte *outbuf, *realbuf; byte current_color; int end_next_bits = whole_bits; int lastbits; if (nextcolor) { realbuf = nextcolor; outbuf = nextmono; memset((char *)in, 0, (nextmono - in)); i = nextcolor - color_in; nextcolor = NULL; end_next_bits = (i / color_line_size) * color_line_size + whole_bits; } else { i = 0; realbuf = color_in; outbuf = in; nextcolor = NULL; } for (current_color = 0; i <= color_in_size && outbuf < in + in_size; outbuf++) { if (spare_bits && i == end_next_bits) { end_next_bits = whole_bits + i + spare_bits; lastbits = 8 - spare_bits; } else lastbits = 0; for (*outbuf = 0, j = 8; --j >= lastbits && i <= color_in_size; realbuf++, i++) { if (*realbuf) { if (current_color > 0) { if (*realbuf == current_color) { *outbuf |= 1 << j; *realbuf = 0;        } else if (nextcolor == NULL) { nextcolor = realbuf - (7 - j); nextmono = outbuf; } } else { *outbuf |= 1 << j; current_color = *realbuf;        *realbuf = 0; } } } } *outbuf = 0;     if (current_color) gp_fprintf(prn_stream, ""\033r%c"", current_color ^ 7); } if (y_24pin) { for (; inp < in_end; inp++, out_end += 24) { gdev_prn_transpose_8x8(inp, line_size, out_end, 3); gdev_prn_transpose_8x8(inp + line_size * 8, line_size, out_end + 1, 3); gdev_prn_transpose_8x8(inp + line_size * 16, line_size, out_end + 2, 3); } while (out_end > out && out_end[-1] == 0 && out_end[-2] == 0 && out_end[-3] == 0) out_end -= 3; } else { for (; inp < in_end; inp++, out_end += 8) { gdev_prn_transpose_8x8(inp, line_size, out_end, 1); } while (out_end > out && out_end[-1] == 0) out_end--; } for (pass = first_pass; pass <= last_pass; pass++) { for (out_blk = outp = out; outp < out_end;) {    if (*outp == 0 && outp + 12 <= out_end && outp[1] == 0 && outp[2] == 0 && (outp[3] | outp[4] | outp[5]) == 0 && (outp[6] | outp[7] | outp[8]) == 0 && (outp[9] | outp[10] | outp[11]) == 0) { byte *zp = outp; int tpos; byte *newp; outp += 12; while (outp + 3 <= out_end && *outp == 0 && outp[1] == 0 && outp[2] == 0) outp += 3; tpos = (outp - out) / bytes_per_space; newp = out + tpos * bytes_per_space; if (newp > zp + 10) {    if (zp > out_blk) epsc_output_run(out_blk, (int)(zp - out_blk), y_mult, start_graphics, prn_stream, pass); gp_fprintf(prn_stream, ""\033D%c%c\t"", tpos, 0); out_blk = outp = newp; } } else outp += y_mult; } if (outp > out_blk) epsc_output_run(out_blk, (int)(outp - out_blk), y_mult, start_graphics, prn_stream, pass); gp_fputc('\r', prn_stream); } } while (nextcolor); skip = 24; lnum += 8 * y_mult; } gp_fputs(""\f\033@"", prn_stream); gs_free(pdev->memory, (char *)out, out_size + 1, 1, ""epsc_print_page(out)""); gs_free(pdev->memory, (char *)in, in_size + 1, 1, ""epsc_print_page(in)""); if (gx_device_has_color(pdev)) gs_free(pdev->memory, (char *)color_in, color_in_size + 1, 1, ""epsc_print_page(rin)""); return 0; }
Description: A buffer overflow vulnerability in epsc_print_page() in devices/gdevepsc.c of Artifex Software GhostScript v9.50 allows a remote attacker to cause a denial of service via a crafted PDF file. This is fixed in v9.51.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool FrameFetchContext::canRequest(Resource::Type type, const ResourceRequest& resourceRequest, const KURL& url, const ResourceLoaderOptions& options, bool forPreload, FetchRequest::OriginRestriction originRestriction) const { ResourceRequestBlockedReason reason = canRequestInternal(type, resourceRequest, url, options, forPreload, originRestriction); if (reason != ResourceRequestBlockedReasonNone) { if (!forPreload) InspectorInstrumentation::didBlockRequest(frame(), resourceRequest, ensureLoaderForNotifications(), options.initiatorInfo, reason); return false; } return true; }
Description: The Content Security Policy (CSP) implementation in Blink, as used in Google Chrome before 49.0.2623.75, does not ignore a URL's path component in the case of a ServiceWorker fetch, which allows remote attackers to obtain sensitive information about visited web pages by reading CSP violation reports, related to FrameFetchContext.cpp and ResourceFetcher.cpp.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void mpa_exp_mod(mpanum dest, const mpanum op1, const mpanum op2, const mpanum n, const mpanum r_modn, const mpanum r2_modn, const mpa_word_t n_inv, mpa_scratch_mem pool) { mpanum A; mpanum B; mpanum xtilde; mpanum *ptr_a; mpanum *ptr_b; mpanum *swapper; int idx; mpa_alloc_static_temp_var(&A, pool); mpa_alloc_static_temp_var(&B, pool); mpa_alloc_static_temp_var(&xtilde, pool); __mpa_montgomery_mul(xtilde, op1, r2_modn, n, n_inv); mpa_copy(A, r_modn); ptr_a = &A; ptr_b = &B; __mpa_set_unused_digits_to_zero(A); __mpa_set_unused_digits_to_zero(B); for (idx = mpa_highest_bit_index(op2); idx >= 0; idx--) { __mpa_montgomery_mul(*ptr_b, *ptr_a, *ptr_a, n, n_inv); if (mpa_get_bit(op2, idx) == 1) { __mpa_montgomery_mul(*ptr_a, *ptr_b, xtilde, n, n_inv); } else { swapper = ptr_a; ptr_a = ptr_b; ptr_b = swapper; } } __mpa_montgomery_mul(*ptr_b, (const mpanum)&const_one, *ptr_a, n, n_inv); mpa_copy(dest, *ptr_b); mpa_free_static_temp_var(&A, pool); mpa_free_static_temp_var(&B, pool); mpa_free_static_temp_var(&xtilde, pool); }
Description: Linaro's open source TEE solution called OP-TEE, version 2.4.0 (and older) is vulnerable to the bellcore attack in the LibTomCrypt code resulting in compromised private RSA key.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int fuse_readdir(struct file *file, struct dir_context *ctx) { struct fuse_file *ff = file->private_data; struct inode *inode = file_inode(file); int err; if (is_bad_inode(inode)) return -EIO; mutex_lock(&ff->readdir.lock); err = UNCACHED; if (ff->open_flags & FOPEN_CACHE_DIR) err = fuse_readdir_cached(file, ctx); if (err == UNCACHED) err = fuse_readdir_uncached(file, ctx); mutex_unlock(&ff->readdir.lock); return err; }
Description: An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int __ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc, int in_mem) { struct ext4_group_desc*gdp; struct buffer_head*bh; struct super_block*sb = inode->i_sb; ext4_fsblk_tblock; intinodes_per_block, inode_offset; iloc->bh = NULL; if (!ext4_valid_inum(sb, inode->i_ino)) return -EFSCORRUPTED; iloc->block_group = (inode->i_ino - 1) / EXT4_INODES_PER_GROUP(sb); gdp = ext4_get_group_desc(sb, iloc->block_group, NULL); if (!gdp) return -EIO; inodes_per_block = EXT4_SB(sb)->s_inodes_per_block; inode_offset = ((inode->i_ino - 1) % EXT4_INODES_PER_GROUP(sb)); block = ext4_inode_table(sb, gdp) + (inode_offset / inodes_per_block); iloc->offset = (inode_offset % inodes_per_block) * EXT4_INODE_SIZE(sb); bh = sb_getblk(sb, block); if (unlikely(!bh)) return -ENOMEM; if (!buffer_uptodate(bh)) { lock_buffer(bh); if (buffer_write_io_error(bh) && !buffer_uptodate(bh)) set_buffer_uptodate(bh); if (buffer_uptodate(bh)) { unlock_buffer(bh); goto has_buffer; } if (in_mem) { struct buffer_head *bitmap_bh; int i, start; start = inode_offset & ~(inodes_per_block - 1); bitmap_bh = sb_getblk(sb, ext4_inode_bitmap(sb, gdp)); if (unlikely(!bitmap_bh)) goto make_io; if (!buffer_uptodate(bitmap_bh)) { brelse(bitmap_bh); goto make_io; } for (i = start; i < start + inodes_per_block; i++) { if (i == inode_offset) continue; if (ext4_test_bit(i, bitmap_bh->b_data)) break; } brelse(bitmap_bh); if (i == start + inodes_per_block) { memset(bh->b_data, 0, bh->b_size); set_buffer_uptodate(bh); unlock_buffer(bh); goto has_buffer; } } make_io: if (EXT4_SB(sb)->s_inode_readahead_blks) { ext4_fsblk_t b, end, table; unsigned num; __u32 ra_blks = EXT4_SB(sb)->s_inode_readahead_blks; table = ext4_inode_table(sb, gdp); b = block & ~((ext4_fsblk_t) ra_blks - 1); if (table > b) b = table; end = b + ra_blks; num = EXT4_INODES_PER_GROUP(sb); if (ext4_has_group_desc_csum(sb)) num -= ext4_itable_unused_count(sb, gdp); table += num / inodes_per_block; if (end > table) end = table; while (b <= end) sb_breadahead(sb, b++); } trace_ext4_load_inode(inode); get_bh(bh); bh->b_end_io = end_buffer_read_sync; submit_bh(REQ_OP_READ, REQ_META | REQ_PRIO, bh); wait_on_buffer(bh); if (!buffer_uptodate(bh)) { EXT4_ERROR_INODE_BLOCK(inode, block, ""unable to read itable block""); brelse(bh); return -EIO; } } has_buffer: iloc->bh = bh; return 0; }
Description: A flaw was found in the Linux kernel's ext4 filesystem. A local user can cause an out-of-bound write in in fs/jbd2/transaction.c code, a denial of service, and a system crash by unmounting a crafted ext4 filesystem image.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int conn_activate_ssl(int server_role) { gnutls_alert_description_t alrt; char *ssl_keyfile; char *ssl_certfile; int err; if (csync_conn_usessl) return 0; ASPRINTF(&ssl_keyfile, ""%s/csync2_ssl_key.pem"", systemdir); ASPRINTF(&ssl_certfile, ""%s/csync2_ssl_cert.pem"", systemdir); gnutls_global_init(); gnutls_global_set_log_function(ssl_log); gnutls_global_set_log_level(10); gnutls_certificate_allocate_credentials(&conn_x509_cred); err = gnutls_certificate_set_x509_key_file(conn_x509_cred, ssl_certfile, ssl_keyfile, GNUTLS_X509_FMT_PEM); if(err != GNUTLS_E_SUCCESS) { gnutls_certificate_free_credentials(conn_x509_cred); gnutls_global_deinit(); csync_fatal( ""SSL: failed to use key file %s and/or certificate file %s: %s (%s)\n"", ssl_keyfile, ssl_certfile, gnutls_strerror(err), gnutls_strerror_name(err) ); } if(server_role) { gnutls_certificate_free_cas(conn_x509_cred); if(gnutls_certificate_set_x509_trust_file(conn_x509_cred, ssl_certfile, GNUTLS_X509_FMT_PEM) < 1) { gnutls_certificate_free_credentials(conn_x509_cred); gnutls_global_deinit(); csync_fatal( ""SSL: failed to use certificate file %s as CA.\n"", ssl_certfile ); } } else gnutls_certificate_free_ca_names(conn_x509_cred); gnutls_init(&conn_tls_session, (server_role ? GNUTLS_SERVER : GNUTLS_CLIENT)); gnutls_priority_set_direct(conn_tls_session, ""PERFORMANCE"", NULL); gnutls_credentials_set(conn_tls_session, GNUTLS_CRD_CERTIFICATE, conn_x509_cred); if(server_role) { gnutls_certificate_send_x509_rdn_sequence(conn_tls_session, 0); gnutls_certificate_server_set_request(conn_tls_session, GNUTLS_CERT_REQUIRE); } gnutls_transport_set_ptr2( conn_tls_session, (gnutls_transport_ptr_t)(long)conn_fd_in, (gnutls_transport_ptr_t)(long)conn_fd_out ); err = gnutls_handshake(conn_tls_session); switch(err) { case GNUTLS_E_SUCCESS: break; case GNUTLS_E_WARNING_ALERT_RECEIVED: alrt = gnutls_alert_get(conn_tls_session); fprintf( csync_debug_out, ""SSL: warning alert received from peer: %d (%s).\n"", alrt, gnutls_alert_get_name(alrt) ); break; case GNUTLS_E_FATAL_ALERT_RECEIVED: alrt = gnutls_alert_get(conn_tls_session); fprintf( csync_debug_out, ""SSL: fatal alert received from peer: %d (%s).\n"", alrt, gnutls_alert_get_name(alrt) ); default: gnutls_bye(conn_tls_session, GNUTLS_SHUT_RDWR); gnutls_deinit(conn_tls_session); gnutls_certificate_free_credentials(conn_x509_cred); gnutls_global_deinit(); csync_fatal( ""SSL: handshake failed: %s (%s)\n"", gnutls_strerror(err), gnutls_strerror_name(err) ); } csync_conn_usessl = 1; return 0; }
Description: An issue was discovered in LINBIT csync2 through 2.0. It does not correctly check for the return value GNUTLS_E_WARNING_ALERT_RECEIVED of the gnutls_handshake() function. It neglects to call this function again, as required by the design of the API.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static bfd_boolean scan_unit_for_symbols (struct comp_unit *unit) { bfd *abfd = unit->abfd; bfd_byte *info_ptr = unit->first_child_die_ptr; bfd_byte *info_ptr_end = unit->stash->info_ptr_end; int nesting_level = 0; struct nest_funcinfo { struct funcinfo *func; } *nested_funcs; int nested_funcs_size; nested_funcs_size = 32; nested_funcs = (struct nest_funcinfo *) bfd_malloc (nested_funcs_size * sizeof (*nested_funcs)); if (nested_funcs == NULL) return FALSE; nested_funcs[nesting_level].func = 0; while (nesting_level >= 0) { unsigned int abbrev_number, bytes_read, i; struct abbrev_info *abbrev; struct attribute attr; struct funcinfo *func; struct varinfo *var; bfd_vma low_pc = 0; bfd_vma high_pc = 0; bfd_boolean high_pc_relative = FALSE; if (info_ptr >= info_ptr_end) goto fail; abbrev_number = _bfd_safe_read_leb128 (abfd, info_ptr, &bytes_read, FALSE, info_ptr_end); info_ptr += bytes_read; if (! abbrev_number) { nesting_level--; continue; } abbrev = lookup_abbrev (abbrev_number, unit->abbrevs); if (! abbrev) { static unsigned int previous_failed_abbrev = -1U; if (abbrev_number != previous_failed_abbrev) { _bfd_error_handler (_(""Dwarf Error: Could not find abbrev number %u.""), abbrev_number); previous_failed_abbrev = abbrev_number; } bfd_set_error (bfd_error_bad_value); goto fail; } var = NULL; if (abbrev->tag == DW_TAG_subprogram || abbrev->tag == DW_TAG_entry_point || abbrev->tag == DW_TAG_inlined_subroutine) { bfd_size_type amt = sizeof (struct funcinfo); func = (struct funcinfo *) bfd_zalloc (abfd, amt); if (func == NULL) goto fail; func->tag = abbrev->tag; func->prev_func = unit->function_table; unit->function_table = func; unit->number_of_functions++; BFD_ASSERT (!unit->cached); if (func->tag == DW_TAG_inlined_subroutine) for (i = nesting_level; i-- != 0; ) if (nested_funcs[i].func) { func->caller_func = nested_funcs[i].func; break; } nested_funcs[nesting_level].func = func; } else { func = NULL; if (abbrev->tag == DW_TAG_variable) { bfd_size_type amt = sizeof (struct varinfo); var = (struct varinfo *) bfd_zalloc (abfd, amt); if (var == NULL) goto fail; var->tag = abbrev->tag; var->stack = 1; var->prev_var = unit->variable_table; unit->variable_table = var; } nested_funcs[nesting_level].func = 0; } for (i = 0; i < abbrev->num_attrs; ++i) { info_ptr = read_attribute (&attr, &abbrev->attrs[i], unit, info_ptr, info_ptr_end); if (info_ptr == NULL) goto fail; if (func) { switch (attr.name) { case DW_AT_call_file: func->caller_file = concat_filename (unit->line_table, attr.u.val); break; case DW_AT_call_line: func->caller_line = attr.u.val; break; case DW_AT_abstract_origin: case DW_AT_specification: if (!find_abstract_instance_name (unit, info_ptr, &attr, &func->name, &func->is_linkage)) goto fail; break; case DW_AT_name: if (func->name == NULL && is_str_attr (attr.form)) { func->name = attr.u.str; if (non_mangled (unit->lang)) func->is_linkage = TRUE; } break; case DW_AT_linkage_name: case DW_AT_MIPS_linkage_name: if (is_str_attr (attr.form)) { func->name = attr.u.str; func->is_linkage = TRUE; } break; case DW_AT_low_pc: low_pc = attr.u.val; break; case DW_AT_high_pc: high_pc = attr.u.val; high_pc_relative = attr.form != DW_FORM_addr; break; case DW_AT_ranges: if (!read_rangelist (unit, &func->arange, attr.u.val)) goto fail; break; case DW_AT_decl_file: func->file = concat_filename (unit->line_table, attr.u.val); break; case DW_AT_decl_line: func->line = attr.u.val; break; default: break; } } else if (var) { switch (attr.name) { case DW_AT_name: var->name = attr.u.str; break; case DW_AT_decl_file: var->file = concat_filename (unit->line_table, attr.u.val); break; case DW_AT_decl_line: var->line = attr.u.val; break; case DW_AT_external: if (attr.u.val != 0) var->stack = 0; break; case DW_AT_location: switch (attr.form) { case DW_FORM_block: case DW_FORM_block1: case DW_FORM_block2: case DW_FORM_block4: case DW_FORM_exprloc: if (attr.u.blk->data != NULL && *attr.u.blk->data == DW_OP_addr) { var->stack = 0; if (attr.u.blk->size == unit->addr_size + 1U) var->addr = bfd_get (unit->addr_size * 8, unit->abfd, attr.u.blk->data + 1); } break; default: break; } break; default: break; } } } if (high_pc_relative) high_pc += low_pc; if (func && high_pc != 0) { if (!arange_add (unit, &func->arange, low_pc, high_pc)) goto fail; } if (abbrev->has_children) { nesting_level++; if (nesting_level >= nested_funcs_size) { struct nest_funcinfo *tmp; nested_funcs_size *= 2; tmp = (struct nest_funcinfo *) bfd_realloc (nested_funcs, nested_funcs_size * sizeof (*nested_funcs)); if (tmp == NULL) goto fail; nested_funcs = tmp; } nested_funcs[nesting_level].func = 0; } } free (nested_funcs); return TRUE; fail: free (nested_funcs); return FALSE; }
Description: dwarf2.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, does not validate the DW_AT_name data type, which allows remote attackers to cause a denial of service (bfd_hash_hash NULL pointer dereference, or out-of-bounds access, and application crash) via a crafted ELF file, related to scan_unit_for_symbols and parse_comp_unit.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int hclge_tm_schd_mode_vnet_base_cfg(struct hclge_vport *vport) { struct hnae3_knic_private_info *kinfo = &vport->nic.kinfo; struct hclge_dev *hdev = vport->back; int ret; u8 i; ret = hclge_tm_pri_schd_mode_cfg(hdev, vport->vport_id); if (ret) return ret; for (i = 0; i < kinfo->num_tc; i++) { u8 sch_mode = hdev->tm_info.tc_info[i].tc_sch_mode; ret = hclge_tm_qs_schd_mode_cfg(hdev, vport->qs_offset + i, sch_mode); if (ret) return ret; } return 0; }
Description: An issue was discovered in the Linux kernel before 5.2.3. An out of bounds access exists in the function hclge_tm_schd_mode_vnet_base_cfg in the file drivers/net/ethernet/hisilicon/hns3/hns3pf/hclge_tm.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void mbim_dissect_sms_read_info(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, gint offset, struct mbim_conv_info *mbim_conv) { proto_tree *subtree; gint base_offset; guint32 i, format, element_count; wmem_array_t *pair_list; struct mbim_pair_list pair_list_item, *p_pair_list_item; base_offset = offset; proto_tree_add_item_ret_uint(tree, hf_mbim_sms_read_info_format, tvb, offset, 4, ENC_LITTLE_ENDIAN, &format); offset += 4; proto_tree_add_item_ret_uint(tree, hf_mbim_sms_read_info_element_count, tvb, offset, 4, ENC_LITTLE_ENDIAN, &element_count); offset += 4; if (element_count) { pair_list = wmem_array_sized_new(wmem_packet_scope(), sizeof(struct mbim_pair_list), element_count); subtree = proto_tree_add_subtree(tree, tvb, offset, 8*element_count, ett_mbim_pair_list, NULL, ""SMS Ref List""); for (i = 0; i < element_count; i++) { proto_tree_add_item_ret_uint(subtree, hf_mbim_sms_read_info_sms_offset, tvb, offset, 4, ENC_LITTLE_ENDIAN, &pair_list_item.offset); offset += 4; proto_tree_add_item_ret_uint(subtree, hf_mbim_sms_read_info_sms_size, tvb, offset, 4, ENC_LITTLE_ENDIAN, &pair_list_item.size); offset += 4; wmem_array_append_one(pair_list, pair_list_item); } for (i = 0; i < element_count; i++) { p_pair_list_item = (struct mbim_pair_list*)wmem_array_index(pair_list, i); if (p_pair_list_item->offset && p_pair_list_item->size) { subtree = proto_tree_add_subtree_format(tree, tvb, base_offset + p_pair_list_item->offset, p_pair_list_item->size, ett_mbim_pair_list, NULL, ""SMS Element #%u"", i+1); if (format == MBIM_SMS_FORMAT_PDU) { mbim_dissect_sms_pdu_record(tvb, pinfo, subtree, base_offset + p_pair_list_item->offset, mbim_conv); } else if (format == MBIM_SMS_FORMAT_CDMA) { mbim_dissect_sms_cdma_record(tvb, pinfo, subtree, base_offset + p_pair_list_item->offset); } else { proto_tree_add_expert(subtree, pinfo, &ei_mbim_unknown_sms_format, tvb, base_offset + p_pair_list_item->offset, p_pair_list_item->size); } } } } }
Description: In Wireshark 2.4.0 to 2.4.1 and 2.2.0 to 2.2.9, the MBIM dissector could crash or exhaust system memory. This was addressed in epan/dissectors/packet-mbim.c by changing the memory-allocation approach.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static ext4_fsblk_t ext4_valid_block_bitmap(struct super_block *sb, struct ext4_group_desc *desc, ext4_group_t block_group, struct buffer_head *bh) { struct ext4_sb_info *sbi = EXT4_SB(sb); ext4_grpblk_t offset; ext4_grpblk_t next_zero_bit; ext4_fsblk_t blk; ext4_fsblk_t group_first_block; if (ext4_has_feature_flex_bg(sb)) { return 0; } group_first_block = ext4_group_first_block_no(sb, block_group); blk = ext4_block_bitmap(sb, desc); offset = blk - group_first_block; if (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data)) return blk; blk = ext4_inode_bitmap(sb, desc); offset = blk - group_first_block; if (!ext4_test_bit(EXT4_B2C(sbi, offset), bh->b_data)) return blk; blk = ext4_inode_table(sb, desc); offset = blk - group_first_block; next_zero_bit = ext4_find_next_zero_bit(bh->b_data, EXT4_B2C(sbi, offset + sbi->s_itb_per_group), EXT4_B2C(sbi, offset)); if (next_zero_bit < EXT4_B2C(sbi, offset + sbi->s_itb_per_group)) return blk; return 0; }
Description: The ext4_valid_block_bitmap function in fs/ext4/balloc.c in the Linux kernel through 4.15.15 allows attackers to cause a denial of service (out-of-bounds read and system crash) via a crafted ext4 image because balloc.c and ialloc.c do not validate bitmap block numbers.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void recovery_character(const char *character) { if (!awaiting_character) { recovery_abort(); fsm_sendFailure(FailureType_Failure_UnexpectedMessage, ""Not in Recovery mode""); layoutHome(); return; } if (strlen(mnemonic) + 1 > MNEMONIC_BUF - 1) { recovery_abort(); fsm_sendFailure(FailureType_Failure_UnexpectedMessage, ""Too many characters attempted during recovery""); layoutHome(); return; } char *pos = strchr(cipher, character[0]); if (character[0] != ' ' && pos == NULL) { recovery_abort(); fsm_sendFailure(FailureType_Failure_SyntaxError, ""Character must be from a to z""); layoutHome(); return; } static int uncyphered_word_count = 0; static bool definitely_using_cipher = false; static CONFIDENTIAL char coded_word[12]; static CONFIDENTIAL char decoded_word[12]; if (!mnemonic[0]) { uncyphered_word_count = 0; definitely_using_cipher = false; memzero(coded_word, sizeof(coded_word)); memzero(decoded_word, sizeof(decoded_word)); } char decoded_character[2] = "" ""; if (character[0] != ' ') { decoded_character[0] = english_alphabet[(int)(pos - cipher)]; strlcat(coded_word, character, sizeof(coded_word)); strlcat(decoded_word, decoded_character, sizeof(decoded_word)); if (enforce_wordlist && 4 <= strlen(coded_word)) { bool maybe_not_using_cipher = attempt_auto_complete(coded_word); bool maybe_using_cipher = attempt_auto_complete(decoded_word); if (!maybe_not_using_cipher && maybe_using_cipher) { definitely_using_cipher = true; } else if (maybe_not_using_cipher && !definitely_using_cipher && MAX_UNCYPHERED_WORDS < uncyphered_word_count++) { recovery_abort(); fsm_sendFailure(FailureType_Failure_SyntaxError, ""Words were not entered correctly. Make sure you are using the substition cipher.""); layoutHome(); return; } } } else { memzero(coded_word, sizeof(coded_word)); memzero(decoded_word, sizeof(decoded_word)); } strlcat(mnemonic, decoded_character, MNEMONIC_BUF); next_character(); }
Description: Insufficient checks in the finite state machine of the ShapeShift KeepKey hardware wallet before firmware 6.2.2 allow a partial reset of cryptographic secrets to known values via crafted messages. Notably, this breaks the security of U2F for new server registrations and invalidates existing registrations. This vulnerability can be exploited by unauthenticated attackers and the interface is reachable via WebUSB.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void bigben_set_led(struct led_classdev *led, enum led_brightness value) { struct device *dev = led->dev->parent; struct hid_device *hid = to_hid_device(dev); struct bigben_device *bigben = hid_get_drvdata(hid); int n; bool work; unsigned long flags; if (!bigben) { hid_err(hid, ""no device data\n""); return; } for (n = 0; n < NUM_LEDS; n++) { if (led == bigben->leds[n]) { spin_lock_irqsave(&bigben->lock, flags); if (value == LED_OFF) { work = (bigben->led_state & BIT(n)); bigben->led_state &= ~BIT(n); } else { work = !(bigben->led_state & BIT(n)); bigben->led_state |= BIT(n); } spin_unlock_irqrestore(&bigben->lock, flags); if (work) { bigben->work_led = true; schedule_work(&bigben->worker); } return; } } }
Description: The Linux kernel through 6.1.9 has a Use-After-Free in bigben_remove in drivers/hid/hid-bigbenff.c via a crafted USB device because the LED controllers remain registered for too long.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int sqlite3CheckObjectName( Parse *pParse,             const char *zName,         const char *zType,         const char *zTblName       ){ sqlite3 *db = pParse->db; if( sqlite3WritableSchema(db) || db->init.imposterTable ){ return SQLITE_OK; } if( db->init.busy ){ if( sqlite3_stricmp(zType, db->init.azInit[0]) || sqlite3_stricmp(zName, db->init.azInit[1]) || sqlite3_stricmp(zTblName, db->init.azInit[2]) ){ if( sqlite3Config.bExtraSchemaChecks ){ sqlite3ErrorMsg(pParse, """");  return SQLITE_ERROR; } } }else{ if( pParse->nested==0  && 0==sqlite3StrNICmp(zName, ""sqlite_"", 7) ){ sqlite3ErrorMsg(pParse, ""object name reserved for internal use: %s"", zName); return SQLITE_ERROR; } } return SQLITE_OK; }
Description: SQLite 3.30.1 mishandles certain SELECT statements with a nonexistent VIEW, leading to an application crash.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void vmx_refresh_apicv_exec_ctrl(struct kvm_vcpu *vcpu) { struct vcpu_vmx *vmx = to_vmx(vcpu); vmcs_write32(PIN_BASED_VM_EXEC_CONTROL, vmx_pin_based_exec_ctrl(vmx)); }
Description: arch/x86/kvm/vmx.c in the Linux kernel through 4.6.3 mishandles the APICv on/off state, which allows guest OS users to obtain direct APIC MSR access on the host OS, and consequently cause a denial of service (host OS crash) or possibly execute arbitrary code on the host OS, via x2APIC mode.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static char *qemu_disk_scsi_drive_string(libxl__gc *gc, const char *target_path, int unit, const char *format, const libxl_device_disk *disk, int colo_mode, const char **id_ptr) { char *drive = NULL; char *common = GCSPRINTF(""if=none,cache=writeback""); const char *exportname = disk->colo_export; const char *active_disk = disk->active_disk; const char *hidden_disk = disk->hidden_disk; const char *id; switch (colo_mode) { case LIBXL__COLO_NONE: id = GCSPRINTF(""scsi0-hd%d"", unit); drive = GCSPRINTF(""file=%s,id=%s,format=%s,%s"", target_path, id, format, common); break; case LIBXL__COLO_PRIMARY: id = exportname; drive = GCSPRINTF( ""%s,id=%s,driver=quorum,"" ""children.0.file.filename=%s,"" ""children.0.driver=%s,"" ""read-pattern=fifo,"" ""vote-threshold=1"", common, id, target_path, format); break; case LIBXL__COLO_SECONDARY: id = ""top-colo""; drive = GCSPRINTF( ""%s,id=%s,driver=replication,"" ""mode=secondary,"" ""top-id=top-colo,"" ""file.driver=qcow2,"" ""file.file.filename=%s,"" ""file.backing.driver=qcow2,"" ""file.backing.file.filename=%s,"" ""file.backing.backing=%s"", common, id, active_disk, hidden_disk, exportname); break; default: abort(); } *id_ptr = id; return drive; }
Description: An issue was discovered in Xen 4.7 through 4.10.x. libxl fails to pass the readonly flag to qemu when setting up a SCSI disk, due to what was probably an erroneous merge conflict resolution. Malicious guest administrators or (in some situations) users may be able to write to supposedly read-only disk images. Only emulated SCSI disks (specified as ""sd"" in the libxl disk configuration, or an equivalent) are affected. IDE disks (""hd"") are not affected (because attempts to make them readonly are rejected). Additionally, CDROM devices (that is, devices specified to be presented to the guest as CDROMs, regardless of the nature of the backing storage on the host) are not affected; they are always read only. Only systems using qemu-xen (rather than qemu-xen-traditional) as the device model version are vulnerable. Only systems using libxl or libxl-based toolstacks are vulnerable. (This includes xl, and libvirt with the libxl driver.) The vulnerability is present in Xen versions 4.7 and later. (In earlier versions, provided that the patch for XSA-142 has been applied, attempts to create read only disks are rejected.) If the host and guest together usually support PVHVM, the issue is exploitable only if the malicious guest administrator has control of the guest kernel or guest kernel command line.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: GVariant * g_variant_get_child_value (GVariant *value, gsize     index_) { g_return_val_if_fail (index_ < g_variant_n_children (value), NULL); g_return_val_if_fail (value->depth < G_MAXSIZE, NULL); if (~g_atomic_int_get (&value->state) & STATE_SERIALISED) { g_variant_lock (value); if (~value->state & STATE_SERIALISED) { GVariant *child; child = g_variant_ref (value->contents.tree.children[index_]); g_variant_unlock (value); return child; } g_variant_unlock (value); } { GVariantSerialised serialised = g_variant_to_serialised (value); GVariantSerialised s_child; GVariant *child; s_child = g_variant_serialised_get_child (serialised, index_); if (!(value->state & STATE_TRUSTED) && g_variant_type_info_query_depth (s_child.type_info) >= G_VARIANT_MAX_RECURSION_DEPTH - value->depth) { g_assert (g_variant_is_of_type (value, G_VARIANT_TYPE_VARIANT)); return g_variant_new_tuple (NULL, 0); } child = g_slice_new (GVariant); child->type_info = s_child.type_info; child->state = (value->state & STATE_TRUSTED) | STATE_SERIALISED; child->size = s_child.size; g_atomic_ref_count_init (&child->ref_count); child->depth = value->depth + 1; child->contents.serialised.bytes = g_bytes_ref (value->contents.serialised.bytes); child->contents.serialised.data = s_child.data; return child; } }
Description: A flaw was found in GLib. GVariant deserialization is vulnerable to an exponential blowup issue where a crafted GVariant can cause excessive processing, leading to denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: WORD32 ihevcd_parse_transform_tree(codec_t *ps_codec, WORD32 x0, WORD32 y0, WORD32 cu_x_base, WORD32 cu_y_base, WORD32 log2_trafo_size, WORD32 trafo_depth, WORD32 blk_idx, WORD32 intra_pred_mode) { IHEVCD_ERROR_T ret = (IHEVCD_ERROR_T)IHEVCD_SUCCESS; sps_t *ps_sps; pps_t *ps_pps; WORD32 value; WORD32 x1, y1; WORD32 max_trafo_depth; bitstrm_t *ps_bitstrm = &ps_codec->s_parse.s_bitstrm; WORD32 intra_split_flag; WORD32 split_transform_flag; WORD32 ctxt_idx; cab_ctxt_t *ps_cabac = &ps_codec->s_parse.s_cabac; max_trafo_depth = ps_codec->s_parse.s_cu.i4_max_trafo_depth; ps_sps = ps_codec->s_parse.ps_sps; ps_pps = ps_codec->s_parse.ps_pps; intra_split_flag = ps_codec->s_parse.s_cu.i4_intra_split_flag; { split_transform_flag = 0; if((log2_trafo_size <= ps_sps->i1_log2_max_transform_block_size) && (log2_trafo_size > ps_sps->i1_log2_min_transform_block_size) && (trafo_depth < max_trafo_depth) && !(intra_split_flag && (trafo_depth == 0))) { ctxt_idx = IHEVC_CAB_SPLIT_TFM + (5 - log2_trafo_size); TRACE_CABAC_CTXT(""split_transform_flag"", ps_cabac->u4_range, ctxt_idx); split_transform_flag = ihevcd_cabac_decode_bin(ps_cabac, ps_bitstrm, ctxt_idx); AEV_TRACE(""split_transform_flag"", split_transform_flag, ps_cabac->u4_range); } else { WORD32 inter_split_flag = 0; if((0 == ps_sps->i1_max_transform_hierarchy_depth_inter) && (PRED_MODE_INTER == ps_codec->s_parse.s_cu.i4_pred_mode) && (PART_2Nx2N != ps_codec->s_parse.s_cu.i4_part_mode) && (0 == trafo_depth)) { inter_split_flag = 1; } if((log2_trafo_size > ps_sps->i1_log2_max_transform_block_size) || ((1 == intra_split_flag) && (0 == trafo_depth)) || (1 == inter_split_flag)) { split_transform_flag = 1; } } if(0 == trafo_depth) { ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth] = 0; ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth] = 0; } else { ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth] = ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth - 1]; ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth] = ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth - 1]; } if(trafo_depth == 0 || log2_trafo_size > 2) { ctxt_idx = IHEVC_CAB_CBCR_IDX + trafo_depth; if((trafo_depth == 0) || ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth - 1]) { TRACE_CABAC_CTXT(""cbf_cb"", ps_cabac->u4_range, ctxt_idx); value = ihevcd_cabac_decode_bin(ps_cabac, ps_bitstrm, ctxt_idx); AEV_TRACE(""cbf_cb"", value, ps_cabac->u4_range); ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth] = value; } if((trafo_depth == 0) || ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth - 1]) { TRACE_CABAC_CTXT(""cbf_cr"", ps_cabac->u4_range, ctxt_idx); value = ihevcd_cabac_decode_bin(ps_cabac, ps_bitstrm, ctxt_idx); AEV_TRACE(""cbf_cr"", value, ps_cabac->u4_range); ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth] = value; } } if(split_transform_flag) { WORD32 intra_pred_mode_tmp; x1 = x0 + ((1 << log2_trafo_size) >> 1); y1 = y0 + ((1 << log2_trafo_size) >> 1); intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[0]; ihevcd_parse_transform_tree(ps_codec, x0, y0, x0, y0, log2_trafo_size - 1, trafo_depth + 1, 0, intra_pred_mode_tmp); intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[1]; ihevcd_parse_transform_tree(ps_codec, x1, y0, x0, y0, log2_trafo_size - 1, trafo_depth + 1, 1, intra_pred_mode_tmp); intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[2]; ihevcd_parse_transform_tree(ps_codec, x0, y1, x0, y0, log2_trafo_size - 1, trafo_depth + 1, 2, intra_pred_mode_tmp); intra_pred_mode_tmp = trafo_depth ? intra_pred_mode : ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[3]; ihevcd_parse_transform_tree(ps_codec, x1, y1, x0, y0, log2_trafo_size - 1, trafo_depth + 1, 3, intra_pred_mode_tmp); } else { WORD32 ctb_x_base; WORD32 ctb_y_base; WORD32 cu_qp_delta_abs; tu_t *ps_tu = ps_codec->s_parse.ps_tu; cu_qp_delta_abs = 0; ctb_x_base = ps_codec->s_parse.i4_ctb_x << ps_sps->i1_log2_ctb_size; ctb_y_base = ps_codec->s_parse.i4_ctb_y << ps_sps->i1_log2_ctb_size; if((ps_codec->s_parse.s_cu.i4_pred_mode == PRED_MODE_INTRA) || (trafo_depth != 0) || (ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth]) || (ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth])) { ctxt_idx = IHEVC_CAB_CBF_LUMA_IDX; ctxt_idx += (trafo_depth == 0) ? 1 : 0; TRACE_CABAC_CTXT(""cbf_luma"", ps_cabac->u4_range, ctxt_idx); value = ihevcd_cabac_decode_bin(ps_cabac, ps_bitstrm, ctxt_idx); AEV_TRACE(""cbf_luma"", value, ps_cabac->u4_range); ps_codec->s_parse.s_cu.i1_cbf_luma = value; } else { ps_codec->s_parse.s_cu.i1_cbf_luma = 1; } ps_tu->b1_cb_cbf = 0; ps_tu->b1_cr_cbf = 0; ps_tu->b1_y_cbf = 0; ps_tu->b4_pos_x = ((x0 - ctb_x_base) >> 2); ps_tu->b4_pos_y = ((y0 - ctb_y_base) >> 2); ps_tu->b1_transquant_bypass = ps_codec->s_parse.s_cu.i4_cu_transquant_bypass; ps_tu->b3_size = (log2_trafo_size - 2); ps_tu->b7_qp = ps_codec->s_parse.u4_qp; ps_tu->b6_luma_intra_mode = intra_pred_mode; ps_tu->b3_chroma_intra_mode_idx = ps_codec->s_parse.s_cu.i4_intra_chroma_pred_mode_idx; if(ps_codec->s_parse.s_cu.i1_cbf_luma || ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth] || ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth]) { WORD32 intra_pred_mode_chroma; if(ps_pps->i1_cu_qp_delta_enabled_flag && !ps_codec->s_parse.i4_is_cu_qp_delta_coded) { WORD32 c_max        = TU_MAX_QP_DELTA_ABS; WORD32 ctxt_inc     = IHEVC_CAB_QP_DELTA_ABS; WORD32 ctxt_inc_max = CTXT_MAX_QP_DELTA_ABS; TRACE_CABAC_CTXT(""cu_qp_delta_abs"", ps_cabac->u4_range, ctxt_inc); cu_qp_delta_abs = ihevcd_cabac_decode_bins_tunary(ps_cabac, ps_bitstrm, c_max, ctxt_inc, 0, ctxt_inc_max); if(cu_qp_delta_abs >= c_max) { value = ihevcd_cabac_decode_bypass_bins_egk(ps_cabac, ps_bitstrm, 0); cu_qp_delta_abs += value; } AEV_TRACE(""cu_qp_delta_abs"", cu_qp_delta_abs, ps_cabac->u4_range); ps_codec->s_parse.i4_is_cu_qp_delta_coded = 1; if(cu_qp_delta_abs) { value = ihevcd_cabac_decode_bypass_bin(ps_cabac, ps_bitstrm); AEV_TRACE(""cu_qp_delta_sign"", value, ps_cabac->u4_range); if(value) cu_qp_delta_abs = -cu_qp_delta_abs; } ps_codec->s_parse.s_cu.i4_cu_qp_delta = cu_qp_delta_abs; } if(ps_codec->s_parse.s_cu.i1_cbf_luma) { ps_tu->b1_y_cbf = 1; ihevcd_parse_residual_coding(ps_codec, x0, y0, log2_trafo_size, 0, intra_pred_mode); } if(4 == ps_codec->s_parse.s_cu.i4_intra_chroma_pred_mode_idx) intra_pred_mode_chroma = ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[0]; else { intra_pred_mode_chroma = gau1_intra_pred_chroma_modes[ps_codec->s_parse.s_cu.i4_intra_chroma_pred_mode_idx]; if(intra_pred_mode_chroma == ps_codec->s_parse.s_cu.ai4_intra_luma_pred_mode[0]) { intra_pred_mode_chroma = INTRA_ANGULAR(34); } } if(log2_trafo_size > 2) { if(ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth]) { ps_tu->b1_cb_cbf = 1; ihevcd_parse_residual_coding(ps_codec, x0, y0, log2_trafo_size - 1, 1, intra_pred_mode_chroma); } if(ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth]) { ps_tu->b1_cr_cbf = 1; ihevcd_parse_residual_coding(ps_codec, x0, y0, log2_trafo_size - 1, 2, intra_pred_mode_chroma); } } else if(blk_idx == 3) { if(ps_codec->s_parse.s_cu.ai1_cbf_cb[trafo_depth]) { ps_tu->b1_cb_cbf = 1; ihevcd_parse_residual_coding(ps_codec, cu_x_base, cu_y_base, log2_trafo_size, 1, intra_pred_mode_chroma); } if(ps_codec->s_parse.s_cu.ai1_cbf_cr[trafo_depth]) { ps_tu->b1_cr_cbf = 1; ihevcd_parse_residual_coding(ps_codec, cu_x_base, cu_y_base, log2_trafo_size, 2, intra_pred_mode_chroma); } } else { ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE; } } else { if((3 != blk_idx) && (2 == log2_trafo_size)) { ps_tu->b3_chroma_intra_mode_idx = INTRA_PRED_CHROMA_IDX_NONE; } } { if((ps_codec->s_parse.s_cu.i4_pos_x << 3) == (ps_tu->b4_pos_x << 2) && (ps_codec->s_parse.s_cu.i4_pos_y << 3) == (ps_tu->b4_pos_y << 2)) { ps_tu->b1_first_tu_in_cu = 1; } else { ps_tu->b1_first_tu_in_cu = 0; } } ps_codec->s_parse.ps_tu++; ps_codec->s_parse.s_cu.i4_tu_cnt++; ps_codec->s_parse.i4_pic_tu_idx++; } } return ret; }
Description: A remote code execution vulnerability in libhevc in Mediaserver could enable an attacker using a specially crafted file to cause memory corruption during media file and data processing. This issue is rated as Critical due to the possibility of remote code execution within the context of the Mediaserver process. Product: Android. Versions: 5.0.2, 5.1.1, 6.0, 6.0.1, 7.0, 7.1.1. Android ID: A-33966031.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void headerMergeLegacySigs(Header h, Header sigh) { HeaderIterator hi; struct rpmtd_s td; hi = headerInitIterator(sigh); for (; headerNext(hi, &td); rpmtdFreeData(&td)) { switch (td.tag) { case RPMSIGTAG_SIZE: td.tag = RPMTAG_SIGSIZE; break; case RPMSIGTAG_PGP: td.tag = RPMTAG_SIGPGP; break; case RPMSIGTAG_MD5: td.tag = RPMTAG_SIGMD5; break; case RPMSIGTAG_GPG: td.tag = RPMTAG_SIGGPG; break; case RPMSIGTAG_PGP5: td.tag = RPMTAG_SIGPGP5; break; case RPMSIGTAG_PAYLOADSIZE: td.tag = RPMTAG_ARCHIVESIZE; break; case RPMSIGTAG_FILESIGNATURES: td.tag = RPMTAG_FILESIGNATURES; break; case RPMSIGTAG_FILESIGNATURELENGTH: td.tag = RPMTAG_FILESIGNATURELENGTH; break; case RPMSIGTAG_VERITYSIGNATURES: case RPMSIGTAG_VERITYSIGNATUREALGO: case RPMSIGTAG_SHA1: case RPMSIGTAG_SHA256: case RPMSIGTAG_DSA: case RPMSIGTAG_RSA: default: if (!(td.tag >= HEADER_SIGBASE && td.tag < HEADER_TAGBASE)) continue; break; } if (!headerIsEntry(h, td.tag)) { switch (td.type) { case RPM_NULL_TYPE: continue; break; case RPM_CHAR_TYPE: case RPM_INT8_TYPE: case RPM_INT16_TYPE: case RPM_INT32_TYPE: case RPM_INT64_TYPE: if (td.count != 1) continue; break; case RPM_STRING_TYPE: case RPM_STRING_ARRAY_TYPE: case RPM_BIN_TYPE: if (td.count >= 16*1024) continue; break; case RPM_I18NSTRING_TYPE: continue; break; } (void) headerPut(h, &td, HEADERPUT_DEFAULT); } } headerFreeIterator(hi); }
Description: A flaw was found in RPM's signature check functionality when reading a package file. This flaw allows an attacker who can convince a victim to install a seemingly verifiable package, whose signature header was modified, to cause RPM database corruption and execute code. The highest threat from this vulnerability is to data integrity, confidentiality, and system availability.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Status GetInitOp(const string& export_dir, const MetaGraphDef& meta_graph_def, string* init_op_name) { const auto& sig_def_map = meta_graph_def.signature_def(); const auto& init_op_sig_it = meta_graph_def.signature_def().find(kSavedModelInitOpSignatureKey); if (init_op_sig_it != sig_def_map.end()) { *init_op_name = init_op_sig_it->second.outputs() .find(kSavedModelInitOpSignatureKey) ->second.name(); return Status::OK(); } const auto& collection_def_map = meta_graph_def.collection_def(); string init_op_collection_key; if (collection_def_map.find(kSavedModelMainOpKey) != collection_def_map.end()) { init_op_collection_key = kSavedModelMainOpKey; } else { init_op_collection_key = kSavedModelLegacyInitOpKey; } const auto init_op_it = collection_def_map.find(init_op_collection_key); if (init_op_it != collection_def_map.end()) { if (init_op_it->second.node_list().value_size() != 1) { return errors::FailedPrecondition( strings::StrCat(""Expected exactly one main op in : "", export_dir)); } *init_op_name = init_op_it->second.node_list().value(0); } return Status::OK(); }
Description: Tensorflow is an Open Source Machine Learning Framework. The implementation of `GetInitOp` is vulnerable to a crash caused by dereferencing a null pointer. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void Compute(OpKernelContext* ctx) override { const Tensor& sorted_inputs_t = ctx->input(0); const Tensor& values_t = ctx->input(1); OP_REQUIRES( ctx, sorted_inputs_t.shape().dims() >= 2, errors::InvalidArgument(""sorted input argument must be a matrix"")); OP_REQUIRES(ctx, sorted_inputs_t.dim_size(0) == values_t.dim_size(0), Status(error::INVALID_ARGUMENT, ""Leading dim_size of both tensors must match."")); OP_REQUIRES(ctx, values_t.NumElements() < std::numeric_limits<int>::max(), Status(error::INVALID_ARGUMENT, ""values tensor size must less than INT_MAX"")); Tensor* output_t; OP_REQUIRES_OK(ctx, ctx->allocate_output(0, values_t.shape(), &output_t)); if (output_t->dtype() == DT_INT32) { OP_REQUIRES(ctx, FastBoundsCheck(sorted_inputs_t.dim_size(1), std::numeric_limits<int>::max()), errors::InvalidArgument(""trailing dim_size must less than "" ""INT_MAX for int32 output type, was "", sorted_inputs_t.dim_size(1))); } auto output = output_t->template flat<OutType>(); const auto sorted_inputs = sorted_inputs_t.template flat<T>(); const auto values = values_t.template flat<T>(); OP_REQUIRES_OK( ctx, functor::LowerBoundFunctor<Device, T, OutType>::Compute( ctx, sorted_inputs, values, sorted_inputs_t.dim_size(0), sorted_inputs_t.dim_size(1), values_t.dim_size(1), &output)); }
Description: TensorFlow is an open source platform for machine learning. If `LowerBound` or `UpperBound` is given an empty`sorted_inputs` input, it results in a `nullptr` dereference, leading to a segfault that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit bce3717eaef4f769019fd18e990464ca4a2efeea. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void vmx_complete_atomic_exit(struct vcpu_vmx *vmx) { u32 exit_intr_info; if (!(vmx->exit_reason == EXIT_REASON_MCE_DURING_VMENTRY || vmx->exit_reason == EXIT_REASON_EXCEPTION_NMI)) return; vmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO); exit_intr_info = vmx->exit_intr_info; if (is_machine_check(exit_intr_info)) kvm_machine_check(); if ((exit_intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR && (exit_intr_info & INTR_INFO_VALID_MASK)) { kvm_before_handle_nmi(&vmx->vcpu); asm(""int $2""); kvm_after_handle_nmi(&vmx->vcpu); } }
Description: arch/x86/kvm/vmx.c in the Linux kernel through 4.9 mismanages the #BP and #OF exceptions, which allows guest OS users to cause a denial of service (guest OS crash) by declining to handle an exception thrown by an L2 guest.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int pkey_gost_decrypt(EVP_PKEY_CTX *pctx, unsigned char *key, size_t *key_len, const unsigned char *in, size_t in_len) { struct gost_pmeth_data *gctx = EVP_PKEY_CTX_get_data(pctx); switch (gctx->cipher_nid) { case NID_id_Gost28147_89: case NID_undef:  return pkey_GOST_ECcp_decrypt(pctx, key, key_len, in, in_len); case NID_kuznyechik_ctr: case NID_magma_ctr: return pkey_gost2018_decrypt(pctx, key, key_len, in, in_len); default: GOSTerr(GOST_F_PKEY_GOST_DECRYPT, ERR_R_INTERNAL_ERROR); return -1; } }
Description: GOST engine is a reference implementation of the Russian GOST crypto algorithms for OpenSSL. TLS clients using GOST engine when ciphersuite `TLS_GOSTR341112_256_WITH_KUZNYECHIK_CTR_OMAC` is agreed and the server uses 512 bit GOST secret keys are vulnerable to buffer overflow. GOST engine version 3.0.1 contains a patch for this issue. Disabling ciphersuite `TLS_GOSTR341112_256_WITH_KUZNYECHIK_CTR_OMAC` is a possible workaround.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl) { struct scm_fp_list *new_fpl; int i; if (!fpl) return NULL; new_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]), GFP_KERNEL); if (new_fpl) { for (i = 0; i < fpl->count; i++) get_file(fpl->fp[i]); new_fpl->max = new_fpl->count; } return new_fpl; }
Description: The Linux kernel before 4.5 allows local users to bypass file-descriptor limits and cause a denial of service (memory consumption) by leveraging incorrect tracking of descriptor ownership and sending each descriptor over a UNIX socket before closing it. NOTE: this vulnerability exists because of an incorrect fix for CVE-2013-4312.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int domain_soft_reset(struct domain *d) { struct vcpu *v; int rc; spin_lock(&d->shutdown_lock); for_each_vcpu ( d, v ) if ( !v->paused_for_shutdown ) { spin_unlock(&d->shutdown_lock); return -EINVAL; } spin_unlock(&d->shutdown_lock); rc = evtchn_reset(d); if ( rc ) return rc; grant_table_warn_active_grants(d); argo_soft_reset(d); for_each_vcpu ( d, v ) { set_xen_guest_handle(runstate_guest(v), NULL); unmap_vcpu_info(v); } rc = arch_domain_soft_reset(d); if ( !rc ) domain_resume(d); else domain_crash(d); return rc; }
Description: An issue was discovered in Xen through 4.14.x. There is a lack of preemption in evtchn_reset() / evtchn_destroy(). In particular, the FIFO event channel model allows guests to have a large number of event channels active at a time. Closing all of these (when resetting all event channels or when cleaning up after the guest) may take extended periods of time. So far, there was no arrangement for preemption at suitable intervals, allowing a CPU to spend an almost unbounded amount of time in the processing of these operations. Malicious or buggy guest kernels can mount a Denial of Service (DoS) attack affecting the entire system. All Xen versions are vulnerable in principle. Whether versions 4.3 and older are vulnerable depends on underlying hardware characteristics.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void rtps_util_add_type_element_array(proto_tree *tree, tvbuff_t * tvb, gint offset, const guint encoding, dissection_info * info _U_) { proto_tree * bound_tree; guint32 member_id = 0, member_length = 0; guint32 long_number, i; gint zero_alignment, offset_tmp; offset = rtps_util_add_type_library_type(tree, tvb, offset, encoding, info); rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length); zero_alignment = offset; rtps_util_add_type_id(tree, tvb, offset, encoding, zero_alignment, -1, NULL, &(info->base_type_id)); offset += member_length; rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length); proto_tree_add_item(tree, hf_rtps_type_object_element_shared, tvb, offset, 1, encoding); offset += member_length; rtps_util_dissect_parameter_header(tvb, &offset, encoding, &member_id, &member_length); offset_tmp = offset; long_number = tvb_get_guint32(tvb, offset_tmp, encoding); bound_tree = proto_tree_add_subtree_format(tree, tvb, offset_tmp, member_length, ett_rtps_type_bound_list, NULL, ""Bounds (%d elements)"", long_number); offset_tmp += 4; for (i = 0; i < long_number ; i++) { proto_tree_add_item(bound_tree, hf_rtps_type_object_bound, tvb, offset_tmp, 4, encoding); if (info) info->bound = tvb_get_gint32(tvb, offset_tmp, encoding); if (info) info->num_elements = tvb_get_gint32(tvb, offset_tmp, encoding); offset_tmp += 4; } }
Description: Excessive loops in multiple dissectors in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void CWebServer::GetFloorplanImage(WebEmSession & session, const request& req, reply & rep) { std::string idx = request::findValue(&req, ""idx""); if (idx == """") { return; } std::vector<std::vector<std::string> > result; result = m_sql.safe_queryBlob(""SELECT Image FROM Floorplans WHERE ID=%s"", idx.c_str()); if (result.empty()) return; reply::set_content(&rep, result[0][0].begin(), result[0][0].end()); std::string oname = ""floorplan""; if (result[0][0].size() > 10) { if (result[0][0][0] == 'P') oname += "".png""; else if (result[0][0][0] == -1) oname += "".jpg""; else if (result[0][0][0] == 'B') oname += "".bmp""; else if (result[0][0][0] == 'G') oname += "".gif""; } reply::add_header_attachment(&rep, oname); }
Description: Domoticz before 4.10578 allows SQL Injection via the idx parameter in CWebServer::GetFloorplanImage in WebServer.cpp.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void slc_bump(struct slcan *sl) { struct sk_buff *skb; struct can_frame cf; int i, tmp; u32 tmpid; char *cmd = sl->rbuff; cf.can_id = 0; switch (*cmd) { case 'r': cf.can_id = CAN_RTR_FLAG; case 't': cf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN]; sl->rbuff[SLC_CMD_LEN + SLC_SFF_ID_LEN] = 0; cmd += SLC_CMD_LEN + SLC_SFF_ID_LEN + 1; break; case 'R': cf.can_id = CAN_RTR_FLAG; case 'T': cf.can_id |= CAN_EFF_FLAG; cf.can_dlc = sl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN]; sl->rbuff[SLC_CMD_LEN + SLC_EFF_ID_LEN] = 0; cmd += SLC_CMD_LEN + SLC_EFF_ID_LEN + 1; break; default: return; } if (kstrtou32(sl->rbuff + SLC_CMD_LEN, 16, &tmpid)) return; cf.can_id |= tmpid; if (cf.can_dlc >= '0' && cf.can_dlc < '9') cf.can_dlc -= '0'; else return; *(u64 *) (&cf.data) = 0;  if (!(cf.can_id & CAN_RTR_FLAG)) { for (i = 0; i < cf.can_dlc; i++) { tmp = hex_to_bin(*cmd++); if (tmp < 0) return; cf.data[i] = (tmp << 4); tmp = hex_to_bin(*cmd++); if (tmp < 0) return; cf.data[i] |= tmp; } } skb = dev_alloc_skb(sizeof(struct can_frame) + sizeof(struct can_skb_priv)); if (!skb) return; skb->dev = sl->dev; skb->protocol = htons(ETH_P_CAN); skb->pkt_type = PACKET_BROADCAST; skb->ip_summed = CHECKSUM_UNNECESSARY; can_skb_reserve(skb); can_skb_prv(skb)->ifindex = sl->dev->ifindex; memcpy(skb_put(skb, sizeof(struct can_frame)), &cf, sizeof(struct can_frame)); netif_rx_ni(skb); sl->dev->stats.rx_packets++; sl->dev->stats.rx_bytes += cf.can_dlc; }
Description: An issue was discovered in slc_bump in drivers/net/can/slcan.c in the Linux kernel 3.16 through 5.6.2. It allows attackers to read uninitialized can_frame data, potentially containing sensitive information from kernel stack memory, if the configuration lacks CONFIG_INIT_STACK_ALL, aka CID-b9258a2cece4.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: PHP_SNMP_BOOL_PROPERTY_WRITER_FUNCTION(oid_increasing_check) static int php_snmp_write_oid_output_format(php_snmp_object *snmp_object, zval *newval TSRMLS_DC) { zval ztmp; int ret = SUCCESS; if (Z_TYPE_P(newval) != IS_LONG) { ztmp = *newval; zval_copy_ctor(&ztmp); convert_to_long(&ztmp); newval = &ztmp; } switch(Z_LVAL_P(newval)) { case NETSNMP_OID_OUTPUT_SUFFIX: case NETSNMP_OID_OUTPUT_MODULE: case NETSNMP_OID_OUTPUT_FULL: case NETSNMP_OID_OUTPUT_NUMERIC: case NETSNMP_OID_OUTPUT_UCD: case NETSNMP_OID_OUTPUT_NONE: snmp_object->oid_output_format = Z_LVAL_P(newval); break; default: php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unknown SNMP output print format '%ld'"", Z_LVAL_P(newval)); ret = FAILURE; break; } if (newval == &ztmp) { zval_dtor(newval); } return ret; }
Description: ext/snmp/snmp.c in PHP before 5.5.38, 5.6.x before 5.6.24, and 7.x before 7.0.9 improperly interacts with the unserialize implementation and garbage collection, which allows remote attackers to cause a denial of service (use-after-free and application crash) or possibly have unspecified other impact via crafted serialized data, a related issue to CVE-2016-5773.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bfd_boolean _bfd_add_merge_section (bfd *abfd, void **psinfo, asection *sec, void **psecinfo) { struct sec_merge_info *sinfo; struct sec_merge_sec_info *secinfo; unsigned int align; bfd_size_type amt; bfd_byte *contents; if ((abfd->flags & DYNAMIC) != 0 || (sec->flags & SEC_MERGE) == 0) abort (); if (sec->size == 0 || (sec->flags & SEC_EXCLUDE) != 0 || sec->entsize == 0) return TRUE; if (sec->size % sec->entsize != 0) return TRUE; if ((sec->flags & SEC_RELOC) != 0) { return TRUE; } align = sec->alignment_power; if ((sec->entsize < (unsigned) 1 << align && ((sec->entsize & (sec->entsize - 1)) || !(sec->flags & SEC_STRINGS))) || (sec->entsize > (unsigned) 1 << align && (sec->entsize & (((unsigned) 1 << align) - 1)))) { return TRUE; } for (sinfo = (struct sec_merge_info *) *psinfo; sinfo; sinfo = sinfo->next) if ((secinfo = sinfo->chain) && ! ((secinfo->sec->flags ^ sec->flags) & (SEC_MERGE | SEC_STRINGS)) && secinfo->sec->entsize == sec->entsize && secinfo->sec->alignment_power == sec->alignment_power && secinfo->sec->output_section == sec->output_section) break; if (sinfo == NULL) { sinfo = (struct sec_merge_info *) bfd_alloc (abfd, sizeof (struct sec_merge_info)); if (sinfo == NULL) goto error_return; sinfo->next = (struct sec_merge_info *) *psinfo; sinfo->chain = NULL; *psinfo = sinfo; sinfo->htab = sec_merge_init (sec->entsize, (sec->flags & SEC_STRINGS)); if (sinfo->htab == NULL) goto error_return; } amt = sizeof (struct sec_merge_sec_info) - 1 + sec->size; if (sec->flags & SEC_STRINGS) amt += sec->entsize; *psecinfo = bfd_alloc (abfd, amt); if (*psecinfo == NULL) goto error_return; secinfo = (struct sec_merge_sec_info *) *psecinfo; if (sinfo->chain) { secinfo->next = sinfo->chain->next; sinfo->chain->next = secinfo; } else secinfo->next = secinfo; sinfo->chain = secinfo; secinfo->sec = sec; secinfo->psecinfo = psecinfo; secinfo->htab = sinfo->htab; secinfo->first_str = NULL; sec->rawsize = sec->size; if (sec->flags & SEC_STRINGS) memset (secinfo->contents + sec->size, 0, sec->entsize); contents = secinfo->contents; if (! bfd_get_full_section_contents (sec->owner, sec, &contents)) goto error_return; return TRUE; error_return: *psecinfo = NULL; return FALSE; }
Description: An issue was discovered in the merge_strings function in merge.c in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.31. There is a NULL pointer dereference in _bfd_add_merge_section when attempting to merge sections with large alignments. A specially crafted ELF allows remote attackers to cause a denial of service, as demonstrated by ld.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int ip6_mroute_getsockopt(struct sock *sk, int optname, char __user *optval, int __user *optlen) { int olr; int val; struct net *net = sock_net(sk); struct mr6_table *mrt; mrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT); if (!mrt) return -ENOENT; switch (optname) { case MRT6_VERSION: val = 0x0305; break; #ifdef CONFIG_IPV6_PIMSM_V2 case MRT6_PIM: val = mrt->mroute_do_pim; break; #endif case MRT6_ASSERT: val = mrt->mroute_do_assert; break; default: return -ENOPROTOOPT; } if (get_user(olr, optlen)) return -EFAULT; olr = min_t(int, olr, sizeof(int)); if (olr < 0) return -EINVAL; if (put_user(olr, optlen)) return -EFAULT; if (copy_to_user(optval, &val, olr)) return -EFAULT; return 0; }
Description: An issue was discovered in net/ipv6/ip6mr.c in the Linux kernel before 4.11. By setting a specific socket option, an attacker can control a pointer in kernel land and cause an inet_csk_listen_stop general protection fault, or potentially execute arbitrary code under certain circumstances. The issue can be triggered as root (e.g., inside a default LXC container or with the CAP_NET_ADMIN capability) or after namespace unsharing. This occurs because sk_type and protocol are not checked in the appropriate part of the ip6_mroute_* functions. NOTE: this affects Linux distributions that use 4.9.x longterm kernels before 4.9.187.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static enum pkvm_page_state guest_get_page_state(kvm_pte_t pte) { if (!kvm_pte_valid(pte)) return PKVM_NOPAGE; return pkvm_getstate(kvm_pgtable_stage2_pte_prot(pte)); }
Description: In multiple functions of mem_protect.c, there is a possible way to access hypervisor memory due to a memory access check in the wrong place. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.


 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static gboolean key_value_ok(gchar *key, gchar *value) { char *i; for (i = key; *i != 0; i++) { if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' ')) return FALSE; } if (strcmp(key, ""basename"") == 0 || strcmp(key, FILENAME_TYPE) == 0 ) { if (!is_correct_filename(value)) { error_msg(""Value of '%s' ('%s') is not a valid directory name"", key, value); return FALSE; } } return TRUE; }
Description: Directory traversal vulnerability in abrt-dbus in Automatic Bug Reporting Tool (ABRT) allows local users to read, write to, or change ownership of arbitrary files via unspecified vectors to the (1) NewProblem, (2) GetInfo, (3) SetElement, or (4) DeleteElement method.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void binder_free_buf(struct binder_proc *proc, struct binder_thread *thread, struct binder_buffer *buffer, bool is_failure) { binder_inner_proc_lock(proc); if (buffer->transaction) { buffer->transaction->buffer = NULL; buffer->transaction = NULL; } binder_inner_proc_unlock(proc); if (buffer->async_transaction && buffer->target_node) { struct binder_node *buf_node; struct binder_work *w; buf_node = buffer->target_node; binder_node_inner_lock(buf_node); BUG_ON(!buf_node->has_async_transaction); BUG_ON(buf_node->proc != proc); w = binder_dequeue_work_head_ilocked( &buf_node->async_todo); if (!w) { buf_node->has_async_transaction = false; } else { binder_enqueue_work_ilocked( w, &proc->todo); binder_wakeup_proc_ilocked(proc); } binder_node_inner_unlock(buf_node); } trace_binder_transaction_buffer_release(buffer); binder_transaction_buffer_release(proc, thread, buffer, 0, is_failure); binder_alloc_free_buf(&proc->alloc, buffer); }
Description: In multiple functions of binder.c, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.


 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void xmlHTMLEncodeSend(void) { char *result; result = (char *) xmlEncodeEntitiesReentrant(NULL, BAD_CAST buffer); if (result) { xmlGenericError(xmlGenericErrorContext, ""%s"", result); xmlFree(result); } buffer[0] = 0; }
Description: GNOME project libxml2 v2.9.10 has a global buffer over-read vulnerability in xmlEncodeEntitiesInternal at libxml2/entities.c. The issue has been fixed in commit 50f06b3e.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Http::FilterMetadataStatus Context::onRequestMetadata() { if (!wasm_->onRequestMetadata_) { return Http::FilterMetadataStatus::Continue; } if (wasm_->onRequestMetadata_(this, id_).u64_ == 0) { return Http::FilterMetadataStatus::Continue; } return Http::FilterMetadataStatus::Continue; }
Description: Istio 1.4.x before 1.4.9 and Istio 1.5.x before 1.5.4 contain the following vulnerability when telemetry v2 is enabled: by sending a specially crafted packet, an attacker could trigger a Null Pointer Exception resulting in a Denial of Service. This could be sent to the ingress gateway or a sidecar, triggering a null pointer exception which results in a denial of service. This also affects servicemesh-proxy where a null pointer exception flaw was found in servicemesh-proxy. When running Telemetry v2 (not on by default in version 1.4.x), an attacker could send a specially crafted packet to the ingress gateway or proxy sidecar, triggering a denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int selinux_ptrace_traceme(struct task_struct *parent) { return avc_has_perm(&selinux_state, task_sid_subj(parent), task_sid_obj(current), SECCLASS_PROCESS, PROCESS__PTRACE, NULL); }
Description: An issue was discovered in the Linux kernel before 5.14.8. A use-after-free in selinux_ptrace_traceme (aka the SELinux handler for PTRACE_TRACEME) could be used by local attackers to cause memory corruption and escalate privileges, aka CID-a3727a8bac0a. This occurs because of an attempt to access the subjective credentials of another task.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int  dlt_jnpr_ether_post_init(tcpeditdlt_t *ctx) { jnpr_ether_config_t *config; if (ctx->decoder->dlt != dlt_value) return TCPEDIT_OK; config = (jnpr_ether_config_t *)ctx->encoder->config; config->subctx = tcpedit_dlt_init(ctx->tcpedit, DLT_EN10MB); return TCPEDIT_OK; }
Description: Tcpreplay v4.4.1 was discovered to contain a double-free via __interceptor_free.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool read(ReadonlyBytes buffer) { auto fields_size = sizeof(LocalFileHeader) - (sizeof(u8*) * 3); if (buffer.size() < fields_size) return false; if (memcmp(buffer.data(), local_file_header_signature, sizeof(local_file_header_signature)) != 0) return false; memcpy(reinterpret_cast<void*>(&minimum_version), buffer.data() + sizeof(local_file_header_signature), fields_size); name = buffer.data() + sizeof(local_file_header_signature) + fields_size; extra_data = name + name_length; compressed_data = extra_data + extra_data_length; return true; }
Description: SerenityOS 2021-03-27 contains a buffer overflow vulnerability in the EndOfCentralDirectory::read() function.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void sched_feat_disable(int i) { static_key_disable(&sched_feat_keys[i]); }
Description: Race condition in the audit_log_single_execve_arg function in kernel/auditsc.c in the Linux kernel through 4.7 allows local users to bypass intended character-set restrictions or disrupt system-call auditing by changing a certain string, aka a ""double fetch"" vulnerability.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void ip_optprint(netdissect_options *ndo, register const u_char *cp, u_int length) { register u_int option_len; const char *sep = """"; for (; length > 0; cp += option_len, length -= option_len) { u_int option_code; ND_PRINT((ndo, ""%s"", sep)); sep = "",""; ND_TCHECK(*cp); option_code = *cp; ND_PRINT((ndo, ""%s"", tok2str(ip_option_values,""unknown %u"",option_code))); if (option_code == IPOPT_NOP || option_code == IPOPT_EOL) option_len = 1; else { ND_TCHECK(cp[1]); option_len = cp[1]; if (option_len < 2) { ND_PRINT((ndo, "" [bad length %u]"", option_len)); return; } } if (option_len > length) { ND_PRINT((ndo, "" [bad length %u]"", option_len)); return; } ND_TCHECK2(*cp, option_len); switch (option_code) { case IPOPT_EOL: return; case IPOPT_TS: ip_printts(ndo, cp, option_len); break; case IPOPT_RR:        case IPOPT_SSRR: case IPOPT_LSRR: if (ip_printroute(ndo, cp, option_len) == -1) goto trunc; break; case IPOPT_RA: if (option_len < 4) { ND_PRINT((ndo, "" [bad length %u]"", option_len)); break; } ND_TCHECK(cp[3]); if (EXTRACT_16BITS(&cp[2]) != 0) ND_PRINT((ndo, "" value %u"", EXTRACT_16BITS(&cp[2]))); break; case IPOPT_NOP:        case IPOPT_SECURITY: default: break; } } return; trunc: ND_PRINT((ndo, ""%s"", tstr)); }
Description: The IP parser in tcpdump before 4.9.2 has a buffer over-read in print-ip.c:ip_printts().
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int gtTileContig(TIFFRGBAImage* img, uint32* raster, uint32 w, uint32 h) { TIFF* tif = img->tif; tileContigRoutine put = img->put.contig; uint32 col, row, y, rowstoread; tmsize_t pos; uint32 tw, th; unsigned char* buf = NULL; int32 fromskew, toskew; uint32 nrow; int ret = 1, flip; uint32 this_tw, tocol; int32 this_toskew, leftmost_toskew; int32 leftmost_fromskew; uint32 leftmost_tw; tmsize_t bufsize; bufsize = TIFFTileSize(tif); if (bufsize == 0) { TIFFErrorExt(tif->tif_clientdata, TIFFFileName(tif), ""%s"", ""No space for tile buffer""); return (0); } TIFFGetField(tif, TIFFTAG_TILEWIDTH, &tw); TIFFGetField(tif, TIFFTAG_TILELENGTH, &th); flip = setorientation(img); if (flip & FLIP_VERTICALLY) { y = h - 1; toskew = -(int32)(tw + w); } else { y = 0; toskew = -(int32)(tw - w); } leftmost_fromskew = img->col_offset % tw; leftmost_tw = tw - leftmost_fromskew; leftmost_toskew = toskew + leftmost_fromskew; for (row = 0; ret != 0 && row < h; row += nrow) { rowstoread = th - (row + img->row_offset) % th; nrow = (row + rowstoread > h ? h - row : rowstoread); fromskew = leftmost_fromskew; this_tw = leftmost_tw; this_toskew = leftmost_toskew; tocol = 0; col = img->col_offset; while (tocol < w) { if (_TIFFReadTileAndAllocBuffer(tif, (void**) &buf, bufsize, col, row+img->row_offset, 0, 0)==(tmsize_t)(-1) && (buf == NULL || img->stoponerr)) { ret = 0; break; } pos = ((row+img->row_offset) % th) * TIFFTileRowSize(tif) + \ ((tmsize_t) fromskew * img->samplesperpixel); if (tocol + this_tw > w)  { fromskew = tw - (w - tocol); this_tw = tw - fromskew; this_toskew = toskew + fromskew; } (*put)(img, raster+y*w+tocol, tocol, y, this_tw, nrow, fromskew, this_toskew, buf + pos); tocol += this_tw; col += this_tw; fromskew = 0; this_tw = tw; this_toskew = toskew; } y += ((flip & FLIP_VERTICALLY) ? -(int32) nrow : (int32) nrow); } _TIFFfree(buf); if (flip & FLIP_HORIZONTALLY) { uint32 line; for (line = 0; line < h; line++) { uint32 *left = raster + (line * w); uint32 *right = left + w - 1; while ( left < right ) { uint32 temp = *left; *left = *right; *right = temp; left++; right--; } } } return (ret); }
Description: An integer overflow flaw was found in libtiff that exists in the tif_getimage.c file. This flaw allows an attacker to inject and execute arbitrary code when a user opens a crafted TIFF file. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int detach_capi_ctr(struct capi_ctr *ctr) { int err = 0; mutex_lock(&capi_controller_lock); ctr_down(ctr, CAPI_CTR_DETACHED); if (capi_controller[ctr->cnr - 1] != ctr) { err = -EINVAL; goto unlock_out; } capi_controller[ctr->cnr - 1] = NULL; ncontrollers--; if (ctr->procent) remove_proc_entry(ctr->procfn, NULL); printk(KERN_NOTICE ""kcapi: controller [%03d]: %s unregistered\n"", ctr->cnr, ctr->name); unlock_out: mutex_unlock(&capi_controller_lock); return err; }
Description: An issue was discovered in the Linux kernel before 5.14.15. There is an array-index-out-of-bounds flaw in the detach_capi_ctr function in drivers/isdn/capi/kcapi.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static uint32_t readU32(const uint8_t* data, size_t offset) { return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3]; }
Description: Integer overflow in the getCoverageFormat12 function in CmapCoverage.cpp in the Minikin library in Android 5.x before 5.1.1 LMY49G and 6.x before 2016-02-01 allows attackers to cause a denial of service (continuous rebooting) via an application that triggers loading of a crafted TTF font, aka internal bug 25645298.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void HeaderMapImpl::addCopy(const LowerCaseString& key, const std::string& value) { auto* entry = getExistingInline(key.get()); if (entry != nullptr) { appendToHeader(entry->value(), value); return; } HeaderString new_key; new_key.setCopy(key.get().c_str(), key.get().size()); HeaderString new_value; new_value.setCopy(value.c_str(), value.size()); insertByKey(std::move(new_key), std::move(new_value)); ASSERT(new_key.empty());     ASSERT(new_value.empty()); }
Description: Upon receiving each incoming request header data, Envoy will iterate over existing request headers to verify that the total size of the headers stays below a maximum limit. The implementation in versions 1.10.0 through 1.11.1 for HTTP/1.x traffic and all versions of Envoy for HTTP/2 traffic had O(n^2) performance characteristics. A remote attacker may craft a request that stays below the maximum request header size but consists of many thousands of small headers to consume CPU and result in a denial-of-service attack.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static GF_Err mp4_mux_done(GF_MP4MuxCtx *ctx, Bool is_final) { GF_Err e = GF_OK; u32 i, count; GF_PropertyEntry *pe=NULL; count = gf_list_count(ctx->tracks); for (i=0; i<count; i++) { u32 ctts_mode = ctx->ctmode; const GF_PropertyValue *p; Bool has_bframes = GF_FALSE; TrackWriter *tkw = gf_list_get(ctx->tracks, i); p = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ISOM_FORCE_NEGCTTS); if (p && p->value.boolean) ctts_mode = MP4MX_CT_NEGCTTS; if (tkw->min_neg_ctts<0) { if (ctts_mode==MP4MX_CT_NEGCTTS) { gf_isom_set_ctts_v1(ctx->file, tkw->track_num, (u32) -tkw->min_neg_ctts); } else { gf_isom_set_cts_packing(ctx->file, tkw->track_num, GF_TRUE); gf_isom_shift_cts_offset(ctx->file, tkw->track_num, (s32) tkw->min_neg_ctts); gf_isom_set_cts_packing(ctx->file, tkw->track_num, GF_FALSE); gf_isom_set_composition_offset_mode(ctx->file, tkw->track_num, GF_FALSE); mp4_mux_update_edit_list_for_bframes(ctx, tkw, ctts_mode); } has_bframes = GF_TRUE; } else if (tkw->has_ctts && (tkw->stream_type==GF_STREAM_VISUAL)) { mp4_mux_update_edit_list_for_bframes(ctx, tkw, ctts_mode); has_bframes = GF_TRUE; } else if (tkw->ts_delay || tkw->empty_init_dur) { gf_isom_update_edit_list_duration(ctx->file, tkw->track_num); } if (tkw->min_ts_seek_plus_one) { u64 min_ts = tkw->min_ts_seek_plus_one - 1; u64 mdur = gf_isom_get_media_duration(ctx->file, tkw->track_num); u32 delay = 0; if (tkw->clamp_ts_plus_one) { mdur = tkw->max_cts - tkw->min_cts; mdur += tkw->max_cts_samp_dur; } if (mdur > min_ts) mdur -= min_ts; else mdur = 0; if ((ctts_mode != MP4MX_CT_NEGCTTS) && (tkw->ts_delay<0) && (tkw->stream_type==GF_STREAM_VISUAL)) { delay = (u32) -tkw->ts_delay; } if (tkw->src_timescale != tkw->tk_timescale) { min_ts = gf_timestamp_rescale(min_ts, tkw->src_timescale, tkw->tk_timescale); delay = (u32) gf_timestamp_rescale(delay, tkw->src_timescale, tkw->tk_timescale); } mdur += delay; if (ctx->moovts != tkw->tk_timescale) { mdur = gf_timestamp_rescale(mdur, tkw->tk_timescale, ctx->moovts); } gf_isom_remove_edits(ctx->file, tkw->track_num); if (tkw->empty_init_dur) gf_isom_set_edit(ctx->file, tkw->track_num, 0, tkw->empty_init_dur, 0, GF_ISOM_EDIT_EMPTY); gf_isom_set_edit(ctx->file, tkw->track_num, tkw->empty_init_dur, mdur, min_ts, GF_ISOM_EDIT_NORMAL); } if (tkw->force_ctts) { GF_Err gf_isom_force_ctts(GF_ISOFile *file, u32 track); gf_isom_force_ctts(ctx->file, tkw->track_num); } gf_isom_purge_track_reference(ctx->file, tkw->track_num); if (ctx->importer && ctx->dur.num && ctx->dur.den) { u64 mdur = gf_isom_get_media_duration(ctx->file, tkw->track_num); u64 pdur = gf_isom_get_track_duration(ctx->file, tkw->track_num); if (pdur==mdur) { GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (""[MP4Mux] Imported %d frames - duration %g\n"", tkw->nb_samples, ((Double)mdur)/tkw->tk_timescale )); } else { GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (""[MP4Mux] Imported %d frames - media duration %g - track duration %g\n"", tkw->nb_samples, ((Double)mdur)/tkw->tk_timescale, ((Double)pdur)/ctx->moovts )); } } if (tkw->codecid == GF_CODECID_MPEG4_PART2) { Bool force_rewrite = GF_FALSE; u32 PL = tkw->media_profile_level; if (!PL) PL = 0x01; if (ctx->importer) { GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (""Indicated Profile: %s\n"", gf_m4v_get_profile_name((u8) PL) )); } if (has_bframes && (tkw->media_profile_level <= 3)) { PL = 0xF5; GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (""[MP4Mux] Indicated profile doesn't include B-VOPs - forcing %s\n"", gf_m4v_get_profile_name((u8) PL) )); force_rewrite = GF_TRUE; } if (PL != tkw->media_profile_level) { if (force_rewrite) { #ifndef GPAC_DISABLE_AV_PARSERS GF_ESD *esd = gf_isom_get_esd(ctx->file, tkw->track_num, tkw->stsd_idx); assert(esd); gf_m4v_rewrite_pl(&esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength, (u8) PL); gf_isom_change_mpeg4_description(ctx->file, tkw->track_num, tkw->stsd_idx, esd); gf_odf_desc_del((GF_Descriptor*)esd); #endif } if (!ctx->make_qt) gf_isom_set_pl_indication(ctx->file, GF_ISOM_PL_VISUAL, PL); } } if (tkw->has_append) gf_isom_refresh_size_info(ctx->file, tkw->track_num); if ((tkw->nb_samples == 1) && (ctx->dur.num>0) && ctx->dur.den) { u32 dur = (u32) gf_timestamp_rescale(ctx->dur.num, ctx->dur.den, tkw->tk_timescale); gf_isom_set_last_sample_duration(ctx->file, tkw->track_num, dur); } if (tkw->has_open_gop) { if (ctx->importer) { GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (""OpenGOP detected - adjusting file brand\n"")); } gf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_ISO6, GF_TRUE); } mp4_mux_set_hevc_groups(ctx, tkw); p = gf_filter_pid_get_info_str(tkw->ipid, ""ttxt:rem_last"", &pe); if (p && p->value.boolean) gf_isom_remove_sample(ctx->file, tkw->track_num, tkw->nb_samples); p = gf_filter_pid_get_info_str(tkw->ipid, ""ttxt:last_dur"", &pe); if (p) { u64 val = p->value.uint; if (tkw->src_timescale != tkw->tk_timescale) { val = gf_timestamp_rescale(val, tkw->src_timescale, tkw->tk_timescale); } gf_isom_set_last_sample_duration(ctx->file, tkw->track_num, (u32) val); } p = gf_filter_pid_get_info(tkw->ipid, GF_PROP_PID_FORCED_SUB, &pe); if (p) { gf_isom_set_forced_text(ctx->file, tkw->track_num, tkw->stsd_idx, p->value.uint); } if (tkw->is_nalu && ctx->pack_nal && (gf_isom_get_mode(ctx->file)!=GF_ISOM_OPEN_WRITE)) { u32 msize = 0; Bool do_rewrite = GF_FALSE; u32 j, stsd_count = gf_isom_get_sample_description_count(ctx->file, tkw->track_num); p = gf_filter_pid_get_info(tkw->ipid, GF_PROP_PID_MAX_NALU_SIZE, &pe); msize = gf_get_bit_size(p->value.uint); if (msize<8) msize = 8; else if (msize<16) msize = 16; else msize = 32; if (msize<=0xFFFF) { for (j=0; j<stsd_count; j++) { u32 k = 8 * gf_isom_get_nalu_length_field(ctx->file, tkw->track_num, j+1); if (k > msize) { do_rewrite = GF_TRUE; } } if (do_rewrite) { GF_LOG(GF_LOG_INFO, GF_LOG_MEDIA, (""[MP4Mux] Adjusting NALU SizeLength to %d bits\n"", msize )); gf_media_nal_rewrite_samples(ctx->file, tkw->track_num, msize); msize /= 8; for (j=0; j<stsd_count; j++) { gf_isom_set_nalu_length_field(ctx->file, tkw->track_num, j+1, msize); } } } } if (ctx->btrt && !tkw->skip_bitrate_update && ((tkw->nb_samples>1) || ctx->m4sys) ) gf_media_update_bitrate(ctx->file, tkw->track_num); if (!tkw->box_patched) { p = gf_filter_pid_get_property_str(tkw->ipid, ""boxpatch""); if (p && p->value.string) { e = gf_isom_apply_box_patch(ctx->file, tkw->track_id ? tkw->track_id : tkw->item_id, p->value.string, GF_FALSE); if (e) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MP4Mux] Unable to apply box patch %s to track %d: %s\n"", p->value.string, tkw->track_id, gf_error_to_string(e) )); } } tkw->box_patched = GF_TRUE; } } gf_filter_release_property(pe); if (ctx->boxpatch && !ctx->box_patched) { e = gf_isom_apply_box_patch(ctx->file, 0, ctx->boxpatch, GF_FALSE); if (e) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MP4Mux] Unable to apply box patch %s: %s\n"", ctx->boxpatch, gf_error_to_string(e) )); } ctx->box_patched = GF_TRUE; } if (ctx->owns_mov) { if (ctx->moovpad) gf_isom_set_inplace_padding(ctx->file, ctx->moovpad); switch (ctx->store) { case MP4MX_MODE_INTER: if (ctx->cdur.num==0) { e = gf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_STREAMABLE); } else { if (ctx->cdur.num < 0) ctx->cdur.num = 1000; e = gf_isom_make_interleave_ex(ctx->file, &ctx->cdur); } break; case MP4MX_MODE_FLAT: e = gf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_FLAT); break; case MP4MX_MODE_FASTSTART: e = gf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_FASTSTART); break; case MP4MX_MODE_TIGHT: e = gf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_TIGHT); break; } if (e) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MP4Mux] Failed to set storage mode: %s\n"", gf_error_to_string(e) )); gf_isom_delete(ctx->file); } else { e = gf_isom_close(ctx->file); if (e) { GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[MP4Mux] Failed to write file: %s\n"", gf_error_to_string(e) )); } } ctx->file = NULL; if (is_final) gf_filter_pid_set_eos(ctx->opid); } else { ctx->file = NULL; } return e; }
Description: Denial of Service in GitHub repository gpac/gpac prior to 2.3.0-DEV.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void SoftAVC::setDecodeArgs( ivd_video_decode_ip_t *ps_dec_ip, ivd_video_decode_op_t *ps_dec_op, OMX_BUFFERHEADERTYPE *inHeader, OMX_BUFFERHEADERTYPE *outHeader, size_t timeStampIx) { size_t sizeY = outputBufferWidth() * outputBufferHeight(); size_t sizeUV; uint8_t *pBuf; ps_dec_ip->u4_size = sizeof(ivd_video_decode_ip_t); ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t); ps_dec_ip->e_cmd = IVD_CMD_VIDEO_DECODE; if (inHeader) { ps_dec_ip->u4_ts = timeStampIx; ps_dec_ip->pv_stream_buffer = inHeader->pBuffer + inHeader->nOffset; ps_dec_ip->u4_num_Bytes = inHeader->nFilledLen; } else { ps_dec_ip->u4_ts = 0; ps_dec_ip->pv_stream_buffer = NULL; ps_dec_ip->u4_num_Bytes = 0; } if (outHeader) { pBuf = outHeader->pBuffer; } else { pBuf = mFlushOutBuffer; } sizeUV = sizeY / 4; ps_dec_ip->s_out_buffer.u4_min_out_buf_size[0] = sizeY; ps_dec_ip->s_out_buffer.u4_min_out_buf_size[1] = sizeUV; ps_dec_ip->s_out_buffer.u4_min_out_buf_size[2] = sizeUV; ps_dec_ip->s_out_buffer.pu1_bufs[0] = pBuf; ps_dec_ip->s_out_buffer.pu1_bufs[1] = pBuf + sizeY; ps_dec_ip->s_out_buffer.pu1_bufs[2] = pBuf + sizeY + sizeUV; ps_dec_ip->s_out_buffer.u4_num_bufs = 3; return; }
Description: libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-06-01 allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27833616.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static Gif_Stream * read_gif(Gif_Reader *grr, int read_flags, const char* landmark, Gif_ReadErrorHandler handler) { Gif_Stream *gfs; Gif_Image *gfi; Gif_Context gfc; int unknown_block_type = 0; if (gifgetc(grr) != 'G' || gifgetc(grr) != 'I' || gifgetc(grr) != 'F') return 0; (void)gifgetc(grr); (void)gifgetc(grr); (void)gifgetc(grr); gfs = Gif_NewStream(); gfi = Gif_NewImage(); gfc.stream = gfs; gfc.prefix = Gif_NewArray(Gif_Code, GIF_MAX_CODE); gfc.suffix = Gif_NewArray(uint8_t, GIF_MAX_CODE); gfc.length = Gif_NewArray(uint16_t, GIF_MAX_CODE); gfc.handler = handler; gfc.gfi = gfi; gfc.errors[0] = gfc.errors[1] = 0; if (!gfs || !gfi || !gfc.prefix || !gfc.suffix || !gfc.length) goto done; gfs->landmark = landmark; GIF_DEBUG((""\nGIF "")); if (!read_logical_screen_descriptor(gfs, grr)) goto done; GIF_DEBUG((""logscrdesc "")); while (!gifeof(grr)) { uint8_t block = gifgetbyte(grr); switch (block) { case ',':  GIF_DEBUG((""imageread %d "", gfs->nimages)); gfi->identifier = last_name; last_name = 0; if (!Gif_AddImage(gfs, gfi)) goto done; else if (!read_image(grr, &gfc, gfi, read_flags)) { Gif_RemoveImage(gfs, gfs->nimages - 1); gfi = 0; goto done; } gfc.gfi = gfi = Gif_NewImage(); if (!gfi) goto done; break; case ';':  GIF_DEBUG((""term\n"")); goto done; case '!':  block = gifgetbyte(grr); GIF_DEBUG((""ext(0x%02X) "", block)); switch (block) { case 0xF9: read_graphic_control_extension(&gfc, gfi, grr); break; case 0xCE: last_name = suck_data(last_name, 0, grr); break; case 0xFE: if (!read_comment_extension(gfi, grr)) goto done; break; case 0xFF: read_application_extension(&gfc, grr); break; default: read_unknown_extension(&gfc, grr, block, 0, 0); break; } break; default: if (!unknown_block_type) { char buf[256]; sprintf(buf, ""unknown block type %d at file offset %u"", block, grr->pos - 1); gif_read_error(&gfc, 1, buf); unknown_block_type = 1; } break; } } done: if (gfs && gfi) { Gif_Extension* gfex; gfs->end_comment = gfi->comment; gfi->comment = 0; gfs->end_extension_list = gfi->extension_list; gfi->extension_list = 0; for (gfex = gfs->end_extension_list; gfex; gfex = gfex->next) gfex->image = NULL; } Gif_DeleteImage(gfi); Gif_DeleteArray(last_name); Gif_DeleteArray(gfc.prefix); Gif_DeleteArray(gfc.suffix); Gif_DeleteArray(gfc.length); gfc.gfi = 0; if (gfs) gfs->errors = gfc.errors[1]; if (gfs && gfc.errors[1] == 0 && !(read_flags & GIF_READ_TRAILING_GARBAGE_OK) && !grr->eofer(grr)) gif_read_error(&gfc, 0, ""trailing garbage after GIF ignored""); gif_read_error(&gfc, -1, 0); return gfs; }
Description: A double-free bug in the read_gif function in gifread.c in gifsicle 1.90 allows a remote attacker to cause a denial-of-service attack or unspecified other impact via a maliciously crafted file, because last_name is mishandled, a different vulnerability than CVE-2017-1000421.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: AP4_Result AP4_StszAtom::SetSampleSize(AP4_Ordinal sample, AP4_Size sample_size) { if (sample > m_SampleCount || sample == 0) { return AP4_ERROR_OUT_OF_RANGE; } else { if (m_Entries.ItemCount() == 0) { if (sample_size != m_SampleSize) { if (sample == 1) { m_SampleSize = sample_size; return AP4_SUCCESS; } else { return AP4_ERROR_INVALID_PARAMETERS; } } } else { m_Entries[sample - 1] = sample_size; } return AP4_SUCCESS; } }
Description: An issue has been found in Bento4 1.5.1-624. It is a SEGV in AP4_StszAtom::GetSampleSize in Core/Ap4StszAtom.cpp.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void jpc_qmfb_split_colgrp(jpc_fix_t *a, int numrows, int stride, int parity) { int bufsize = JPC_CEILDIVPOW2(numrows, 1); jpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE]; jpc_fix_t *buf = splitbuf; jpc_fix_t *srcptr; jpc_fix_t *dstptr; register jpc_fix_t *srcptr2; register jpc_fix_t *dstptr2; register int n; register int i; int m; int hstartcol; if (bufsize > QMFB_SPLITBUFSIZE) { if (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) { abort(); } } if (numrows >= 2) { hstartcol = (numrows + 1 - parity) >> 1; m = numrows - hstartcol; n = m; dstptr = buf; srcptr = &a[(1 - parity) * stride]; while (n-- > 0) { dstptr2 = dstptr; srcptr2 = srcptr; for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) { *dstptr2 = *srcptr2; ++dstptr2; ++srcptr2; } dstptr += JPC_QMFB_COLGRPSIZE; srcptr += stride << 1; } dstptr = &a[(1 - parity) * stride]; srcptr = &a[(2 - parity) * stride]; n = numrows - m - (!parity); while (n-- > 0) { dstptr2 = dstptr; srcptr2 = srcptr; for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) { *dstptr2 = *srcptr2; ++dstptr2; ++srcptr2; } dstptr += stride; srcptr += stride << 1; } dstptr = &a[hstartcol * stride]; srcptr = buf; n = m; while (n-- > 0) { dstptr2 = dstptr; srcptr2 = srcptr; for (i = 0; i < JPC_QMFB_COLGRPSIZE; ++i) { *dstptr2 = *srcptr2; ++dstptr2; ++srcptr2; } dstptr += stride; srcptr += JPC_QMFB_COLGRPSIZE; } } if (buf != splitbuf) { jas_free(buf); } }
Description: A heap-buffer overflow vulnerability was found in QMFB code in JPC codec caused by buffer being allocated with too small size. jasper versions before 2.0.0 are affected.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void WasmBinaryBuilder::visitBlock(Block* curr) { if (debug) std::cerr << ""zz node: Block"" << std::endl; std::vector<Block*> stack; while (1) { curr->type = getType(); curr->name = getNextLabel(); breakStack.push_back({curr->name, curr->type != none}); stack.push_back(curr); auto peek = input[pos]; if (peek == BinaryConsts::Block) { readNextDebugLocation(); curr = allocator.alloc<Block>(); pos++; if (debugLocation.size()) { currFunction->debugLocations[curr] = *debugLocation.begin(); } continue; } else { break; } } Block* last = nullptr; while (stack.size() > 0) { curr = stack.back(); stack.pop_back(); size_t start = expressionStack.size();     if (last) { expressionStack.push_back(last); } last = curr; processExpressions(); size_t end = expressionStack.size(); if (end < start) { throwError(""block cannot pop from outside""); } pushBlockElements(curr, start, end); curr->finalize(curr->type, breakTargetNames.find(curr->name) != breakTargetNames.end() ); breakStack.pop_back(); breakTargetNames.erase(curr->name); } }
Description: A NULL pointer dereference was discovered in SExpressionWasmBuilder::makeBlock in wasm/wasm-s-parser.c in Binaryen 1.38.26. A crafted wasm input can cause a segmentation fault, leading to denial-of-service, as demonstrated by wasm-as.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static gboolean gvs_tuple_is_normal (GVariantSerialised value) { guint offset_size; gsize offset_ptr; gsize length; gsize offset; gsize i; if G_UNLIKELY (value.data == NULL && value.size != 0) return FALSE; offset_size = gvs_get_offset_size (value.size); length = g_variant_type_info_n_members (value.type_info); offset_ptr = value.size; offset = 0; for (i = 0; i < length; i++) { const GVariantMemberInfo *member_info; GVariantSerialised child; gsize fixed_size; guint alignment; gsize end; member_info = g_variant_type_info_member_info (value.type_info, i); child.type_info = member_info->type_info; child.depth = value.depth + 1; g_variant_type_info_query (child.type_info, &alignment, &fixed_size); while (offset & alignment) { if (offset > value.size || value.data[offset] != '\0') return FALSE; offset++; } child.data = value.data + offset; switch (member_info->ending_type) { case G_VARIANT_MEMBER_ENDING_FIXED: end = offset + fixed_size; break; case G_VARIANT_MEMBER_ENDING_LAST: end = offset_ptr; break; case G_VARIANT_MEMBER_ENDING_OFFSET: if (offset_ptr < offset_size) return FALSE; offset_ptr -= offset_size; if (offset_ptr < offset) return FALSE; end = gvs_read_unaligned_le (value.data + offset_ptr, offset_size); break; default: g_assert_not_reached (); } if (end < offset || end > offset_ptr) return FALSE; child.size = end - offset; if (child.size == 0) child.data = NULL; if (!g_variant_serialised_is_normal (child)) return FALSE; offset = end; } { gsize fixed_size; guint alignment; g_variant_type_info_query (value.type_info, &alignment, &fixed_size); if (fixed_size) { g_assert (fixed_size == value.size); g_assert (offset_ptr == value.size); if (i == 0) { if (value.data[offset++] != '\0') return FALSE; } else { while (offset & alignment) if (value.data[offset++] != '\0') return FALSE; } g_assert (offset == value.size); } } return offset_ptr == offset; }
Description: A flaw was found in GLib. GVariant deserialization is vulnerable to an exponential blowup issue where a crafted GVariant can cause excessive processing, leading to denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int hvm_load_segment_selector( enum x86_segment seg, uint16_t sel) { struct segment_register desctab, cs, segr; struct desc_struct *pdesc, desc; u8 dpl, rpl, cpl; bool_t writable; int fault_type = TRAP_invalid_tss; struct cpu_user_regs *regs = guest_cpu_user_regs(); struct vcpu *v = current; if ( regs->eflags & X86_EFLAGS_VM ) { segr.sel = sel; segr.base = (uint32_t)sel << 4; segr.limit = 0xffffu; segr.attr.bytes = 0xf3; hvm_set_segment_register(v, seg, &segr); return 0; } if ( (sel & 0xfffc) == 0 ) { if ( (seg == x86_seg_cs) || (seg == x86_seg_ss) ) goto fail; memset(&segr, 0, sizeof(segr)); segr.sel = sel; hvm_set_segment_register(v, seg, &segr); return 0; } if ( (seg == x86_seg_ldtr) && (sel & 4) ) goto fail; hvm_get_segment_register(v, x86_seg_cs, &cs); hvm_get_segment_register( v, (sel & 4) ? x86_seg_ldtr : x86_seg_gdtr, &desctab); if ( !desctab.attr.fields.p ) goto fail; if ( ((sel & 0xfff8) + 7) > desctab.limit ) goto fail; pdesc = hvm_map_entry(desctab.base + (sel & 0xfff8), &writable); if ( pdesc == NULL ) goto hvm_map_fail; do { desc = *pdesc; if ( (desc.b & (1u<<12)) == ((seg == x86_seg_ldtr) << 12) ) goto unmap_and_fail; dpl = (desc.b >> 13) & 3; rpl = sel & 3; cpl = cs.sel & 3; switch ( seg ) { case x86_seg_cs: if ( !(desc.b & _SEGMENT_CODE) ) goto unmap_and_fail; if ( !(desc.b & _SEGMENT_EC) && (dpl != rpl) ) goto unmap_and_fail; break; case x86_seg_ss: if ( (desc.b & (_SEGMENT_CODE|_SEGMENT_WR)) != _SEGMENT_WR ) goto unmap_and_fail; if ( (dpl != cpl) || (dpl != rpl) ) goto unmap_and_fail; break; case x86_seg_ldtr: if ( (desc.b & _SEGMENT_TYPE) != (2u<<8) ) goto unmap_and_fail; goto skip_accessed_flag; default: if ( (desc.b & (_SEGMENT_CODE|_SEGMENT_WR)) == _SEGMENT_CODE ) goto unmap_and_fail; if ( ((desc.b & (_SEGMENT_EC|_SEGMENT_CODE)) != (_SEGMENT_EC|_SEGMENT_CODE)) && ((dpl < cpl) || (dpl < rpl)) ) goto unmap_and_fail; break; } if ( !(desc.b & _SEGMENT_P) ) { fault_type = (seg != x86_seg_ss) ? TRAP_no_segment : TRAP_stack_error; goto unmap_and_fail; } } while ( !(desc.b & 0x100) &&  writable &&  (cmpxchg(&pdesc->b, desc.b, desc.b | 0x100) != desc.b) ); desc.b |= 0x100; skip_accessed_flag: hvm_unmap_entry(pdesc); segr.base = (((desc.b <<  0) & 0xff000000u) | ((desc.b << 16) & 0x00ff0000u) | ((desc.a >> 16) & 0x0000ffffu)); segr.attr.bytes = (((desc.b >>  8) & 0x00ffu) | ((desc.b >> 12) & 0x0f00u)); segr.limit = (desc.b & 0x000f0000u) | (desc.a & 0x0000ffffu); if ( segr.attr.fields.g ) segr.limit = (segr.limit << 12) | 0xfffu; segr.sel = sel; hvm_set_segment_register(v, seg, &segr); return 0; unmap_and_fail: hvm_unmap_entry(pdesc); fail: hvm_inject_hw_exception(fault_type, sel & 0xfffc); hvm_map_fail: return 1; }
Description: Xen 4.0.x through 4.7.x mishandle x86 task switches to VM86 mode, which allows local 32-bit x86 HVM guest OS users to gain privileges or cause a denial of service (guest OS crash) by leveraging a guest operating system that uses hardware task switching and allows a new task to start in VM86 mode.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int hvm_unmap_io_range_from_ioreq_server(struct domain *d, ioservid_t id, uint32_t type, uint64_t start, uint64_t end) { struct hvm_ioreq_server *s; int rc; spin_lock_recursive(&d->arch.hvm_domain.ioreq_server.lock); rc = -ENOENT; list_for_each_entry ( s, &d->arch.hvm_domain.ioreq_server.list, list_entry ) { if ( s == d->arch.hvm_domain.default_ioreq_server ) continue; if ( s->id == id ) { struct rangeset *r; switch ( type ) { case XEN_DMOP_IO_RANGE_PORT: case XEN_DMOP_IO_RANGE_MEMORY: case XEN_DMOP_IO_RANGE_PCI: r = s->range[type]; break; default: r = NULL; break; } rc = -EINVAL; if ( !r ) break; rc = -ENOENT; if ( !rangeset_contains_range(r, start, end) ) break; rc = rangeset_remove_range(r, start, end); break; } } spin_unlock_recursive(&d->arch.hvm_domain.ioreq_server.lock); return rc; }
Description: An issue was discovered in Xen 4.5.x through 4.9.x allowing attackers (who control a stub domain kernel or tool stack) to cause a denial of service (host OS crash) because of a missing comparison (of range start to range end) within the DMOP map/unmap implementation.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void bm_poly(Bitmap *b, BmPoint points[], unsigned int n) { unsigned int i; if(n < 2) return; for(i = 0; i < n - 1; i++) { bm_line(b, points[i].x, points[i].y, points[i+1].x, points[i+1].y); } bm_line(b, points[0].x, points[0].y, points[i].x, points[i].y); }
Description: wernsey/bitmap before 2018-08-18 allows a NULL pointer dereference via a 4-bit image.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static gint read_creator_block (FILE     *f, gint      image_ID, guint     total_len, PSPimage *ia) { long          data_start; guchar        buf[4]; guint16       keyword; guint32       length; gchar        *string; gchar        *title = NULL, *artist = NULL, *copyright = NULL, *description = NULL; guint32       dword; guint32       __attribute__((unused))cdate = 0; guint32       __attribute__((unused))mdate = 0; guint32       __attribute__((unused))appid; guint32       __attribute__((unused))appver; GString      *comment; GimpParasite *comment_parasite; data_start = ftell (f); comment = g_string_new (NULL); while (ftell (f) < data_start + total_len) { if (fread (buf, 4, 1, f) < 1 || fread (&keyword, 2, 1, f) < 1 || fread (&length, 4, 1, f) < 1) { g_message (""Error reading creator keyword chunk""); return -1; } if (memcmp (buf, ""~FL\0"", 4) != 0) { g_message (""Invalid keyword chunk header""); return -1; } keyword = GUINT16_FROM_LE (keyword); length = GUINT32_FROM_LE (length); switch (keyword) { case PSP_CRTR_FLD_TITLE: case PSP_CRTR_FLD_ARTIST: case PSP_CRTR_FLD_CPYRGHT: case PSP_CRTR_FLD_DESC: string = g_malloc (length + 1); if (fread (string, length, 1, f) < 1) { g_message (""Error reading creator keyword data""); g_free (string); return -1; } switch (keyword) { case PSP_CRTR_FLD_TITLE: g_free (title); title = string; break; case PSP_CRTR_FLD_ARTIST: g_free (artist); artist = string; break; case PSP_CRTR_FLD_CPYRGHT: g_free (copyright); copyright = string; break; case PSP_CRTR_FLD_DESC: g_free (description); description = string; break; default: g_free (string); } break; case PSP_CRTR_FLD_CRT_DATE: case PSP_CRTR_FLD_MOD_DATE: case PSP_CRTR_FLD_APP_ID: case PSP_CRTR_FLD_APP_VER: if (fread (&dword, 4, 1, f) < 1) { g_message (""Error reading creator keyword data""); return -1; } switch (keyword) { case PSP_CRTR_FLD_CRT_DATE: cdate = dword; break; case PSP_CRTR_FLD_MOD_DATE: mdate = dword; break; case PSP_CRTR_FLD_APP_ID: appid = dword; break; case PSP_CRTR_FLD_APP_VER: appver = dword; break; } break; default: if (try_fseek (f, length, SEEK_CUR) < 0) { return -1; } break; } } if (title) { g_string_append (comment, title); g_free (title); g_string_append (comment, ""\n""); } if (artist) { g_string_append (comment, artist); g_free (artist); g_string_append (comment, ""\n""); } if (copyright) { g_string_append (comment, ""Copyright ""); g_string_append (comment, copyright); g_free (copyright); g_string_append (comment, ""\n""); } if (description) { g_string_append (comment, description); g_free (description); g_string_append (comment, ""\n""); } if (comment->len > 0) { comment_parasite = gimp_parasite_new (""gimp-comment"", GIMP_PARASITE_PERSISTENT, strlen (comment->str) + 1, comment->str); gimp_image_attach_parasite (image_ID, comment_parasite); gimp_parasite_free (comment_parasite); } g_string_free (comment, FALSE); return 0; }
Description: In GIMP 2.8.22, there is a heap-based buffer over-read in read_creator_block in plug-ins/common/file-psp.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int set_evtchn_to_irq(evtchn_port_t evtchn, unsigned int irq) { unsigned row; unsigned col; if (evtchn >= xen_evtchn_max_channels()) return -EINVAL; row = EVTCHN_ROW(evtchn); col = EVTCHN_COL(evtchn); if (evtchn_to_irq[row] == NULL) { if (irq == -1) return 0; evtchn_to_irq[row] = (int *)get_zeroed_page(GFP_KERNEL); if (evtchn_to_irq[row] == NULL) return -ENOMEM; clear_evtchn_to_irq_row(row); } evtchn_to_irq[row][col] = irq; return 0; }
Description: An issue was discovered in the Linux kernel through 5.9.1, as used with Xen through 4.14.x. drivers/xen/events/events_base.c allows event-channel removal during the event-handling loop (a race condition). This can cause a use-after-free or NULL pointer dereference, as demonstrated by a dom0 crash via events for an in-reconfiguration paravirtualized device, aka CID-073d0552ead5.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: char * XkbVModMaskText(XkbDescPtr xkb, unsigned modMask, unsigned mask, unsigned format) { register int i, bit; int len; char *mm, *rtrn; char *str, buf[BUFFER_SIZE]; if ((modMask == 0) && (mask == 0)) { rtrn = tbGetBuffer(5); if (format == XkbCFile) sprintf(rtrn, ""0""); else sprintf(rtrn, ""none""); return rtrn; } if (modMask != 0) mm = XkbModMaskText(modMask, format); else mm = NULL; str = buf; buf[0] = '\0'; if (mask) { char *tmp; for (i = 0, bit = 1; i < XkbNumVirtualMods; i++, bit <<= 1) { if (mask & bit) { tmp = XkbVModIndexText(xkb, i, format); len = strlen(tmp) + 1 + (str == buf ? 0 : 1); if (format == XkbCFile) len += 4; if ((str - (buf + len)) <= BUFFER_SIZE) { if (str != buf) { if (format == XkbCFile) *str++ = '|'; else *str++ = '+'; len--; } } if (format == XkbCFile) sprintf(str, ""%sMask"", tmp); else strcpy(str, tmp); str = &str[len - 1]; } } str = buf; } else str = NULL; if (mm) len = strlen(mm); else len = 0; if (str) len += strlen(str) + (mm == NULL ? 0 : 1); if (len >= BUFFER_SIZE) len = BUFFER_SIZE - 1; rtrn = tbGetBuffer(len + 1); rtrn[0] = '\0'; if (mm != NULL) { i = strlen(mm); if (i > len) i = len; strcpy(rtrn, mm); } else { i = 0; } if (str != NULL) { if (mm != NULL) { if (format == XkbCFile) strcat(rtrn, ""|""); else strcat(rtrn, ""+""); } strncat(rtrn, str, len - i); } rtrn[len] = '\0'; return rtrn; }
Description: In X.Org Server (aka xserver and xorg-server) before 1.19.4, a local attacker authenticated to the X server could overflow a global buffer, causing crashes of the X server or potentially other problems by injecting large or malformed XKB related atoms and accessing them via xkbcomp.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Status BuildInputArgIndex(const OpDef::ArgDef& arg_def, AttrSlice attr_values, const FunctionDef::ArgAttrs* arg_attrs, bool ints_on_device, int64_t resource_arg_unique_id) { bool is_type_list; DataTypeVector dtypes; TF_RETURN_IF_ERROR( ArgNumType(attr_values, arg_def, &is_type_list, &dtypes)); CHECK_GE(dtypes.size(), size_t{1}); int arg_index = result_.nodes.size(); TF_RETURN_IF_ERROR( AddItem(arg_def.name(), {true, arg_index, 0, is_type_list, dtypes})); for (size_t i = 0; i < dtypes.size(); ++i) { TF_RETURN_IF_ERROR(AddItem(strings::StrCat(arg_def.name(), "":"", i), {true, arg_index, 0, false, {dtypes[i]}})); DCHECK_EQ(arg_index, result_.nodes.size()); string name = arg_def.name(); if (dtypes.size() > 1) { strings::StrAppend(&name, ""_"", i); } NodeDef* gnode = AddNode(name); if (ints_on_device && dtypes[i] == DataType::DT_INT32) { gnode->set_op(FunctionLibraryDefinition::kDeviceArgOp); } else { gnode->set_op(FunctionLibraryDefinition::kArgOp); } DataType dtype = arg_def.is_ref() ? MakeRefType(dtypes[i]) : dtypes[i]; AddAttr(""T"", dtype, gnode); AddAttr(""index"", arg_index, gnode); if (resource_arg_unique_id >= 0) { AddAttr(""_resource_arg_unique_id"", resource_arg_unique_id, gnode); } if (arg_attrs) { for (const auto& arg_attr : arg_attrs->attr()) { AddAttr(arg_attr.first, arg_attr.second, gnode->mutable_attr()); } } result_.arg_types.push_back(dtypes[i]); ++arg_index; } return Status::OK(); }
Description: Tensorflow is an Open Source Machine Learning Framework. A malicious user can cause a denial of service by altering a `SavedModel` such that assertions in `function.cc` would be falsified and crash the Python interpreter. The fix will be included in TensorFlow 2.8.0. We will also cherrypick this commit on TensorFlow 2.7.1, TensorFlow 2.6.3, and TensorFlow 2.5.3, as these are also affected and still in supported range.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void sofia_handle_sip_i_reinvite(switch_core_session_t *session, nua_t *nua, sofia_profile_t *profile, nua_handle_t *nh, sofia_private_t *sofia_private, sip_t const *sip, sofia_dispatch_event_t *de, tagi_t tags[]) { char *call_info = NULL; switch_channel_t *channel = NULL; private_object_t *tech_pvt = NULL; nua_respond(nh, SIP_100_TRYING, TAG_END()); if (session) { channel = switch_core_session_get_channel(session); tech_pvt = switch_core_session_get_private(session); if (sip && sip->sip_payload && sip->sip_payload->pl_data) { tech_pvt->mparams.last_sdp_str = switch_core_session_strdup(session, sip->sip_payload->pl_data); } } if (session && profile && sip && sofia_test_pflag(profile, PFLAG_TRACK_CALLS)) { switch_channel_t *channel = switch_core_session_get_channel(session); private_object_t *tech_pvt = (private_object_t *) switch_core_session_get_private(session); char network_ip[80]; int network_port = 0; char via_space[2048]; char branch[16] = """"; sofia_glue_store_session_id(session, profile, sip, 0); sofia_clear_flag(tech_pvt, TFLAG_GOT_ACK); sofia_glue_get_addr(de->data->e_msg, network_ip, sizeof(network_ip), &network_port); switch_stun_random_string(branch, sizeof(branch) - 1, ""0123456789abcdef""); switch_snprintf(via_space, sizeof(via_space), ""SIP/2.0/UDP %s;rport=%d;branch=%s"", network_ip, network_port, branch); switch_channel_set_variable(channel, ""sip_full_via"", via_space); switch_channel_set_variable_printf(channel, ""sip_network_port"", ""%d"", network_port); switch_channel_set_variable_printf(channel, ""sip_recieved_port"", ""%d"", network_port); switch_channel_set_variable_printf(channel, ""sip_via_rport"", ""%d"", network_port); switch_core_recovery_track(session); } if (profile && sofia_test_pflag(profile, PFLAG_MANAGE_SHARED_APPEARANCE)) { if (channel && sip && sip->sip_call_info) { char *p; if ((call_info = sip_header_as_string(nua_handle_home(nh), (void *) sip->sip_call_info))) { if (switch_stristr(""appearance"", call_info)) { switch_channel_set_variable(channel, ""presence_call_info_full"", call_info); if ((p = strchr(call_info, ';'))) { switch_channel_set_variable(channel, ""presence_call_info"", p + 1); } } su_free(nua_handle_home(nh), call_info); } } } if (channel) { if (tech_pvt->mparams.last_sdp_str) { tech_pvt->mparams.prev_sdp_str = tech_pvt->mparams.last_sdp_str; } tech_pvt->mparams.last_sdp_str = NULL; if (sip && sip->sip_payload && sip->sip_payload->pl_data) { if (!zstr(tech_pvt->mparams.prev_sdp_str) && strcmp(tech_pvt->mparams.prev_sdp_str, sip->sip_payload->pl_data)) { switch_channel_set_variable(channel, ""sip_reinvite_sdp"", sip->sip_payload->pl_data); tech_pvt->mparams.last_sdp_str = switch_core_session_strdup(session, sip->sip_payload->pl_data); } else { tech_pvt->mparams.last_sdp_str = tech_pvt->mparams.prev_sdp_str; } } switch_channel_execute_on(channel, ""execute_on_sip_reinvite""); } }
Description: An issue was discovered in function sofia_handle_sip_i_notify in sofia.c in SignalWire freeswitch before 1.10.6, may allow attackers to view sensitive information due to an uninitialized value.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void EXPORT_CALL lou_logFile(const char *fileName) { if (logFile) { fclose(logFile); logFile = NULL; } if (fileName == NULL || fileName[0] == 0 || strlen(fileName) >= 256) return; if (initialLogFileName[0] == 0) strcpy(initialLogFileName, fileName); logFile = fopen(fileName, ""a""); if (logFile == NULL && initialLogFileName[0] != 0) logFile = fopen(initialLogFileName, ""a""); if (logFile == NULL) { fprintf(stderr, ""Cannot open log file %s\n"", fileName); logFile = stderr; } }
Description: Buffer Overflow vulnerability found in Liblouis v.3.24.0 allows a remote attacker to cause a denial of service via the compileTranslationTable.c and lou_setDataPath functions.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int io_register_enable_rings(struct io_ring_ctx *ctx) { if (!(ctx->flags & IORING_SETUP_R_DISABLED)) return -EBADFD; if (ctx->restrictions.registered) ctx->restricted = 1; ctx->flags &= ~IORING_SETUP_R_DISABLED; io_sq_offload_start(ctx); return 0; }
Description: An issue was discovered in fs/io_uring.c in the Linux kernel through 5.11.8. It allows attackers to cause a denial of service (deadlock) because exit may be waiting to park a SQPOLL thread, but concurrently that SQPOLL thread is waiting for a signal to start, aka CID-3ebba796fa25.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Expression* Eval::operator()(Binary_Expression* b_in) { Expression_Obj lhs = b_in->left(); Expression_Obj rhs = b_in->right(); enum Sass_OP op_type = b_in->optype(); if (op_type == Sass_OP::AND) { lhs = lhs->perform(this); if (!*lhs) return lhs.detach(); return rhs->perform(this); } else if (op_type == Sass_OP::OR) { lhs = lhs->perform(this); if (*lhs) return lhs.detach(); return rhs->perform(this); } while (Variable* l_v = Cast<Variable>(lhs)) { lhs = operator()(l_v); } while (Variable* r_v = Cast<Variable>(rhs)) { rhs = operator()(r_v); } Binary_Expression_Obj b = b_in; while (Binary_Expression* l_b = Cast<Binary_Expression>(lhs)) { if (!force && l_b->is_delayed()) break; lhs = operator()(l_b); } while (Binary_Expression* r_b = Cast<Binary_Expression>(rhs)) { if (!force && r_b->is_delayed()) break; rhs = operator()(r_b); } if (!force && op_type == Sass_OP::DIV && b->is_delayed()) { b->right(b->right()->perform(this)); b->left(b->left()->perform(this)); return b.detach(); } if (Number* l_n = Cast<Number>(lhs)) { if (Number* r_n = Cast<Number>(rhs)) { try { switch (op_type) { case Sass_OP::EQ: return *l_n == *r_n ? bool_true : bool_false; case Sass_OP::NEQ: return *l_n == *r_n ? bool_false : bool_true; case Sass_OP::LT: return *l_n < *r_n ? bool_true : bool_false; case Sass_OP::GTE: return *l_n < *r_n ? bool_false : bool_true; case Sass_OP::LTE: return *l_n < *r_n || *l_n == *r_n ? bool_true : bool_false; case Sass_OP::GT: return *l_n < *r_n || *l_n == *r_n ? bool_false : bool_true; case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD: return Operators::op_numbers(op_type, *l_n, *r_n, options(), b_in->pstate()); default: break; } } catch (Exception::OperationError& err) { traces.push_back(Backtrace(b_in->pstate())); throw Exception::SassValueError(traces, b_in->pstate(), err); } } else if (Color* r_col = Cast<Color>(rhs)) { Color_RGBA_Obj r_c = r_col->toRGBA(); try { switch (op_type) { case Sass_OP::EQ: return *l_n == *r_c ? bool_true : bool_false; case Sass_OP::NEQ: return *l_n == *r_c ? bool_false : bool_true; case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD: return Operators::op_number_color(op_type, *l_n, *r_c, options(), b_in->pstate()); default: break; } } catch (Exception::OperationError& err) { traces.push_back(Backtrace(b_in->pstate())); throw Exception::SassValueError(traces, b_in->pstate(), err); } } } else if (Color* l_col = Cast<Color>(lhs)) { Color_RGBA_Obj l_c = l_col->toRGBA(); if (Color* r_col = Cast<Color>(rhs)) { Color_RGBA_Obj r_c = r_col->toRGBA(); try { switch (op_type) { case Sass_OP::EQ: return *l_c == *r_c ? bool_true : bool_false; case Sass_OP::NEQ: return *l_c == *r_c ? bool_false : bool_true; case Sass_OP::LT: return *l_c < *r_c ? bool_true : bool_false; case Sass_OP::GTE: return *l_c < *r_c ? bool_false : bool_true; case Sass_OP::LTE: return *l_c < *r_c || *l_c == *r_c ? bool_true : bool_false; case Sass_OP::GT: return *l_c < *r_c || *l_c == *r_c ? bool_false : bool_true; case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD: return Operators::op_colors(op_type, *l_c, *r_c, options(), b_in->pstate()); default: break; } } catch (Exception::OperationError& err) { traces.push_back(Backtrace(b_in->pstate())); throw Exception::SassValueError(traces, b_in->pstate(), err); } } else if (Number* r_n = Cast<Number>(rhs)) { try { switch (op_type) { case Sass_OP::EQ: return *l_c == *r_n ? bool_true : bool_false; case Sass_OP::NEQ: return *l_c == *r_n ? bool_false : bool_true; case Sass_OP::ADD: case Sass_OP::SUB: case Sass_OP::MUL: case Sass_OP::DIV: case Sass_OP::MOD: return Operators::op_color_number(op_type, *l_c, *r_n, options(), b_in->pstate()); default: break; } } catch (Exception::OperationError& err) { traces.push_back(Backtrace(b_in->pstate())); throw Exception::SassValueError(traces, b_in->pstate(), err); } } } String_Schema_Obj ret_schema; if (String_Schema* s_l = Cast<String_Schema>(b->left())) { if (!s_l->has_interpolant() && (!s_l->is_right_interpolant())) { ret_schema = SASS_MEMORY_NEW(String_Schema, b->pstate()); Binary_Expression_Obj bin_ex = SASS_MEMORY_NEW(Binary_Expression, b->pstate(), b->op(), s_l->last(), b->right()); bin_ex->is_delayed(b->left()->is_delayed() || b->right()->is_delayed());         for (size_t i = 0; i < s_l->length() - 1; ++i) { ret_schema->append(Cast<PreValue>(s_l->at(i)->perform(this))); } ret_schema->append(Cast<PreValue>(bin_ex->perform(this))); return ret_schema->perform(this); } } if (String_Schema* s_r = Cast<String_Schema>(b->right())) { if (!s_r->has_interpolant() && (!s_r->is_left_interpolant() || op_type == Sass_OP::DIV)) { ret_schema = SASS_MEMORY_NEW(String_Schema, b->pstate()); Binary_Expression_Obj bin_ex = SASS_MEMORY_NEW(Binary_Expression, b->pstate(), b->op(), b->left(), s_r->first()); bin_ex->is_delayed(b->left()->is_delayed() || b->right()->is_delayed());         ret_schema->append(Cast<PreValue>(bin_ex->perform(this))); for (size_t i = 1; i < s_r->length(); ++i) { ret_schema->append(Cast<PreValue>(s_r->at(i)->perform(this))); } return ret_schema->perform(this); } } if (op_type == Sass_OP::EQ || op_type == Sass_OP::NEQ || op_type == Sass_OP::GT || op_type == Sass_OP::GTE || op_type == Sass_OP::LT || op_type == Sass_OP::LTE) { LOCAL_FLAG(force, true); lhs->is_expanded(false); lhs->set_delayed(false); lhs = lhs->perform(this); rhs->is_expanded(false); rhs->set_delayed(false); rhs = rhs->perform(this); } else { lhs = lhs->perform(this); } rhs = rhs->perform(this); AST_Node_Obj lu = lhs; AST_Node_Obj ru = rhs; Expression::Type l_type; Expression::Type r_type; String_Schema_Obj s1 = Cast<String_Schema>(b->left()); String_Schema_Obj s2 = Cast<String_Schema>(b->right()); Binary_Expression_Obj b1 = Cast<Binary_Expression>(b->left()); Binary_Expression_Obj b2 = Cast<Binary_Expression>(b->right()); bool schema_op = false; bool force_delay = (s2 && s2->is_left_interpolant()) || (s1 && s1->is_right_interpolant()) || (b1 && b1->is_right_interpolant()) || (b2 && b2->is_left_interpolant()); if ((s1 && s1->has_interpolants()) || (s2 && s2->has_interpolants()) || force_delay) { if (op_type == Sass_OP::DIV || op_type == Sass_OP::MUL || op_type == Sass_OP::MOD || op_type == Sass_OP::ADD || op_type == Sass_OP::SUB || op_type == Sass_OP::EQ) { if (String_Constant* str = Cast<String_Constant>(lhs)) { std::string value(str->value()); const char* start = value.c_str(); if (Prelexer::sequence < Prelexer::dimension, Prelexer::end_of_file >(start) != 0) { lhs = Parser::lexed_dimension(b->pstate(), str->value()); } } if (String_Constant* str = Cast<String_Constant>(rhs)) { std::string value(str->value()); const char* start = value.c_str(); if (Prelexer::sequence < Prelexer::dimension, Prelexer::number >(start) != 0) { rhs = Parser::lexed_dimension(b->pstate(), str->value()); } } } To_Value to_value(ctx); Value_Obj v_l = Cast<Value>(lhs->perform(&to_value)); Value_Obj v_r = Cast<Value>(rhs->perform(&to_value)); if (force_delay) { std::string str(""""); str += v_l->to_string(options()); if (b->op().ws_before) str += "" ""; str += b->separator(); if (b->op().ws_after) str += "" ""; str += v_r->to_string(options()); String_Constant* val = SASS_MEMORY_NEW(String_Constant, b->pstate(), str); val->is_interpolant(b->left()->has_interpolant()); return val; } } try { switch(op_type) { case Sass_OP::EQ:  return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::eq(lhs, rhs)); case Sass_OP::NEQ: return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::neq(lhs, rhs)); case Sass_OP::GT:  return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::gt(lhs, rhs)); case Sass_OP::GTE: return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::gte(lhs, rhs)); case Sass_OP::LT:  return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::lt(lhs, rhs)); case Sass_OP::LTE: return SASS_MEMORY_NEW(Boolean, b->pstate(), Operators::lte(lhs, rhs)); default: break; } } catch (Exception::OperationError& err) { traces.push_back(Backtrace(b->pstate())); throw Exception::SassValueError(traces, b->pstate(), err); } l_type = lhs->concrete_type(); r_type = rhs->concrete_type(); Expression_Obj rv; try { ParserState pstate(b->pstate()); if (l_type == Expression::NUMBER && r_type == Expression::NUMBER) { Number* l_n = Cast<Number>(lhs); Number* r_n = Cast<Number>(rhs); l_n->reduce(); r_n->reduce(); rv = Operators::op_numbers(op_type, *l_n, *r_n, options(), pstate); } else if (l_type == Expression::NUMBER && r_type == Expression::COLOR) { Number* l_n = Cast<Number>(lhs); Color_RGBA_Obj r_c = Cast<Color>(rhs)->toRGBA(); rv = Operators::op_number_color(op_type, *l_n, *r_c, options(), pstate); } else if (l_type == Expression::COLOR && r_type == Expression::NUMBER) { Color_RGBA_Obj l_c = Cast<Color>(lhs)->toRGBA(); Number* r_n = Cast<Number>(rhs); rv = Operators::op_color_number(op_type, *l_c, *r_n, options(), pstate); } else if (l_type == Expression::COLOR && r_type == Expression::COLOR) { Color_RGBA_Obj l_c = Cast<Color>(lhs)->toRGBA(); Color_RGBA_Obj r_c = Cast<Color>(rhs)->toRGBA(); rv = Operators::op_colors(op_type, *l_c, *r_c, options(), pstate); } else { To_Value to_value(ctx); Value_Obj v_l = Cast<Value>(lhs->perform(&to_value)); Value_Obj v_r = Cast<Value>(rhs->perform(&to_value)); bool interpolant = b->is_right_interpolant() || b->is_left_interpolant() || b->is_interpolant(); if (op_type == Sass_OP::SUB) interpolant = false; if (l_type == Expression::MAP || l_type == Expression::FUNCTION_VAL) { traces.push_back(Backtrace(v_l->pstate())); throw Exception::InvalidValue(traces, *v_l); } if (r_type == Expression::MAP || l_type == Expression::FUNCTION_VAL) { traces.push_back(Backtrace(v_r->pstate())); throw Exception::InvalidValue(traces, *v_r); } Value* ex = Operators::op_strings(b->op(), *v_l, *v_r, options(), pstate, !interpolant);         if (String_Constant* str = Cast<String_Constant>(ex)) { if (str->concrete_type() == Expression::STRING) { String_Constant* lstr = Cast<String_Constant>(lhs); String_Constant* rstr = Cast<String_Constant>(rhs); if (op_type != Sass_OP::SUB) { if (String_Constant* org = lstr ? lstr : rstr) { str->quote_mark(org->quote_mark()); } } } } ex->is_interpolant(b->is_interpolant()); rv = ex; } } catch (Exception::OperationError& err) { traces.push_back(Backtrace(b->pstate())); throw Exception::SassValueError(traces, b->pstate(), err); } if (rv) { if (schema_op) { (*s2)[0] = rv; rv = s2->perform(this); } } return rv.detach(); }
Description: LibSass before 3.6.3 allows a heap-based buffer over-read in Sass::weaveParents in ast_sel_weave.cpp.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int ossl_ffc_validate_public_key_partial(const FFC_PARAMS *params, const BIGNUM *pub_key, int *ret) { int ok = 0; BIGNUM *tmp = NULL; BN_CTX *ctx = NULL; *ret = 0; ctx = BN_CTX_new_ex(NULL); if (ctx == NULL) goto err; BN_CTX_start(ctx); tmp = BN_CTX_get(ctx); if (tmp == NULL || !BN_set_word(tmp, 1)) goto err; if (BN_cmp(pub_key, tmp) <= 0) { *ret |= FFC_ERROR_PUBKEY_TOO_SMALL; goto err; } if (BN_copy(tmp, params->p) == NULL || !BN_sub_word(tmp, 1)) goto err; if (BN_cmp(pub_key, tmp) >= 0) { *ret |= FFC_ERROR_PUBKEY_TOO_LARGE; goto err; } ok = 1; err: if (ctx != NULL) { BN_CTX_end(ctx); BN_CTX_free(ctx); } return ok; }
Description: An invalid pointer dereference on read can be triggered when an
application tries to check a malformed DSA public key by the
EVP_PKEY_public_check() function. This will most likely lead
to an application crash. This function can be called on public
keys supplied from untrusted sources which could allow an attacker
to cause a denial of service attack.

The TLS implementation in OpenSSL does not call this function
but applications might call the function if there are additional
security requirements imposed by standards such as FIPS 140-3.


 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: LoadWatcher(ScriptContext* context, content::RenderFrame* frame, v8::Local<v8::Function> cb) : content::RenderFrameObserver(frame), context_(context), callback_(context->isolate(), cb) { if (ExtensionFrameHelper::Get(frame)-> did_create_current_document_element()) { base::MessageLoop::current()->PostTask( FROM_HERE, base::Bind(&LoadWatcher::CallbackAndDie, base::Unretained(this), true)); } }
Description: extensions/renderer/render_frame_observer_natives.cc in Google Chrome before 49.0.2623.75 does not properly consider object lifetimes and re-entrancy issues during OnDocumentElementCreated handling, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via unknown vectors.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void SearchBoxExtensionWrapper::NavigateContentWindow( const v8::FunctionCallbackInfo<v8::Value>& args) { content::RenderView* render_view = GetRenderView(); if (!render_view) return; if (!args.Length()) { ThrowInvalidParameters(args); return; } GURL destination_url; bool is_most_visited_item_url = false; if (args[0]->IsNumber()) { InstantMostVisitedItem item; if (SearchBox::Get(render_view)->GetMostVisitedItemWithID( args[0]->IntegerValue(), &item)) { destination_url = item.url; is_most_visited_item_url = true; } } else { const base::string16& possibly_relative_url = V8ValueToUTF16(args[0]); GURL current_url = GetCurrentURL(render_view); destination_url = internal::ResolveURL(current_url, possibly_relative_url); } DVLOG(1) << render_view << "" NavigateContentWindow: "" << destination_url; if (destination_url.is_valid() && !destination_url.SchemeIs(url::kJavaScriptScheme)) { WindowOpenDisposition disposition = CURRENT_TAB; if (args[1]->IsNumber()) { disposition = (WindowOpenDisposition) args[1]->Uint32Value(); } SearchBox::Get(render_view)->NavigateToURL(destination_url, disposition, is_most_visited_item_url); } }
Description: The Chrome Instant feature in Google Chrome before 48.0.2564.109 does not ensure that a New Tab Page (NTP) navigation target is on the most-visited or suggestions list, which allows remote attackers to bypass intended restrictions via unspecified vectors, related to instant_service.cc and search_tab_helper.cc.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void g_variant_fill_gvs (GVariantSerialised *serialised, gpointer            data) { GVariant *value = data; g_variant_lock (value); g_variant_ensure_size (value); g_variant_unlock (value); if (serialised->type_info == NULL) serialised->type_info = value->type_info; g_assert (serialised->type_info == value->type_info); if (serialised->size == 0) serialised->size = value->size; g_assert (serialised->size == value->size); serialised->depth = value->depth; if (serialised->data) g_variant_store (value, serialised->data); }
Description: A flaw was found in GLib. GVariant deserialization is vulnerable to an exponential blowup issue where a crafted GVariant can cause excessive processing, leading to denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static bfd_boolean process_archive_index_and_symbols (struct archive_info *  arch, unsigned int           sizeof_ar_index, bfd_boolean            read_symbols) { size_t got; unsigned long size; size = strtoul (arch->arhdr.ar_size, NULL, 10); if ((signed long) size < 0) { error (_(""%s: invalid archive header size: %ld\n""), arch->file_name, size); return FALSE; } size = size + (size & 1); arch->next_arhdr_offset += sizeof arch->arhdr + size; if (! read_symbols) { if (fseek (arch->file, size, SEEK_CUR) != 0) { error (_(""%s: failed to skip archive symbol table\n""), arch->file_name); return FALSE; } } else { unsigned long i; unsigned char integer_buffer[sizeof arch->index_num]; unsigned char * index_buffer; assert (sizeof_ar_index <= sizeof integer_buffer); if (size < sizeof_ar_index) { error (_(""%s: the archive index is empty\n""), arch->file_name); return FALSE; } got = fread (integer_buffer, 1, sizeof_ar_index, arch->file); if (got != sizeof_ar_index) { error (_(""%s: failed to read archive index\n""), arch->file_name); return FALSE; } arch->index_num = byte_get_big_endian (integer_buffer, sizeof_ar_index); size -= sizeof_ar_index; if (size < arch->index_num * sizeof_ar_index || size < arch->index_num) { error (_(""%s: the archive index is supposed to have 0x%lx entries of %d bytes, but the size is only 0x%lx\n""), arch->file_name, (long) arch->index_num, sizeof_ar_index, size); return FALSE; } index_buffer = (unsigned char *) malloc (arch->index_num * sizeof_ar_index); if (index_buffer == NULL) { error (_(""Out of memory whilst trying to read archive symbol index\n"")); return FALSE; } got = fread (index_buffer, sizeof_ar_index, arch->index_num, arch->file); if (got != arch->index_num) { free (index_buffer); error (_(""%s: failed to read archive index\n""), arch->file_name); return FALSE; } size -= arch->index_num * sizeof_ar_index; arch->index_array = (elf_vma *) malloc (arch->index_num * sizeof (* arch->index_array)); if (arch->index_array == NULL) { free (index_buffer); error (_(""Out of memory whilst trying to convert the archive symbol index\n"")); return FALSE; } for (i = 0; i < arch->index_num; i++) arch->index_array[i] = byte_get_big_endian ((unsigned char *) (index_buffer + (i * sizeof_ar_index)), sizeof_ar_index); free (index_buffer); if (size < 1) { error (_(""%s: the archive has an index but no symbols\n""), arch->file_name); return FALSE; } arch->sym_table = (char *) malloc (size); if (arch->sym_table == NULL) { error (_(""Out of memory whilst trying to read archive index symbol table\n"")); return FALSE; } arch->sym_size = size; got = fread (arch->sym_table, 1, size, arch->file); if (got != size) { error (_(""%s: failed to read archive index symbol table\n""), arch->file_name); return FALSE; } } got = fread (&arch->arhdr, 1, sizeof arch->arhdr, arch->file); if (got != sizeof arch->arhdr && got != 0) { error (_(""%s: failed to read archive header following archive index\n""), arch->file_name); return FALSE; } return TRUE; }
Description: elfcomm.c in readelf in GNU Binutils 2.29 allows remote attackers to cause a denial of service (excessive memory allocation) or possibly have unspecified other impact via a crafted ELF file that triggers a ""buffer overflow on fuzzed archive header,"" related to an uninitialized variable, an improper conditional jump, and the get_archive_member_name, process_archive_index_and_symbols, and setup_archive functions.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int run_post_create(const char *dirname) { if (!dir_is_in_dump_location(dirname)) { error_msg(""Bad problem directory name '%s', should start with: '%s'"", dirname, g_settings_dump_location); return 400;  } if (!dir_has_correct_permissions(dirname)) { error_msg(""Problem directory '%s' isn't owned by root:abrt or others are not restricted from access"", dirname); return 400;  } if (g_settings_privatereports) { struct dump_dir *dd = dd_opendir(dirname, DD_OPEN_READONLY); const bool complete = dd && problem_dump_dir_is_complete(dd); dd_close(dd); if (complete) { error_msg(""Problem directory '%s' has already been processed"", dirname); return 403; } } else if (!dump_dir_accessible_by_uid(dirname, client_uid)) { if (errno == ENOTDIR) { error_msg(""Path '%s' isn't problem directory"", dirname); return 404;  } error_msg(""Problem directory '%s' can't be accessed by user with uid %ld"", dirname, (long)client_uid); return 403;  } int child_stdout_fd; int child_pid = spawn_event_handler_child(dirname, ""post-create"", &child_stdout_fd); char *dup_of_dir = NULL; struct strbuf *cmd_output = strbuf_new(); bool child_is_post_create = 1;  read_child_output: for (;;) { char buf[250];  errno = 0; int r = safe_read(child_stdout_fd, buf, sizeof(buf) - 1); if (r <= 0) break; buf[r] = '\0'; char *raw = buf; char *newline; while ((newline = strchr(raw, '\n')) != NULL) { *newline = '\0'; strbuf_append_str(cmd_output, raw); char *msg = cmd_output->buf; log(""%s"", msg); if (child_is_post_create && prefixcmp(msg, ""DUP_OF_DIR: "") == 0 ) { free(dup_of_dir); dup_of_dir = xstrdup(msg + strlen(""DUP_OF_DIR: "")); } strbuf_clear(cmd_output); raw = newline + 1; } strbuf_append_str(cmd_output, raw); } int status = 0; if (safe_waitpid(child_pid, &status, 0) <= 0) perror_msg(""waitpid(%d)"", child_pid); if (!child_is_post_create) goto ret; if (status != 0) { if (WIFSIGNALED(status)) { log(""'post-create' on '%s' killed by signal %d"", dirname, WTERMSIG(status)); goto delete_bad_dir; } if (!dup_of_dir) { log(""'post-create' on '%s' exited with %d"", dirname, WEXITSTATUS(status)); goto delete_bad_dir; } } const char *work_dir = (dup_of_dir ? dup_of_dir : dirname); struct dump_dir *dd = dd_opendir(work_dir,  0); if (!dd) goto delete_bad_dir; char *count_str = dd_load_text_ext(dd, FILENAME_COUNT, DD_FAIL_QUIETLY_ENOENT); unsigned long count = strtoul(count_str, NULL, 10); if ((status != 0 && dup_of_dir) || count == 0) { count++; char new_count_str[sizeof(long)*3 + 2]; sprintf(new_count_str, ""%lu"", count); dd_save_text(dd, FILENAME_COUNT, new_count_str); if (strcmp(dd->dd_dirname, dirname) != 0) { struct dump_dir *new_dd = dd_opendir(dirname, DD_OPEN_READONLY); char *last_ocr = NULL; if (new_dd) { last_ocr = dd_load_text_ext(new_dd, FILENAME_TIME, DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE | DD_FAIL_QUIETLY_ENOENT); dd_close(new_dd); } else {    error_msg(""Can't read the last occurrence file from the new dump directory.""); } if (!last_ocr) {    log(""Using current time for the last occurrence file which may be incorrect.""); time_t t = time(NULL); last_ocr = xasprintf(""%lu"", (long)t); } dd_save_text(dd, FILENAME_LAST_OCCURRENCE, last_ocr); free(last_ocr); } } dd_sanitize_mode_and_owner(dd); dd_close(dd); if (!dup_of_dir) log_notice(""New problem directory %s, processing"", work_dir); else { log_warning(""Deleting problem directory %s (dup of %s)"", strrchr(dirname, '/') + 1, strrchr(dup_of_dir, '/') + 1); delete_dump_dir(dirname); } int fd; child_pid = spawn_event_handler_child( work_dir, (dup_of_dir ? ""notify-dup"" : ""notify""), &fd ); xmove_fd(fd, child_stdout_fd); child_is_post_create = 0; strbuf_clear(cmd_output); free(dup_of_dir); dup_of_dir = NULL; goto read_child_output; delete_bad_dir: log_warning(""Deleting problem directory '%s'"", dirname); delete_dump_dir(dirname); ret: strbuf_free(cmd_output); free(dup_of_dir); close(child_stdout_fd); return 0; }
Description: The default event handling scripts in Automatic Bug Reporting Tool (ABRT) allow local users to gain privileges as demonstrated by a symlink attack on a var_log_messages file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void win_redr_status(win_T *wp, int ignore_pum UNUSED) { introw; char_u*p; intlen; intfillchar; intattr; intthis_ru_col; static int  busy = FALSE; if (busy) return; busy = TRUE; row = statusline_row(wp); wp->w_redr_status = FALSE; if (wp->w_status_height == 0) { redraw_cmdline = TRUE; } else if (!redrawing() || (!ignore_pum && pum_visible())) { wp->w_redr_status = TRUE; } #ifdef FEAT_STL_OPT else if (*p_stl != NUL || *wp->w_p_stl != NUL) { redraw_custom_statusline(wp); } #endif else { fillchar = fillchar_status(&attr, wp); get_trans_bufname(wp->w_buffer); p = NameBuff; len = (int)STRLEN(p); if (bt_help(wp->w_buffer) #ifdef FEAT_QUICKFIX || wp->w_p_pvw #endif || bufIsChanged(wp->w_buffer) || wp->w_buffer->b_p_ro) *(p + len++) = ' '; if (bt_help(wp->w_buffer)) { STRCPY(p + len, _(""[Help]"")); len += (int)STRLEN(p + len); } #ifdef FEAT_QUICKFIX if (wp->w_p_pvw) { STRCPY(p + len, _(""[Preview]"")); len += (int)STRLEN(p + len); } #endif if (bufIsChanged(wp->w_buffer) #ifdef FEAT_TERMINAL && !bt_terminal(wp->w_buffer) #endif ) { STRCPY(p + len, ""[+]""); len += 3; } if (wp->w_buffer->b_p_ro) { STRCPY(p + len, _(""[RO]"")); len += (int)STRLEN(p + len); } this_ru_col = ru_col - (Columns - wp->w_width); if (this_ru_col < (wp->w_width + 1) / 2) this_ru_col = (wp->w_width + 1) / 2; if (this_ru_col <= 1) { p = (char_u *)""<"";    len = 1; } else if (has_mbyte) { intclen = 0, i; clen = mb_string2cells(p, -1); for (i = 0; p[i] != NUL && clen >= this_ru_col - 1; i += (*mb_ptr2len)(p + i)) clen -= (*mb_ptr2cells)(p + i); len = clen; if (i > 0) { p = p + i - 1; *p = '<'; ++len; } } else if (len > this_ru_col - 1) { p += len - (this_ru_col - 1); *p = '<'; len = this_ru_col - 1; } screen_puts(p, row, wp->w_wincol, attr); screen_fill(row, row + 1, len + wp->w_wincol, this_ru_col + wp->w_wincol, fillchar, fillchar, attr); if (get_keymap_str(wp, (char_u *)""<%s>"", NameBuff, MAXPATHL) && (int)(this_ru_col - len) > (int)(STRLEN(NameBuff) + 1)) screen_puts(NameBuff, row, (int)(this_ru_col - STRLEN(NameBuff) - 1 + wp->w_wincol), attr); #ifdef FEAT_CMDL_INFO win_redr_ruler(wp, TRUE, ignore_pum); #endif } if (wp->w_vsep_width != 0 && wp->w_status_height != 0 && redrawing()) { if (stl_connected(wp)) fillchar = fillchar_status(&attr, wp); else fillchar = fillchar_vsep(&attr); screen_putchar(fillchar, row, W_ENDCOL(wp), attr); } busy = FALSE; }
Description: vim is vulnerable to Heap-based Buffer Overflow
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static njs_ret_t njs_array_prototype_unshift(njs_vm_t *vm, njs_value_t *args, nxt_uint_t nargs, njs_index_t unused) { njs_ret_t    ret; nxt_uint_t   n; njs_array_t  *array; if (njs_is_array(&args[0])) { array = args[0].data.u.array; n = nargs - 1; if (n != 0) { if ((intptr_t) n > (array->start - array->data)) { ret = njs_array_expand(vm, array, n, 0); if (nxt_slow_path(ret != NXT_OK)) { return ret; } } array->length += n; n = nargs; do { n--; array->start--; array->start[0] = args[n]; } while (n > 1); } njs_value_number_set(&vm->retval, array->length); } return NXT_OK; }
Description: njs through 0.3.1, used in NGINX, has a heap-based buffer overflow in Array.prototype.splice after a resize, related to njs_array_prototype_splice in njs/njs_array.c, because of njs_array_expand size mishandling.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static gint dissect_wccp2_alternate_mask_value_set_element(tvbuff_t *tvb, int offset, gint length, guint el_index, packet_info *pinfo, proto_tree *info_tree, wccp_address_table* addr_table) { proto_item *tl, *header; proto_tree *element_tree, *value_tree; guint number_of_elements; gint new_length, total_length; guint i; element_tree = proto_tree_add_subtree_format(info_tree, tvb, offset, 0, ett_alternate_mask_value_set_element, &header, ""Alternate Mask/Value Set Element(%d)"", el_index); total_length = 0; new_length=dissect_wccp2_mask_element(tvb,offset,length,pinfo,element_tree); total_length += length - new_length; NOTE_EATEN_LENGTH(new_length); if (length < 4) return length - 4; number_of_elements  = tvb_get_ntohl(tvb, offset); tl = proto_tree_add_uint(element_tree, hf_alt_assignment_mask_value_set_element_num_wc_value_elements, tvb, offset, 4, number_of_elements); value_tree = proto_item_add_subtree(tl, ett_alternate_mv_set_element_list); total_length += 4; EAT(4); for (i=0; i < number_of_elements; i++) { new_length=dissect_wccp2_web_cache_value_element(tvb, offset, length, pinfo, value_tree, addr_table); total_length += length - new_length; NOTE_EATEN_LENGTH(new_length); } proto_item_set_len(header, total_length); return length; }
Description: In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-wccp.c had a large loop that was addressed by ensuring that a calculated length was monotonically increasing.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void svm_get_segment_register(struct vcpu *v, enum x86_segment seg, struct segment_register *reg) { struct vmcb_struct *vmcb = v->arch.hvm_svm.vmcb; ASSERT((v == current) || !vcpu_runnable(v)); switch ( seg ) { case x86_seg_cs: memcpy(reg, &vmcb->cs, sizeof(*reg)); reg->attr.fields.g = reg->limit > 0xFFFFF; break; case x86_seg_ds: memcpy(reg, &vmcb->ds, sizeof(*reg)); if ( reg->attr.fields.type != 0 ) reg->attr.fields.type |= 0x1; break; case x86_seg_es: memcpy(reg, &vmcb->es, sizeof(*reg)); if ( reg->attr.fields.type != 0 ) reg->attr.fields.type |= 0x1; break; case x86_seg_fs: svm_sync_vmcb(v); memcpy(reg, &vmcb->fs, sizeof(*reg)); if ( reg->attr.fields.type != 0 ) reg->attr.fields.type |= 0x1; break; case x86_seg_gs: svm_sync_vmcb(v); memcpy(reg, &vmcb->gs, sizeof(*reg)); if ( reg->attr.fields.type != 0 ) reg->attr.fields.type |= 0x1; break; case x86_seg_ss: memcpy(reg, &vmcb->ss, sizeof(*reg)); reg->attr.fields.dpl = vmcb->_cpl; if ( reg->attr.fields.type == 0 ) reg->attr.fields.db = 0; break; case x86_seg_tr: svm_sync_vmcb(v); memcpy(reg, &vmcb->tr, sizeof(*reg)); reg->attr.fields.type |= 0x2; break; case x86_seg_gdtr: memcpy(reg, &vmcb->gdtr, sizeof(*reg)); break; case x86_seg_idtr: memcpy(reg, &vmcb->idtr, sizeof(*reg)); break; case x86_seg_ldtr: svm_sync_vmcb(v); memcpy(reg, &vmcb->ldtr, sizeof(*reg)); break; default: BUG(); } }
Description: The x86 emulator in Xen does not properly treat x86 NULL segments as unusable when accessing memory, which might allow local HVM guest users to gain privileges via vectors involving ""unexpected"" base/limit values.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num, int vid_hdr_offset, int max_beb_per1024, bool disable_fm) { struct ubi_device *ubi; int i, err; if (max_beb_per1024 < 0 || max_beb_per1024 > MAX_MTD_UBI_BEB_LIMIT) return -EINVAL; if (!max_beb_per1024) max_beb_per1024 = CONFIG_MTD_UBI_BEB_LIMIT; for (i = 0; i < UBI_MAX_DEVICES; i++) { ubi = ubi_devices[i]; if (ubi && mtd->index == ubi->mtd->index) { pr_err(""ubi: mtd%d is already attached to ubi%d\n"", mtd->index, i); return -EEXIST; } } if (mtd->type == MTD_UBIVOLUME) { pr_err(""ubi: refuse attaching mtd%d - it is already emulated on top of UBI\n"", mtd->index); return -EINVAL; } if (mtd->type == MTD_MLCNANDFLASH && !(mtd->flags & MTD_SLC_ON_MLC_EMULATION)) { pr_err(""ubi: refuse attaching mtd%d - MLC NAND is not supported\n"", mtd->index); return -EINVAL; } if (ubi_num == UBI_DEV_NUM_AUTO) { for (ubi_num = 0; ubi_num < UBI_MAX_DEVICES; ubi_num++) if (!ubi_devices[ubi_num]) break; if (ubi_num == UBI_MAX_DEVICES) { pr_err(""ubi: only %d UBI devices may be created\n"", UBI_MAX_DEVICES); return -ENFILE; } } else { if (ubi_num >= UBI_MAX_DEVICES) return -EINVAL; if (ubi_devices[ubi_num]) { pr_err(""ubi: ubi%i already exists\n"", ubi_num); return -EEXIST; } } ubi = kzalloc(sizeof(struct ubi_device), GFP_KERNEL); if (!ubi) return -ENOMEM; device_initialize(&ubi->dev); ubi->dev.release = dev_release; ubi->dev.class = &ubi_class; ubi->dev.groups = ubi_dev_groups; ubi->dev.parent = &mtd->dev; ubi->mtd = mtd; ubi->ubi_num = ubi_num; ubi->vid_hdr_offset = vid_hdr_offset; ubi->autoresize_vol_id = -1; #ifdef CONFIG_MTD_UBI_FASTMAP ubi->fm_pool.used = ubi->fm_pool.size = 0; ubi->fm_wl_pool.used = ubi->fm_wl_pool.size = 0; ubi->fm_pool.max_size = min(((int)mtd_div_by_eb(ubi->mtd->size, ubi->mtd) / 100) * 5, UBI_FM_MAX_POOL_SIZE); ubi->fm_pool.max_size = max(ubi->fm_pool.max_size, UBI_FM_MIN_POOL_SIZE); ubi->fm_wl_pool.max_size = ubi->fm_pool.max_size / 2; ubi->fm_disabled = (!fm_autoconvert || disable_fm) ? 1 : 0; if (fm_debug) ubi_enable_dbg_chk_fastmap(ubi); if (!ubi->fm_disabled && (int)mtd_div_by_eb(ubi->mtd->size, ubi->mtd) <= UBI_FM_MAX_START) { ubi_err(ubi, ""More than %i PEBs are needed for fastmap, sorry."", UBI_FM_MAX_START); ubi->fm_disabled = 1; } ubi_msg(ubi, ""default fastmap pool size: %d"", ubi->fm_pool.max_size); ubi_msg(ubi, ""default fastmap WL pool size: %d"", ubi->fm_wl_pool.max_size); #else ubi->fm_disabled = 1; #endif mutex_init(&ubi->buf_mutex); mutex_init(&ubi->ckvol_mutex); mutex_init(&ubi->device_mutex); spin_lock_init(&ubi->volumes_lock); init_rwsem(&ubi->fm_protect); init_rwsem(&ubi->fm_eba_sem); ubi_msg(ubi, ""attaching mtd%d"", mtd->index); err = io_init(ubi, max_beb_per1024); if (err) goto out_free; err = -ENOMEM; ubi->peb_buf = vmalloc(ubi->peb_size); if (!ubi->peb_buf) goto out_free; #ifdef CONFIG_MTD_UBI_FASTMAP ubi->fm_size = ubi_calc_fm_size(ubi); ubi->fm_buf = vzalloc(ubi->fm_size); if (!ubi->fm_buf) goto out_free; #endif err = ubi_attach(ubi, disable_fm ? 1 : 0); if (err) { ubi_err(ubi, ""failed to attach mtd%d, error %d"", mtd->index, err); goto out_free; } if (ubi->autoresize_vol_id != -1) { err = autoresize(ubi, ubi->autoresize_vol_id); if (err) goto out_detach; } err = uif_init(ubi); if (err) goto out_detach; err = ubi_debugfs_init_dev(ubi); if (err) goto out_uif; ubi->bgt_thread = kthread_create(ubi_thread, ubi, ""%s"", ubi->bgt_name); if (IS_ERR(ubi->bgt_thread)) { err = PTR_ERR(ubi->bgt_thread); ubi_err(ubi, ""cannot spawn \""%s\"", error %d"", ubi->bgt_name, err); goto out_debugfs; } ubi_msg(ubi, ""attached mtd%d (name \""%s\"", size %llu MiB)"", mtd->index, mtd->name, ubi->flash_size >> 20); ubi_msg(ubi, ""PEB size: %d bytes (%d KiB), LEB size: %d bytes"", ubi->peb_size, ubi->peb_size >> 10, ubi->leb_size); ubi_msg(ubi, ""min./max. I/O unit sizes: %d/%d, sub-page size %d"", ubi->min_io_size, ubi->max_write_size, ubi->hdrs_min_io_size); ubi_msg(ubi, ""VID header offset: %d (aligned %d), data offset: %d"", ubi->vid_hdr_offset, ubi->vid_hdr_aloffset, ubi->leb_start); ubi_msg(ubi, ""good PEBs: %d, bad PEBs: %d, corrupted PEBs: %d"", ubi->good_peb_count, ubi->bad_peb_count, ubi->corr_peb_count); ubi_msg(ubi, ""user volume: %d, internal volumes: %d, max. volumes count: %d"", ubi->vol_count - UBI_INT_VOL_COUNT, UBI_INT_VOL_COUNT, ubi->vtbl_slots); ubi_msg(ubi, ""max/mean erase counter: %d/%d, WL threshold: %d, image sequence number: %u"", ubi->max_ec, ubi->mean_ec, CONFIG_MTD_UBI_WL_THRESHOLD, ubi->image_seq); ubi_msg(ubi, ""available PEBs: %d, total reserved PEBs: %d, PEBs reserved for bad PEB handling: %d"", ubi->avail_pebs, ubi->rsvd_pebs, ubi->beb_rsvd_pebs); spin_lock(&ubi->wl_lock); ubi->thread_enabled = 1; wake_up_process(ubi->bgt_thread); spin_unlock(&ubi->wl_lock); ubi_devices[ubi_num] = ubi; ubi_notify_all(ubi, UBI_VOLUME_ADDED, NULL); return ubi_num; out_debugfs: ubi_debugfs_exit_dev(ubi); out_uif: uif_close(ubi); out_detach: ubi_wl_close(ubi); ubi_free_all_volumes(ubi); vfree(ubi->vtbl); out_free: vfree(ubi->peb_buf); vfree(ubi->fm_buf); put_device(&ubi->dev); return err; }
Description: An issue was discovered in drivers/mtd/ubi/cdev.c in the Linux kernel 6.2. There is a divide-by-zero error in do_div(sz,mtd->erasesize), used indirectly by ctrl_cdev_ioctl, when mtd->erasesize is 0.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int get_exif_tag_dbl_value(struct iw_exif_state *e, unsigned int tag_pos, double *pv) { unsigned int field_type; unsigned int value_count; unsigned int value_pos; unsigned int numer, denom; field_type = iw_get_ui16_e(&e->d[tag_pos+2],e->endian); value_count = iw_get_ui32_e(&e->d[tag_pos+4],e->endian); if(value_count!=1) return 0; if(field_type!=5) return 0;  value_pos = iw_get_ui32_e(&e->d[tag_pos+8],e->endian); if(value_pos > e->d_len-8) return 0; numer = iw_get_ui32_e(&e->d[value_pos  ],e->endian); denom = iw_get_ui32_e(&e->d[value_pos+4],e->endian); if(denom==0) return 0; *pv = ((double)numer)/denom; return 1; }
Description: The iw_get_ui16le function in imagew-util.c:405:23 in libimageworsener.a in ImageWorsener 1.3.1 allows remote attackers to cause a denial of service (invalid read and SEGV) via a crafted image, related to imagew-jpeg.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void controloptions (lua_State *L, int opt, const char **fmt, Header *h) { switch (opt) { case  ' ': return;   case '>': h->endian = BIG; return; case '<': h->endian = LITTLE; return; case '!': { int a = getnum(fmt, MAXALIGN); if (!isp2(a)) luaL_error(L, ""alignment %d is not a power of 2"", a); h->align = a; return; } default: { const char *msg = lua_pushfstring(L, ""invalid format option '%c'"", opt); luaL_argerror(L, 1, msg); } } }
Description: Integer overflow in the getnum function in lua_struct.c in Redis 2.8.x before 2.8.24 and 3.0.x before 3.0.6 allows context-dependent attackers with permission to run Lua code in a Redis session to cause a denial of service (memory corruption and application crash) or possibly bypass intended sandbox restrictions via a large number, which triggers a stack-based buffer overflow.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool TIFF_MemoryReader::GetTag ( XMP_Uns8 ifd, XMP_Uns16 id, TagInfo* info ) const { const TweakedIFDEntry* thisTag = this->FindTagInIFD ( ifd, id ); if ( thisTag == 0 ) return false; XMP_Uns16 thisType = GetUns16AsIs ( &thisTag->type ); XMP_Uns32 thisBytes = GetUns32AsIs ( &thisTag->bytes ); if ( (thisType < kTIFF_ByteType) || (thisType > kTIFF_LastType) ) return false; if ( info != 0 ) { info->id = GetUns16AsIs ( &thisTag->id ); info->type = thisType; info->count = thisBytes / (XMP_Uns32)kTIFF_TypeSizes[thisType]; info->dataLen = thisBytes; info->dataPtr = this->GetDataPtr ( thisTag ); } return true; }
Description: An issue was discovered in Exempi before 2.4.3. It allows remote attackers to cause a denial of service (invalid memcpy with resultant use-after-free) or possibly have unspecified other impact via a .pdf file containing JPEG data, related to XMPFiles/source/FormatSupport/ReconcileTIFF.cpp, XMPFiles/source/FormatSupport/TIFF_MemoryReader.cpp, and XMPFiles/source/FormatSupport/TIFF_Support.hpp.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int main(int argc, char **argv) { sc_context_t *ctx = NULL; sc_context_param_t ctx_param; sc_card_t *card = NULL; int r; decode_options(argc, argv); memset(&ctx_param, 0, sizeof(ctx_param)); ctx_param.ver      = 0; ctx_param.app_name = app_name; r = sc_context_create(&ctx, &ctx_param); if (r) { fprintf(stderr, ""Failed to establish context: %s\n"", sc_strerror(r)); return 1; } r = util_connect_card(ctx, &card, opt_reader, opt_wait, 0); if (r) { fprintf(stderr, ""Failed to connect to card: %s\n"", sc_strerror(r)); return 1; } if (card->type == SC_CARD_TYPE_MCRD_ESTEID_V30) do_esteid(card); else if (card->type == SC_CARD_TYPE_BELPIC_EID) do_belpic(card); else { fprintf(stderr, ""Not an EstEID or Belpic card!\n""); goto out; } if (exec_program) { char *const largv[] = {exec_program, NULL}; sc_unlock(card); sc_disconnect_card(card); sc_release_context(ctx); execv(exec_program, largv); perror(""execv()""); exit(1); } out: sc_unlock(card); sc_disconnect_card(card); sc_release_context(ctx); exit(exit_status); }
Description: sc_context_create in ctx.c in libopensc in OpenSC 0.19.0 has a memory leak, as demonstrated by a call from eidenv.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void PasswordGenerationAgent::ShowGenerationPopup() { Send(new AutofillHostMsg_ShowPasswordGenerationPopup( routing_id(), render_frame()->GetRenderView()->ElementBoundsInWindow( generation_element_), generation_element_.maxLength(), generation_element_.nameForAutofill(), is_manually_triggered_, *generation_form_data_->form)); generation_popup_shown_ = true; }
Description: The Autofill implementation in Google Chrome before 51.0.2704.63 mishandles the interaction between field updates and JavaScript code that triggers a frame deletion, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted web site, a different vulnerability than CVE-2016-1701.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: zzip_size_t zzip_disk_fread(void *ptr, zzip_size_t sized, zzip_size_t nmemb, ZZIP_DISK_FILE * file) { zzip_size_t size = sized * nmemb; if (! ptr || ! sized || ! file) return 0; if (size > file->avail) size = file->avail; if (file->stored) { memcpy(ptr, file->stored, size); file->stored += size; file->avail -= size; return size; } file->zlib.avail_out = sized * nmemb; file->zlib.next_out = ptr; ___ zzip_size_t total_old = file->zlib.total_out; ___ int err = inflate(&file->zlib, Z_NO_FLUSH); if (err == Z_STREAM_END) file->avail = 0; else if (err == Z_OK) file->avail -= file->zlib.total_out - total_old; else return 0; return file->zlib.total_out - total_old; ____; ____; }
Description: In ZZIPlib 0.13.67, there is a bus error caused by loading of a misaligned address in the zzip_disk_findfirst function of zzip/mmapped.c. Remote attackers could leverage this vulnerability to cause a denial of service via a crafted zip file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int ldbm_back_bind(Slapi_PBlock *pb) { backend *be; ldbm_instance *inst; ber_tag_t method; struct berval *cred; struct ldbminfo *li; struct backentry *e; Slapi_Attr *attr; Slapi_Value **bvals; entry_address *addr; back_txn txn = {NULL}; int rc = SLAPI_BIND_SUCCESS; int result_sent = 0; slapi_pblock_get(pb, SLAPI_BACKEND, &be); slapi_pblock_get(pb, SLAPI_PLUGIN_PRIVATE, &li); slapi_pblock_get(pb, SLAPI_TARGET_ADDRESS, &addr); slapi_pblock_get(pb, SLAPI_BIND_METHOD, &method); slapi_pblock_get(pb, SLAPI_BIND_CREDENTIALS, &cred); slapi_pblock_get(pb, SLAPI_TXN, &txn.back_txn_txn); if (!txn.back_txn_txn) { dblayer_txn_init(li, &txn); slapi_pblock_set(pb, SLAPI_TXN, txn.back_txn_txn); } inst = (ldbm_instance *)be->be_instance_info; if (inst->inst_ref_count) { slapi_counter_increment(inst->inst_ref_count); } else { slapi_log_err(SLAPI_LOG_ERR, ""ldbm_back_bind"", ""instance %s does not exist.\n"", inst->inst_name); return (SLAPI_BIND_FAIL); } if (method == LDAP_AUTH_SIMPLE && cred->bv_len == 0) { rc = SLAPI_BIND_ANONYMOUS; goto bail; } if ((e = find_entry(pb, be, addr, &txn, &result_sent)) == NULL) { rc = SLAPI_BIND_FAIL; if (!result_sent) { slapi_send_ldap_result(pb, LDAP_INAPPROPRIATE_AUTH, NULL, NULL, 0, NULL); } goto bail; } switch (method) { case LDAP_AUTH_SIMPLE: { Slapi_Value cv; if (slapi_entry_attr_find(e->ep_entry, ""userpassword"", &attr) != 0) { slapi_send_ldap_result(pb, LDAP_INAPPROPRIATE_AUTH, NULL, NULL, 0, NULL); CACHE_RETURN(&inst->inst_cache, &e); rc = SLAPI_BIND_FAIL; goto bail; } bvals = attr_get_present_values(attr); slapi_value_init_berval(&cv, cred); if (slapi_pw_find_sv(bvals, &cv) != 0) { slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, ""Invalid credentials""); slapi_send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, NULL, 0, NULL); CACHE_RETURN(&inst->inst_cache, &e); value_done(&cv); rc = SLAPI_BIND_FAIL; goto bail; } value_done(&cv); } break; default: slapi_send_ldap_result(pb, LDAP_STRONG_AUTH_NOT_SUPPORTED, NULL, ""auth method not supported"", 0, NULL); CACHE_RETURN(&inst->inst_cache, &e); rc = SLAPI_BIND_FAIL; goto bail; } CACHE_RETURN(&inst->inst_cache, &e); bail: if (inst->inst_ref_count) { slapi_counter_decrement(inst->inst_ref_count); } return rc; }
Description: When binding against a DN during authentication, the reply from 389-ds-base will be different whether the DN exists or not. This can be used by an unauthenticated attacker to check the existence of an entry in the LDAP database.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool lcPiecesLibrary::LoadTexture(lcTexture* Texture) { char FileName[2*LC_MAXPATH]; if (mZipFiles[static_cast<int>(lcZipFileType::Official)]) { lcMemFile TextureFile; sprintf(FileName, ""parts/textures/%s.png"", Texture->mName); if (!mZipFiles[static_cast<int>(lcZipFileType::Unofficial)] || !mZipFiles[static_cast<int>(lcZipFileType::Unofficial)]->ExtractFile(FileName, TextureFile)) { sprintf(FileName, ""ldraw/parts/textures/%s.png"", Texture->mName); if (!mZipFiles[static_cast<int>(lcZipFileType::Official)]->ExtractFile(FileName, TextureFile)) return false; } return Texture->Load(TextureFile); } else return Texture->Load(Texture->mFileName); }
Description: LeoCAD before 21.03 sometimes allows a use-after-free during the opening of a new document.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv) { struct passwd *pw = NULL, pw_s; const char *user = NULL; cfg_t cfg_st; cfg_t *cfg = &cfg_st; char buffer[BUFSIZE]; char *buf = NULL; char *authfile_dir; size_t authfile_dir_len; int pgu_ret, gpn_ret; int retval = PAM_IGNORE; device_t *devices = NULL; unsigned n_devices = 0; int openasuser; int should_free_origin = 0; int should_free_appid = 0; int should_free_auth_file = 0; int should_free_authpending_file = 0; parse_cfg(flags, argc, argv, cfg); if (!cfg->origin) { strcpy(buffer, DEFAULT_ORIGIN_PREFIX); if (gethostname(buffer + strlen(DEFAULT_ORIGIN_PREFIX), BUFSIZE - strlen(DEFAULT_ORIGIN_PREFIX)) == -1) { DBG(""Unable to get host name""); goto done; } DBG(""Origin not specified, using \""%s\"""", buffer); cfg->origin = strdup(buffer); if (!cfg->origin) { DBG(""Unable to allocate memory""); goto done; } else { should_free_origin = 1; } } if (!cfg->appid) { DBG(""Appid not specified, using the same value of origin (%s)"", cfg->origin); cfg->appid = strdup(cfg->origin); if (!cfg->appid) { DBG(""Unable to allocate memory"") goto done; } else { should_free_appid = 1; } } if (cfg->max_devs == 0) { DBG(""Maximum devices number not set. Using default (%d)"", MAX_DEVS); cfg->max_devs = MAX_DEVS; } devices = malloc(sizeof(device_t) * cfg->max_devs); if (!devices) { DBG(""Unable to allocate memory""); retval = PAM_IGNORE; goto done; } pgu_ret = pam_get_user(pamh, &user, NULL); if (pgu_ret != PAM_SUCCESS || user == NULL) { DBG(""Unable to access user %s"", user); retval = PAM_CONV_ERR; goto done; } DBG(""Requesting authentication for user %s"", user); gpn_ret = getpwnam_r(user, &pw_s, buffer, sizeof(buffer), &pw); if (gpn_ret != 0 || pw == NULL || pw->pw_dir == NULL || pw->pw_dir[0] != '/') { DBG(""Unable to retrieve credentials for user %s, (%s)"", user, strerror(errno)); retval = PAM_USER_UNKNOWN; goto done; } DBG(""Found user %s"", user); DBG(""Home directory for %s is %s"", user, pw->pw_dir); if (!cfg->auth_file) { buf = NULL; authfile_dir = secure_getenv(DEFAULT_AUTHFILE_DIR_VAR); if (!authfile_dir) { DBG(""Variable %s is not set. Using default value ($HOME/.config/)"", DEFAULT_AUTHFILE_DIR_VAR); authfile_dir_len = strlen(pw->pw_dir) + strlen(""/.config"") + strlen(DEFAULT_AUTHFILE) + 1; buf = malloc(sizeof(char) * (authfile_dir_len)); if (!buf) { DBG(""Unable to allocate memory""); retval = PAM_IGNORE; goto done; } snprintf(buf, authfile_dir_len, ""%s/.config%s"", pw->pw_dir, DEFAULT_AUTHFILE); } else { DBG(""Variable %s set to %s"", DEFAULT_AUTHFILE_DIR_VAR, authfile_dir); authfile_dir_len = strlen(authfile_dir) + strlen(DEFAULT_AUTHFILE) + 1; buf = malloc(sizeof(char) * (authfile_dir_len)); if (!buf) { DBG(""Unable to allocate memory""); retval = PAM_IGNORE; goto done; } snprintf(buf, authfile_dir_len, ""%s%s"", authfile_dir, DEFAULT_AUTHFILE); } DBG(""Using default authentication file %s"", buf); cfg->auth_file = buf;  should_free_auth_file = 1; buf = NULL; } else { DBG(""Using authentication file %s"", cfg->auth_file); } openasuser = geteuid() == 0 && cfg->openasuser; if (openasuser) { if (seteuid(pw_s.pw_uid)) { DBG(""Unable to switch user to uid %i"", pw_s.pw_uid); retval = PAM_IGNORE; goto done; } DBG(""Switched to uid %i"", pw_s.pw_uid); } retval = get_devices_from_authfile(cfg->auth_file, user, cfg->max_devs, cfg->debug, cfg->debug_file, devices, &n_devices); if (openasuser) { if (seteuid(0)) { DBG(""Unable to switch back to uid 0""); retval = PAM_IGNORE; goto done; } DBG(""Switched back to uid 0""); } if (retval != 1) { n_devices = 0; } if (n_devices == 0) { if (cfg->nouserok) { DBG(""Found no devices but nouserok specified. Skipping authentication""); retval = PAM_SUCCESS; goto done; } else if (retval != 1) { DBG(""Unable to get devices from file %s"", cfg->auth_file); retval = PAM_AUTHINFO_UNAVAIL; goto done; } else { DBG(""Found no devices. Aborting.""); retval = PAM_AUTHINFO_UNAVAIL; goto done; } } if (!cfg->authpending_file) { int actual_size = snprintf(buffer, BUFSIZE, DEFAULT_AUTHPENDING_FILE_PATH, getuid()); if (actual_size >= 0 && actual_size < BUFSIZE) { cfg->authpending_file = strdup(buffer); } if (!cfg->authpending_file) { DBG(""Unable to allocate memory for the authpending_file, touch request notifications will not be emitted""); } else { should_free_authpending_file = 1; } } else { if (strlen(cfg->authpending_file) == 0) { DBG(""authpending_file is set to an empty value, touch request notifications will be disabled""); cfg->authpending_file = NULL; } } int authpending_file_descriptor = -1; if (cfg->authpending_file) { DBG(""Using file '%s' for emitting touch request notifications"", cfg->authpending_file); authpending_file_descriptor = open(cfg->authpending_file, O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY, 0664); if (authpending_file_descriptor < 0) { DBG(""Unable to emit 'authentication started' notification by opening the file '%s', (%s)"", cfg->authpending_file, strerror(errno)); } } if (cfg->manual == 0) { if (cfg->interactive) { converse(pamh, PAM_PROMPT_ECHO_ON, cfg->prompt != NULL ? cfg->prompt : DEFAULT_PROMPT); } retval = do_authentication(cfg, devices, n_devices, pamh); } else { retval = do_manual_authentication(cfg, devices, n_devices, pamh); } if (authpending_file_descriptor >= 0) { if (close(authpending_file_descriptor) < 0) { DBG(""Unable to emit 'authentication stopped' notification by closing the file '%s', (%s)"", cfg->authpending_file, strerror(errno)); } } if (retval != 1) { DBG(""do_authentication returned %d"", retval); retval = PAM_AUTH_ERR; goto done; } retval = PAM_SUCCESS; done: free_devices(devices, n_devices); if (buf) { free(buf); buf = NULL; } if (should_free_origin) { free((char *) cfg->origin); cfg->origin = NULL; } if (should_free_appid) { free((char *) cfg->appid); cfg->appid = NULL; } if (should_free_auth_file) { free((char *) cfg->auth_file); cfg->auth_file = NULL; } if (should_free_authpending_file) { free((char *) cfg->authpending_file); cfg->authpending_file = NULL; } if (cfg->alwaysok && retval != PAM_SUCCESS) { DBG(""alwaysok needed (otherwise return with %d)"", retval); retval = PAM_SUCCESS; } DBG(""done. [%s]"", pam_strerror(pamh, retval)); if (cfg->is_custom_debug_file) { fclose(cfg->debug_file); } return retval; }
Description: Yubico pam-u2f 1.0.7 attempts parsing of the configured authfile (default $HOME/.config/Yubico/u2f_keys) as root (unless openasuser was enabled), and does not properly verify that the path lacks symlinks pointing to other files on the system owned by root. If the debug option is enabled in the PAM configuration, part of the file contents of a symlink target will be logged, possibly revealing sensitive information.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void __gnttab_unmap_common( struct gnttab_unmap_common *op) { domid_t          dom; struct domain   *ld, *rd; struct grant_table *lgt, *rgt; struct active_grant_entry *act; s16              rc = 0; ld = current->domain; lgt = ld->grant_table; op->frame = (unsigned long)(op->dev_bus_addr >> PAGE_SHIFT); if ( unlikely(op->handle >= lgt->maptrack_limit) ) { gdprintk(XENLOG_INFO, ""Bad handle %#x\n"", op->handle); op->status = GNTST_bad_handle; return; } op->map = &maptrack_entry(lgt, op->handle); grant_read_lock(lgt); if ( unlikely(!read_atomic(&op->map->flags)) ) { grant_read_unlock(lgt); gdprintk(XENLOG_INFO, ""Zero flags for handle %#x\n"", op->handle); op->status = GNTST_bad_handle; return; } dom = op->map->domid; grant_read_unlock(lgt); if ( unlikely((rd = rcu_lock_domain_by_id(dom)) == NULL) ) { gdprintk(XENLOG_INFO, ""Could not find domain %d\n"", dom); domain_crash(ld);  return; } rc = xsm_grant_unmapref(XSM_HOOK, ld, rd); if ( rc ) { rcu_unlock_domain(rd); op->status = GNTST_permission_denied; return; } TRACE_1D(TRC_MEM_PAGE_GRANT_UNMAP, dom); rgt = rd->grant_table; grant_read_lock(rgt); op->flags = read_atomic(&op->map->flags); if ( unlikely(!op->flags) || unlikely(op->map->domid != dom) ) { gdprintk(XENLOG_WARNING, ""Unstable handle %#x\n"", op->handle); rc = GNTST_bad_handle; goto unmap_out; } op->rd = rd; act = active_entry_acquire(rgt, op->map->ref); if ( op->frame == 0 ) { op->frame = act->frame; } else { if ( unlikely(op->frame != act->frame) ) PIN_FAIL(act_release_out, GNTST_general_error, ""Bad frame number doesn't match gntref. (%lx != %lx)\n"", op->frame, act->frame); op->map->flags &= ~GNTMAP_device_map; } if ( (op->host_addr != 0) && (op->flags & GNTMAP_host_map) ) { if ( (rc = replace_grant_host_mapping(op->host_addr, op->frame, op->new_addr,  op->flags)) < 0 ) goto act_release_out; op->map->flags &= ~GNTMAP_host_map; } act_release_out: active_entry_release(act); unmap_out: grant_read_unlock(rgt); if ( rc == GNTST_okay && gnttab_need_iommu_mapping(ld) ) { unsigned int kind; int err = 0; double_gt_lock(lgt, rgt); kind = mapkind(lgt, rd, op->frame); if ( !kind ) err = iommu_unmap_page(ld, op->frame); else if ( !(kind & MAPKIND_WRITE) ) err = iommu_map_page(ld, op->frame, op->frame, IOMMUF_readable); double_gt_unlock(lgt, rgt); if ( err ) rc = GNTST_general_error; } if ( rc == GNTST_okay && !(op->flags & GNTMAP_readonly) ) gnttab_mark_dirty(rd, op->frame); op->status = rc; rcu_unlock_domain(rd); }
Description: The grant-table feature in Xen through 4.8.x provides false mapping information in certain cases of concurrent unmap calls, which allows backend attackers to obtain sensitive information or gain privileges, aka XSA-218 bug 1.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: OM_uint32 KRB5_CALLCONV gss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle, gss_qop_t *qop_state, gss_iov_buffer_desc *iov, int iov_count) { OM_uint32 status; gss_union_ctx_id_t ctx; gss_mechanism mech; status = val_unwrap_iov_args(minor_status, context_handle, NULL, qop_state, iov, iov_count); if (status != GSS_S_COMPLETE) return status; ctx = (gss_union_ctx_id_t)context_handle; mech = gssint_get_mechanism(ctx->mech_type); if (mech == NULL) return GSS_S_BAD_MECH; if (mech->gss_verify_mic_iov == NULL) return GSS_S_UNAVAILABLE; status = mech->gss_verify_mic_iov(minor_status, ctx->internal_ctx_id, qop_state, iov, iov_count); if (status != GSS_S_COMPLETE) map_error(minor_status, mech); return status; }
Description: Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int cdxl_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *pkt) { CDXLVideoContext *c = avctx->priv_data; AVFrame * const p = data; int ret, w, h, encoding, aligned_width, buf_size = pkt->size; const uint8_t *buf = pkt->data; if (buf_size < 32) return AVERROR_INVALIDDATA; encoding        = buf[1] & 7; c->format       = buf[1] & 0xE0; w               = AV_RB16(&buf[14]); h               = AV_RB16(&buf[16]); c->bpp          = buf[19]; c->palette_size = AV_RB16(&buf[20]); c->palette      = buf + 32; c->video        = c->palette + c->palette_size; c->video_size   = buf_size - c->palette_size - 32; if (c->palette_size > 512) return AVERROR_INVALIDDATA; if (buf_size < c->palette_size + 32) return AVERROR_INVALIDDATA; if (c->bpp < 1) return AVERROR_INVALIDDATA; if (c->format != BIT_PLANAR && c->format != BIT_LINE && c->format != CHUNKY) { avpriv_request_sample(avctx, ""Pixel format 0x%0x"", c->format); return AVERROR_PATCHWELCOME; } if ((ret = ff_set_dimensions(avctx, w, h)) < 0) return ret; if (c->format == CHUNKY) aligned_width = avctx->width; else aligned_width = FFALIGN(c->avctx->width, 16); c->padded_bits  = aligned_width - c->avctx->width; if (c->video_size < aligned_width * avctx->height * (int64_t)c->bpp / 8) return AVERROR_INVALIDDATA; if (!encoding && c->palette_size && c->bpp <= 8 && c->format != CHUNKY) { avctx->pix_fmt = AV_PIX_FMT_PAL8; } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8)) { if (c->palette_size != (1 << (c->bpp - 1))) return AVERROR_INVALIDDATA; avctx->pix_fmt = AV_PIX_FMT_BGR24; } else if (!encoding && c->bpp == 24 && c->format == CHUNKY && !c->palette_size) { avctx->pix_fmt = AV_PIX_FMT_RGB24; } else { avpriv_request_sample(avctx, ""Encoding %d, bpp %d and format 0x%x"", encoding, c->bpp, c->format); return AVERROR_PATCHWELCOME; } if ((ret = ff_get_buffer(avctx, p, 0)) < 0) return ret; p->pict_type = AV_PICTURE_TYPE_I; if (encoding) { av_fast_padded_malloc(&c->new_video, &c->new_video_size, h * w + AV_INPUT_BUFFER_PADDING_SIZE); if (!c->new_video) return AVERROR(ENOMEM); if (c->bpp == 8) cdxl_decode_ham8(c, p); else cdxl_decode_ham6(c, p); } else if (avctx->pix_fmt == AV_PIX_FMT_PAL8) { cdxl_decode_rgb(c, p); } else { cdxl_decode_raw(c, p); } *got_frame = 1; return buf_size; }
Description: The cdxl_decode_frame function in libavcodec/cdxl.c in FFmpeg 2.8.x before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 does not exclude the CHUNKY format, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int lp8000_print_page(gx_device_printer *pdev, gp_file *prn_stream) { int line_size = gdev_mem_bytes_per_scan_line((gx_device *)pdev); int in_size = line_size; unsigned int report_size; byte *buf1 = (byte *)gs_malloc(pdev->memory, in_size, 1, ""lp8000_print_page(buf1)""); byte *buf2 = (byte *)gs_malloc(pdev->memory, in_size, 1, ""lp8000_print_page(buf2)""); byte *in = buf1; byte *out = buf2; int lnum, top, bottom, left, width; int count, left1, left2, left0; if ( buf1 == 0 || buf2 == 0 ) {       if ( buf1 ) gs_free(pdev->memory, (char *)buf1, in_size, 1, ""lp8000_print_page(buf1)""); if ( buf2 ) gs_free(pdev->memory, (char *)buf2, in_size, 1, ""lp8000_print_page(buf2)""); return_error(gs_error_VMerror); } gp_fwrite(""\033\001@EJL \n"",1,8,prn_stream); gp_fwrite(""@EJL EN LA=ESC/PAGE\n"",1,20,prn_stream); gp_fwrite(""\035rhE\033\001@EJL \n"",1,12,prn_stream); gp_fwrite(""@EJL SE LA=ESC/PAGE\n"",1,20,prn_stream); gp_fwrite(""@EJL SET PU=1 PS=A4 ZO=OFF\n"",1,27,prn_stream); gp_fwrite(""@EJL EN LA=ESC/PAGE\n"",1,20,prn_stream); gp_fwrite(""\0350;0.24muE\0352;300;300drE"",1,23,prn_stream); gp_fwrite(""\0350;300;300drE\0351tsE\0351mmE"",1,23,prn_stream); gp_fwrite(""\0357isE\0355iaF\0355ipP\03514psE\0350poE"",1,26,prn_stream); gp_fwrite(""\03560;60loE\0350X\0350Y"",1,15,prn_stream); gp_fwrite(""\0350;0;2360;3388caE"",1,17,prn_stream); gp_fwrite(""\0351cmE\0350alfP"",1,11,prn_stream); gp_fwrite(""\0350affP\0350boP\0350abP"",1,16,prn_stream); gp_fwrite(""\0354ilG\0350bcI\0350sarG"",1,16,prn_stream); gp_fwrite(""\0351;0;100spE\0352owE"",1,16,prn_stream); left1  =  (int) (L_MARGIN * pdev->x_pixels_per_inch) - 60; left1 = (left1 >> 3) << 3; left0 = left1; gp_fwrite(""\035"",1,1,prn_stream); gp_fprintf(prn_stream,""%d"",left1); gp_fwrite(""X"",1,1,prn_stream); gp_fwrite(""\0353bcI"",1,5,prn_stream); top = T_MARGIN * pdev->y_pixels_per_inch; bottom = pdev->height - B_MARGIN * pdev->y_pixels_per_inch; left  = ( (int) (L_MARGIN * pdev->x_pixels_per_inch) ) >> 3 ; width = ((pdev->width - (int)(R_MARGIN * pdev->x_pixels_per_inch)) >> 3) - left; for ( lnum = top; lnum < bottom ; ) { byte *in_data; byte *inp; byte *in_end; byte *outp; register byte *p, *q; gdev_prn_get_bits(pdev, lnum, in, &in_data); while ( in_data[0] == 0 && !memcmp((char *)in_data, (char *)in_data + 1, line_size - 1) && lnum < bottom ) { lnum++; gdev_prn_get_bits(pdev, lnum, in, &in_data); } if(lnum == bottom ) break; (void)gdev_prn_copy_scan_lines(pdev, lnum, in, in_size); inp = in  + left; in_end = inp + width; while (in_end > inp &&  in_end[-1] == 0) { in_end--; } for(left2 = 0; inp < in_end && inp[0] == 0; inp++,left2++); left2 = left1 + (left2 << 3); outp = out; for( p = inp, q = inp + 1 ; q < in_end ; ) { if( *p != *q++ ) { *outp++ = *p++; } else { for (count = 2; ( *p == *q ) && (q < in_end); q++, count++) {} while (count > 257) { *outp++ = *p; *outp++ = *p; *outp++ = 255; p += 257; count -=257; } *outp++ = *p; *outp++ = *p; *outp++ = count - 2; p += count; q = p+1; } } if (p == (in_end - 1)) *outp++ = *p; if (left2 != left0) { left0 = left2; gp_fwrite(""\035"",1,1,prn_stream); gp_fprintf(prn_stream,""%d"",left2); gp_fwrite(""X"",1,1,prn_stream); } gp_fwrite(""\035"",1,1,prn_stream); gp_fprintf(prn_stream,""%d"",lnum-60); gp_fwrite(""Y\035"",1,2,prn_stream); report_size = outp - out; gp_fprintf(prn_stream,""%d;"",report_size); report_size = (in_end - inp) << 3; gp_fprintf(prn_stream,""%d;"",report_size); gp_fwrite(""1;0bi{I"",1,7,prn_stream); gp_fwrite(out,1,(outp - out),prn_stream); lnum++; } gp_fwrite(""\0350bcI"",1,5,prn_stream); gp_fwrite(""\0351coO"",1,5,prn_stream); gp_fwrite(""\035rhE"",1,4,prn_stream); gp_fwrite(""\033\001@EJL \n"",1,8,prn_stream); gp_fwrite(""@EJL SE LA=ESC/PAGE\n"",1,20,prn_stream); gp_fwrite(""@EJL SET PU=1 PS=A4 ZO=OFF\n"",1,27,prn_stream); gp_fwrite(""@EJL EN LA=ESC/PAGE\n"",1,20,prn_stream); gp_fwrite(""\0350;0.24muE\0352;300;300drE"",1,23,prn_stream); gp_fwrite(""\0350;300;300drE\0351tsE\0351mmE"",1,23,prn_stream); gp_fwrite(""\0357isE\0355iaF\0355ipP\03514psE\0350poE"",1,26,prn_stream); gp_fwrite(""\03560;60loE\0350X\0350Y"",1,15,prn_stream); gp_fwrite(""\0350;0;2360;3388caE"",1,17,prn_stream); gp_fwrite(""\0351cmE\0350alfP"",1,11,prn_stream); gp_fwrite(""\0350affP\0350boP\0350abP"",1,16,prn_stream); gp_fwrite(""\0354ilG\0350bcI\0350sarG"",1,16,prn_stream); gp_fwrite(""\035rhE"",1,4,prn_stream); gp_fwrite(""\033\001@EJL \n"",1,8,prn_stream); gp_fwrite(""\033\001@EJL \n"",1,8,prn_stream); gp_fflush(prn_stream); gs_free(pdev->memory, (char *)buf2, in_size, 1, ""lp8000_print_page(buf2)""); gs_free(pdev->memory, (char *)buf1, in_size, 1, ""lp8000_print_page(buf1)""); return 0; }
Description: A heap-based buffer overwrite vulnerability was found in GhostScript's lp8000_print_page() function in the gdevlp8k.c file. This flaw allows an attacker to trick a user into opening a crafted PDF file, triggering the heap buffer overflow that could lead to memory corruption or a denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: const char *nghttp2_strerror(int error_code) { switch (error_code) { case 0: return ""Success""; case NGHTTP2_ERR_INVALID_ARGUMENT: return ""Invalid argument""; case NGHTTP2_ERR_BUFFER_ERROR: return ""Out of buffer space""; case NGHTTP2_ERR_UNSUPPORTED_VERSION: return ""Unsupported SPDY version""; case NGHTTP2_ERR_WOULDBLOCK: return ""Operation would block""; case NGHTTP2_ERR_PROTO: return ""Protocol error""; case NGHTTP2_ERR_INVALID_FRAME: return ""Invalid frame octets""; case NGHTTP2_ERR_EOF: return ""EOF""; case NGHTTP2_ERR_DEFERRED: return ""Data transfer deferred""; case NGHTTP2_ERR_STREAM_ID_NOT_AVAILABLE: return ""No more Stream ID available""; case NGHTTP2_ERR_STREAM_CLOSED: return ""Stream was already closed or invalid""; case NGHTTP2_ERR_STREAM_CLOSING: return ""Stream is closing""; case NGHTTP2_ERR_STREAM_SHUT_WR: return ""The transmission is not allowed for this stream""; case NGHTTP2_ERR_INVALID_STREAM_ID: return ""Stream ID is invalid""; case NGHTTP2_ERR_INVALID_STREAM_STATE: return ""Invalid stream state""; case NGHTTP2_ERR_DEFERRED_DATA_EXIST: return ""Another DATA frame has already been deferred""; case NGHTTP2_ERR_START_STREAM_NOT_ALLOWED: return ""request HEADERS is not allowed""; case NGHTTP2_ERR_GOAWAY_ALREADY_SENT: return ""GOAWAY has already been sent""; case NGHTTP2_ERR_INVALID_HEADER_BLOCK: return ""Invalid header block""; case NGHTTP2_ERR_INVALID_STATE: return ""Invalid state""; case NGHTTP2_ERR_TEMPORAL_CALLBACK_FAILURE: return ""The user callback function failed due to the temporal error""; case NGHTTP2_ERR_FRAME_SIZE_ERROR: return ""The length of the frame is invalid""; case NGHTTP2_ERR_HEADER_COMP: return ""Header compression/decompression error""; case NGHTTP2_ERR_FLOW_CONTROL: return ""Flow control error""; case NGHTTP2_ERR_INSUFF_BUFSIZE: return ""Insufficient buffer size given to function""; case NGHTTP2_ERR_PAUSE: return ""Callback was paused by the application""; case NGHTTP2_ERR_TOO_MANY_INFLIGHT_SETTINGS: return ""Too many inflight SETTINGS""; case NGHTTP2_ERR_PUSH_DISABLED: return ""Server push is disabled by peer""; case NGHTTP2_ERR_DATA_EXIST: return ""DATA or HEADERS frame has already been submitted for the stream""; case NGHTTP2_ERR_SESSION_CLOSING: return ""The current session is closing""; case NGHTTP2_ERR_HTTP_HEADER: return ""Invalid HTTP header field was received""; case NGHTTP2_ERR_HTTP_MESSAGING: return ""Violation in HTTP messaging rule""; case NGHTTP2_ERR_REFUSED_STREAM: return ""Stream was refused""; case NGHTTP2_ERR_INTERNAL: return ""Internal error""; case NGHTTP2_ERR_CANCEL: return ""Cancel""; case NGHTTP2_ERR_SETTINGS_EXPECTED: return ""When a local endpoint expects to receive SETTINGS frame, it "" ""receives an other type of frame""; case NGHTTP2_ERR_NOMEM: return ""Out of memory""; case NGHTTP2_ERR_CALLBACK_FAILURE: return ""The user callback function failed""; case NGHTTP2_ERR_BAD_CLIENT_MAGIC: return ""Received bad client magic byte string""; case NGHTTP2_ERR_FLOODED: return ""Flooding was detected in this HTTP/2 session, and it must be "" ""closed""; default: return ""Unknown error code""; } }
Description: In nghttp2 before version 1.41.0, the overly large HTTP/2 SETTINGS frame payload causes denial of service. The proof of concept attack involves a malicious client constructing a SETTINGS frame with a length of 14,400 bytes (2400 individual settings entries) over and over again. The attack causes the CPU to spike at 100%. nghttp2 v1.41.0 fixes this vulnerability. There is a workaround to this vulnerability. Implement nghttp2_on_frame_recv_callback callback, and if received frame is SETTINGS frame and the number of settings entries are large (e.g., > 32), then drop the connection.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int writelogentry(PFTPCONTEXT context, const char *logtext1, const char *logtext2) { charcvbuf[32], _text[512]; time_titm = time(NULL); struct tmltm; localtime_r(&itm, &ltm); _text[0] = 0; if ( ltm.tm_mday < 10 ) strcat(_text, ""0""); ultostr(ltm.tm_mday, cvbuf); strcat(_text, cvbuf); strcat(_text, ""-""); if ( ltm.tm_mon+1 < 10 ) strcat(_text, ""0""); ultostr(ltm.tm_mon+1, cvbuf); strcat(_text, cvbuf); strcat(_text, ""-""); ultostr(ltm.tm_year+1900, cvbuf); strcat(_text, cvbuf); strcat(_text, "" ""); if ( ltm.tm_hour < 10 ) strcat(_text, ""0""); ultostr(ltm.tm_hour, cvbuf); strcat(_text, cvbuf); strcat(_text, "":""); if ( ltm.tm_min < 10 ) strcat(_text, ""0""); ultostr(ltm.tm_min, cvbuf); strcat(_text, cvbuf); strcat(_text, "":""); if ( ltm.tm_sec < 10 ) strcat(_text, ""0""); ultostr(ltm.tm_sec, cvbuf); strcat(_text, cvbuf); if (context) { strcat(_text, "" S-id=""); ultostr(context->SessionID, cvbuf); strcat(_text, cvbuf); } strcat(_text, "": ""); if (logtext1) strcat(_text, logtext1); if (logtext2) strcat(_text, logtext2); strcat(_text, CRLF); return writeconsolestr(_text); }
Description: LightFTP version 1.1 is vulnerable to a buffer overflow in the ""writelogentry"" function resulting a denial of services or a remote code execution.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void g_keyfile_settings_backend_constructed (GObject *object) { GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object); if (kfsb->file == NULL) { char *filename = g_build_filename (g_get_user_config_dir (), ""glib-2.0"", ""settings"", ""keyfile"", NULL); kfsb->file = g_file_new_for_path (filename); g_free (filename); } if (kfsb->prefix == NULL) { kfsb->prefix = g_strdup (""/""); kfsb->prefix_len = 1; } kfsb->keyfile = g_key_file_new (); kfsb->permission = g_simple_permission_new (TRUE); kfsb->dir = g_file_get_parent (kfsb->file); g_file_make_directory_with_parents (kfsb->dir, NULL, NULL); kfsb->file_monitor = g_file_monitor (kfsb->file, G_FILE_MONITOR_NONE, NULL, NULL); kfsb->dir_monitor = g_file_monitor (kfsb->dir, G_FILE_MONITOR_NONE, NULL, NULL); compute_checksum (kfsb->digest, NULL, 0); g_signal_connect (kfsb->file_monitor, ""changed"", G_CALLBACK (file_changed), kfsb); g_signal_connect (kfsb->dir_monitor, ""changed"", G_CALLBACK (dir_changed), kfsb); g_keyfile_settings_backend_keyfile_writable (kfsb); g_keyfile_settings_backend_keyfile_reload (kfsb); load_system_settings (kfsb); }
Description: The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: kadm5_ret_t kadm5_modify_principal(void *server_handle, kadm5_principal_ent_t entry, long mask) { int                     ret, ret2, i; kadm5_policy_ent_rec    pol; krb5_boolean            have_pol = FALSE; krb5_db_entry           *kdb; krb5_tl_data            *tl_data_orig; osa_princ_ent_rec       adb; kadm5_server_handle_t handle = server_handle; CHECK_HANDLE(server_handle); krb5_clear_error_message(handle->context); if((mask & KADM5_PRINCIPAL) || (mask & KADM5_LAST_PWD_CHANGE) || (mask & KADM5_MOD_TIME) || (mask & KADM5_MOD_NAME) || (mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) || (mask & KADM5_KEY_DATA) || (mask & KADM5_LAST_SUCCESS) || (mask & KADM5_LAST_FAILED)) return KADM5_BAD_MASK; if((mask & ~ALL_PRINC_MASK)) return KADM5_BAD_MASK; if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR)) return KADM5_BAD_MASK; if(entry == (kadm5_principal_ent_t) NULL) return EINVAL; if (mask & KADM5_TL_DATA) { tl_data_orig = entry->tl_data; while (tl_data_orig) { if (tl_data_orig->tl_data_type < 256) return KADM5_BAD_TL_TYPE; tl_data_orig = tl_data_orig->tl_data_next; } } ret = kdb_get_entry(handle, entry->principal, &kdb, &adb); if (ret) return(ret); if ((mask & KADM5_POLICY)) { ret = get_policy(handle, entry->policy, &pol, &have_pol); if (ret) goto done; adb.aux_attributes |= KADM5_POLICY; if (adb.policy) free(adb.policy); adb.policy = strdup(entry->policy); } if (have_pol) { if (pol.pw_max_life) { ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb, &(kdb->pw_expiration)); if (ret) goto done; kdb->pw_expiration += pol.pw_max_life; } else { kdb->pw_expiration = 0; } } if ((mask & KADM5_POLICY_CLR) && (adb.aux_attributes & KADM5_POLICY)) { free(adb.policy); adb.policy = NULL; adb.aux_attributes &= ~KADM5_POLICY; kdb->pw_expiration = 0; } if ((mask & KADM5_ATTRIBUTES)) kdb->attributes = entry->attributes; if ((mask & KADM5_MAX_LIFE)) kdb->max_life = entry->max_life; if ((mask & KADM5_PRINC_EXPIRE_TIME)) kdb->expiration = entry->princ_expire_time; if (mask & KADM5_PW_EXPIRATION) kdb->pw_expiration = entry->pw_expiration; if (mask & KADM5_MAX_RLIFE) kdb->max_renewable_life = entry->max_renewable_life; if((mask & KADM5_KVNO)) { for (i = 0; i < kdb->n_key_data; i++) kdb->key_data[i].key_data_kvno = entry->kvno; } if (mask & KADM5_TL_DATA) { krb5_tl_data *tl; for (tl = entry->tl_data; tl; tl = tl->tl_data_next) { ret = krb5_dbe_update_tl_data(handle->context, kdb, tl); if( ret ) { goto done; } } } if (mask & KADM5_FAIL_AUTH_COUNT) { if (entry->fail_auth_count != 0) { ret = KADM5_BAD_SERVER_PARAMS; goto done; } kdb->fail_auth_count = 0; } kdb->mask = mask; ret = k5_kadm5_hook_modify(handle->context, handle->hook_handles, KADM5_HOOK_STAGE_PRECOMMIT, entry, mask); if (ret) goto done; ret = kdb_put_entry(handle, kdb, &adb); if (ret) goto done; (void) k5_kadm5_hook_modify(handle->context, handle->hook_handles, KADM5_HOOK_STAGE_POSTCOMMIT, entry, mask); ret = KADM5_OK; done: if (have_pol) { ret2 = kadm5_free_policy_ent(handle->lhandle, &pol); ret = ret ? ret : ret2; } kdb_free_entry(handle, kdb, &adb); return ret; }
Description: The (1) kadm5_create_principal_3 and (2) kadm5_modify_principal functions in lib/kadm5/srv/svr_principal.c in kadmind in MIT Kerberos 5 (aka krb5) 1.12.x and 1.13.x before 1.13.4 and 1.14.x before 1.14.1 allow remote authenticated users to cause a denial of service (NULL pointer dereference and daemon crash) by specifying KADM5_POLICY with a NULL policy name.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int MqttClient_WaitType(MqttClient *client, void *packet_obj, byte wait_type, word16 wait_packet_id, int timeout_ms) { int rc; word16 packet_id; MqttPacketType packet_type; #ifdef WOLFMQTT_MULTITHREAD MqttPendResp *pendResp; int readLocked; #endif MqttMsgStat* mms_stat; int waitMatchFound; if (client == NULL || packet_obj == NULL) { return MQTT_CODE_ERROR_BAD_ARG; } mms_stat = (MqttMsgStat*)packet_obj; wait_again: packet_id = 0; packet_type = MQTT_PACKET_TYPE_RESERVED; #ifdef WOLFMQTT_MULTITHREAD pendResp = NULL; readLocked = 0; #endif waitMatchFound = 0; #ifdef WOLFMQTT_DEBUG_CLIENT PRINTF(""MqttClient_WaitType: Type %s (%d), ID %d"", MqttPacket_TypeDesc((MqttPacketType)wait_type), wait_type, wait_packet_id); #endif switch ((int)*mms_stat) { case MQTT_MSG_BEGIN: { #ifdef WOLFMQTT_MULTITHREAD rc = wm_SemLock(&client->lockRecv); if (rc != 0) { PRINTF(""MqttClient_WaitType: recv lock error!""); return rc; } readLocked = 1; #endif client->packet.stat = MQTT_PK_BEGIN; } FALL_THROUGH; #ifdef WOLFMQTT_V5 case MQTT_MSG_AUTH: #endif case MQTT_MSG_WAIT: { #ifdef WOLFMQTT_MULTITHREAD pendResp = NULL; rc = wm_SemLock(&client->lockClient); if (rc == 0) { if (MqttClient_RespList_Find(client, (MqttPacketType)wait_type,  wait_packet_id, &pendResp)) { if (pendResp->packetDone) { rc = pendResp->packet_ret; #ifdef WOLFMQTT_DEBUG_CLIENT PRINTF(""PendResp already Done %p: Rc %d"", pendResp, rc); #endif MqttClient_RespList_Remove(client, pendResp); wm_SemUnlock(&client->lockClient); wm_SemUnlock(&client->lockRecv); return rc; } } wm_SemUnlock(&client->lockClient); } else { break;  } #endif  *mms_stat = MQTT_MSG_WAIT; rc = MqttPacket_Read(client, client->rx_buf, client->rx_buf_len, timeout_ms); if (rc <= 0) { break; } client->packet.buf_len = rc; rc = MqttClient_DecodePacket(client, client->rx_buf, client->packet.buf_len, NULL, &packet_type, NULL, &packet_id); if (rc < 0) { break; } #ifdef WOLFMQTT_DEBUG_CLIENT PRINTF(""Read Packet: Len %d, Type %d, ID %d"", client->packet.buf_len, packet_type, packet_id); #endif *mms_stat = MQTT_MSG_READ; } FALL_THROUGH; case MQTT_MSG_READ: case MQTT_MSG_READ_PAYLOAD: { MqttPacketType use_packet_type; void* use_packet_obj; #ifdef WOLFMQTT_MULTITHREAD readLocked = 1;  #endif if (*mms_stat == MQTT_MSG_READ_PAYLOAD) { packet_type = MQTT_PACKET_TYPE_PUBLISH; } if ((wait_type == MQTT_PACKET_TYPE_ANY || wait_type == packet_type || MqttIsPubRespPacket(packet_type) == MqttIsPubRespPacket(wait_type)) && (wait_packet_id == 0 || wait_packet_id == packet_id)) { use_packet_obj = packet_obj; waitMatchFound = 1; } else { use_packet_obj = &client->msg; } use_packet_type = packet_type; #ifdef WOLFMQTT_MULTITHREAD pendResp = NULL; rc = wm_SemLock(&client->lockClient); if (rc == 0) { if (MqttClient_RespList_Find(client, packet_type, packet_id, &pendResp)) { pendResp->packetProcessing = 1; use_packet_obj = pendResp->packet_obj; use_packet_type = pendResp->packet_type; waitMatchFound = 0; } wm_SemUnlock(&client->lockClient); } else { break;  } #endif  rc = MqttClient_HandlePacket(client, use_packet_type, use_packet_obj, timeout_ms); #ifdef WOLFMQTT_NONBLOCK if (rc == MQTT_CODE_CONTINUE) { return rc; } #endif if (rc >= 0) { rc = MQTT_CODE_SUCCESS; } #ifdef WOLFMQTT_MULTITHREAD if (pendResp) { if (wm_SemLock(&client->lockClient) == 0) { pendResp->packetDone = 1; pendResp->packet_ret = rc; #ifdef WOLFMQTT_DEBUG_CLIENT PRINTF(""PendResp Done %p"", pendResp); #endif pendResp = NULL; wm_SemUnlock(&client->lockClient); } } #endif  break; } case MQTT_MSG_WRITE: case MQTT_MSG_WRITE_PAYLOAD: default: { #ifdef WOLFMQTT_DEBUG_CLIENT PRINTF(""MqttClient_WaitType: Invalid state %d!"", *mms_stat); #endif rc = MQTT_CODE_ERROR_STAT; break; } }  #ifdef WOLFMQTT_NONBLOCK if (rc != MQTT_CODE_CONTINUE) #endif { *mms_stat = MQTT_MSG_BEGIN; } #ifdef WOLFMQTT_MULTITHREAD if (readLocked) { wm_SemUnlock(&client->lockRecv); } #endif if (rc < 0) { #ifdef WOLFMQTT_DEBUG_CLIENT PRINTF(""MqttClient_WaitType: Failure: %s (%d)"", MqttClient_ReturnCodeToString(rc), rc); #endif return rc; } if (!waitMatchFound) { goto wait_again; } return rc; }
Description: wolfSSL wolfMQTT 1.9 has a heap-based buffer overflow (4 bytes) in MqttDecode_Publish (called from MqttClient_DecodePacket and MqttClient_HandlePacket).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void lys_node_free(struct lys_node *node, void (*private_destructor)(const struct lys_node *node, void *priv), int shallow) { struct ly_ctx *ctx; struct lys_node *sub, *next; if (!node) { return; } assert(node->module); assert(node->module->ctx); ctx = node->module->ctx; if (node->priv && private_destructor) { private_destructor(node, node->priv); } lydict_remove(ctx, node->name); if (!(node->nodetype & (LYS_INPUT | LYS_OUTPUT))) { lys_iffeature_free(ctx, node->iffeature, node->iffeature_size, shallow, private_destructor); lydict_remove(ctx, node->dsc); lydict_remove(ctx, node->ref); } if (!shallow && !(node->nodetype & (LYS_LEAF | LYS_LEAFLIST))) { LY_TREE_FOR_SAFE(node->child, next, sub) { lys_node_free(sub, private_destructor, 0); } } lys_extension_instances_free(ctx, node->ext, node->ext_size, private_destructor); switch (node->nodetype) { case LYS_CONTAINER: lys_container_free(ctx, (struct lys_node_container *)node, private_destructor); break; case LYS_CHOICE: lys_when_free(ctx, ((struct lys_node_choice *)node)->when, private_destructor); break; case LYS_LEAF: lys_leaf_free(ctx, (struct lys_node_leaf *)node, private_destructor); break; case LYS_LEAFLIST: lys_leaflist_free(ctx, (struct lys_node_leaflist *)node, private_destructor); break; case LYS_LIST: lys_list_free(ctx, (struct lys_node_list *)node, private_destructor); break; case LYS_ANYXML: case LYS_ANYDATA: lys_anydata_free(ctx, (struct lys_node_anydata *)node, private_destructor); break; case LYS_USES: lys_uses_free(ctx, (struct lys_node_uses *)node, private_destructor); break; case LYS_CASE: lys_when_free(ctx, ((struct lys_node_case *)node)->when, private_destructor); break; case LYS_AUGMENT: break; case LYS_GROUPING: lys_grp_free(ctx, (struct lys_node_grp *)node, private_destructor); break; case LYS_RPC: case LYS_ACTION: lys_rpc_action_free(ctx, (struct lys_node_rpc_action *)node, private_destructor); break; case LYS_NOTIF: lys_notif_free(ctx, (struct lys_node_notif *)node, private_destructor); break; case LYS_INPUT: case LYS_OUTPUT: lys_inout_free(ctx, (struct lys_node_inout *)node, private_destructor); break; case LYS_EXT: case LYS_UNKNOWN: LOGINT(ctx); break; } lys_node_unlink(node); free(node); }
Description: In function lys_node_free() in libyang <= v1.0.225, it asserts that the value of node->module can't be NULL. But in some cases, node->module can be null, which triggers a reachable assertion (CWE-617).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static char *clean_path(char *path) { char *ch; char *ch2; char *str; str = xmalloc(strlen(path)); ch = path; ch2 = str; while (true) { *ch2 = *ch; ch++; ch2++; if (!*(ch-1)) break; while (*(ch - 1) == '/' && *ch == '/') ch++; } while ((ch = strrchr(str, '/'))) { if (ch == str) break; if (!*(ch+1)) *ch = 0; else break; } return str; }
Description: checkpath in OpenRC before 0.44.7 uses the direct output of strlen() to allocate strings, which does not account for the '\0' byte at the end of the string. This results in memory corruption. CVE-2021-42341 was introduced in git commit 63db2d99e730547339d1bdd28e8437999c380cae, which was introduced as part of OpenRC 0.44.0 development.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: GdkPixbuf* gdk_pixbuf_gif_anim_iter_get_pixbuf (GdkPixbufAnimationIter *anim_iter) { GdkPixbufGifAnimIter *iter = GDK_PIXBUF_GIF_ANIM_ITER (anim_iter); GdkPixbufGifAnim *anim = iter->gif_anim; GdkPixbufFrame *requested_frame; GList *link; if (iter->current_frame != NULL) requested_frame = iter->current_frame->data; else requested_frame = g_list_last (anim->frames)->data; if (anim->last_frame != NULL) { link = g_list_find (anim->frames, anim->last_frame); while (link != NULL && link->data != requested_frame) link = link->next; if (link == NULL) anim->last_frame = NULL; } if (anim->last_frame == NULL) { gsize len = 0; if (anim->last_frame_data == NULL) anim->last_frame_data = gdk_pixbuf_new (GDK_COLORSPACE_RGB, TRUE, 8, anim->width, anim->height); if (anim->last_frame_data == NULL) return NULL; if (g_size_checked_mul (&len, gdk_pixbuf_get_rowstride (anim->last_frame_data), anim->height)) memset (gdk_pixbuf_get_pixels (anim->last_frame_data), 0, len); else return NULL; composite_frame (anim, g_list_nth_data (anim->frames, 0)); } if (requested_frame == anim->last_frame) return anim->last_frame_data; for (link = g_list_find (anim->frames, anim->last_frame); link->next != NULL && link->data != requested_frame; link = link->next) { GdkPixbufFrame *frame = link->data; guchar *pixels; int y, x_end, y_end; switch (frame->action) { case GDK_PIXBUF_FRAME_RETAIN: break; case GDK_PIXBUF_FRAME_DISPOSE: pixels = gdk_pixbuf_get_pixels (anim->last_frame_data); x_end = MIN (anim->last_frame->x_offset + anim->last_frame->width, anim->width); y_end = MIN (anim->last_frame->y_offset + anim->last_frame->height, anim->height); for (y = anim->last_frame->y_offset; y < y_end; y++) { guchar *line = pixels + y * gdk_pixbuf_get_rowstride (anim->last_frame_data) + anim->last_frame->x_offset * 4; memset (line, 0, (x_end - anim->last_frame->x_offset) * 4); } break; case GDK_PIXBUF_FRAME_REVERT: if (anim->last_frame_revert_data != NULL) gdk_pixbuf_copy_area (anim->last_frame_revert_data, 0, 0, anim->last_frame->width, anim->last_frame->height, anim->last_frame_data, anim->last_frame->x_offset, anim->last_frame->y_offset); break; } composite_frame (anim, link->next->data); } return anim->last_frame_data; }
Description: GNOME GdkPixbuf (aka GDK-PixBuf) before 2.42.8 allows a heap-based buffer overflow when compositing or clearing frames in GIF files, as demonstrated by io-gif-animation.c composite_frame. This overflow is controllable and could be abused for code execution, especially on 32-bit systems.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void cb_mq_metrics(mk_mq_t *queue, void *data, size_t size) { flb_sds_t out_data; struct flb_hs_buf *buf; struct mk_list *metrics_list = NULL; metrics_list = pthread_getspecific(hs_metrics_key); if (!metrics_list) { metrics_list = flb_malloc(sizeof(struct mk_list)); if (!metrics_list) { flb_errno(); return; } mk_list_init(metrics_list); pthread_setspecific(hs_metrics_key, metrics_list); } out_data = flb_msgpack_raw_to_json_sds(data, size); if (!out_data) { return; } buf = flb_malloc(sizeof(struct flb_hs_buf)); if (!buf) { flb_errno(); flb_sds_destroy(out_data); return; } buf->users = 0; buf->data = out_data; buf->raw_data = flb_malloc(size); memcpy(buf->raw_data, data, size); buf->raw_size = size; mk_list_add(&buf->_head, metrics_list); cleanup_metrics(); }
Description: Fluent Bit 1.6.10 has a NULL pointer dereference when an flb_malloc return value is not validated by flb_avro.c or http_server/api/v1/metrics.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: TfLiteStatus ResizeOutput(TfLiteContext* context, const TfLiteTensor* input, const TfLiteTensor* axis, TfLiteTensor* output) { int axis_value; if (axis->type == kTfLiteInt64) { axis_value = static_cast<int>(*GetTensorData<int64_t>(axis)); } else { axis_value = *GetTensorData<int>(axis); } if (axis_value < 0) { axis_value += NumDimensions(input); } TfLiteIntArray* output_dims = TfLiteIntArrayCreate(NumDimensions(input) - 1); int j = 0; for (int i = 0; i < NumDimensions(input); ++i) { if (i != axis_value) { output_dims->data[j] = SizeOfDimension(input, i); ++j; } } return context->ResizeTensor(context, output, output_dims); }
Description: TensorFlow is an end-to-end open source platform for machine learning. A specially crafted TFLite model could trigger an OOB write on heap in the TFLite implementation of `ArgMin`/`ArgMax`(https://github.com/tensorflow/tensorflow/blob/102b211d892f3abc14f845a72047809b39cc65ab/tensorflow/lite/kernels/arg_min_max.cc#L52-L59). If `axis_value` is not a value between 0 and `NumDimensions(input)`, then the condition in the `if` is never true, so code writes past the last valid element of `output_dims->data`. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int sudo_auth_init(const struct sudoers_context *ctx, struct passwd *pw, unsigned int mode) { sudo_auth *auth; int status = AUTH_SUCCESS; debug_decl(sudo_auth_init, SUDOERS_DEBUG_AUTH); if (auth_switch[0].name == NULL) debug_return_int(0); for (auth = auth_switch; auth->name; auth++) { if (ISSET(mode, MODE_NONINTERACTIVE)) SET(auth->flags, FLAG_NONINTERACTIVE); if (auth->init && !IS_DISABLED(auth)) { status = (auth->init)(ctx, pw, auth); if (status == AUTH_FAILURE) SET(auth->flags, FLAG_DISABLED); else if (status == AUTH_ERROR) break; } } if ((standalone = IS_STANDALONE(&auth_switch[0]))) { bool found = false; for (auth = auth_switch; auth->name; auth++) { if (IS_DISABLED(auth)) continue; if (!IS_STANDALONE(auth)) { audit_failure(ctx, ctx->runas.argv, N_(""invalid authentication methods"")); log_warningx(ctx, SLOG_SEND_MAIL, N_(""Invalid authentication methods compiled into sudo!  "" ""You may not mix standalone and non-standalone authentication."")); debug_return_int(-1); } if (!found) { found = true; continue; } SET(auth->flags, FLAG_DISABLED); } } for (auth = auth_switch; auth->name; auth++) { if (!IS_DISABLED(auth)) { sudo_auth *first = auth; for (; auth->name; auth++) { if (!IS_DISABLED(auth)) break; } if (auth->name == NULL) SET(first->flags, FLAG_ONEANDONLY); break; } } debug_return_int(status == AUTH_ERROR ? -1 : 0); }
Description: Sudo before 1.9.15 might allow row hammer attacks (for authentication bypass or privilege escalation) because application logic sometimes is based on not equaling an error value (instead of equaling a success value), and because the values do not resist flips of a single bit.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void AICast_ScriptParse( cast_state_t *cs ) { gentity_t   *ent; char        *pScript; char        *token; qboolean wantName; qboolean inScript; int eventNum; int numEventItems; cast_script_event_t *curEvent; char params[MAX_QPATH]; cast_script_stack_action_t  *action; int i; int bracketLevel; qboolean buildScript;        if ( !level.scriptAI ) { return; } ent = &g_entities[cs->entityNum]; if ( !ent->aiName ) { return; } buildScript = qtrue; pScript = level.scriptAI; wantName = qtrue; inScript = qfalse; COM_BeginParseSession( ""AICast_ScriptParse"" ); bracketLevel = 0; numEventItems = 0; memset( cast_temp_events, 0, sizeof( cast_temp_events ) ); while ( 1 ) { token = COM_Parse( &pScript ); if ( !token[0] ) { if ( !wantName ) { G_Error( ""AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\n"", COM_GetCurrentParseLine() ); } break; } if ( token[0] == '}' ) { if ( inScript ) { break; } if ( wantName ) { G_Error( ""AICast_ScriptParse(), Error (line %d): '}' found, but not expected.\n"", COM_GetCurrentParseLine() ); } wantName = qtrue; } else if ( token[0] == '{' )    { if ( wantName ) { G_Error( ""AICast_ScriptParse(), Error (line %d): '{' found, NAME expected.\n"", COM_GetCurrentParseLine() ); } } else if ( wantName )   { if ( !Q_strcasecmp( ent->aiName, token ) ) { inScript = qtrue; numEventItems = 0; } wantName = qfalse; } else if ( inScript )   { if ( !Q_strcasecmp( token, ""attributes"" ) ) { AICast_CheckLevelAttributes( cs, ent, &pScript ); continue; } eventNum = AICast_EventForString( token ); if ( eventNum < 0 ) { G_Error( ""AICast_ScriptParse(), Error (line %d): unknown event: %s.\n"", COM_GetCurrentParseLine(), token ); } if ( numEventItems >= MAX_SCRIPT_EVENTS ) { G_Error( ""AICast_ScriptParse(), Error (line %d): MAX_SCRIPT_EVENTS reached (%d)\n"", COM_GetCurrentParseLine(), MAX_SCRIPT_EVENTS ); } if ( !Q_stricmp( token, ""friendlysightcorpse"" ) ) { cs->aiFlags &= ~AIFL_CORPSESIGHTING; } curEvent = &cast_temp_events[numEventItems]; curEvent->eventNum = eventNum; memset( params, 0, sizeof( params ) ); while ( ( token = COM_Parse( &pScript ) ) && ( token[0] != '{' ) ) { if ( !token[0] ) { G_Error( ""AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\n"", COM_GetCurrentParseLine() ); } if ( eventNum == 13 ) {   if ( strlen( token ) > 1 ) { if ( BG_IndexForString( token, animStateStr, qtrue ) < 0 ) { G_Error( ""AICast_ScriptParse(), Error (line %d): unknown state type '%s'.\n"", COM_GetCurrentParseLine(), token ); } } } if ( strlen( params ) ) { Q_strcat( params, sizeof( params ), "" "" ); } Q_strcat( params, sizeof( params ), token ); } if ( strlen( params ) ) { curEvent->params = G_Alloc( strlen( params ) + 1 ); Q_strncpyz( curEvent->params, params, strlen( params ) + 1 ); } while ( ( token = COM_Parse( &pScript ) ) && ( token[0] != '}' ) ) { if ( !token[0] ) { G_Error( ""AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\n"", COM_GetCurrentParseLine() ); } action = AICast_ActionForString( cs, token ); if ( !action ) { G_Error( ""AICast_ScriptParse(), Error (line %d): unknown action: %s.\n"", COM_GetCurrentParseLine(), token ); } curEvent->stack.items[curEvent->stack.numItems].action = action; memset( params, 0, sizeof( params ) ); token = COM_ParseExt( &pScript, qfalse ); for ( i = 0; token[0]; i++ ) { if ( strlen( params ) ) { Q_strcat( params, sizeof( params ), "" "" ); } if ( i == 0 ) { if ( !Q_stricmp( action->actionString, ""playsound"" ) ) { G_SoundIndex( token ); } if (    buildScript && ( !Q_stricmp( action->actionString, ""mu_start"" ) || !Q_stricmp( action->actionString, ""mu_play"" ) || !Q_stricmp( action->actionString, ""mu_queue"" ) || !Q_stricmp( action->actionString, ""startcam"" ) || !Q_stricmp( action->actionString, ""startcamblack"" ) ) ) { if ( strlen( token ) ) { trap_SendServerCommand( cs->entityNum, va( ""addToBuild %s\n"", token ) ); } } if ( !Q_stricmp( action->actionString, ""giveweapon"" ) ) { gitem_t *weap = BG_FindItem2( token );    RegisterItem( weap );   } if ( !Q_stricmp( action->actionString, ""changelevel"" ) ) { Q_strncpyz( level.nextMap, token, sizeof( level.nextMap ) ); trap_Cvar_Set( ""nextmap"", level.nextMap ); } } if ( strrchr( token,' ' ) ) { Q_strcat( params, sizeof( params ), ""\"""" ); } Q_strcat( params, sizeof( params ), token ); if ( strrchr( token,' ' ) ) { Q_strcat( params, sizeof( params ), ""\"""" ); } token = COM_ParseExt( &pScript, qfalse ); } if ( strlen( params ) ) { curEvent->stack.items[curEvent->stack.numItems].params = G_Alloc( strlen( params ) + 1 ); Q_strncpyz( curEvent->stack.items[curEvent->stack.numItems].params, params, strlen( params ) + 1 ); } curEvent->stack.numItems++; if ( curEvent->stack.numItems >= AICAST_MAX_SCRIPT_STACK_ITEMS ) { G_Error( ""AICast_ScriptParse(): script exceeded MAX_SCRIPT_ITEMS (%d), line %d\n"", AICAST_MAX_SCRIPT_STACK_ITEMS, COM_GetCurrentParseLine() ); } } numEventItems++; } else    { while ( ( token = COM_Parse( &pScript ) ) ) { if ( !token[0] ) { G_Error( ""AICast_ScriptParse(), Error (line %d): '}' expected, end of script found.\n"", COM_GetCurrentParseLine() ); } else if ( token[0] == '{' ) { bracketLevel++; } else if ( token[0] == '}' ) { if ( !--bracketLevel ) { break; } } } } } if ( numEventItems > 0 ) { cs->castScriptEvents = G_Alloc( sizeof( cast_script_event_t ) * numEventItems ); memcpy( cs->castScriptEvents, cast_temp_events, sizeof( cast_script_event_t ) * numEventItems ); cs->numCastScriptEvents = numEventItems; cs->castScriptStatus.castScriptEventIndex = -1; } }
Description: A vulnerability has been found in rtcwcoop 1.0.2 and classified as problematic. Affected by this vulnerability is the function AICast_ScriptLoad of the file code/game/ai_cast_script.c of the component Team Command Handler. The manipulation leads to denial of service. The identifier of the patch is f2cd18bc2e1cbca8c4b78bee9c392272bd5f42ac. It is recommended to apply a patch to fix this issue. The identifier VDB-221485 was assigned to this vulnerability.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static long ec_device_ioctl_xcmd(struct cros_ec_dev *ec, void __user *arg) { long ret; struct cros_ec_command u_cmd; struct cros_ec_command *s_cmd; if (copy_from_user(&u_cmd, arg, sizeof(u_cmd))) return -EFAULT; if ((u_cmd.outsize > EC_MAX_MSG_BYTES) || (u_cmd.insize > EC_MAX_MSG_BYTES)) return -EINVAL; s_cmd = kmalloc(sizeof(*s_cmd) + max(u_cmd.outsize, u_cmd.insize), GFP_KERNEL); if (!s_cmd) return -ENOMEM; if (copy_from_user(s_cmd, arg, sizeof(*s_cmd) + u_cmd.outsize)) { ret = -EFAULT; goto exit; } s_cmd->command += ec->cmd_offset; ret = cros_ec_cmd_xfer(ec->ec_dev, s_cmd); if (ret < 0) goto exit; if (copy_to_user(arg, s_cmd, sizeof(*s_cmd) + u_cmd.insize)) ret = -EFAULT; exit: kfree(s_cmd); return ret; }
Description: Race condition in the ec_device_ioctl_xcmd function in drivers/platform/chrome/cros_ec_dev.c in the Linux kernel before 4.7 allows local users to cause a denial of service (out-of-bounds array access) by changing a certain size value, aka a ""double fetch"" vulnerability.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void ext4_es_insert_extent(struct inode *inode, ext4_lblk_t lblk, ext4_lblk_t len, ext4_fsblk_t pblk, unsigned int status) { struct extent_status newes; ext4_lblk_t end = lblk + len - 1; int err1 = 0; int err2 = 0; struct ext4_sb_info *sbi = EXT4_SB(inode->i_sb); struct extent_status *es1 = NULL; struct extent_status *es2 = NULL; if (EXT4_SB(inode->i_sb)->s_mount_state & EXT4_FC_REPLAY) return; es_debug(""add [%u/%u) %llu %x to extent status tree of inode %lu\n"", lblk, len, pblk, status, inode->i_ino); if (!len) return; BUG_ON(end < lblk); if ((status & EXTENT_STATUS_DELAYED) && (status & EXTENT_STATUS_WRITTEN)) { ext4_warning(inode->i_sb, ""Inserting extent [%u/%u] as "" "" delayed and written which can potentially "" "" cause data loss."", lblk, len); WARN_ON(1); } newes.es_lblk = lblk; newes.es_len = len; ext4_es_store_pblock_status(&newes, pblk, status); trace_ext4_es_insert_extent(inode, &newes); ext4_es_insert_extent_check(inode, &newes); retry: if (err1 && !es1) es1 = __es_alloc_extent(true); if ((err1 || err2) && !es2) es2 = __es_alloc_extent(true); write_lock(&EXT4_I(inode)->i_es_lock); err1 = __es_remove_extent(inode, lblk, end, NULL, es1); if (err1 != 0) goto error; err2 = __es_insert_extent(inode, &newes, es2); if (err2 == -ENOMEM && !ext4_es_must_keep(&newes)) err2 = 0; if (err2 != 0) goto error; if (sbi->s_cluster_ratio > 1 && test_opt(inode->i_sb, DELALLOC) && (status & EXTENT_STATUS_WRITTEN || status & EXTENT_STATUS_UNWRITTEN)) __revise_pending(inode, lblk, len); if (es1 && !es1->es_len) __es_free_extent(es1); if (es2 && !es2->es_len) __es_free_extent(es2); error: write_unlock(&EXT4_I(inode)->i_es_lock); if (err1 || err2) goto retry; ext4_es_print_tree(inode); return; }
Description: The Linux kernel before 6.5.4 has an es1 use-after-free in fs/ext4/extents_status.c, related to ext4_es_insert_extent.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void sycc422_to_rgb(opj_image_t* img) { int *d0, *d1, *d2, *r, *g, *b; const int *y, *cb, *cr; int maxw, maxh, max, offset, upb; int i, j; i = (int)img->comps[0].prec; offset = 1 << (i - 1); upb = (1 << i) - 1; maxw = (int)img->comps[0].w; maxh = (int)img->comps[0].h; max = maxw * maxh; y = img->comps[0].data; cb = img->comps[1].data; cr = img->comps[2].data; d0 = r = FX_Alloc(int, (size_t)max); d1 = g = FX_Alloc(int, (size_t)max); d2 = b = FX_Alloc(int, (size_t)max); for (i = 0; i < maxh; ++i) { for (j = 0; (OPJ_UINT32)j < (maxw & ~(OPJ_UINT32)1); j += 2) { sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b); ++y; ++r; ++g; ++b; sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b); ++y; ++r; ++g; ++b; ++cb; ++cr; } if (j < maxw) { sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b); ++y; ++r; ++g; ++b; ++cb; ++cr; } } FX_Free(img->comps[0].data); img->comps[0].data = d0; FX_Free(img->comps[1].data); img->comps[1].data = d1; FX_Free(img->comps[2].data); img->comps[2].data = d2; img->comps[1].w = maxw; img->comps[1].h = maxh; img->comps[2].w = maxw; img->comps[2].h = maxh; img->comps[1].w = (OPJ_UINT32)maxw; img->comps[1].h = (OPJ_UINT32)maxh; img->comps[2].w = (OPJ_UINT32)maxw; img->comps[2].h = (OPJ_UINT32)maxh; img->comps[1].dx = img->comps[0].dx; img->comps[2].dx = img->comps[0].dx; img->comps[1].dy = img->comps[0].dy; img->comps[2].dy = img->comps[0].dy; }
Description: Multiple integer overflows in the (1) sycc422_to_rgb and (2) sycc444_to_rgb functions in fxcodec/codec/fx_codec_jpx_opj.cpp in PDFium, as used in Google Chrome before 48.0.2564.82, allow remote attackers to cause a denial of service (out-of-bounds read) or possibly have unspecified other impact via a crafted PDF document.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int inet_dgram_connect(struct socket *sock, struct sockaddr *uaddr, int addr_len, int flags) { struct sock *sk = sock->sk; int err; if (addr_len < sizeof(uaddr->sa_family)) return -EINVAL; if (uaddr->sa_family == AF_UNSPEC) return sk->sk_prot->disconnect(sk, flags); if (BPF_CGROUP_PRE_CONNECT_ENABLED(sk)) { err = sk->sk_prot->pre_connect(sk, uaddr, addr_len); if (err) return err; } if (data_race(!inet_sk(sk)->inet_num) && inet_autobind(sk)) return -EAGAIN; return sk->sk_prot->connect(sk, uaddr, addr_len); }
Description: A vulnerability has been found in Linux Kernel and classified as problematic. This vulnerability affects the function inet6_stream_ops/inet6_dgram_ops of the component IPv6 Handler. The manipulation leads to race condition. It is recommended to apply a patch to fix this issue. VDB-211090 is the identifier assigned to this vulnerability.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: CFX_PathData* CFX_Font::LoadGlyphPath(uint32_t glyph_index, int dest_width) { if (!m_Face) { return NULL; } FXFT_Set_Pixel_Sizes(m_Face, 0, 64); FXFT_Matrix ft_matrix = {65536, 0, 0, 65536}; if (m_pSubstFont) { if (m_pSubstFont->m_ItalicAngle) { int skew = m_pSubstFont->m_ItalicAngle; skew = -skew <= static_cast<int>(ANGLESKEW_ARRAY_SIZE) ? -58 : -g_AngleSkew[-skew]; if (m_bVertical) ft_matrix.yx += ft_matrix.yy * skew / 100; else ft_matrix.xy += -ft_matrix.xx * skew / 100; } if (m_pSubstFont->m_SubstFlags & FXFONT_SUBST_MM) { AdjustMMParams(glyph_index, dest_width, m_pSubstFont->m_Weight); } } ScopedFontTransform scoped_transform(m_Face, &ft_matrix); int load_flags = FXFT_LOAD_NO_BITMAP; if (!(m_Face->face_flags & FT_FACE_FLAG_SFNT) || !FT_IS_TRICKY(m_Face)) { load_flags |= FT_LOAD_NO_HINTING; } if (FXFT_Load_Glyph(m_Face, glyph_index, load_flags)) return NULL; if (m_pSubstFont && !(m_pSubstFont->m_SubstFlags & FXFONT_SUBST_MM) && m_pSubstFont->m_Weight > 400) { uint32_t index = (m_pSubstFont->m_Weight - 400) / 10; if (index >= WEIGHTPOW_ARRAY_SIZE) index = WEIGHTPOW_ARRAY_SIZE - 1; int level = 0; if (m_pSubstFont->m_Charset == FXFONT_SHIFTJIS_CHARSET) level = g_WeightPow_SHIFTJIS[index] * 2 * 65536 / 36655; else level = g_WeightPow[index] * 2; FXFT_Outline_Embolden(FXFT_Get_Glyph_Outline(m_Face), level); } FXFT_Outline_Funcs funcs; funcs.move_to = _Outline_MoveTo; funcs.line_to = _Outline_LineTo; funcs.conic_to = _Outline_ConicTo; funcs.cubic_to = _Outline_CubicTo; funcs.shift = 0; funcs.delta = 0; OUTLINE_PARAMS params; params.m_bCount = TRUE; params.m_PointCount = 0; FXFT_Outline_Decompose(FXFT_Get_Glyph_Outline(m_Face), &funcs, &params); if (params.m_PointCount == 0) { return NULL; } CFX_PathData* pPath = new CFX_PathData; pPath->SetPointCount(params.m_PointCount); params.m_bCount = FALSE; params.m_PointCount = 0; params.m_pPoints = pPath->GetPoints(); params.m_CurX = params.m_CurY = 0; params.m_CoordUnit = 64 * 64.0; FXFT_Outline_Decompose(FXFT_Get_Glyph_Outline(m_Face), &funcs, &params); _Outline_CheckEmptyContour(&params); pPath->TrimPoints(params.m_PointCount); if (params.m_PointCount) { pPath->GetPoints()[params.m_PointCount - 1].m_Flag |= FXPT_CLOSEFIGURE; } return pPath; }
Description: core/fxge/ge/fx_ge_text.cpp in PDFium, as used in Google Chrome before 51.0.2704.63, miscalculates certain index values, which allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted PDF document.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Status TrySimplify(NodeDef* consumer, string* simplified_node_name) override { NodeDef* producer; TF_RETURN_IF_ERROR(GetInputNode(consumer->input(0), &producer)); const bool producer_is_cast = IsCastLike(*producer); const bool can_optimize = !IsCheckNumerics(*producer) && ((producer_is_cast && IsValuePreserving(*consumer)) || (IsValuePreserving(*producer) && IsCastLike(*consumer))); if (!can_optimize || IsControlFlow(*producer) || IsInPreserveSet(*producer) || producer->device() != consumer->device()) { return Status::OK(); } const NodeDef* cast_like_node = producer_is_cast ? producer : consumer; const OpDef* cast_like_op_def = nullptr; TF_RETURN_IF_ERROR(OpRegistry::Global()->LookUpOpDef(cast_like_node->op(), &cast_like_op_def)); DataType cast_src_type; TF_RETURN_IF_ERROR(InputTypeForNode(*cast_like_node, *cast_like_op_def, 0, &cast_src_type)); DataType cast_dst_type; TF_RETURN_IF_ERROR(OutputTypeForNode(*cast_like_node, *cast_like_op_def, 0, &cast_dst_type)); if (!IsFixedSizeType(cast_src_type) || !IsFixedSizeType(cast_dst_type)) { return Status::OK(); } else if (producer_is_cast && DataTypeSize(cast_dst_type) <= DataTypeSize(cast_src_type)) { return Status::OK(); } else if (!producer_is_cast && DataTypeSize(cast_dst_type) >= DataTypeSize(cast_src_type)) { return Status::OK(); } const string optimized_producer_name = OptimizedNodeName( ParseNodeScopeAndName(producer->name()), DataTypeString(cast_dst_type)); const string optimized_consumer_name = OptimizedNodeName( ParseNodeScopeAndName(consumer->name()), DataTypeString(cast_src_type)); const bool is_already_optimized = ctx().node_map->NodeExists(optimized_consumer_name) || ctx().node_map->NodeExists(optimized_producer_name); if (is_already_optimized) { return Status::OK(); } NodeDef* input; TF_RETURN_IF_ERROR(GetInputNode(producer->input(0), &input)); NodeDef* new_producer = AddCopyNode(optimized_consumer_name, consumer); new_producer->set_input(0, producer->input(0)); ctx().node_map->AddOutput(input->name(), new_producer->name()); NodeDef* new_consumer = AddCopyNode(optimized_producer_name, producer); new_consumer->set_input(0, new_producer->name()); NodeDef* new_value_preserving = producer_is_cast ? new_producer : new_consumer; const DataType new_input_type = producer_is_cast ? cast_src_type : cast_dst_type; TF_RETURN_IF_ERROR(SetInputType(new_input_type, new_value_preserving)); TF_RETURN_IF_ERROR(IsKernelRegisteredForNode(*new_value_preserving)); ctx().node_map->AddOutput(new_producer->name(), new_consumer->name()); AddToOptimizationQueue(new_producer); *simplified_node_name = new_consumer->name(); return Status::OK(); }
Description: TensorFlow is an end-to-end open source platform for machine learning. The implementation of TrySimplify(https://github.com/tensorflow/tensorflow/blob/c22d88d6ff33031aa113e48aa3fc9aa74ed79595/tensorflow/core/grappler/optimizers/arithmetic_optimizer.cc#L390-L401) has undefined behavior due to dereferencing a null pointer in corner cases that result in optimizing a node with no inputs. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static PixelChannels **AcquirePixelThreadSet(const Image *images) { const Image *next; PixelChannels **pixels; register ssize_t i; size_t columns, number_threads; number_threads=(size_t) GetMagickResourceLimit(ThreadResource); pixels=(PixelChannels **) AcquireQuantumMemory(number_threads, sizeof(*pixels)); if (pixels == (PixelChannels **) NULL) return((PixelChannels **) NULL); (void) memset(pixels,0,number_threads*sizeof(*pixels)); columns=images->columns; for (next=images; next != (Image *) NULL; next=next->next) columns=MagickMax(next->columns,columns); for (i=0; i < (ssize_t) number_threads; i++) { register ssize_t j; pixels[i]=(PixelChannels *) AcquireQuantumMemory(columns,sizeof(**pixels)); if (pixels[i] == (PixelChannels *) NULL) return(DestroyPixelThreadSet(pixels)); for (j=0; j < (ssize_t) columns; j++) { register ssize_t k; for (k=0; k < MaxPixelChannels; k++) pixels[i][j].channel[k]=0.0; } } return(pixels); }
Description: ImageMagick 7.0.8-50 Q16 has a heap-based buffer overflow at MagickCore/statistic.c in EvaluateImages because of mishandling rows.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: inline Result ClientImpl::Delete(const std::string &path, const Headers &headers, const char *body, size_t content_length, const std::string &content_type) { Request req; req.method = ""DELETE""; req.headers = headers; req.path = path; if (!content_type.empty()) { req.headers.emplace(""Content-Type"", content_type); } req.body.assign(body, content_length); return send_(std::move(req)); }
Description: Versions of the package yhirose/cpp-httplib before 0.12.4 are vulnerable to CRLF Injection when untrusted user input is used to set the content-type header in the HTTP .Patch, .Post, .Put and .Delete requests. This can lead to logical errors and other misbehaviors.

**Note:** This issue is present due to an incomplete fix for [CVE-2020-11709](https://security.snyk.io/vuln/SNYK-UNMANAGED-YHIROSECPPHTTPLIB-2366507).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void onig_reg_resize(regex_t *reg) { resize: if (reg->alloc > reg->used) { unsigned char *new_ptr = xrealloc(reg->p, reg->used); if (new_ptr) { reg->alloc = reg->used; reg->p = new_ptr; } } if (reg->chain) { reg = reg->chain; goto resize; } }
Description: A double free was found in the Regexp compiler in Ruby 3.x before 3.0.4 and 3.1.x before 3.1.2. If a victim attempts to create a Regexp from untrusted user input, an attacker may be able to write to unexpected memory locations.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void proto_register_p_mul (void) { static hf_register_info hf[] = { { &hf_length, { ""Length of PDU"", ""p_mul.length"", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_priority, { ""Priority"", ""p_mul.priority"", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_map_first, { ""First"", ""p_mul.first"", FT_BOOLEAN, 8, TFS (&no_yes), 0x80, NULL, HFILL } }, { &hf_map_last, { ""Last"", ""p_mul.last"", FT_BOOLEAN, 8, TFS (&no_yes), 0x40, NULL, HFILL } }, { &hf_map_unused, { ""MAP unused"", ""p_mul.unused"", FT_UINT8, BASE_DEC, NULL, 0xC0, NULL, HFILL } }, { &hf_pdu_type, { ""PDU Type"", ""p_mul.pdu_type"", FT_UINT8, BASE_DEC, VALS (pdu_vals), 0x3F, NULL, HFILL } }, { &hf_pdu_type_value, { ""PDU Type"", ""p_mul.pdu_type_value"", FT_UINT8, BASE_DEC, VALS (pdu_vals), 0x3F, NULL, HFILL } }, { &hf_no_pdus, { ""Total Number of PDUs"", ""p_mul.no_pdus"", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_seq_no, { ""Sequence Number of PDUs"", ""p_mul.seq_no"", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_unused8, { ""Unused"", ""p_mul.unused"", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_unused16, { ""Unused"", ""p_mul.unused"", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_checksum, { ""Checksum"", ""p_mul.checksum"", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL } }, { &hf_checksum_good, { ""Good"", ""p_mul.checksum_good"", FT_BOOLEAN, BASE_NONE, NULL, 0x0, ""True: checksum matches packet content; False: doesn't match content or not checked"", HFILL } }, { &hf_checksum_bad, { ""Bad"", ""p_mul.checksum_bad"", FT_BOOLEAN, BASE_NONE, NULL, 0x0, ""True: checksum doesn't match packet content; False: matches content or not checked"", HFILL } }, { &hf_source_id_ack, { ""Source ID of Ack Sender"", ""p_mul.source_id_ack"", FT_IPv4, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_source_id, { ""Source ID"", ""p_mul.source_id"", FT_IPv4, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_message_id, { ""Message ID (MSID)"", ""p_mul.message_id"", FT_UINT32, BASE_DEC, NULL, 0x0, ""Message ID"", HFILL } }, { &hf_expiry_time, { ""Expiry Time"", ""p_mul.expiry_time"", FT_ABSOLUTE_TIME, ABSOLUTE_TIME_LOCAL, NULL, 0x0, NULL, HFILL } }, { &hf_mc_group, { ""Multicast Group"", ""p_mul.mc_group"", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_ann_mc_group, { ""Announced Multicast Group"", ""p_mul.ann_mc_group"", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_fec_len, { ""FEC Parameter Length"", ""p_mul.fec.length"", FT_UINT8, BASE_DEC, NULL, 0x0, ""Forward Error Correction Parameter Length"", HFILL } }, { &hf_fec_id, { ""FEC ID"", ""p_mul.fec.id"", FT_UINT8, BASE_HEX, NULL, 0x0, ""Forward Error Correction ID"", HFILL } }, { &hf_fec_parameters, { ""FEC Parameters"", ""p_mul.fec.parameters"", FT_NONE, BASE_NONE, NULL, 0x0, ""Forward Error Correction Parameters"", HFILL } }, { &hf_count_of_dest, { ""Count of Destination Entries"", ""p_mul.dest_count"", FT_UINT16,BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_length_of_res, { ""Length of Reserved Field"", ""p_mul.reserved_length"",FT_UINT16,BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_ack_count, { ""Count of Ack Info Entries"", ""p_mul.ack_count"", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_ack_entry, { ""Ack Info Entry"", ""p_mul.ack_info_entry"", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_ack_length, { ""Length of Ack Info Entry"", ""p_mul.ack_length"", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_miss_seq_no, { ""Missing Data PDU Seq Number"", ""p_mul.missing_seq_no"", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_miss_seq_range, { ""Missing Data PDU Seq Range"", ""p_mul.missing_seq_range"", FT_BYTES, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_tot_miss_seq_no, { ""Total Number of Missing Data PDU Sequence Numbers"", ""p_mul.no_missing_seq_no"", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_timestamp_option, { ""Timestamp"", ""p_mul.timestamp"", FT_UINT64, BASE_DEC, NULL, 0x0, ""Timestamp Option (in units of 100ms)"", HFILL } }, { &hf_dest_entry, { ""Destination Entry"", ""p_mul.dest_entry"", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_dest_id, { ""Destination ID"", ""p_mul.dest_id"", FT_IPv4, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_msg_seq_no, { ""Message Sequence Number"", ""p_mul.msg_seq_no"", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_sym_key, { ""Symmetric Key"", ""p_mul.sym_key"", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_data_fragment, { ""Fragment of Data"", ""p_mul.data_fragment"", FT_NONE, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_msg_fragments, { ""Message fragments"", ""p_mul.fragments"", FT_NONE, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_msg_fragment, { ""Message fragment"", ""p_mul.fragment"", FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_msg_fragment_overlap, { ""Message fragment overlap"", ""p_mul.fragment.overlap"", FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_msg_fragment_overlap_conflicts, { ""Message fragment overlapping with conflicting data"", ""p_mul.fragment.overlap.conflicts"", FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_msg_fragment_multiple_tails, { ""Message has multiple tail fragments"", ""p_mul.fragment.multiple_tails"", FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_msg_fragment_too_long_fragment, { ""Message fragment too long"", ""p_mul.fragment.too_long_fragment"", FT_BOOLEAN, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_msg_fragment_error, { ""Message defragmentation error"", ""p_mul.fragment.error"", FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_msg_fragment_count, { ""Message fragment count"", ""p_mul.fragment.count"", FT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL } }, { &hf_msg_reassembled_in, { ""Reassembled in"", ""p_mul.reassembled.in"", FT_FRAMENUM, BASE_NONE, NULL, 0x00, NULL, HFILL } }, { &hf_msg_reassembled_length, { ""Reassembled P_MUL length"", ""p_mul.reassembled.length"", FT_UINT32, BASE_DEC, NULL, 0x00, NULL, HFILL } }, { &hf_analysis_ack_time, { ""Ack Time"", ""p_mul.analysis.ack_time"", FT_RELATIVE_TIME, BASE_NONE, NULL, 0x0, ""The time between the Last PDU and the Ack"", HFILL } }, { &hf_analysis_trans_time, { ""Transfer Time"", ""p_mul.analysis.trans_time"", FT_RELATIVE_TIME, BASE_NONE, NULL, 0x0, ""The time between the first Address PDU and the Ack"", HFILL } }, { &hf_analysis_retrans_time, { ""Retransmission Time"", ""p_mul.analysis.retrans_time"", FT_RELATIVE_TIME, BASE_NONE, NULL, 0x0, ""The time between the last PDU and this PDU"", HFILL } }, { &hf_analysis_total_retrans_time, { ""Total Retransmission Time"", ""p_mul.analysis.total_retrans_time"", FT_RELATIVE_TIME, BASE_NONE, NULL, 0x0, ""The time between the first PDU and this PDU"", HFILL } }, { &hf_analysis_addr_pdu_time, { ""Time since Address PDU"", ""p_mul.analysis.elapsed_time"", FT_RELATIVE_TIME, BASE_NONE, NULL, 0x0, ""The time between the Address PDU and this PDU"", HFILL } }, { &hf_analysis_prev_pdu_time, { ""PDU Delay"", ""p_mul.analysis.pdu_delay"", FT_RELATIVE_TIME, BASE_NONE, NULL, 0x0, ""The time between the last PDU and this PDU"", HFILL } }, { &hf_analysis_last_pdu_num, { ""Last Data PDU in"", ""p_mul.analysis.last_pdu_in"", FT_FRAMENUM, BASE_NONE, NULL, 0x0, ""The last Data PDU found in this frame"", HFILL } }, { &hf_analysis_addr_pdu_num, { ""Address PDU in"", ""p_mul.analysis.addr_pdu_in"", FT_FRAMENUM, BASE_NONE, NULL, 0x0, ""The Address PDU is found in this frame"", HFILL } }, { &hf_analysis_acks_addr_pdu_num, { ""This is an Ack to the Address PDU in"", ""p_mul.analysis.acks_addr_pdu_in"", FT_FRAMENUM, BASE_NONE, FRAMENUM_TYPE(FT_FRAMENUM_ACK), 0x0, ""The Address PDU is found in this frame"", HFILL } }, { &hf_analysis_acks_acked_addr_pdu_num, { ""This is an Ack-Ack to the Address PDU in"", ""p_mul.analysis.acks_acked_addr_pdu_in"", FT_FRAMENUM, BASE_NONE, FRAMENUM_TYPE(FT_FRAMENUM_DUP_ACK), 0x0, ""The Address PDU is found in this frame"", HFILL } }, { &hf_analysis_prev_pdu_num, { ""Previous PDU in"", ""p_mul.analysis.prev_pdu_in"", FT_FRAMENUM, BASE_NONE, NULL, 0x0, ""The previous PDU is found in this frame"", HFILL } }, { &hf_analysis_ack_num, { ""Ack PDU in"", ""p_mul.analysis.ack_in"", FT_FRAMENUM, BASE_NONE, NULL, 0x0, ""This packet has an Ack in this frame"", HFILL } }, { &hf_analysis_ack_missing, { ""Ack PDU missing"", ""p_mul.analysis.ack_missing"", FT_NONE, BASE_NONE, NULL, 0x0, ""The acknowledgement for this packet is missing"", HFILL } }, { &hf_analysis_retrans_no, { ""Retransmission #"", ""p_mul.analysis.retrans_no"", FT_UINT32, BASE_DEC, NULL, 0x0, ""Retransmission count"", HFILL } }, { &hf_analysis_ack_dup_no, { ""Duplicate ACK #"", ""p_mul.analysis.dup_ack_no"", FT_UINT32, BASE_DEC, NULL, 0x0, ""Duplicate Ack count"", HFILL } }, { &hf_analysis_msg_resend_from, { ""Retransmission of Message in"", ""p_mul.analysis.msg_first_in"", FT_FRAMENUM, BASE_NONE, NULL, 0x0, ""This Message was first sent in this frame"", HFILL } }, { &hf_analysis_ack_resend_from, { ""Retransmission of Ack in"", ""p_mul.analysis.ack_first_in"", FT_FRAMENUM, BASE_NONE, NULL, 0x0, ""This Ack was first sent in this frame"", HFILL } }, { &hf_analysis_total_time, { ""Total Time"", ""p_mul.analysis.total_time"", FT_RELATIVE_TIME, BASE_NONE, NULL, 0x0, ""The time between the first and the last Address PDU"", HFILL } }, }; static gint *ett[] = { &ett_p_mul, &ett_pdu_type, &ett_dest_entry, &ett_ack_entry, &ett_range_entry, &ett_checksum, &ett_seq_analysis, &ett_ack_analysis, &ett_seq_ack_analysis, &ett_msg_fragment, &ett_msg_fragments }; static ei_register_info ei[] = { { &ei_address_pdu_missing, { ""p_mul.analysis.addr_pdu_missing"", PI_SEQUENCE, PI_NOTE, ""Address PDU missing"", EXPFILL }}, { &ei_analysis_ack_missing, { ""p_mul.analysis.ack_missing.expert"", PI_SEQUENCE, PI_NOTE, ""Ack PDU missing"", EXPFILL }}, { &ei_analysis_ack_dup_no, { ""p_mul.analysis.dup_ack_no.expert"", PI_SEQUENCE, PI_NOTE, ""Dup ACK #"", EXPFILL }}, { &ei_analysis_prev_pdu_missing, { ""p_mul.analysis.prev_pdu_missing"", PI_SEQUENCE, PI_NOTE, ""Previous PDU missing"", EXPFILL }}, { &ei_analysis_retrans_no, { ""p_mul.analysis.retrans_no.expert"", PI_SEQUENCE, PI_NOTE, ""Retransmission #"", EXPFILL }}, { &ei_message_discarded, { ""p_mul.message_discarded"", PI_RESPONSE_CODE, PI_NOTE, ""Message discarded"", EXPFILL }}, { &ei_checksum_bad, { ""p_mul.checksum_bad.expert"", PI_CHECKSUM, PI_WARN, ""Bad checksum"", EXPFILL }}, { &ei_ack_length, { ""p_mul.ack_length.invalid"", PI_MALFORMED, PI_WARN, ""Invalid ack info length"", EXPFILL }}, { &ei_miss_seq_range, { ""p_mul.missing_seq_range.invalid"", PI_UNDECODED, PI_WARN, ""Invalid missing sequence range"", EXPFILL }}, { &ei_miss_seq_no, { ""p_mul.missing_seq_no.invalid"", PI_UNDECODED, PI_WARN, ""Invalid missing seq number"", EXPFILL }}, { &ei_tot_miss_seq_no, { ""p_mul.no_missing_seq_no.expert"", PI_RESPONSE_CODE, PI_NOTE, ""Missing seq numbers"", EXPFILL }}, { &ei_length, { ""p_mul.length.invalid"", PI_MALFORMED, PI_WARN, ""Incorrect length field"", EXPFILL }}, { &ei_more_data, { ""p_mul.more_data"", PI_MALFORMED, PI_WARN, ""More data in packet"", EXPFILL }}, }; module_t *p_mul_module; expert_module_t* expert_p_mul; proto_p_mul = proto_register_protocol (PNAME, PSNAME, PFNAME); p_mul_handle = register_dissector(PFNAME, dissect_p_mul, proto_p_mul); proto_register_field_array (proto_p_mul, hf, array_length (hf)); proto_register_subtree_array (ett, array_length (ett)); expert_p_mul = expert_register_protocol(proto_p_mul); expert_register_field_array(expert_p_mul, ei, array_length(ei)); register_init_routine (&p_mul_init_routine); reassembly_table_register (&p_mul_reassembly_table, &addresses_reassembly_table_functions); p_mul_id_hash_table = wmem_map_new_autoreset(wmem_epan_scope(), wmem_file_scope(), p_mul_id_hash, p_mul_id_hash_equal); p_mul_module = prefs_register_protocol (proto_p_mul, NULL); prefs_register_obsolete_preference (p_mul_module, ""tport""); prefs_register_obsolete_preference (p_mul_module, ""rport""); prefs_register_obsolete_preference (p_mul_module, ""dport""); prefs_register_obsolete_preference (p_mul_module, ""aport""); prefs_register_bool_preference (p_mul_module, ""reassemble"", ""Reassemble fragmented P_Mul packets"", ""Reassemble fragmented P_Mul packets"", &p_mul_reassemble); prefs_register_bool_preference (p_mul_module, ""relative_msgid"", ""Use relative Message ID"", ""Make the P_Mul dissector use relative"" "" message id number instead of absolute"" "" ones"", &use_relative_msgid); prefs_register_bool_preference (p_mul_module, ""seq_ack_analysis"", ""SEQ/ACK Analysis"", ""Calculate sequence/acknowledgement analysis"", &use_seq_ack_analysis); prefs_register_enum_preference (p_mul_module, ""decode"", ""Decode Data PDU as"", ""Type of content in Data_PDU"", &decode_option, decode_options, FALSE); }
Description: In Wireshark 2.6.0 to 2.6.5 and 2.4.0 to 2.4.11, the P_MUL dissector could crash. This was addressed in epan/dissectors/packet-p_mul.c by rejecting the invalid sequence number of zero.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static long sock_hash_delete_elem(struct bpf_map *map, void *key) { struct bpf_shtab *htab = container_of(map, struct bpf_shtab, map); u32 hash, key_size = map->key_size; struct bpf_shtab_bucket *bucket; struct bpf_shtab_elem *elem; int ret = -ENOENT; hash = sock_hash_bucket_hash(key, key_size); bucket = sock_hash_select_bucket(htab, hash); raw_spin_lock_bh(&bucket->lock); elem = sock_hash_lookup_elem_raw(&bucket->head, hash, key, key_size); if (elem) { hlist_del_rcu(&elem->node); sock_map_unref(elem->sk, elem); sock_hash_free_elem(htab, elem); ret = 0; } raw_spin_unlock_bh(&bucket->lock); return ret; }
Description: A deadlock flaw was found in the Linux kernel’s BPF subsystem. This flaw allows a local user to potentially crash the system.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void proto_register_thrift(void) { static hf_register_info hf[] = { { &hf_thrift_version, { ""Version"", ""thrift.version"", FT_UINT16, BASE_HEX, NULL, 0x0, NULL, HFILL } }, { &hf_thrift_mtype, { ""Message type"", ""thrift.mtype"", FT_UINT8, BASE_DEC, VALS(thrift_mtype_vals), 0x0, NULL, HFILL } }, { &hf_thrift_str_len, { ""Length"", ""thrift.str_len"", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_thrift_method, { ""Method"", ""thrift.method"", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_thrift_seq_id, { ""Sequence Id"", ""thrift.seq_id"", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_thrift_type, { ""Type"", ""thrift.type"", FT_UINT8, BASE_DEC, VALS(thrift_type_vals), 0x0, NULL, HFILL } }, { &hf_thrift_fid, { ""Field Id"", ""thrift.fid"", FT_UINT16, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_thrift_i16, { ""Integer16"", ""thrift.i16"", FT_INT16, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_thrift_i32, { ""Integer32"", ""thrift.i32"", FT_INT32, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_thrift_utf7str, { ""UTF7 String"", ""thrift.utf7str"", FT_STRING, BASE_NONE, NULL, 0x0, NULL, HFILL } }, { &hf_thrift_num_list_item, { ""Number of List Items"", ""thrift.num_list_item"", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_thrift_num_map_item, { ""Number of Map Items"", ""thrift.num_map_item"", FT_UINT32, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_thrift_bool, { ""Boolean"", ""thrift.bool"", FT_UINT8, BASE_DEC, VALS(thrift_bool_vals), 0x0, NULL, HFILL } }, { &hf_thrift_byte, { ""Byte"", ""thrift.byte"", FT_UINT8, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_thrift_i64, { ""Integer64"", ""thrift.i64"", FT_INT64, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_thrift_u64, { ""Integer64"", ""thrift.u64"", FT_UINT64, BASE_DEC, NULL, 0x0, NULL, HFILL } }, { &hf_thrift_double, { ""Double"", ""thrift.double"", FT_DOUBLE, BASE_NONE, NULL, 0x0, NULL, HFILL } }, }; static gint* ett[] = { &ett_thrift, }; proto_thrift = proto_register_protocol(""Thrift Protocol"", ""Thrift"", ""thrift""); proto_register_field_array(proto_thrift, hf, array_length(hf)); proto_register_subtree_array(ett, array_length(ett)); }
Description: In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-thrift.c had a large loop that was addressed by not proceeding with dissection after encountering an unexpected type.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: xmlAutomataStatePtr xmlAutomataNewCountTrans2(xmlAutomataPtr am, xmlAutomataStatePtr from, xmlAutomataStatePtr to, const xmlChar *token, const xmlChar *token2, int min, int max, void *data) { xmlRegAtomPtr atom; int counter; if ((am == NULL) || (from == NULL) || (token == NULL)) return(NULL); if (min < 0) return(NULL); if ((max < min) || (max < 1)) return(NULL); atom = xmlRegNewAtom(am, XML_REGEXP_STRING); if (atom == NULL) return(NULL); if ((token2 == NULL) || (*token2 == 0)) { atom->valuep = xmlStrdup(token); } else { int lenn, lenp; xmlChar *str; lenn = strlen((char *) token2); lenp = strlen((char *) token); str = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2); if (str == NULL) { xmlRegFreeAtom(atom); return(NULL); } memcpy(&str[0], token, lenp); str[lenp] = '|'; memcpy(&str[lenp + 1], token2, lenn); str[lenn + lenp + 1] = 0; atom->valuep = str; } atom->data = data; if (min == 0) atom->min = 1; else atom->min = min; atom->max = max; counter = xmlRegGetCounter(am); am->counters[counter].min = min; am->counters[counter].max = max; if (to == NULL) { to = xmlRegNewState(am); xmlRegStatePush(am, to); } xmlRegStateAddTrans(am, from, atom, to, counter, -1); xmlRegAtomPush(am, atom); am->state = to; if (to == NULL) to = am->state; if (to == NULL) return(NULL); if (min == 0) xmlFAGenerateEpsilonTransition(am, from, to); return(to); }
Description: In several functions of xmlregexp.c, there is a possible out of bounds write due to a heap buffer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void Huff_Compress(msg_t *mbuf, int offset) { inti, ch, size; byteseq[65536]; byte*buffer; huff_thuff; size = mbuf->cursize - offset; buffer = mbuf->data+ + offset; if (size<=0) { return; } Com_Memset(&huff, 0, sizeof(huff_t)); huff.tree = huff.lhead = huff.loc[NYT] =  &(huff.nodeList[huff.blocNode++]); huff.tree->symbol = NYT; huff.tree->weight = 0; huff.lhead->next = huff.lhead->prev = NULL; huff.tree->parent = huff.tree->left = huff.tree->right = NULL; seq[0] = (size>>8); seq[1] = size&0xff; bloc = 16; for (i=0; i<size; i++ ) { ch = buffer[i]; Huff_transmit(&huff, ch, seq); Huff_addRef(&huff, (byte)ch); } bloc += 8; mbuf->cursize = (bloc>>3) + offset; Com_Memcpy(mbuf->data+offset, seq, (bloc>>3)); }
Description: Buffer overflow in ioquake3 before 2017-08-02 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted packet.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static inline char* parse_to_param(char *buffer, char *end, struct to_body *to_b, int *returned_status, int multi) { struct to_param *param; int status; int saved_status; char  *tmp; param=0; status=E_PARA_VALUE; saved_status=E_PARA_VALUE; for( tmp=buffer; tmp<end; tmp++) { switch(*tmp) { case ' ': case '\t': switch (status) { case TAG3: param->type=TAG_PARAM; case PARA_NAME: case TAG1: case TAG2: param->name.len = tmp-param->name.s; status = S_EQUAL; break; case PARA_VALUE_TOKEN: param->value.len = tmp-param->value.s; status = E_PARA_VALUE; add_param( param , to_b ); break; case F_CRLF: case F_LF: case F_CR: status=saved_status; break; } break; case '\n': switch (status) { case S_PARA_NAME: case S_EQUAL: case S_PARA_VALUE: case E_PARA_VALUE: saved_status=status; status=F_LF; break; case TAG3: param->type=TAG_PARAM; case PARA_NAME: case TAG1: case TAG2: param->name.len = tmp-param->name.s; saved_status = S_EQUAL; status = F_LF; break; case PARA_VALUE_TOKEN: param->value.len = tmp-param->value.s; saved_status = E_PARA_VALUE; status = F_LF; add_param( param , to_b ); break; case F_CR: status=F_CRLF; break; case F_CRLF: case F_LF: status=saved_status; goto endofheader; default: goto parse_error; } break; case '\r': switch (status) { case S_PARA_NAME: case S_EQUAL: case S_PARA_VALUE: case E_PARA_VALUE: saved_status=status; status=F_CR; break; case TAG3: param->type=TAG_PARAM; case PARA_NAME: case TAG1: case TAG2: param->name.len = tmp-param->name.s; saved_status = S_EQUAL; status = F_CR; break; case PARA_VALUE_TOKEN: param->value.len = tmp-param->value.s; saved_status = E_PARA_VALUE; status = F_CR; add_param( param , to_b ); break; case F_CRLF: case F_CR: case F_LF: status=saved_status; goto endofheader; default: goto parse_error; } break; case  0: case ',': switch (status) { case PARA_VALUE_QUOTED: break; case PARA_NAME: param->name.len = tmp-param->name.s; case S_EQUAL: case S_PARA_VALUE: if (param->type==TAG_PARAM) goto parse_error; param->value.s = tmp; case PARA_VALUE_TOKEN: status = E_PARA_VALUE; param->value.len = tmp-param->value.s; add_param( param , to_b ); case E_PARA_VALUE: saved_status = status; if ( !multi && *tmp==',') goto parse_error; goto endofheader; break; default: goto parse_error; } break; case '\\': switch (status) { case PARA_VALUE_QUOTED: switch (*(tmp+1)) { case '\r': case '\n': break; default: tmp++; break; } break; default: goto parse_error; } break; case '""': switch (status) { case S_PARA_VALUE: param->value.s = tmp+1; status = PARA_VALUE_QUOTED; break; case PARA_VALUE_QUOTED: param->value.len=tmp-param->value.s ; add_param( param , to_b ); status = E_PARA_VALUE; break; case F_CRLF: case F_LF: case F_CR: goto endofheader; default: goto parse_error; } break; case ';' : switch (status) { case PARA_VALUE_QUOTED: break; case PARA_NAME: param->name.len = tmp-param->name.s; case S_EQUAL: case S_PARA_VALUE: if (param->type==TAG_PARAM) goto parse_error; param->value.s = tmp; case PARA_VALUE_TOKEN: param->value.len=tmp-param->value.s; add_param(param,to_b); case E_PARA_VALUE: param = (struct to_param*) pkg_malloc(sizeof(struct to_param)); if (!param){ LM_ERR(""out of pkg memory\n"" ); goto error; } memset(param,0,sizeof(struct to_param)); param->type=GENERAL_PARAM; status = S_PARA_NAME; break; case F_CRLF: case F_LF: case F_CR: goto endofheader; default: goto parse_error; } break; case 'T': case 't' : switch (status) { case PARA_VALUE_QUOTED: case PARA_VALUE_TOKEN: case PARA_NAME: break; case S_PARA_NAME: param->name.s = tmp; status = TAG1; break; case S_PARA_VALUE: param->value.s = tmp; status = PARA_VALUE_TOKEN; break; case TAG1: case TAG2: case TAG3: status = PARA_NAME; break; case F_CRLF: case F_LF: case F_CR: goto endofheader; default: goto parse_error; } break; case 'A': case 'a' : switch (status) { case PARA_VALUE_QUOTED: case PARA_VALUE_TOKEN: case PARA_NAME: break; case S_PARA_NAME: param->name.s = tmp; status = PARA_NAME; break; case S_PARA_VALUE: param->value.s = tmp; status = PARA_VALUE_TOKEN; break; case TAG1: status = TAG2; break; case TAG2: case TAG3: status = PARA_NAME; break; case F_CRLF: case F_LF: case F_CR: goto endofheader; default: goto parse_error; } break; case 'G': case 'g' : switch (status) { case PARA_VALUE_QUOTED: case PARA_VALUE_TOKEN: case PARA_NAME: break; case S_PARA_NAME: param->name.s = tmp; status = PARA_NAME; break; case S_PARA_VALUE: param->value.s = tmp; status = PARA_VALUE_TOKEN; break; case TAG1: case TAG3: status = PARA_NAME; break; case TAG2: status = TAG3; break; case F_CRLF: case F_LF: case F_CR: goto endofheader; default: goto parse_error; } break; case '=': switch (status) { case PARA_VALUE_QUOTED: break; case TAG3: param->type=TAG_PARAM; case PARA_NAME: case TAG1: case TAG2: param->name.len = tmp-param->name.s; status = S_PARA_VALUE; break; case S_EQUAL: status = S_PARA_VALUE; break; case F_CRLF: case F_LF: case F_CR: goto endofheader; default: goto parse_error; } break; default: switch (status) { case TAG1: case TAG2: case TAG3: status = PARA_NAME; break; case PARA_VALUE_TOKEN: case PARA_NAME: case PARA_VALUE_QUOTED: break; case S_PARA_NAME: param->name.s = tmp; status = PARA_NAME; break; case S_PARA_VALUE: param->value.s = tmp; status = PARA_VALUE_TOKEN; break; case F_CRLF: case F_LF: case F_CR: goto endofheader; default: LM_ERR(""spitting out [%c] in status %d\n"",*tmp,status ); goto error; } } } endofheader: if (param) { if (saved_status==S_EQUAL||saved_status==S_PARA_VALUE) { saved_status = E_PARA_VALUE; param->value.s= 0; param->value.len=0; if (param->type==TAG_PARAM) goto parse_error; add_param(param, to_b); } else { pkg_free(param); } } *returned_status=saved_status; return tmp; parse_error: LM_ERR(""unexpected char [%c] in status %d: <<%.*s>> .\n"", *tmp,status, (int)(tmp-buffer), ZSW(buffer)); error: if (param) pkg_free(param); free_to_params(to_b); to_b->error=PARSE_ERROR; *returned_status = status; return tmp; }
Description: OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior to versions 3.1.7 and 3.2.4, when the function `append_hf` handles a SIP message with a malformed To header, a call to the function `abort()` is performed, resulting in a crash. This is due to the following check in `data_lump.c:399` in the function `anchor_lump`. An attacker abusing this vulnerability will crash OpenSIPS leading to Denial of Service. It affects configurations containing functions that make use of the affected code, such as the function `append_hf`. This issue has been fixed in versions 3.1.7 and 3.2.4.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int php_mb_parse_encoding_list(const char *value, int value_length, mbfl_encoding ***return_list, int *return_size, int persistent) { int n, l, size, bauto, ret = 1; char *p, *p1, *p2, *endp, *tmpstr; mbfl_encoding *encoding; mbfl_no_encoding *src; mbfl_encoding **entry, **list; list = nullptr; if (value == nullptr || value_length <= 0) { if (return_list) { *return_list = nullptr; } if (return_size) { *return_size = 0; } return 0; } else { mbfl_no_encoding *identify_list; int identify_list_size; identify_list = MBSTRG(default_detect_order_list); identify_list_size = MBSTRG(default_detect_order_list_size); if (value[0]=='""' && value[value_length-1]=='""' && value_length>2) { tmpstr = (char *)strndup(value+1, value_length-2); value_length -= 2; } else tmpstr = (char *)strndup(value, value_length); if (tmpstr == nullptr) { return 0; } endp = tmpstr + value_length; n = 1; p1 = tmpstr; while ((p2 = (char*)string_memnstr(p1, "","", 1, endp)) != nullptr) { p1 = p2 + 1; n++; } size = n + identify_list_size; list = (mbfl_encoding **)calloc(size, sizeof(mbfl_encoding*)); if (list != nullptr) { entry = list; n = 0; bauto = 0; p1 = tmpstr; do { p2 = p = (char*)string_memnstr(p1, "","", 1, endp); if (p == nullptr) { p = endp; } *p = '\0'; while (p1 < p && (*p1 == ' ' || *p1 == '\t')) { p1++; } p--; while (p > p1 && (*p == ' ' || *p == '\t')) { *p = '\0'; p--; } if (strcasecmp(p1, ""auto"") == 0) { if (!bauto) { bauto = 1; l = identify_list_size; src = identify_list; for (int i = 0; i < l; i++) { *entry++ = (mbfl_encoding*) mbfl_no2encoding(*src++); n++; } } } else { encoding = (mbfl_encoding*) mbfl_name2encoding(p1); if (encoding != nullptr) { *entry++ = encoding; n++; } else { ret = 0; } } p1 = p2 + 1; } while (n < size && p2 != nullptr); if (n > 0) { if (return_list) { *return_list = list; } else { free(list); } } else { free(list); if (return_list) { *return_list = nullptr; } ret = 0; } if (return_size) { *return_size = n; } } else { if (return_list) { *return_list = nullptr; } if (return_size) { *return_size = 0; } ret = 0; } free(tmpstr); } return ret; }
Description: Out-of-bounds write in the (1) mb_detect_encoding, (2) mb_send_mail, and (3) mb_detect_order functions in Facebook HHVM before 3.15.0 allows attackers to have unspecified impact via unknown vectors.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void ttm_put_pages(struct page **pages, unsigned npages, int flags, enum ttm_caching_state cstate) { struct ttm_page_pool *pool = ttm_get_pool(flags, false, cstate); #ifdef CONFIG_TRANSPARENT_HUGEPAGE struct ttm_page_pool *huge = ttm_get_pool(flags, true, cstate); #endif unsigned long irq_flags; unsigned i; if (pool == NULL) { i = 0; while (i < npages) { #ifdef CONFIG_TRANSPARENT_HUGEPAGE struct page *p = pages[i]; #endif unsigned order = 0, j; if (!pages[i]) { ++i; continue; } #ifdef CONFIG_TRANSPARENT_HUGEPAGE if (!(flags & TTM_PAGE_FLAG_DMA32)) { for (j = 0; j < HPAGE_PMD_NR; ++j) if (p++ != pages[i + j]) break; if (j == HPAGE_PMD_NR) order = HPAGE_PMD_ORDER; } #endif if (page_count(pages[i]) != 1) pr_err(""Erroneous page count. Leaking pages.\n""); __free_pages(pages[i], order); j = 1 << order; while (j) { pages[i++] = NULL; --j; } } return; } i = 0; #ifdef CONFIG_TRANSPARENT_HUGEPAGE if (huge) { unsigned max_size, n2free; spin_lock_irqsave(&huge->lock, irq_flags); while (i < npages) { struct page *p = pages[i]; unsigned j; if (!p) break; for (j = 0; j < HPAGE_PMD_NR; ++j) if (p++ != pages[i + j]) break; if (j != HPAGE_PMD_NR) break; list_add_tail(&pages[i]->lru, &huge->list); for (j = 0; j < HPAGE_PMD_NR; ++j) pages[i++] = NULL; huge->npages++; } max_size = _manager->options.max_size; max_size /= HPAGE_PMD_NR; if (huge->npages > max_size) n2free = huge->npages - max_size; else n2free = 0; spin_unlock_irqrestore(&huge->lock, irq_flags); if (n2free) ttm_page_pool_free(huge, n2free, false); } #endif spin_lock_irqsave(&pool->lock, irq_flags); while (i < npages) { if (pages[i]) { if (page_count(pages[i]) != 1) pr_err(""Erroneous page count. Leaking pages.\n""); list_add_tail(&pages[i]->lru, &pool->list); pages[i] = NULL; pool->npages++; } ++i; } npages = 0; if (pool->npages > _manager->options.max_size) { npages = pool->npages - _manager->options.max_size; if (npages < NUM_PAGES_TO_ALLOC) npages = NUM_PAGES_TO_ALLOC; } spin_unlock_irqrestore(&pool->lock, irq_flags); if (npages) ttm_page_pool_free(pool, npages, false); }
Description: In the Linux kernel 5.0.0-rc7 (as distributed in ubuntu/linux.git on kernel.ubuntu.com), mounting a crafted f2fs filesystem image and performing some operations can lead to slab-out-of-bounds read access in ttm_put_pages in drivers/gpu/drm/ttm/ttm_page_alloc.c. This is related to the vmwgfx or ttm module.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static MagickBooleanType WriteRGFImage(const ImageInfo *image_info,Image *image, ExceptionInfo *exception) { MagickBooleanType status; int bit; register const PixelPacket *p; register ssize_t x; ssize_t y; unsigned char byte; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickSignature); assert(image != (Image *) NULL); assert(image->signature == MagickSignature); if (image->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickSignature); status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception); if (status == MagickFalse) return(status); (void) TransformImageColorspace(image,sRGBColorspace); if((image->columns > 255L) || (image->rows > 255L)) ThrowWriterException(ImageError,""Dimensions must be less than 255x255""); (void) WriteBlobByte(image,image->columns & 0xff); (void) WriteBlobByte(image,image->rows & 0xff); (void) SetImageType(image,BilevelType); x=0; y=0; for (y=0; y < (ssize_t) image->rows; y++) { p=GetVirtualPixels(image,0,y,image->columns,1,exception); if (p == (const PixelPacket *) NULL) break; bit=0; byte=0; for (x=0; x < (ssize_t) image->columns; x++) { byte>>=1; if (GetPixelLuma(image,p) < (QuantumRange/2.0)) byte|=0x80; bit++; if (bit == 8) { (void) WriteBlobByte(image,byte); bit=0; byte=0; } p++; } if (bit != 0) (void) WriteBlobByte(image,byte); status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } (void) CloseBlob(image); return(MagickTrue); }
Description: coders/rgf.c in ImageMagick before 6.9.4-10 allows remote attackers to cause a denial of service (assertion failure) by converting an image to rgf format.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int gerbv_open_image(gerbv_project_t *gerbvProject, gchar const* filename, int idx, int reload, gerbv_HID_Attribute *fattr, int n_fattr, gboolean forceLoadFile) { gerb_file_t *fd; gerbv_image_t *parsed_image = NULL, *parsed_image2 = NULL; gint retv = -1; gboolean isPnpFile = FALSE, foundBinary; gerbv_HID_Attribute *attr_list = NULL; int n_attr = 0; if (reload) { attr_list =  gerbvProject->file[idx]->image->info->attr_list; n_attr =  gerbvProject->file[idx]->image->info->n_attr; } else { attr_list = fattr; n_attr = n_fattr; } if ((idx+1) >= gerbvProject->max_files) { gerbvProject->file = g_renew (gerbv_fileinfo_t *, gerbvProject->file, gerbvProject->max_files + 2); gerbvProject->file[gerbvProject->max_files] = NULL; gerbvProject->file[gerbvProject->max_files+1] = NULL; gerbvProject->max_files += 2; } dprintf(""In open_image, about to try opening filename = %s\n"", filename); fd = gerb_fopen(filename); if (fd == NULL) { GERB_COMPILE_ERROR(_(""Trying to open \""%s\"": %s""), filename, strerror(errno)); return -1; } fd->filename = g_strdup(filename); dprintf(""In open_image, successfully opened file.  Now check its type....\n""); if (gerber_is_rs274x_p(fd, &foundBinary)) { dprintf(""Found RS-274X file\n""); if (!foundBinary || forceLoadFile) { gchar *currentLoadDirectory = g_path_get_dirname (filename); parsed_image = parse_gerb(fd, currentLoadDirectory); g_free (currentLoadDirectory); } } else if(drill_file_p(fd, &foundBinary)) { dprintf(""Found drill file\n""); if (!foundBinary || forceLoadFile) parsed_image = parse_drillfile(fd, attr_list, n_attr, reload); } else if (pick_and_place_check_file_type(fd, &foundBinary)) { dprintf(""Found pick-n-place file\n""); if (!foundBinary || forceLoadFile) { if (!reload) { pick_and_place_parse_file_to_images(fd, &parsed_image, &parsed_image2); } else { switch (gerbvProject->file[idx]->image->layertype) { case GERBV_LAYERTYPE_PICKANDPLACE_TOP: parsed_image2 = (void *)!NULL; pick_and_place_parse_file_to_images(fd, &parsed_image, &parsed_image2); parsed_image2 = NULL; break; case GERBV_LAYERTYPE_PICKANDPLACE_BOT: parsed_image2 = (void *)!NULL; pick_and_place_parse_file_to_images(fd, &parsed_image2, &parsed_image); parsed_image2 = NULL; break; default: GERB_COMPILE_ERROR(_(""%s: unknown pick-and-place board side to reload""), filename); } } isPnpFile = TRUE; } } else if (gerber_is_rs274d_p(fd)) { gchar *str = g_strdup_printf(_(""Most likely found a RS-274D file "" ""\""%s\"" ... trying to open anyways\n""), filename); dprintf(""%s"", str); g_warning(""%s"", str); g_free (str); if (!foundBinary || forceLoadFile) { gchar *currentLoadDirectory = g_path_get_dirname (filename); parsed_image = parse_gerb(fd, currentLoadDirectory); g_free (currentLoadDirectory); } } else { dprintf(""Unknown filetype""); GERB_COMPILE_ERROR(_(""%s: Unknown file type.""), filename); parsed_image = NULL; } g_free(fd->filename); gerb_fclose(fd); if (parsed_image == NULL) { return -1; } if (parsed_image) { gchar *baseName = g_path_get_basename (filename); gchar *displayedName; if (isPnpFile) displayedName = g_strconcat (baseName, _("" (top)""), NULL); else displayedName = g_strdup (baseName); retv = gerbv_add_parsed_image_to_project (gerbvProject, parsed_image, filename, displayedName, idx, reload); g_free (baseName); g_free (displayedName); } gerbvProject->file[idx]->layer_dirty = FALSE; if (parsed_image2) { gchar *baseName = g_path_get_basename (filename); gchar *displayedName; displayedName = g_strconcat (baseName, _("" (bottom)""), NULL); retv = gerbv_add_parsed_image_to_project (gerbvProject, parsed_image2, filename, displayedName, idx + 1, reload); g_free (baseName); g_free (displayedName); } return retv; }
Description: A user able to control file input to Gerbv, between versions 2.4.0 and 2.10.0, can cause a crash and cause denial-of-service with a specially crafted Gerber RS-274X file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static Jsi_RC jsi_ArrayPushCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this, Jsi_Value **ret, Jsi_Func *funcPtr) { Jsi_Obj *obj; if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) { Jsi_ValueMakeNumber(interp, ret, 0); return JSI_OK; } obj = _this->d.obj; int argc = Jsi_ValueGetLength(interp, args); int curlen = Jsi_ObjGetLength(interp, obj); if (curlen < 0) { Jsi_ObjSetLength(interp, obj, 0); } int i; for (i = 0; i < argc; ++i) { Jsi_Value *ov = Jsi_ValueArrayIndex(interp, args, i); if (!ov) { Jsi_LogBug(""Arguments Error""); ov = Jsi_ValueNew(interp); } Jsi_ValueInsertArray(interp, _this, curlen + i, ov, 0); } Jsi_ValueMakeNumber(interp, ret, Jsi_ObjGetLength(interp, obj)); return JSI_OK; }
Description: Integer overflow vulnerability in function Jsi_ObjSetLength in jsish before 3.0.6, allows remote attackers to execute arbitrary code.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int dissect_rgmp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void* data _U_) { proto_tree *tree; proto_item *item; guint8 type; int offset = 0; guint32 dst = g_htonl(MC_RGMP); if (memcmp(pinfo->dst.data, &dst, 4)) return 0; col_set_str(pinfo->cinfo, COL_PROTOCOL, ""RGMP""); col_clear(pinfo->cinfo, COL_INFO); item = proto_tree_add_item(parent_tree, proto_rgmp, tvb, offset, -1, ENC_NA); tree = proto_item_add_subtree(item, ett_rgmp); type = tvb_get_guint8(tvb, offset); col_add_str(pinfo->cinfo, COL_INFO, val_to_str(type, rgmp_types, ""Unknown Type: 0x%02x"")); proto_tree_add_uint(tree, hf_type, tvb, offset, 1, type); offset += 1; proto_tree_add_item(tree, hf_reserved, tvb, offset, 1, ENC_NA); offset += 1; igmp_checksum(tree, tvb, hf_checksum, hf_checksum_bad, pinfo, 0); offset += 2; proto_tree_add_item(tree, hf_maddr, tvb, offset, 4, ENC_BIG_ENDIAN); offset += 4; return offset; }
Description: In Wireshark 2.2.0 to 2.2.6 and 2.0.0 to 2.0.12, the RGMP dissector could crash. This was addressed in epan/dissectors/packet-rgmp.c by validating an IPv4 address.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int ascii_load_sockaddr(struct sockaddr_storage *ss, char *buf) { struct sockaddr_in6 ssin6; struct sockaddr_in  ssin; memset(&ssin, 0, sizeof ssin); memset(&ssin6, 0, sizeof ssin6); if (!strcmp(""local"", buf)) { ss->ss_family = AF_LOCAL; } else if (buf[0] == '[' && buf[strlen(buf)-1] == ']') { buf[strlen(buf)-1] = '\0'; if (inet_pton(AF_INET6, buf+1, &ssin6.sin6_addr) != 1) return 0; ssin6.sin6_family = AF_INET6; memcpy(ss, &ssin6, sizeof(ssin6)); ss->ss_len = sizeof(struct sockaddr_in6); } else { if (inet_pton(AF_INET, buf, &ssin.sin_addr) != 1) return 0; ssin.sin_family = AF_INET; memcpy(ss, &ssin, sizeof(ssin)); ss->ss_len = sizeof(struct sockaddr_in); } return 1; }
Description: ascii_load_sockaddr in smtpd in OpenBSD before 7.1 errata 024 and 7.2 before errata 020, and OpenSMTPD Portable before 7.0.0-portable commit f748277, can abort upon a connection from a local, scoped IPv6 address.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void svg_node_start(void *sax_cbck, const char *name, const char *name_space, const GF_XMLAttribute *attributes, u32 nb_attributes) { #ifndef SKIP_ALL GF_SVG_Parser *parser = (GF_SVG_Parser *)sax_cbck; SVG_NodeStack *stack, *parent; SVG_Element *elt; SVG_Element *cond = NULL; u32 xmlns; Bool has_ns; parent = (SVG_NodeStack *)gf_list_last(parser->node_stack); if (parent && parent->node->sgprivate->tag==TAG_LSR_conditional) { cond = parent->node; parent = NULL; } if (!parent && (parser->load->type == GF_SM_LOAD_DIMS) && parser->load->ctx) { if (!gf_list_count(parser->load->ctx->streams)) { parser->laser_es = gf_sm_stream_new(parser->load->ctx, 1, GF_STREAM_SCENE, GF_CODECID_DIMS); if (!parser->laser_es) { svg_report(parser, GF_OUT_OF_MEM, NULL); return; } parser->laser_es->timeScale = 1000; parser->laser_au = gf_sm_stream_au_new(parser->laser_es, 0, 0, GF_TRUE); if (!parser->laser_au) { svg_report(parser, GF_OUT_OF_MEM, NULL); return; } } else { parser->laser_es = gf_list_get(parser->load->ctx->streams, 0); parser->laser_au = gf_list_last(parser->laser_es->AUs); } } if ((!parent && (parser->load->type!=GF_SM_LOAD_SVG)) || cond) { u32 com_type; has_ns=GF_FALSE; svg_check_namespace(parser, attributes, nb_attributes, &has_ns); if (!strcmp(name, ""SAFSession"")) return; if (!strcmp(name, ""sceneHeader"")) return; if (!strcmp(name, ""LASeRHeader"")) { GF_ESD *esd; if (!parser->load->ctx) { svg_report(parser, GF_BAD_PARAM, ""Invalid parser context""); return; } esd = lsr_parse_header(parser, name, name_space, attributes, nb_attributes); if (!esd) { svg_report(parser, GF_BAD_PARAM, ""Invalid LASER Header""); return; } esd->ESID = 1; parser->laser_es = gf_sm_stream_new(parser->load->ctx, esd->ESID, esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication); if (!parser->laser_es) { svg_report(parser, GF_OUT_OF_MEM, NULL); return; } if (!parser->load->ctx->root_od) { parser->load->ctx->root_od = (GF_ObjectDescriptor *) gf_odf_desc_new(GF_ODF_IOD_TAG); if (!parser->load->ctx->root_od) { svg_report(parser, GF_OUT_OF_MEM, NULL); return; } } gf_list_add(parser->load->ctx->root_od->ESDescriptors, esd); parser->laser_es->timeScale = esd->slConfig->timestampResolution; return; } if (!strcmp(name, ""sceneUnit"") ) { u32 time, i; Bool rap; time = 0; rap =  GF_FALSE; if (!gf_list_count(parser->laser_es->AUs)) rap = GF_TRUE; for (i=0; i<nb_attributes; i++) { GF_XMLAttribute *att = (GF_XMLAttribute *) &attributes[i]; if (!strcmp(att->name, ""time"")) time = atoi(att->value); else if (!strcmp(att->name, ""rap"")) rap = !strcmp(att->value, ""yes"") ? GF_TRUE : GF_FALSE; } parser->laser_au = gf_sm_stream_au_new(parser->laser_es, time, 0, rap); if (!parser->laser_au) { svg_report(parser, GF_OUT_OF_MEM, NULL); return; } return; } if (!strcmp(name, ""StreamHeader"") || !strcmp(name, ""RemoteStreamHeader"") || !strcmp(name, ""mediaHeader"") || !strcmp(name, ""imageHeader"") ) { char *url = NULL; char *src = NULL; const char *ID = NULL; u32 time, codecid, ST, i, ts_res; GF_ODUpdate *odU; GF_ObjectDescriptor *od; SVG_SAFExternalStream*st; if (!parser->saf_es && parser->load->ctx) { GF_ESD *esd = (GF_ESD*)gf_odf_desc_esd_new(2); esd->ESID = 0xFFFE; esd->decoderConfig->streamType = GF_STREAM_OD; esd->decoderConfig->objectTypeIndication = 1; parser->saf_es = gf_sm_stream_new(parser->load->ctx, esd->ESID, GF_STREAM_OD, GF_CODECID_OD_V1); if (!parser->saf_es) { svg_report(parser, GF_OUT_OF_MEM, NULL); return; } if (!parser->load->ctx->root_od) { parser->load->ctx->root_od = (GF_ObjectDescriptor *) gf_odf_desc_new(GF_ODF_IOD_TAG); if (!parser->load->ctx->root_od) { svg_report(parser, GF_OUT_OF_MEM, NULL); return; } } parser->saf_es->timeScale = 1000; gf_list_add(parser->load->ctx->root_od->ESDescriptors, esd); } time = 0; ts_res = 1000; codecid = ST = 0; for (i=0; i<nb_attributes; i++) { GF_XMLAttribute *att = (GF_XMLAttribute *) &attributes[i]; if (!strcmp(att->name, ""time"")) time = atoi(att->value); else if (!strcmp(att->name, ""rap"")) ;else if (!strcmp(att->name, ""url"")) url = gf_strdup(att->value); else if (!strcmp(att->name, ""streamID"")) ID = att->value; else if (!strcmp(att->name, ""objectTypeIndication"")) codecid = atoi(att->value); else if (!strcmp(att->name, ""codecID"")) { codecid = GF_4CC(att->value[0],att->value[1],att->value[2],att->value[3]); } else if (!strcmp(att->name, ""streamType"")) ST = atoi(att->value); else if (!strcmp(att->name, ""timeStampResolution"")) ts_res = atoi(att->value); else if (!strcmp(att->name, ""source"")) src = att->value; } if (!strcmp(name, ""imageHeader"")) ST = 4; st = svg_saf_get_next_available_stream(parser); st->stream_name = ID ? gf_strdup(ID) : NULL; parser->saf_au = gf_sm_stream_au_new(parser->saf_es, time, 0, GF_FALSE); if (!parser->saf_au) { svg_report(parser, GF_OUT_OF_MEM, NULL); return; } odU = (GF_ODUpdate *) gf_odf_com_new(GF_ODF_OD_UPDATE_TAG); if (!odU) { svg_report(parser, GF_OUT_OF_MEM, NULL); return; } gf_list_add(parser->saf_au->commands, odU); od = (GF_ObjectDescriptor *) gf_odf_desc_new(GF_ODF_OD_TAG); if (!od) { svg_report(parser, GF_OUT_OF_MEM, NULL); return; } gf_list_add(odU->objectDescriptors, od); od->objectDescriptorID = st->id; if (url) { od->URLString = url; } else { GF_MuxInfo *mux; GF_ESD *esd = (GF_ESD*)gf_odf_desc_esd_new(2); if (!esd) { svg_report(parser, GF_OUT_OF_MEM, NULL); return; } gf_list_add(od->ESDescriptors, esd); esd->decoderConfig->objectTypeIndication = codecid; esd->decoderConfig->streamType = ST; esd->ESID = st->id; mux = (GF_MuxInfo *)gf_odf_desc_new(GF_ODF_MUXINFO_TAG); if (!mux) { svg_report(parser, GF_OUT_OF_MEM, NULL); return; } gf_list_add(esd->extensionDescriptors, mux); if (src) { mux->file_name = gf_strdup(src); st->nhml_info = NULL; } else { FILE *nhml; char szName[1024]; if (parser->load->localPath) { strcpy(szName, parser->load->localPath); strcat(szName, ""/""); strcat(szName, ID ? ID : """"); } else { strcpy(szName, ID ? ID : """"); } strcat(szName, ""_temp.nhml""); mux->file_name = gf_strdup(szName); st->nhml_info = mux->file_name; nhml = gf_fopen(st->nhml_info, ""wt""); if (nhml) { gf_fprintf(nhml, ""<?xml version=\""1.0\"" encoding=\""UTF-8\"" ?>\n""); gf_fprintf(nhml, ""<NHNTStream version=\""1.0\"" timeScale=\""%d\"" streamType=\""%d\"" objectTypeIndication=\""%d\"" inRootOD=\""no\"" trackID=\""%d\"">\n"", ts_res, ST, codecid, st->id); gf_fclose(nhml); } else { GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (""[LASeR Parser] Error opening nhml file %s while preparing import\n"", st->nhml_info)); } mux->delete_file = GF_TRUE; } } return; } if (!strcmp(name, ""mediaUnit"") || !strcmp(name, ""imageUnit"") ) { FILE *nhml; char *id = NULL; char *src = NULL; SVG_SAFExternalStream*st; u32 i, rap, time, offset, length; rap = time = offset = length = 0; for (i=0; i<nb_attributes; i++) { GF_XMLAttribute *att = (GF_XMLAttribute *) &attributes[i]; if (!strcmp(att->name, ""time"")) time = atoi(att->value); else if (!strcmp(att->name, ""source"")) src = att->value; else if (!strcmp(att->name, ""ref"")) id = att->value; else if (!strcmp(att->name, ""rap"")) rap = !strcmp(att->value, ""yes"") ? 1 : 0; else if (!strcmp(att->name, ""startOffset"")) offset = atoi(att->value); else if (!strcmp(att->name, ""length"")) length = atoi(att->value); } st = svg_saf_get_stream(parser, 0, id); if (!st || !st->nhml_info) { return; } nhml = gf_fopen(st->nhml_info, ""a+t""); gf_fprintf(nhml, ""<NHNTSample ""); if (time) gf_fprintf(nhml, ""DTS=\""%d\"" "", time); if (length) gf_fprintf(nhml, ""dataLength=\""%d\"" "", length); if (offset) gf_fprintf(nhml, ""mediaOffset=\""%d\"" "", offset); if (rap) gf_fprintf(nhml, ""isRAP=\""yes\"" ""); if (src) gf_fprintf(nhml, ""mediaFile=\""%s\"" "", src); gf_fprintf(nhml, ""/>\n""); gf_fclose(nhml); return; } if (!strcmp(name, ""endOfStream"") ) { FILE *nhml; char *id = NULL; u32 i; SVG_SAFExternalStream*st; for (i=0; i<nb_attributes; i++) { GF_XMLAttribute *att = (GF_XMLAttribute *) &attributes[i]; if (!strcmp(att->name, ""ref"")) id = att->value; } st = svg_saf_get_stream(parser, 0, id); if (!st || !st->nhml_info) { return; } nhml = gf_fopen(st->nhml_info, ""a+t""); gf_fprintf(nhml, ""</NHNTStream>\n""); gf_fclose(nhml); return; } if (!strcmp(name, ""endOfSAFSession"") ) { return; } if ((parser->load->type==GF_SM_LOAD_XSR) && !parser->laser_au && !cond) { if (parser->load->flags & GF_SM_LOAD_CONTEXT_READY) { assert(parser->laser_es); parser->laser_au = gf_sm_stream_au_new(parser->laser_es, 0, 0, GF_FALSE); if (!parser->laser_au) { svg_report(parser, GF_OUT_OF_MEM, NULL); return; } } else { svg_report(parser, GF_BAD_PARAM, ""LASeR sceneUnit not defined for command %s"", name); return; } } com_type = lsr_get_command_by_name(name); if (com_type != GF_SG_UNDEFINED) { SVG_NodeStack *top; GF_Err e; parser->command = gf_sg_command_new(parser->load->scene_graph, com_type); if (!parser->command) { svg_report(parser, GF_OUT_OF_MEM, NULL); return; } top = (SVG_NodeStack*)gf_list_last(parser->node_stack); if (top) { top->unknown_depth ++; parser->command_depth++; } e = lsr_parse_command(parser, attributes, nb_attributes); if (e!= GF_OK) { parser->command->node = NULL; gf_sg_command_del(parser->command); parser->command = NULL; GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (""[LASeR Parser] Error parsing %s command - skipping\n"", (parser->load->type==GF_SM_LOAD_XSR) ? ""LASeR"" : ""DIMS"")); return; } if (cond) { GF_DOMUpdates *up = cond->children ? (GF_DOMUpdates *)cond->children->node : NULL; if (!up) { up = gf_dom_add_updates_node((GF_Node*)cond); if (parser->load->flags & GF_SM_LOAD_FOR_PLAYBACK) { gf_node_set_callback_function((GF_Node*)up, xsr_exec_command_list); } } gf_list_add(up->updates, parser->command); } else if (parser->laser_au) { gf_list_add(parser->laser_au->commands, parser->command); } switch (com_type) { case GF_SG_LSR_NEW_SCENE: case GF_SG_LSR_REFRESH_SCENE: if (parser->laser_au) parser->laser_au->flags |= GF_SM_AU_RAP; break; } parser->current_ns = GF_XMLNS_SVG; return; } } if (!parent && !parser->command && (parser->load->flags & GF_SM_LOAD_CONTEXT_STREAMING)) { gf_sg_reset(parser->load->scene_graph); parser->has_root = 0; } if ((parser->has_root==1) && !parent && !parser->command) return; xmlns = parser->current_ns; has_ns = GF_FALSE; elt = svg_parse_element(parser, name, name_space, attributes, nb_attributes, parent, &has_ns); if (!elt) { if (parent) parent->unknown_depth++; else if (cond) parser->command_depth++; return; } GF_SAFEALLOC(stack, SVG_NodeStack); if (!stack) { parser->last_error = GF_OUT_OF_MEM; return; } stack->node = elt; stack->current_ns = xmlns; stack->has_ns = has_ns; gf_list_add(parser->node_stack, stack); if ( (gf_node_get_tag((GF_Node *)elt) == TAG_SVG_svg) && (!parser->has_root || (parser->command && !parser->command->node) ) ) { if (!parser->has_root) svg_init_root_element(parser, elt); if (parser->command) parser->command->node = (GF_Node*)elt; } else if (!parent && parser->has_root && parser->command) { GF_CommandField *field = (GF_CommandField *)gf_list_get(parser->command->command_fields, 0); if (field) { if (field->new_node && (field->new_node->sgprivate->tag==TAG_DOMText)) { gf_node_unregister(field->new_node, NULL); field->new_node = NULL; } if (field->new_node) { field->field_ptr = &field->node_list; gf_node_list_add_child(& field->node_list, field->new_node); field->new_node = NULL; gf_node_list_add_child( & field->node_list, (GF_Node*) elt); } else if (field->node_list) { gf_node_list_add_child(& field->node_list, (GF_Node*) elt); } else { field->new_node = (GF_Node*)elt; field->field_ptr = &field->new_node; } } else { assert(parser->command->tag==GF_SG_LSR_NEW_SCENE); assert(gf_node_get_tag((GF_Node *)elt) == TAG_SVG_svg); if(!parser->command->node) parser->command->node = (GF_Node *)elt; } } else if (!parser->has_root ) { gf_list_del_item(parser->node_stack, stack); gf_free(stack); gf_node_unregister((GF_Node *)elt, NULL); } else if ((parser->has_root==2) && !parser->fragment_root) { parser->fragment_root = (GF_Node *)elt; } #endif }
Description: An invalid memory address dereference vulnerability exists in gpac 1.1.0 via the svg_node_start function, which causes a segmentation fault and application crash.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void EC_GROUP_free(EC_GROUP *group) { if (!group) return; if (group->meth->group_finish != 0) group->meth->group_finish(group); EC_EX_DATA_free_all_data(&group->extra_data); if (group->generator != NULL) EC_POINT_free(group->generator); BN_free(&group->order); BN_free(&group->cofactor); if (group->seed) OPENSSL_free(group->seed); OPENSSL_free(group); }
Description: A timing attack flaw was found in OpenSSL 1.0.1u and before that could allow a malicious user with local access to recover ECDSA P-256 private keys.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void AICast_ScriptLoad( void ) { char filename[MAX_QPATH]; vmCvar_t mapname; fileHandle_t f; int len; level.scriptAI = NULL; trap_Cvar_VariableStringBuffer( ""ai_scriptName"", filename, sizeof( filename ) ); if ( strlen( filename ) > 0 ) { trap_Cvar_Register( &mapname, ""ai_scriptName"", """", CVAR_ROM ); } else { trap_Cvar_Register( &mapname, ""mapname"", """", CVAR_SERVERINFO | CVAR_ROM ); } Q_strncpyz( filename, ""maps/"", sizeof( filename ) ); Q_strcat( filename, sizeof( filename ), mapname.string ); if ( g_gametype.integer <= GT_COOP ) { Q_strcat( filename, sizeof( filename ), "".coop.ai"" ); } else { Q_strcat( filename, sizeof( filename ), "".ai"" ); } len = trap_FS_FOpenFile( filename, &f, FS_READ ); G_Printf( ""Loading: %s\n"", filename ); if ( len < 0 ) { return; } level.scriptAI = G_Alloc( len ); trap_FS_Read( level.scriptAI, len, f ); trap_FS_FCloseFile( f ); return; }
Description: A vulnerability has been found in rtcwcoop 1.0.2 and classified as problematic. Affected by this vulnerability is the function AICast_ScriptLoad of the file code/game/ai_cast_script.c of the component Team Command Handler. The manipulation leads to denial of service. The identifier of the patch is f2cd18bc2e1cbca8c4b78bee9c392272bd5f42ac. It is recommended to apply a patch to fix this issue. The identifier VDB-221485 was assigned to this vulnerability.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void youngcollection (lua_State *L, global_State *g) { GCObject **psurvival;   lua_assert(g->gcstate == GCSpropagate); markold(g, g->allgc, g->reallyold); markold(g, g->finobj, g->finobjrold); atomic(L); psurvival = sweepgen(L, g, &g->allgc, g->survival); sweepgen(L, g, psurvival, g->reallyold); g->reallyold = g->old; g->old = *psurvival;   g->survival = g->allgc;   psurvival = sweepgen(L, g, &g->finobj, g->finobjsur); sweepgen(L, g, psurvival, g->finobjrold); g->finobjrold = g->finobjold; g->finobjold = *psurvival;   g->finobjsur = g->finobj;   sweepgen(L, g, &g->tobefnz, NULL); finishgencycle(L, g); }
Description: lgc.c in Lua 5.4.0 mishandles the interaction between barriers and the sweep phase, leading to a memory access violation involving collectgarbage.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void jv_dump_term(struct dtoa_context* C, jv x, int flags, int indent, FILE* F, jv* S) { char buf[JVP_DTOA_FMT_MAX_LEN]; const char* color = 0; double refcnt = (flags & JV_PRINT_REFCOUNT) ? jv_get_refcnt(x) - 1 : -1; if (flags & JV_PRINT_COLOR) { for (unsigned i=0; i<sizeof(color_kinds)/sizeof(color_kinds[0]); i++) { if (jv_get_kind(x) == color_kinds[i]) { color = colors[i]; put_str(color, F, S, flags & JV_PRINT_ISATTY); break; } } } switch (jv_get_kind(x)) { default: case JV_KIND_INVALID: if (flags & JV_PRINT_INVALID) { jv msg = jv_invalid_get_msg(jv_copy(x)); if (jv_get_kind(msg) == JV_KIND_STRING) { put_str(""<invalid:"", F, S, flags & JV_PRINT_ISATTY); jvp_dump_string(msg, flags | JV_PRINT_ASCII, F, S, flags & JV_PRINT_ISATTY); put_str("">"", F, S, flags & JV_PRINT_ISATTY); } else { put_str(""<invalid>"", F, S, flags & JV_PRINT_ISATTY); } } else { assert(0 && ""Invalid value""); } break; case JV_KIND_NULL: put_str(""null"", F, S, flags & JV_PRINT_ISATTY); break; case JV_KIND_FALSE: put_str(""false"", F, S, flags & JV_PRINT_ISATTY); break; case JV_KIND_TRUE: put_str(""true"", F, S, flags & JV_PRINT_ISATTY); break; case JV_KIND_NUMBER: { double d = jv_number_value(x); if (d != d) { put_str(""null"", F, S, flags & JV_PRINT_ISATTY); } else { if (d > DBL_MAX) d = DBL_MAX; if (d < -DBL_MAX) d = -DBL_MAX; put_str(jvp_dtoa_fmt(C, buf, d), F, S, flags & JV_PRINT_ISATTY); } break; } case JV_KIND_STRING: jvp_dump_string(x, flags & JV_PRINT_ASCII, F, S, flags & JV_PRINT_ISATTY); if (flags & JV_PRINT_REFCOUNT) put_refcnt(C, refcnt, F, S, flags & JV_PRINT_ISATTY); break; case JV_KIND_ARRAY: { if (jv_array_length(jv_copy(x)) == 0) { put_str(""[]"", F, S, flags & JV_PRINT_ISATTY); break; } put_str(""["", F, S, flags & JV_PRINT_ISATTY); if (flags & JV_PRINT_PRETTY) { put_char('\n', F, S, flags & JV_PRINT_ISATTY); put_indent(indent + 1, flags, F, S, flags & JV_PRINT_ISATTY); } jv_array_foreach(x, i, elem) { if (i!=0) { if (flags & JV_PRINT_PRETTY) { put_str("",\n"", F, S, flags & JV_PRINT_ISATTY); put_indent(indent + 1, flags, F, S, flags & JV_PRINT_ISATTY); } else { put_str("","", F, S, flags & JV_PRINT_ISATTY); } } jv_dump_term(C, elem, flags, indent + 1, F, S); if (color) put_str(color, F, S, flags & JV_PRINT_ISATTY); } if (flags & JV_PRINT_PRETTY) { put_char('\n', F, S, flags & JV_PRINT_ISATTY); put_indent(indent, flags, F, S, flags & JV_PRINT_ISATTY); } if (color) put_str(color, F, S, flags & JV_PRINT_ISATTY); put_char(']', F, S, flags & JV_PRINT_ISATTY); if (flags & JV_PRINT_REFCOUNT) put_refcnt(C, refcnt, F, S, flags & JV_PRINT_ISATTY); break; } case JV_KIND_OBJECT: { if (jv_object_length(jv_copy(x)) == 0) { put_str(""{}"", F, S, flags & JV_PRINT_ISATTY); break; } put_char('{', F, S, flags & JV_PRINT_ISATTY); if (flags & JV_PRINT_PRETTY) { put_char('\n', F, S, flags & JV_PRINT_ISATTY); put_indent(indent + 1, flags, F, S, flags & JV_PRINT_ISATTY); } int first = 1; int i = 0; jv keyset = jv_null(); while (1) { jv key, value; if (flags & JV_PRINT_SORTED) { if (first) { keyset = jv_keys(jv_copy(x)); i = 0; } else { i++; } if (i >= jv_array_length(jv_copy(keyset))) { jv_free(keyset); break; } key = jv_array_get(jv_copy(keyset), i); value = jv_object_get(jv_copy(x), jv_copy(key)); } else { if (first) { i = jv_object_iter(x); } else { i = jv_object_iter_next(x, i); } if (!jv_object_iter_valid(x, i)) break; key = jv_object_iter_key(x, i); value = jv_object_iter_value(x, i); } if (!first) { if (flags & JV_PRINT_PRETTY){ put_str("",\n"", F, S, flags & JV_PRINT_ISATTY); put_indent(indent + 1, flags, F, S, flags & JV_PRINT_ISATTY); } else { put_str("","", F, S, flags & JV_PRINT_ISATTY); } } if (color) put_str(COLRESET, F, S, flags & JV_PRINT_ISATTY); first = 0; if (color) put_str(FIELD_COLOR, F, S, flags & JV_PRINT_ISATTY); jvp_dump_string(key, flags & JV_PRINT_ASCII, F, S, flags & JV_PRINT_ISATTY); jv_free(key); if (color) put_str(COLRESET, F, S, flags & JV_PRINT_ISATTY); if (color) put_str(color, F, S, flags & JV_PRINT_ISATTY); put_str((flags & JV_PRINT_PRETTY) ? "": "" : "":"", F, S, flags & JV_PRINT_ISATTY); if (color) put_str(COLRESET, F, S, flags & JV_PRINT_ISATTY); jv_dump_term(C, value, flags, indent + 1, F, S); if (color) put_str(color, F, S, flags & JV_PRINT_ISATTY); } if (flags & JV_PRINT_PRETTY) { put_char('\n', F, S, flags & JV_PRINT_ISATTY); put_indent(indent, flags, F, S, flags & JV_PRINT_ISATTY); } if (color) put_str(color, F, S, flags & JV_PRINT_ISATTY); put_char('}', F, S, flags & JV_PRINT_ISATTY); if (flags & JV_PRINT_REFCOUNT) put_refcnt(C, refcnt, F, S, flags & JV_PRINT_ISATTY); } } jv_free(x); if (color) { put_str(COLRESET, F, S, flags & JV_PRINT_ISATTY); } }
Description: The jv_dump_term function in jq 1.5 allows remote attackers to cause a denial of service (stack consumption and application crash) via a crafted JSON file. This issue has been fixed in jq 1.6_rc1-r0.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int _option_parse(gnrc_tcp_tcb_t *tcb, tcp_hdr_t *hdr) { uint8_t offset = GET_OFFSET(byteorder_ntohs(hdr->off_ctl)); if (offset <= TCP_HDR_OFFSET_MIN) { return 0; } uint8_t *opt_ptr = (uint8_t *) hdr + sizeof(tcp_hdr_t); uint8_t opt_left = (offset - TCP_HDR_OFFSET_MIN) * 4; while (opt_left > 0) { tcp_hdr_opt_t *option = (tcp_hdr_opt_t *) opt_ptr; switch (option->kind) { case TCP_OPTION_KIND_EOL: DEBUG(""gnrc_tcp_option.c : _option_parse() : EOL option found\n""); return 0; case TCP_OPTION_KIND_NOP: DEBUG(""gnrc_tcp_option.c : _option_parse() : NOP option found\n""); opt_ptr += 1; opt_left -= 1; continue; case TCP_OPTION_KIND_MSS: if (option->length != TCP_OPTION_LENGTH_MSS) { DEBUG(""gnrc_tcp_option.c : _option_parse() : invalid MSS Option length.\n""); return -1; } tcb->mss = (option->value[0] << 8) | option->value[1]; DEBUG(""gnrc_tcp_option.c : _option_parse() : MSS option found. MSS=%""PRIu16""\n"", tcb->mss); break; default: DEBUG(""gnrc_tcp_option.c : _option_parse() : Unknown option found.\ KIND=%""PRIu8"", LENGTH=%""PRIu8""\n"", option->kind, option->length); } if (option->length > opt_left) { DEBUG(""gnrc_tcp_option.c : _option_parse() : invalid option length\n""); return 0; } opt_ptr += option->length; opt_left -= option->length; } return 0; }
Description: In the TCP implementation (gnrc_tcp) in RIOT through 2019.07, the parser for TCP options does not terminate on all inputs, allowing a denial-of-service, because sys/net/gnrc/transport_layer/tcp/gnrc_tcp_option.c has an infinite loop for an unknown zero-length option.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: const char* WinPKIErrorString(void) { static char error_string[64]; DWORD error_code = GetLastError(); if ((error_code >> 16) != 0x8009) return WindowsErrorString(); switch (error_code) { case NTE_BAD_UID: return ""Bad UID.""; case CRYPT_E_MSG_ERROR: return ""An error occurred while performing an operation on a cryptographic message.""; case CRYPT_E_UNKNOWN_ALGO: return ""Unknown cryptographic algorithm.""; case CRYPT_E_INVALID_MSG_TYPE: return ""Invalid cryptographic message type.""; case CRYPT_E_HASH_VALUE: return ""The hash value is not correct""; case CRYPT_E_ISSUER_SERIALNUMBER: return ""Invalid issuer and/or serial number.""; case CRYPT_E_BAD_LEN: return ""The length specified for the output data was insufficient.""; case CRYPT_E_BAD_ENCODE: return ""An error occurred during encode or decode operation.""; case CRYPT_E_FILE_ERROR: return ""An error occurred while reading or writing to a file.""; case CRYPT_E_NOT_FOUND: return ""Cannot find object or property.""; case CRYPT_E_EXISTS: return ""The object or property already exists.""; case CRYPT_E_NO_PROVIDER: return ""No provider was specified for the store or object.""; case CRYPT_E_DELETED_PREV: return ""The previous certificate or CRL context was deleted.""; case CRYPT_E_NO_MATCH: return ""Cannot find the requested object.""; case CRYPT_E_UNEXPECTED_MSG_TYPE: case CRYPT_E_NO_KEY_PROPERTY: case CRYPT_E_NO_DECRYPT_CERT: return ""Private key or certificate issue""; case CRYPT_E_BAD_MSG: return ""Not a cryptographic message.""; case CRYPT_E_NO_SIGNER: return ""The signed cryptographic message does not have a signer for the specified signer index.""; case CRYPT_E_REVOKED: return ""The certificate is revoked.""; case CRYPT_E_NO_REVOCATION_DLL: case CRYPT_E_NO_REVOCATION_CHECK: case CRYPT_E_REVOCATION_OFFLINE: case CRYPT_E_NOT_IN_REVOCATION_DATABASE: return ""Cannot check certificate revocation.""; case CRYPT_E_INVALID_NUMERIC_STRING: case CRYPT_E_INVALID_PRINTABLE_STRING: case CRYPT_E_INVALID_IA5_STRING: case CRYPT_E_INVALID_X500_STRING: case  CRYPT_E_NOT_CHAR_STRING: return ""Invalid string.""; case CRYPT_E_SECURITY_SETTINGS: return ""The cryptographic operation failed due to a local security option setting.""; case CRYPT_E_NO_VERIFY_USAGE_CHECK: case CRYPT_E_VERIFY_USAGE_OFFLINE: return ""Cannot complete usage check.""; case CRYPT_E_NO_TRUSTED_SIGNER: return ""None of the signers of the cryptographic message or certificate trust list is trusted.""; default: static_sprintf(error_string, ""Unknown PKI error 0x%08lX"", error_code); return error_string; } }
Description: Akeo Consulting Rufus prior to version 2.17.1187 does not adequately validate the integrity of updates downloaded over HTTP, allowing an attacker to easily convince a user to execute arbitrary code
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void lcTexture::CreateGridTexture() { constexpr int NumLevels = 9; mImages.resize(NumLevels); quint8* Previous = nullptr; for (int ImageLevel = 0; ImageLevel < NumLevels; ImageLevel++) { Image& GridImage = mImages[ImageLevel]; const int GridSize = 256 >> ImageLevel; GridImage.Allocate(GridSize, GridSize, LC_PIXEL_FORMAT_A8); if (Previous) { const int PreviousGridSize = 2 * GridSize; for (int y = 0; y < GridSize - 1; y++) { for (int x = 0; x < GridSize - 1; x++) { const quint8 a = Previous[x * 2 + y * 2 * PreviousGridSize] > 64 ? 255 : 0; const quint8 b = Previous[x * 2 + 1 + y * 2 * PreviousGridSize] > 64 ? 255 : 0; const quint8 c = Previous[x * 2 + (y * 2 + 1) * PreviousGridSize] > 64 ? 255 : 0; const quint8 d = Previous[x * 2 + 1 + (y * 2 + 1) * PreviousGridSize] > 64 ? 255 : 0; GridImage.mData[x + y * GridSize] = (a + b + c + d) / 4; } int x = GridSize - 1; const quint8 a = Previous[x * 2 + y * 2 * PreviousGridSize]; const quint8 c = Previous[x * 2 + (y * 2 + 1) * PreviousGridSize]; GridImage.mData[x + y * GridSize] = (a + c) / 2; } int y = GridSize - 1; for (int x = 0; x < GridSize - 1; x++) { const quint8 a = Previous[x * 2 + y * 2 * PreviousGridSize]; const quint8 b = Previous[x * 2 + 1 + y * 2 * PreviousGridSize]; GridImage.mData[x + y * GridSize] = (a + b) / 2; } int x = GridSize - 1; GridImage.mData[x + y * GridSize] = Previous[x + y * PreviousGridSize]; } else { const float Radius1 = (80 >> ImageLevel) * (80 >> ImageLevel); const float Radius2 = (72 >> ImageLevel) * (72 >> ImageLevel); quint8* TempBuffer = new quint8[GridSize * GridSize]; for (int y = 0; y < GridSize; y++) { quint8* Pixel = TempBuffer + y * GridSize; memset(Pixel, 0, GridSize); const float y2 = (y - GridSize / 2) * (y - GridSize / 2); if (Radius1 <= y2) continue; if (Radius2 <= y2) { const int x1 = sqrtf(Radius1 - y2); for (int x = GridSize / 2 - x1; x < GridSize / 2 + x1; x++) Pixel[x] = 255; } else { const int x1 = sqrtf(Radius1 - y2); const int x2 = sqrtf(Radius2 - y2); for (int x = GridSize / 2 - x1; x < GridSize / 2 - x2; x++) Pixel[x] = 255; for (int x = GridSize / 2 + x2; x < GridSize / 2 + x1; x++) Pixel[x] = 255; } } for (int y = 0; y < GridSize - 1; y++) { for (int x = 0; x < GridSize - 1; x++) { const quint8 a = TempBuffer[x + y * GridSize]; const quint8 b = TempBuffer[x + 1 + y * GridSize]; const quint8 c = TempBuffer[x + (y + 1) * GridSize]; const quint8 d = TempBuffer[x + 1 + (y + 1) * GridSize]; GridImage.mData[x + y * GridSize] = (a + b + c + d) / 4; } int x = GridSize - 1; const quint8 a = TempBuffer[x + y * GridSize]; const quint8 c = TempBuffer[x + (y + 1) * GridSize]; GridImage.mData[x + y * GridSize] = (a + c) / 2; } int y = GridSize - 1; for (int x = 0; x < GridSize - 1; x++) { const quint8 a = TempBuffer[x + y * GridSize]; const quint8 b = TempBuffer[x + 1 + y * GridSize]; GridImage.mData[x + y * GridSize] = (a + b) / 2; } int x = GridSize - 1; GridImage.mData[x + y * GridSize] = TempBuffer[x + y * GridSize]; delete[] TempBuffer; } Previous = GridImage.mData; } mRefCount = 1; mFlags = LC_TEXTURE_WRAPU | LC_TEXTURE_WRAPV | LC_TEXTURE_MIPMAPS | LC_TEXTURE_ANISOTROPIC; lcGetPiecesLibrary()->QueueTextureUpload(this); }
Description: LeoCAD before 21.03 sometimes allows a use-after-free during the opening of a new document.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void gen_assignment(codegen_scope *s, node *tree, node *rhs, int sp, int val) { int idx; int type = nint(tree->car); switch (type) { case NODE_GVAR: case NODE_ARG: case NODE_LVAR: case NODE_IVAR: case NODE_CVAR: case NODE_CONST: case NODE_NIL: case NODE_MASGN: if (rhs) { codegen(s, rhs, VAL); pop(); sp = cursp(); } break; case NODE_COLON2: case NODE_CALL: case NODE_SCALL: break; case NODE_NVAR: codegen_error(s, ""Can't assign to numbered parameter""); break; default: codegen_error(s, ""unknown lhs""); break; } tree = tree->cdr; switch (type) { case NODE_GVAR: gen_setxv(s, OP_SETGV, sp, nsym(tree), val); break; case NODE_ARG: case NODE_LVAR: idx = lv_idx(s, nsym(tree)); if (idx > 0) { if (idx != sp) { gen_move(s, idx, sp, val); } break; } else {                       gen_setupvar(s, sp, nsym(tree)); } break; case NODE_IVAR: gen_setxv(s, OP_SETIV, sp, nsym(tree), val); break; case NODE_CVAR: gen_setxv(s, OP_SETCV, sp, nsym(tree), val); break; case NODE_CONST: gen_setxv(s, OP_SETCONST, sp, nsym(tree), val); break; case NODE_COLON2: if (sp) { gen_move(s, cursp(), sp, 0); } sp = cursp(); push(); codegen(s, tree->car, VAL); if (rhs) { codegen(s, rhs, VAL); pop(); gen_move(s, sp, cursp(), 0); } pop_n(2); idx = new_sym(s, nsym(tree->cdr)); genop_2(s, OP_SETMCNST, sp, idx); break; case NODE_CALL: case NODE_SCALL: { int noself = 0, safe = (type == NODE_SCALL), skip = 0, top, call, n = 0; mrb_sym mid = nsym(tree->cdr->car); top = cursp(); if (val || sp == cursp()) { push();                    } call = cursp(); if (!tree->car) { noself = 1; push(); } else { codegen(s, tree->car, VAL);  } if (safe) { int recv = cursp()-1; gen_move(s, cursp(), recv, 1); skip = genjmp2_0(s, OP_JMPNIL, cursp(), val); } tree = tree->cdr->cdr->car; if (tree) { if (tree->car) {             n = gen_values(s, tree->car, VAL, (tree->cdr->car)?13:14); if (n < 0) {               n = 15; push(); } } if (tree->cdr->car) {        if (n == 14) { pop_n(n); genop_2(s, OP_ARRAY, cursp(), n); push(); n = 15; } gen_hash(s, tree->cdr->car->cdr, VAL, 0); if (n < 14) { n++; } else { pop_n(2); genop_2(s, OP_ARYPUSH, cursp(), 1); } push(); } } if (rhs) { codegen(s, rhs, VAL); pop(); } else { gen_move(s, cursp(), sp, 0); } if (val) { gen_move(s, top, cursp(), 1); } if (n < 14) { n++; } else { pop(); genop_2(s, OP_ARYPUSH, cursp(), 1); } s->sp = call; if (mid == MRB_OPSYM_2(s->mrb, aref) && n == 2) { genop_1(s, OP_SETIDX, cursp()); } else { genop_3(s, noself ? OP_SSEND : OP_SEND, cursp(), new_sym(s, attrsym(s, mid)), n); } if (safe) { dispatch(s, skip); } s->sp = top; } break; case NODE_MASGN: gen_vmassignment(s, tree->car, sp, val); break; case NODE_NIL: break; default: codegen_error(s, ""unknown lhs""); break; } if (val) push(); }
Description: Out-of-bounds Read in GitHub repository mruby/mruby prior to 3.2.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int _redisContextConnectTcp(redisContext *c, const char *addr, int port, const struct timeval *timeout, const char *source_addr) { int s, rv, n; char _port[6];   struct addrinfo hints, *servinfo, *bservinfo, *p, *b; int blocking = (c->flags & REDIS_BLOCK); int reuseaddr = (c->flags & REDIS_REUSEADDR); int reuses = 0; long timeout_msec = -1; servinfo = NULL; c->connection_type = REDIS_CONN_TCP; c->tcp.port = port; if (c->tcp.host != addr) { free(c->tcp.host); c->tcp.host = strdup(addr); } if (timeout) { if (c->timeout != timeout) { if (c->timeout == NULL) c->timeout = malloc(sizeof(struct timeval)); memcpy(c->timeout, timeout, sizeof(struct timeval)); } } else { free(c->timeout); c->timeout = NULL; } if (redisContextTimeoutMsec(c, &timeout_msec) != REDIS_OK) { __redisSetError(c, REDIS_ERR_IO, ""Invalid timeout specified""); goto error; } if (source_addr == NULL) { free(c->tcp.source_addr); c->tcp.source_addr = NULL; } else if (c->tcp.source_addr != source_addr) { free(c->tcp.source_addr); c->tcp.source_addr = strdup(source_addr); } snprintf(_port, 6, ""%d"", port); memset(&hints,0,sizeof(hints)); hints.ai_family = AF_INET; hints.ai_socktype = SOCK_STREAM; if ((rv = getaddrinfo(c->tcp.host,_port,&hints,&servinfo)) != 0) { hints.ai_family = AF_INET6; if ((rv = getaddrinfo(addr,_port,&hints,&servinfo)) != 0) { __redisSetError(c,REDIS_ERR_OTHER,gai_strerror(rv)); return REDIS_ERR; } } for (p = servinfo; p != NULL; p = p->ai_next) { addrretry: if ((s = socket(p->ai_family,p->ai_socktype,p->ai_protocol)) == -1) continue; c->fd = s; if (redisSetBlocking(c,0) != REDIS_OK) goto error; if (c->tcp.source_addr) { int bound = 0; if ((rv = getaddrinfo(c->tcp.source_addr, NULL, &hints, &bservinfo)) != 0) { char buf[128]; snprintf(buf,sizeof(buf),""Can't get addr: %s"",gai_strerror(rv)); __redisSetError(c,REDIS_ERR_OTHER,buf); goto error; } if (reuseaddr) { n = 1; if (setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char*) &n, sizeof(n)) < 0) { freeaddrinfo(bservinfo); goto error; } } for (b = bservinfo; b != NULL; b = b->ai_next) { if (bind(s,b->ai_addr,b->ai_addrlen) != -1) { bound = 1; break; } } freeaddrinfo(bservinfo); if (!bound) { char buf[128]; snprintf(buf,sizeof(buf),""Can't bind socket: %s"",strerror(errno)); __redisSetError(c,REDIS_ERR_OTHER,buf); goto error; } } if (connect(s,p->ai_addr,p->ai_addrlen) == -1) { if (errno == EHOSTUNREACH) { redisContextCloseFd(c); continue; } else if (errno == EINPROGRESS && !blocking) { } else if (errno == EADDRNOTAVAIL && reuseaddr) { if (++reuses >= REDIS_CONNECT_RETRIES) { goto error; } else { redisContextCloseFd(c); goto addrretry; } } else { if (redisContextWaitReady(c,timeout_msec) != REDIS_OK) goto error; } } if (blocking && redisSetBlocking(c,1) != REDIS_OK) goto error; if (redisSetTcpNoDelay(c) != REDIS_OK) goto error; c->flags |= REDIS_CONNECTED; rv = REDIS_OK; goto end; } if (p == NULL) { char buf[128]; snprintf(buf,sizeof(buf),""Can't create socket: %s"",strerror(errno)); __redisSetError(c,REDIS_ERR_OTHER,buf); goto error; } error: rv = REDIS_ERR; end: if(servinfo) { freeaddrinfo(servinfo); } return rv;  }
Description: async.c and dict.c in libhiredis.a in hiredis through 0.14.0 allow a NULL pointer dereference because malloc return values are unchecked.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void __return_cfs_rq_runtime(struct cfs_rq *cfs_rq) { struct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg); s64 slack_runtime = cfs_rq->runtime_remaining - min_cfs_rq_runtime; if (slack_runtime <= 0) return; raw_spin_lock(&cfs_b->lock); if (cfs_b->quota != RUNTIME_INF && cfs_rq->runtime_expires == cfs_b->runtime_expires) { cfs_b->runtime += slack_runtime; if (cfs_b->runtime > sched_cfs_bandwidth_slice() && !list_empty(&cfs_b->throttled_cfs_rq)) start_cfs_slack_bandwidth(cfs_b); } raw_spin_unlock(&cfs_b->lock); cfs_rq->runtime_remaining -= slack_runtime; }
Description: kernel/sched/fair.c in the Linux kernel before 5.3.9, when cpu.cfs_quota_us is used (e.g., with Kubernetes), allows attackers to cause a denial of service against non-cpu-bound applications by generating a workload that triggers unwanted slice expiration, aka CID-de53fd7aedb1. (In other words, although this slice expiration would typically be seen with benign workloads, it is possible that an attacker could calculate how many stray requests are required to force an entire Kubernetes cluster into a low-performance state caused by slice expiration, and ensure that a DDoS attack sent that number of stray requests. An attack does not affect the stability of the kernel; it only causes mismanagement of application execution.)
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: WORD32 ih264d_read_mmco_commands(struct _DecStruct * ps_dec) { dec_bit_stream_t *ps_bitstrm = ps_dec->ps_bitstrm; dpb_commands_t *ps_dpb_cmds = ps_dec->ps_dpb_cmds; dec_slice_params_t * ps_slice = ps_dec->ps_cur_slice; WORD32 j; UWORD8 u1_buf_mode; struct MMCParams *ps_mmc_params; UWORD32 *pu4_bitstrm_buf = ps_dec->ps_bitstrm->pu4_buffer; UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst; UWORD32 u4_bit_ofst = ps_dec->ps_bitstrm->u4_ofst; ps_slice->u1_mmco_equalto5 = 0; { if(ps_dec->u1_nal_unit_type == IDR_SLICE_NAL) { ps_slice->u1_no_output_of_prior_pics_flag = ih264d_get_bit_h264(ps_bitstrm); COPYTHECONTEXT(""SH: no_output_of_prior_pics_flag"", ps_slice->u1_no_output_of_prior_pics_flag); ps_slice->u1_long_term_reference_flag = ih264d_get_bit_h264( ps_bitstrm); COPYTHECONTEXT(""SH: long_term_reference_flag"", ps_slice->u1_long_term_reference_flag); ps_dpb_cmds->u1_idr_pic = 1; ps_dpb_cmds->u1_no_output_of_prior_pics_flag = ps_slice->u1_no_output_of_prior_pics_flag; ps_dpb_cmds->u1_long_term_reference_flag = ps_slice->u1_long_term_reference_flag; } else { u1_buf_mode = ih264d_get_bit_h264(ps_bitstrm);             COPYTHECONTEXT(""SH: adaptive_ref_pic_buffering_flag"", u1_buf_mode); ps_dpb_cmds->u1_buf_mode = u1_buf_mode; j = 0; if(u1_buf_mode == 1) { UWORD32 u4_mmco; UWORD32 u4_diff_pic_num; UWORD32 u4_lt_idx, u4_max_lt_idx; u4_mmco = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf); while(u4_mmco != END_OF_MMCO) { ps_mmc_params = &ps_dpb_cmds->as_mmc_params[j]; ps_mmc_params->u4_mmco = u4_mmco; switch(u4_mmco) { case MARK_ST_PICNUM_AS_NONREF: u4_diff_pic_num = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf); ps_mmc_params->u4_diff_pic_num = u4_diff_pic_num; break; case MARK_LT_INDEX_AS_NONREF: u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf); ps_mmc_params->u4_lt_idx = u4_lt_idx; break; case MARK_ST_PICNUM_AS_LT_INDEX: u4_diff_pic_num = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf); ps_mmc_params->u4_diff_pic_num = u4_diff_pic_num; u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf); ps_mmc_params->u4_lt_idx = u4_lt_idx; break; case SET_MAX_LT_INDEX: { u4_max_lt_idx = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf); ps_mmc_params->u4_max_lt_idx_plus1 = u4_max_lt_idx; break; } case RESET_REF_PICTURES: { ps_slice->u1_mmco_equalto5 = 1; break; } case SET_LT_INDEX: u4_lt_idx = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf); ps_mmc_params->u4_lt_idx = u4_lt_idx; break; default: break; } u4_mmco = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf); j++; } ps_dpb_cmds->u1_num_of_commands = j; } } ps_dpb_cmds->u1_dpb_commands_read = 1; ps_dpb_cmds->u1_dpb_commands_read_slc = 1; } u4_bit_ofst = ps_dec->ps_bitstrm->u4_ofst - u4_bit_ofst; return u4_bit_ofst; }
Description: The H.264 decoder in libstagefright in Android 6.x before 2016-04-01 mishandles Memory Management Control Operation (MMCO) data, which allows remote attackers to execute arbitrary code or cause a denial of service (memory corruption) via a crafted media file, aka internal bug 25818142.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void TextDocumentParser::insertFakePreElement() { Vector<Attribute> attributes; attributes.append(Attribute(styleAttr, ""word-wrap: break-word; white-space: pre-wrap;"")); AtomicHTMLToken fakePre(HTMLToken::StartTag, preTag.localName(), attributes); treeBuilder()->constructTree(&fakePre); treeBuilder()->setShouldSkipLeadingNewline(false); forcePlaintextForTextDocument(); m_haveInsertedFakePreElement = true; }
Description: Google Chrome before 50.0.2661.75 does not properly consider that frame removal may occur during callback execution, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted extension.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int amd_iommu_domain_init(struct domain *d) { struct domain_iommu *hd = dom_iommu(d); hd->arch.paging_mode = is_hvm_domain(d) ? 2 : amd_iommu_get_paging_mode(max_page); return 0; }
Description: An issue was discovered in Xen through 4.12.x allowing x86 AMD HVM guest OS users to cause a denial of service or possibly gain privileges by triggering data-structure access during pagetable-height updates. When running on AMD systems with an IOMMU, Xen attempted to dynamically adapt the number of levels of pagetables (the pagetable height) in the IOMMU according to the guest's address space size. The code to select and update the height had several bugs. Notably, the update was done without taking a lock which is necessary for safe operation. A malicious guest administrator can cause Xen to access data structures while they are being modified, causing Xen to crash. Privilege escalation is thought to be very difficult but cannot be ruled out. Additionally, there is a potential memory leak of 4kb per guest boot, under memory pressure. Only Xen on AMD CPUs is vulnerable. Xen running on Intel CPUs is not vulnerable. ARM systems are not vulnerable. Only systems where guests are given direct access to physical devices are vulnerable. Systems which do not use PCI pass-through are not vulnerable. Only HVM guests can exploit the vulnerability. PV and PVH guests cannot. All versions of Xen with IOMMU support are vulnerable.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int for_each_problem_in_dir(const char *path, uid_t caller_uid, int (*callback)(struct dump_dir *dd, void *arg), void *arg) { DIR *dp = opendir(path); if (!dp) { return 0; } int brk = 0; struct dirent *dent; while ((dent = readdir(dp)) != NULL) { if (dot_or_dotdot(dent->d_name)) continue;  char *full_name = concat_path_file(path, dent->d_name); if (caller_uid == -1 || dump_dir_accessible_by_uid(full_name, caller_uid)) { int sv_logmode = logmode; logmode = 0; struct dump_dir *dd = dd_opendir(full_name, DD_OPEN_READONLY | DD_FAIL_QUIETLY_EACCES | DD_DONT_WAIT_FOR_LOCK); logmode = sv_logmode; if (dd) { brk = callback ? callback(dd, arg) : 0; dd_close(dd); } } free(full_name); if (brk) break; } closedir(dp); return brk; }
Description: abrt-dbus in Automatic Bug Reporting Tool (ABRT) allows local users to delete or change the ownership of arbitrary files via the problem directory argument to the (1) ChownProblemDir, (2) DeleteElement, or (3) DeleteProblem method.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: struct bus_id_priv *get_busid_priv(const char *busid) { int idx; struct bus_id_priv *bid = NULL; spin_lock(&busid_table_lock); idx = get_busid_idx(busid); if (idx >= 0) bid = &(busid_table[idx]); spin_unlock(&busid_table_lock); return bid; }
Description: In the Linux Kernel before version 4.16.11, 4.14.43, 4.9.102, and 4.4.133, multiple race condition errors when handling probe, disconnect, and rebind operations can be exploited to trigger a use-after-free condition or a NULL pointer dereference by sending multiple USB over IP packets.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void print_perm_line (int        idx, GPtrArray *items, int        cols) { g_autoptr(GString) res = g_string_new (NULL); int i; g_string_append_printf (res, ""    [%d] %s"", idx, (char *) items->pdata[0]); for (i = 1; i < items->len; i++) { char *p; int len; p = strrchr (res->str, '\n'); if (!p) p = res->str; len = (res->str + strlen (res->str)) - p; if (len + strlen ((char *) items->pdata[i]) + 2 >= cols) g_string_append_printf (res, "",\n        %s"", (char *) items->pdata[i]); else g_string_append_printf (res, "", %s"", (char *) items->pdata[i]); } g_print (""%s\n"", res->str); }
Description: Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In versions prior to 1.10.8, 1.12.8, 1.14.4, and 1.15.4, if an attacker publishes a Flatpak app with elevated permissions, they can hide those permissions from users of the `flatpak(1)` command-line interface by setting other permissions to crafted values that contain non-printable control characters such as `ESC`. A fix is available in versions 1.10.8, 1.12.8, 1.14.4, and 1.15.4. As a workaround, use a GUI like GNOME Software rather than the command-line interface, or only install apps whose maintainers you trust.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void jbd2_journal_wait_updates(journal_t *journal) { transaction_t *commit_transaction = journal->j_running_transaction; if (!commit_transaction) return; spin_lock(&commit_transaction->t_handle_lock); while (atomic_read(&commit_transaction->t_updates)) { DEFINE_WAIT(wait); prepare_to_wait(&journal->j_wait_updates, &wait, TASK_UNINTERRUPTIBLE); if (atomic_read(&commit_transaction->t_updates)) { spin_unlock(&commit_transaction->t_handle_lock); write_unlock(&journal->j_state_lock); schedule(); write_lock(&journal->j_state_lock); spin_lock(&commit_transaction->t_handle_lock); } finish_wait(&journal->j_wait_updates, &wait); } spin_unlock(&commit_transaction->t_handle_lock); }
Description: jbd2_journal_wait_updates in fs/jbd2/transaction.c in the Linux kernel before 5.17.1 has a use-after-free caused by a transaction_t race condition.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: X509_POLICY_NODE *ossl_policy_level_add_node(X509_POLICY_LEVEL *level, X509_POLICY_DATA *data, X509_POLICY_NODE *parent, X509_POLICY_TREE *tree) { X509_POLICY_NODE *node; node = OPENSSL_zalloc(sizeof(*node)); if (node == NULL) { ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE); return NULL; } node->data = data; node->parent = parent; if (level) { if (OBJ_obj2nid(data->valid_policy) == NID_any_policy) { if (level->anyPolicy) goto node_error; level->anyPolicy = node; } else { if (level->nodes == NULL) level->nodes = ossl_policy_node_cmp_new(); if (level->nodes == NULL) { ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE); goto node_error; } if (!sk_X509_POLICY_NODE_push(level->nodes, node)) { ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE); goto node_error; } } } if (tree) { if (tree->extra_data == NULL) tree->extra_data = sk_X509_POLICY_DATA_new_null(); if (tree->extra_data == NULL){ ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE); goto node_error; } if (!sk_X509_POLICY_DATA_push(tree->extra_data, data)) { ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE); goto node_error; } } if (parent) parent->nchild++; return node; node_error: ossl_policy_node_free(node); return NULL; }
Description: A security vulnerability has been identified in all supported versions

of OpenSSL related to the verification of X.509 certificate chains
that include policy constraints.  Attackers may be able to exploit this
vulnerability by creating a malicious certificate chain that triggers
exponential use of computational resources, leading to a denial-of-service
(DoS) attack on affected systems.

Policy processing is disabled by default but can be enabled by passing
the `-policy' argument to the command line utilities or by calling the
`X509_VERIFY_PARAM_set1_policies()' function.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void dom_load_html(INTERNAL_FUNCTION_PARAMETERS, int mode)  { zval *id; xmlDoc *docp = NULL, *newdoc; dom_object *intern; dom_doc_propsptr doc_prop; char *source; int source_len, refcount, ret; long options = 0; htmlParserCtxtPtr ctxt; id = getThis(); if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""p|l"", &source, &source_len, &options) == FAILURE) { return; } if (!source_len) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty string supplied as input""); RETURN_FALSE; } if (mode == DOM_LOAD_FILE) { ctxt = htmlCreateFileParserCtxt(source, NULL); } else { source_len = xmlStrlen(source); ctxt = htmlCreateMemoryParserCtxt(source, source_len); } if (!ctxt) { RETURN_FALSE; } if (options) { htmlCtxtUseOptions(ctxt, options); } ctxt->vctxt.error = php_libxml_ctx_error; ctxt->vctxt.warning = php_libxml_ctx_warning; if (ctxt->sax != NULL) { ctxt->sax->error = php_libxml_ctx_error; ctxt->sax->warning = php_libxml_ctx_warning; } htmlParseDocument(ctxt); newdoc = ctxt->myDoc; htmlFreeParserCtxt(ctxt); if (!newdoc) RETURN_FALSE; if (id != NULL && instanceof_function(Z_OBJCE_P(id), dom_document_class_entry TSRMLS_CC)) { intern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC); if (intern != NULL) { docp = (xmlDocPtr) dom_object_get_node(intern); doc_prop = NULL; if (docp != NULL) { php_libxml_decrement_node_ptr((php_libxml_node_object *) intern TSRMLS_CC); doc_prop = intern->document->doc_props; intern->document->doc_props = NULL; refcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern TSRMLS_CC); if (refcount != 0) { docp->_private = NULL; } } intern->document = NULL; if (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, newdoc TSRMLS_CC) == -1) { RETURN_FALSE; } intern->document->doc_props = doc_prop; } php_libxml_increment_node_ptr((php_libxml_node_object *)intern, (xmlNodePtr)newdoc, (void *)intern TSRMLS_CC); RETURN_TRUE; } else { DOM_RET_OBJ((xmlNodePtr) newdoc, &ret, NULL); } }
Description: PHP before 5.4.42, 5.5.x before 5.5.26, and 5.6.x before 5.6.10 does not ensure that pathnames lack %00 sequences, which might allow remote attackers to read or write to arbitrary files via crafted input to an application that calls (1) a DOMDocument save method or (2) the GD imagepsloadfont function, as demonstrated by a filename\0.html attack that bypasses an intended configuration in which client users may write to only .html files.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static inline void tlb_end_vma(struct mmu_gather *tlb, struct vm_area_struct *vma) { if (tlb->fullmm || IS_ENABLED(CONFIG_MMU_GATHER_MERGE_VMAS)) return; tlb_flush_mmu_tlbonly(tlb); }
Description: An issue was discovered in include/asm-generic/tlb.h in the Linux kernel before 5.19. Because of a race condition (unmap_mapping_range versus munmap), a device driver can free a page while it still has stale TLB entries. This only occurs in situations with VM_PFNMAP VMAs.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void double_evtchn_lock(struct evtchn *lchn, struct evtchn *rchn) { if ( lchn < rchn ) { spin_lock(&lchn->lock); spin_lock(&rchn->lock); } else { if ( lchn != rchn ) spin_lock(&rchn->lock); spin_lock(&lchn->lock); } }
Description: An issue was discovered in Xen through 4.14.x. There are evtchn_reset() race conditions. Uses of EVTCHNOP_reset (potentially by a guest on itself) or XEN_DOMCTL_soft_reset (by itself covered by XSA-77) can lead to the violation of various internal assumptions. This may lead to out of bounds memory accesses or triggering of bug checks. In particular, x86 PV guests may be able to elevate their privilege to that of the host. Host and guest crashes are also possible, leading to a Denial of Service (DoS). Information leaks cannot be ruled out. All Xen versions from 4.5 onwards are vulnerable. Xen versions 4.4 and earlier are not vulnerable.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int32_t conn_handler(uint8_t *packet, conn_param *cparam, size_t max) { uint32_t len, tmp, pos = 0, len_of_var = 0; int      len_of_str = 0; int32_t  rv         = 0; if (packet[pos] != CMD_CONNECT) { return (-1); } else { pos++; } len = (uint32_t) get_var_integer(packet + pos, &len_of_var); pos += len_of_var; cparam->pro_name.body = (char *) copyn_utf8_str(packet, &pos, &len_of_str, max-pos); cparam->pro_name.len = len_of_str; rv                   = len_of_str < 0 ? PROTOCOL_ERROR : 0; log_trace(""pro_name: %s"", cparam->pro_name.body); cparam->pro_ver = packet[pos]; pos++; cparam->con_flag    = packet[pos]; cparam->clean_start = (cparam->con_flag & 0x02) >> 1; cparam->will_flag   = (cparam->con_flag & 0x04) >> 2; cparam->will_qos    = (cparam->con_flag & 0x18) >> 3; cparam->will_retain = (cparam->con_flag & 0x20) >> 5; log_trace(""conn flag:%x"", cparam->con_flag); pos++; NNI_GET16(packet + pos, tmp); cparam->keepalive_mqtt = tmp; pos += 2; if (cparam->pro_ver == MQTT_PROTOCOL_VERSION_v5) { log_trace(""MQTT V5 Properties""); cparam->properties = decode_buf_properties( packet, len, &pos, &cparam->prop_len, true); if (cparam->properties) { conn_param_set_property(cparam, cparam->properties); if ((rv = check_properties(cparam->properties)) != SUCCESS) { return rv; } } } log_trace(""pos after property: [%d]"", pos); cparam->clientid.body = (char *) copyn_utf8_str(packet, &pos, &len_of_str, max-pos); cparam->clientid.len = len_of_str; if (len_of_str == 0) { char clientid_r[20] = {0}; snprintf(clientid_r, 20, ""nanomq-%08x"", nni_random()); clientid_r[19]        = '\0'; cparam->clientid.body = nng_strdup(clientid_r); cparam->clientid.len  = strlen(clientid_r); cparam->assignedid    = true; } else if (len_of_str < 0) { return (PROTOCOL_ERROR); } log_trace(""clientid: [%s] [%d]"", cparam->clientid.body, len_of_str); if (cparam->pro_ver == MQTT_PROTOCOL_VERSION_v5 && cparam->assignedid) { property *assigned_cid = property_set_value_str(ASSIGNED_CLIENT_IDENTIFIER, cparam->clientid.body, cparam->clientid.len, false); if (cparam->properties == NULL) { cparam->properties = property_alloc(); } property_append(cparam->properties, assigned_cid); } if (rv == 0 && cparam->will_flag != 0) { if (cparam->pro_ver == MQTT_PROTOCOL_VERSION_v5) { cparam->will_properties = decode_buf_properties( packet, len, &pos, &cparam->will_prop_len, true); if (cparam->will_properties) { conn_param_set_will_property( cparam, cparam->will_properties); if ((rv = check_properties( cparam->will_properties)) != SUCCESS) { return rv; } } } cparam->will_topic.body = (char *) copyn_utf8_str(packet, &pos, &len_of_str, max-pos); cparam->will_topic.len = len_of_str; rv                     = len_of_str < 0 ? 1 : 0; if (cparam->will_topic.body == NULL || rv != 0) { rv = PROTOCOL_ERROR; return rv; } log_trace(""will_topic: %s %d"", cparam->will_topic.body, rv); if (rv == 0) { if (cparam->payload_format_indicator == 0) { cparam->will_msg.body = (char *) copyn_str( packet, &pos, &len_of_str, max - pos); } else if (rv == 0 && cparam->payload_format_indicator == 0x01) { cparam->will_msg.body = (char *) copyn_utf8_str( packet, &pos, &len_of_str, max - pos); } cparam->will_msg.len = len_of_str; rv = len_of_str < 0 ? PAYLOAD_FORMAT_INVALID : 0; log_trace( ""will_msg: %s %d"", cparam->will_msg.body, rv); } } if (rv == 0 && (cparam->con_flag & 0x80) > 0) { cparam->username.body = (char *) copyn_utf8_str(packet, &pos, &len_of_str, max-pos); cparam->username.len = len_of_str; rv                   = len_of_str < 0 ? PAYLOAD_FORMAT_INVALID : 0; if (rv != 0) { return rv; } log_trace( ""username: %s %d"", cparam->username.body, len_of_str); } if (rv == 0 && (cparam->con_flag & 0x40) > 0) { cparam->password.body = copyn_utf8_str(packet, &pos, &len_of_str, max-pos); cparam->password.len = len_of_str; rv                   = len_of_str < 0 ? PAYLOAD_FORMAT_INVALID : 0; if (rv != 0) { return rv; } log_trace( ""password: %s %d"", cparam->password.body, len_of_str); } if (len + len_of_var + 1 != pos) { log_error(""in connect handler""); rv = PROTOCOL_ERROR; } return rv; }
Description: In NanoMQ v0.15.0-0, Heap overflow occurs in read_byte function of mqtt_code.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int _gdGetColors (gdIOCtx * in, gdImagePtr im, int gd2xFlag) { int i; if (gd2xFlag) { int trueColorFlag; if (!gdGetByte (&trueColorFlag, in)) { goto fail1; } if (trueColorFlag != im->trueColor) { goto fail1; } if (!im->trueColor) { if (!gdGetWord (&im->colorsTotal, in)) { goto fail1; } if (im->colorsTotal > gdMaxColors) { goto fail1; } } if (!gdGetInt (&im->transparent, in)) { goto fail1; } } else { if (!gdGetByte (&im->colorsTotal, in)) { goto fail1; } if (!gdGetWord (&im->transparent, in)) { goto fail1; } if (im->transparent == 257) { im->transparent = (-1); } } GD2_DBG (printf (""Palette had %d colours (T=%d)\n"", im->colorsTotal, im->transparent)); if (im->trueColor) { return TRUE; } for (i = 0; (i < gdMaxColors); i++) { if (!gdGetByte (&im->red[i], in)) { goto fail1; } if (!gdGetByte (&im->green[i], in)) { goto fail1; } if (!gdGetByte (&im->blue[i], in)) { goto fail1; } if (gd2xFlag) { if (!gdGetByte (&im->alpha[i], in)) { goto fail1; } } } for (i = 0; (i < im->colorsTotal); i++) { im->open[i] = 0; }; return TRUE; fail1: return FALSE; }
Description: In the GD Graphics Library (aka LibGD) through 2.2.5, there is a heap-based buffer over-read in tiffWriter in gd_tiff.c. NOTE: the vendor says ""In my opinion this issue should not have a CVE, since the GD and GD2 formats are documented to be 'obsolete, and should only be used for development and testing purposes.'
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void snd_timer_user_ccallback(struct snd_timer_instance *timeri, int event, struct timespec *tstamp, unsigned long resolution) { struct snd_timer_user *tu = timeri->callback_data; struct snd_timer_tread r1; unsigned long flags; if (event >= SNDRV_TIMER_EVENT_START && event <= SNDRV_TIMER_EVENT_PAUSE) tu->tstamp = *tstamp; if ((tu->filter & (1 << event)) == 0 || !tu->tread) return; r1.event = event; r1.tstamp = *tstamp; r1.val = resolution; spin_lock_irqsave(&tu->qlock, flags); snd_timer_user_append_to_tqueue(tu, &r1); spin_unlock_irqrestore(&tu->qlock, flags); kill_fasync(&tu->fasync, SIGIO, POLL_IN); wake_up(&tu->qchange_sleep); }
Description: sound/core/timer.c in the Linux kernel through 4.6 does not initialize certain r1 data structures, which allows local users to obtain sensitive information from kernel stack memory via crafted use of the ALSA timer interface, related to the (1) snd_timer_user_ccallback and (2) snd_timer_user_tinterrupt functions.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static Jsi_RC jsi_ArrayIndexSubCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,Jsi_Value **ret, Jsi_Func *funcPtr, int op) { int istart = 0, n, i = 0, dir=1, idx=-1; Jsi_Value *seq = Jsi_ValueArrayIndex(interp, args, 0), *start = Jsi_ValueArrayIndex(interp, args, 1); Jsi_Obj *obj = _this->d.obj; if (_this->vt != JSI_VT_OBJECT || !Jsi_ObjIsArray(interp, _this->d.obj)) return Jsi_LogError(""expected array object""); if (!seq) { goto bail; } n = jsi_SizeOfArray(interp, obj);     if (n == 0) { goto bail; } Jsi_Number nstart; if (op == 2) { istart = n-1; } if (start && Jsi_GetNumberFromValue(interp,start, &nstart)==JSI_OK) { istart = (int)nstart; if (istart > n) goto bail; if (istart < 0) istart = (n+istart); if (istart<0) goto bail; } if (op == 2) { istart = n-1; dir = -1; } Jsi_ObjListifyArray(interp, obj); for (i = istart; ; i+=dir) { if ((dir>0 && i>=n) || (dir<0 && i<0) || i>=(int)obj->arrCnt) break; if (obj->arr[i] && Jsi_ValueCmp(interp, obj->arr[i], seq, JSI_CMP_EXACT)==0) { idx = i; break; } } bail: if (op == 3) Jsi_ValueMakeBool(interp, ret, (idx!=-1)); else Jsi_ValueMakeNumber(interp, ret, idx); return JSI_OK; }
Description: Jsish v3.5.0 was discovered to contain a heap buffer overflow via jsi_ArraySliceCmd in src/jsiArray.c. This vulnerability can lead to a Denial of Service (DoS).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: PJ_DEF(pj_status_t) pjmedia_vid_conf_disconnect_port( pjmedia_vid_conf *vid_conf, unsigned src_slot, unsigned sink_slot) { vconf_port *src_port, *dst_port; unsigned i, j; PJ_ASSERT_RETURN(vid_conf && src_slot<vid_conf->opt.max_slot_cnt &&  sink_slot<vid_conf->opt.max_slot_cnt, PJ_EINVAL); pj_mutex_lock(vid_conf->mutex); src_port = vid_conf->ports[src_slot]; dst_port = vid_conf->ports[sink_slot]; if (!src_port || !dst_port) { pj_mutex_unlock(vid_conf->mutex); return PJ_EINVAL; } for (i=0; i<src_port->listener_cnt; ++i) { if (src_port->listener_slots[i] == sink_slot) break; } for (j=0; j<dst_port->transmitter_cnt; ++j) { if (dst_port->transmitter_slots[j] == src_slot) break; } if (i != src_port->listener_cnt && j != dst_port->transmitter_cnt) { unsigned k; pj_assert(src_port->listener_cnt > 0 &&  src_port->listener_cnt < vid_conf->opt.max_slot_cnt); pj_assert(dst_port->transmitter_cnt > 0 &&  dst_port->transmitter_cnt < vid_conf->opt.max_slot_cnt); for (k=0; k<dst_port->transmitter_cnt; ++k) cleanup_render_state(dst_port, k); pj_array_erase(src_port->listener_slots, sizeof(unsigned),  src_port->listener_cnt, i); pj_array_erase(dst_port->transmitter_slots, sizeof(unsigned),  dst_port->transmitter_cnt, j); --src_port->listener_cnt; --dst_port->transmitter_cnt; update_render_state(vid_conf, dst_port); --vid_conf->connect_cnt; if (AUTO_STOP_CLOCK && vid_conf->connect_cnt == 0) { pj_status_t status; status = pjmedia_clock_stop(vid_conf->clock); if (status != PJ_SUCCESS) { PJ_PERROR(4, (THIS_FILE, status, ""Failed to stop clock"")); return status; } } PJ_LOG(4,(THIS_FILE, ""Port %d (%.*s) stop transmitting to port %d (%.*s)"", src_slot, (int)src_port->name.slen, src_port->name.ptr, sink_slot, (int)dst_port->name.slen, dst_port->name.ptr)); } pj_mutex_unlock(vid_conf->mutex); return PJ_SUCCESS; }
Description: PJSIP is a free and open source multimedia communication library written in the C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In various parts of PJSIP, when error/failure occurs, it is found that the function returns without releasing the currently held locks. This could result in a system deadlock, which cause a denial of service for the users. No release has yet been made which contains the linked fix commit. All versions up to an including 2.11.1 are affected. Users may need to manually apply the patch.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int print_actuals_and_locals(Dwarf_Debug dbg, Dwarf_Line_Context line_context, Dwarf_Unsigned bogus_bytes_count, Dwarf_Small *bogus_bytes_ptr, Dwarf_Small *orig_line_ptr, Dwarf_Small *line_ptr, Dwarf_Small *section_start, Dwarf_Small *line_ptr_actuals, Dwarf_Small *line_ptr_end, Dwarf_Half   address_size, int *        err_count_out, Dwarf_Error *error) { int res = 0; dwarfstring m8; Dwarf_Unsigned offset = 0; dwarfstring_constructor(&m8); if (bogus_bytes_count > 0) { Dwarf_Unsigned wcount = bogus_bytes_count; Dwarf_Unsigned boffset = bogus_bytes_ptr - section_start; dwarfstring_append_printf_u(&m8, ""*** DWARF CHECK: the line table prologue  header_length "" "" is %"" DW_PR_DUu "" too high, we pretend it is smaller."", wcount); dwarfstring_append_printf_u(&m8, ""Section offset: 0x%"" DW_PR_XZEROS DW_PR_DUx, boffset); dwarfstring_append_printf_u(&m8, "" (%"" DW_PR_DUu "") ***\n"", boffset); *err_count_out += 1; } offset = line_ptr - section_start; dwarfstring_append_printf_u(&m8, ""  statement prog offset in section: 0x%"" DW_PR_XZEROS DW_PR_DUx, offset); dwarfstring_append_printf_u(&m8, "" (%"" DW_PR_DUu "")\n"", offset); _dwarf_printf(dbg,dwarfstring_string(&m8)); dwarfstring_reset(&m8); { Dwarf_Bool doaddrs = false; Dwarf_Bool dolines = true; if (!line_ptr_actuals) { Dwarf_Bool is_single_table = true; Dwarf_Bool is_actuals_table = false; print_line_header(dbg, is_single_table, is_actuals_table); res = read_line_table_program(dbg, line_ptr, line_ptr_end, orig_line_ptr, section_start, line_context, address_size, doaddrs, dolines, is_single_table, is_actuals_table, error, err_count_out); if (res != DW_DLV_OK) { dwarfstring_destructor(&m8); dwarf_srclines_dealloc_b(line_context); return res; } } else { Dwarf_Bool is_single_table = false; Dwarf_Bool is_actuals_table = false; if (line_context->lc_version_number != EXPERIMENTAL_LINE_TABLES_VERSION) { dwarf_srclines_dealloc_b(line_context); dwarfstring_destructor(&m8); _dwarf_error(dbg, error, DW_DLE_VERSION_STAMP_ERROR); return (DW_DLV_ERROR); } print_line_header(dbg, is_single_table, is_actuals_table); res = read_line_table_program(dbg, line_ptr, line_ptr_actuals, orig_line_ptr, section_start, line_context, address_size, doaddrs, dolines, is_single_table, is_actuals_table, error,err_count_out); if (res != DW_DLV_OK) { dwarfstring_destructor(&m8); dwarf_srclines_dealloc_b(line_context); return res; } if (line_context->lc_actuals_table_offset > 0) { is_actuals_table = true; print_line_header(dbg, is_single_table, is_actuals_table); res = read_line_table_program(dbg, line_ptr_actuals, line_ptr_end, orig_line_ptr, section_start, line_context, address_size, doaddrs, dolines, is_single_table, is_actuals_table, error, err_count_out); if (res != DW_DLV_OK) { dwarfstring_destructor(&m8); dwarf_srclines_dealloc_b(line_context); return res; } } } } dwarfstring_destructor(&m8); dwarf_srclines_dealloc_b(line_context); return DW_DLV_OK; }
Description: libdwarf before 20201201 allows a dwarf_print_lines.c NULL pointer dereference and application crash via a DWARF5 line-table header that has an invalid FORM for a pathname.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void RGWCivetWeb::init_env(CephContext *cct) { env.init(cct); const struct mg_request_info* info = mg_get_request_info(conn); if (! info) { return; } for (int i = 0; i < info->num_headers; i++) { const struct mg_request_info::mg_header* header = &info->http_headers[i]; const boost::string_ref name(header->name); const auto& value = header->value; if (boost::algorithm::iequals(name, ""content-length"")) { env.set(""CONTENT_LENGTH"", value); continue; } if (boost::algorithm::iequals(name, ""content-type"")) { env.set(""CONTENT_TYPE"", value); continue; } if (boost::algorithm::iequals(name, ""connection"")) { explicit_keepalive = boost::algorithm::iequals(value, ""keep-alive""); explicit_conn_close = boost::algorithm::iequals(value, ""close""); } static const boost::string_ref HTTP_{""HTTP_""}; char buf[name.size() + HTTP_.size() + 1]; auto dest = std::copy(std::begin(HTTP_), std::end(HTTP_), buf); for (auto src = name.begin(); src != name.end(); ++src, ++dest) { if (*src == '-') { *dest = '_'; } else { *dest = std::toupper(*src); } } *dest = '\0'; env.set(buf, value); } env.set(""REMOTE_ADDR"", info->remote_addr); env.set(""REQUEST_METHOD"", info->request_method); env.set(""HTTP_VERSION"", info->http_version); env.set(""REQUEST_URI"", info->request_uri);   env.set(""SCRIPT_URI"", info->uri);  if (info->query_string) { env.set(""QUERY_STRING"", info->query_string); } if (info->remote_user) { env.set(""REMOTE_USER"", info->remote_user); } if (port <= 0) lderr(cct) << ""init_env: bug: invalid port number"" << dendl; char port_buf[16]; snprintf(port_buf, sizeof(port_buf), ""%d"", port); env.set(""SERVER_PORT"", port_buf); if (info->is_ssl) { env.set(""SERVER_PORT_SECURE"", port_buf); } }
Description: In Ceph before 12.2.3 and 13.x through 13.0.1, the rgw_civetweb.cc RGWCivetWeb::init_env function in radosgw doesn't handle malformed HTTP headers properly, allowing for denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static Type convertStructTypePacked(spirv::StructType type, LLVMTypeConverter &converter) { auto elementsVector = llvm::to_vector<8>( llvm::map_range(type.getElementTypes(), [&](Type elementType) { return converter.convertType(elementType); })); return LLVM::LLVMStructType::getLiteral(type.getContext(), elementsVector, true); }
Description: llvm-project commit a0138390 was discovered to contain a segmentation fault via the component mlir::Type::isa<mlir::LLVM::LLVMVoidType.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Status ConvBackpropComputeDimensionsV2( StringPiece label, int num_spatial_dims, const TensorShape& input_shape, const TensorShape& filter_shape, const TensorShape& out_backprop_shape, const gtl::ArraySlice<int32>& dilations, const std::vector<int32>& strides, Padding padding, absl::Span<const int64> explicit_paddings, TensorFormat data_format, ConvBackpropDimensions* dims) { const int num_dims = num_spatial_dims + 2; if (input_shape.dims() != num_dims) { return errors::InvalidArgument(label, "": input must be "", num_dims, ""-dimensional""); } if (filter_shape.dims() != num_dims) { return errors::InvalidArgument(label, "": filter must be "", num_dims, ""-dimensional""); } if (out_backprop_shape.dims() != num_dims) { return errors::InvalidArgument(label, "": out_backprop must be "", num_dims, ""-dimensional""); } int batch_dim = GetTensorBatchDimIndex(num_dims, data_format); dims->batch_size = input_shape.dim_size(batch_dim); if (dims->batch_size != out_backprop_shape.dim_size(batch_dim)) { return errors::InvalidArgument( label, "": input and out_backprop must have the same batch size."", "" Input batch: "", dims->batch_size, "", outbackprop batch: "", out_backprop_shape.dim_size(batch_dim), "", batch_dim: "", batch_dim); } int feature_dim = GetTensorFeatureDimIndex(num_dims, data_format); dims->in_depth = input_shape.dim_size(feature_dim); VLOG(2) << ""input vs filter_in depth "" << dims->in_depth << "" "" << filter_shape.dim_size(num_dims - 2); if (dims->in_depth % filter_shape.dim_size(num_dims - 2)) { return errors::InvalidArgument( label, "": input depth must be evenly divisible by filter depth""); } dims->out_depth = filter_shape.dim_size(num_dims - 1); if (dims->out_depth != out_backprop_shape.dim_size(feature_dim)) { return errors::InvalidArgument( label, "": filter and out_backprop must have the same out_depth""); } dims->spatial_dims.resize(num_spatial_dims); for (int i = 0; i < num_spatial_dims; ++i) { int image_dim = GetTensorSpatialDimIndex(num_dims, data_format, i); int64 padding_before = -1, padding_after = -1; if (padding == EXPLICIT) { padding_before = explicit_paddings[2 * image_dim]; padding_after = explicit_paddings[2 * image_dim + 1]; } TF_RETURN_IF_ERROR(ConvBackpropExtractAndVerifyDimension( label, input_shape, filter_shape, out_backprop_shape, dilations, strides, padding, padding_before, padding_after, image_dim, i, &dims->spatial_dims[i])); } return Status::OK(); }
Description: TensorFlow is an end-to-end open source platform for machine learning. An attacker can trigger a division by 0 in `tf.raw_ops.Conv2DBackpropFilter`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/496c2630e51c1a478f095b084329acedb253db6b/tensorflow/core/kernels/conv_grad_shape_utils.cc#L130) does a modulus operation where the divisor is controlled by the caller. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int ImagingFliDecode(Imaging im, ImagingCodecState state, UINT8 *buf, Py_ssize_t bytes) { UINT8 *ptr; int framesize; int c, chunks, advance; int l, lines; int i, j, x = 0, y, ymax; if (bytes < 4) { return 0; } ptr = buf; framesize = I32(ptr); if (framesize < I32(ptr)) { return 0; } if (bytes < 8) { state->errcode = IMAGING_CODEC_OVERRUN; return -1; } if (I16(ptr + 4) != 0xF1FA) { state->errcode = IMAGING_CODEC_UNKNOWN; return -1; } chunks = I16(ptr + 6); ptr += 16; bytes -= 16; for (c = 0; c < chunks; c++) { UINT8 *data; if (bytes < 10) { state->errcode = IMAGING_CODEC_OVERRUN; return -1; } data = ptr + 6; switch (I16(ptr + 4)) { case 4: case 11: break;  case 7: lines = I16(data); data += 2; for (l = y = 0; l < lines && y < state->ysize; l++, y++) { UINT8 *local_buf = (UINT8 *)im->image[y]; int p, packets; ERR_IF_DATA_OOB(2) packets = I16(data); data += 2; while (packets & 0x8000) { if (packets & 0x4000) { y += 65536 - packets;  if (y >= state->ysize) { state->errcode = IMAGING_CODEC_OVERRUN; return -1; } local_buf = (UINT8 *)im->image[y]; } else { local_buf[state->xsize - 1] = (UINT8)packets; } ERR_IF_DATA_OOB(2) packets = I16(data); data += 2; } for (p = x = 0; p < packets; p++) { ERR_IF_DATA_OOB(2) x += data[0];  if (data[1] >= 128) { ERR_IF_DATA_OOB(4) i = 256 - data[1];  if (x + i + i > state->xsize) { break; } for (j = 0; j < i; j++) { local_buf[x++] = data[2]; local_buf[x++] = data[3]; } data += 2 + 2; } else { i = 2 * (int)data[1];  if (x + i > state->xsize) { break; } ERR_IF_DATA_OOB(2 + i) memcpy(local_buf + x, data + 2, i); data += 2 + i; x += i; } } if (p < packets) { break;  } } if (l < lines) { state->errcode = IMAGING_CODEC_OVERRUN; return -1; } break; case 12: y = I16(data); ymax = y + I16(data + 2); data += 4; for (; y < ymax && y < state->ysize; y++) { UINT8 *out = (UINT8 *)im->image[y]; ERR_IF_DATA_OOB(1) int p, packets = *data++; for (p = x = 0; p < packets; p++, x += i) { ERR_IF_DATA_OOB(2) x += data[0];  if (data[1] & 0x80) { i = 256 - data[1];  if (x + i > state->xsize) { break; } ERR_IF_DATA_OOB(3) memset(out + x, data[2], i); data += 3; } else { i = data[1];  if (x + i > state->xsize) { break; } ERR_IF_DATA_OOB(2 + i) memcpy(out + x, data + 2, i); data += i + 2; } } if (p < packets) { break;  } } if (y < ymax) { state->errcode = IMAGING_CODEC_OVERRUN; return -1; } break; case 13: for (y = 0; y < state->ysize; y++) { memset(im->image[y], 0, state->xsize); } break; case 15: for (y = 0; y < state->ysize; y++) { UINT8 *out = (UINT8 *)im->image[y]; data += 1;  for (x = 0; x < state->xsize; x += i) { ERR_IF_DATA_OOB(2) if (data[0] & 0x80) { i = 256 - data[0]; if (x + i > state->xsize) { break;  } ERR_IF_DATA_OOB(i + 1) memcpy(out + x, data + 1, i); data += i + 1; } else { i = data[0]; if (x + i > state->xsize) { break;  } memset(out + x, data[1], i); data += 2; } } if (x != state->xsize) { state->errcode = IMAGING_CODEC_OVERRUN; return -1; } } break; case 16: if (state->xsize > bytes / state->ysize) { return ptr - buf;  } for (y = 0; y < state->ysize; y++) { UINT8 *local_buf = (UINT8 *)im->image[y]; memcpy(local_buf, data, state->xsize); data += state->xsize; } break; case 18: break;  default: state->errcode = IMAGING_CODEC_UNKNOWN; return -1; } advance = I32(ptr); if (advance < 0 || advance > bytes) { state->errcode = IMAGING_CODEC_OVERRUN; return -1; } ptr += advance; bytes -= advance; } return -1;  }
Description: An issue was discovered in Pillow before 8.2.0. For FLI data, FliDecode did not properly check that the block advance was non-zero, potentially leading to an infinite loop on load.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Status Compute(OpKernelContext* context, AsyncOpKernel::DoneCallback done) { const Tensor& data_t = context->input(0); const Tensor& batch_index_t = context->input(1); if (batch_index_t.shape().dim_size(0) > data_t.shape().dim_size(0)) { return errors::InvalidArgument( ""Wrong shape for index tensor. Expected 0th dimension size to be no "" ""greater than "", data_t.shape().dim_size(0), ""; Got: "", batch_index_t.shape().dim_size(0), "".""); } if (batch_index_t.shape().dim_size(1) != 3) { return errors::InvalidArgument( ""Wrong shape for index tensor. Expected 1st dimension size to be 3 ; "" ""Got: "", batch_index_t.shape().dim_size(1), "".""); } const int64_t batch_key = context->input(2).scalar<int64_t>()(); const bool nonempty_input = batch_index_t.dim_size(0) > 0; std::vector<int64_t> sizes; std::vector<int64_t> batch_keys; std::vector<Tensor> split_inputs; if (nonempty_input) { auto batch_indices = batch_index_t.shaped<int64_t, 2>({batch_index_t.dim_size(0), 3}); for (int i = 0; i < batch_index_t.dim_size(0); ++i) { sizes.push_back(batch_indices(i, 2) - batch_indices(i, 1)); batch_keys.push_back(batch_indices(i, 0)); } TF_RETURN_IF_ERROR(Split(context, data_t, sizes, &split_inputs)); } std::vector<AsyncOpKernel::DoneCallback> done_callbacks_to_call; Status status = [&]() -> Status { mutex_lock ml(mu_); auto tensor_it = waiting_tensors_.find(batch_key); if (tensor_it != waiting_tensors_.end()) { context->set_output(0, tensor_it->second.tensor); waiting_tensors_.erase(tensor_it); done_callbacks_to_call.push_back(done); return OkStatus(); } const uint64 deadline_micros = Env::Default()->NowMicros() + timeout_micros_; if (!waiting_callbacks_ .emplace(batch_key, WaitingCallback{deadline_micros, context, done}) .second) { return errors::AlreadyExists( ""Multiple session runs with the same batch key.""); } if (nonempty_input) { for (size_t i = 0; i < batch_keys.size(); ++i) { auto runs_it = waiting_callbacks_.find(batch_keys[i]); if (runs_it != waiting_callbacks_.end()) { runs_it->second.context->set_output(0, split_inputs[i]); done_callbacks_to_call.push_back(runs_it->second.done); waiting_callbacks_.erase(runs_it); } else { if (!waiting_tensors_ .emplace(batch_keys[i], WaitingTensor{deadline_micros, split_inputs[i]}) .second) { return errors::AlreadyExists( ""Multiple tensors returned for same batch key.""); } } } } return OkStatus(); }(); for (const AsyncOpKernel::DoneCallback& done_callback : done_callbacks_to_call) { done_callback(); } return status; }
Description: TensorFlow is an open source platform for machine learning. When `Unbatch` receives a nonscalar input `id`, it gives a `CHECK` fail that can trigger a denial of service attack. We have patched the issue in GitHub commit 4419d10d576adefa36b0e0a9425d2569f7c0189f. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int printer_open(struct inode *inode, struct file *fd) { struct printer_dev*dev; unsigned longflags; intret = -EBUSY; dev = container_of(inode->i_cdev, struct printer_dev, printer_cdev); spin_lock_irqsave(&dev->lock, flags); if (dev->interface < 0) { spin_unlock_irqrestore(&dev->lock, flags); return -ENODEV; } if (!dev->printer_cdev_open) { dev->printer_cdev_open = 1; fd->private_data = dev; ret = 0; dev->printer_status |= PRINTER_SELECTED; } spin_unlock_irqrestore(&dev->lock, flags); DBG(dev, ""printer_open returned %x\n"", ret); return ret; }
Description: A vulnerability was found in the Linux kernel, where accessing a deallocated instance in printer_ioctl() printer_ioctl() tries to access of a printer_dev instance. However, use-after-free arises because it had been freed by gprinter_free().
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: GF_Err tenc_dump(GF_Box *a, FILE * trace) { GF_TrackEncryptionBox *ptr = (GF_TrackEncryptionBox*) a; if (!a) return GF_BAD_PARAM; gf_isom_box_dump_start(a, ""TrackEncryptionBox"", trace); fprintf(trace, ""isEncrypted=\""%d\"""", ptr->isProtected); if (ptr->Per_Sample_IV_Size) fprintf(trace, "" IV_size=\""%d\"" KID=\"""", ptr->Per_Sample_IV_Size); else { fprintf(trace, "" constant_IV_size=\""%d\"" constant_IV=\"""", ptr->constant_IV_size); dump_data_hex(trace, (char *) ptr->constant_IV, ptr->constant_IV_size); fprintf(trace, ""\""  KID=\""""); } dump_data_hex(trace, (char *) ptr->KID, 16); if (ptr->version)  fprintf(trace, ""\"" crypt_byte_block=\""%d\"" skip_byte_block=\""%d"", ptr->crypt_byte_block, ptr->skip_byte_block); fprintf(trace, ""\"">\n""); gf_isom_box_dump_done(""TrackEncryptionBox"", a, trace); return GF_OK; }
Description: An issue was discovered in MP4Box in GPAC 0.7.1. The function urn_Read in isomedia/box_code_base.c has a heap-based buffer over-read.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int toneport_init(struct usb_line6 *line6, const struct usb_device_id *id) { int err; struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6; toneport->type = id->driver_info; INIT_DELAYED_WORK(&toneport->pcm_work, toneport_start_pcm); line6->disconnect = line6_toneport_disconnect; err = line6_init_pcm(line6, &toneport_pcm_properties); if (err < 0) return err; err = snd_ctl_add(line6->card, snd_ctl_new1(&toneport_control_monitor, line6->line6pcm)); if (err < 0) return err; if (toneport_has_source_select(toneport)) { err = snd_ctl_add(line6->card, snd_ctl_new1(&toneport_control_source, line6->line6pcm)); if (err < 0) return err; } line6_read_serial_number(line6, &toneport->serial_number); line6_read_data(line6, 0x80c2, &toneport->firmware_version, 1); if (toneport_has_led(toneport)) { err = toneport_init_leds(toneport); if (err < 0) return err; } err = toneport_setup(toneport); if (err) return err; return snd_card_register(line6->card); }
Description: An issue was discovered in the Linux kernel before 5.1.8. There is a NULL pointer dereference caused by a malicious USB device in the sound/usb/line6/driver.c driver.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int XSetStandardProperties ( Display *dpy, Window w, _Xconst char *name, _Xconst char *icon_string, Pixmap icon_pixmap, char **argv, int argc, XSizeHints *hints) { XWMHints phints; phints.flags = 0; if (name != NULL) XStoreName (dpy, w, name); if (icon_string != NULL) { XChangeProperty (dpy, w, XA_WM_ICON_NAME, XA_STRING, 8, PropModeReplace, (_Xconst unsigned char *)icon_string, (int)safestrlen(icon_string)); } if (icon_pixmap != None) { phints.icon_pixmap = icon_pixmap; phints.flags |= IconPixmapHint; } if (argv != NULL) XSetCommand(dpy, w, argv, argc); if (hints != NULL) XSetNormalHints(dpy, w, hints); if (phints.flags != 0) XSetWMHints(dpy, w, &phints); return 1; }
Description: LookupCol.c in X.Org X through X11R7.7 and libX11 before 1.7.1 might allow remote attackers to execute arbitrary code. The libX11 XLookupColor request (intended for server-side color lookup) contains a flaw allowing a client to send color-name requests with a name longer than the maximum size allowed by the protocol (and also longer than the maximum packet size for normal-sized packets). The user-controlled data exceeding the maximum size is then interpreted by the server as additional X protocol requests and executed, e.g., to disable X server authorization completely. For example, if the victim encounters malicious terminal control sequences for color codes, then the attacker may be able to take full control of the running graphical session.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void arch_do_multicall_call(struct mc_state *state) { if ( !is_pv_32bit_vcpu(current) ) { struct multicall_entry *call = &state->call; if ( (call->op < ARRAY_SIZE(pv_hypercall_table)) && pv_hypercall_table[call->op].native ) call->result = pv_hypercall_table[call->op].native( call->args[0], call->args[1], call->args[2], call->args[3], call->args[4], call->args[5]); else call->result = -ENOSYS; } #ifdef CONFIG_COMPAT else { struct compat_multicall_entry *call = &state->compat_call; if ( (call->op < ARRAY_SIZE(pv_hypercall_table)) && pv_hypercall_table[call->op].compat ) call->result = pv_hypercall_table[call->op].compat( call->args[0], call->args[1], call->args[2], call->args[3], call->args[4], call->args[5]); else call->result = -ENOSYS; } #endif }
Description: Xen through 4.8.x on 64-bit platforms mishandles page tables after an IRET hypercall, which might allow PV guest OS users to execute arbitrary code on the host OS, aka XSA-213.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int mqtt_conn_del(struct mqtt_conn *conn) { mk_event_del(conn->ctx->evl, &conn->event); close(conn->fd); flb_free(conn); return 0; }
Description: An issue was discovered in the MQTT input plugin in Fluent Bit through 1.0.4. When this plugin acts as an MQTT broker (server), it mishandles incoming network messages. After processing a crafted packet, the plugin's mqtt_packet_drop function (in /plugins/in_mqtt/mqtt_prot.c) executes the memmove() function with a negative size parameter. That leads to a crash of the whole Fluent Bit server via a SIGSEGV signal.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static s32 gf_avc_read_pps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 nal_hdr) { s32 pps_id; AVC_PPS *pps; gf_bs_enable_emulation_byte_removal(bs, GF_TRUE); if (!nal_hdr) { gf_bs_read_int_log(bs, 1, ""forbidden_zero_bit""); gf_bs_read_int_log(bs, 2, ""nal_ref_idc""); gf_bs_read_int_log(bs, 5, ""nal_unit_type""); } pps_id = gf_bs_read_ue_log(bs, ""pps_id""); if (pps_id >= 255) { return -1; } pps = &avc->pps[pps_id]; pps->id = pps_id; if (!pps->status) pps->status = 1; pps->sps_id = gf_bs_read_ue_log(bs, ""sps_id""); if (pps->sps_id >= 32) { pps->sps_id = 0; return -1; } if (!avc->sps[pps->sps_id].state && !avc->sps[pps->sps_id + GF_SVC_SSPS_ID_SHIFT].state) { return -1; } avc->pps_active_idx = pps->id;  avc->sps_active_idx = pps->sps_id;  pps->entropy_coding_mode_flag = gf_bs_read_int_log(bs, 1, ""entropy_coding_mode_flag""); pps->pic_order_present = gf_bs_read_int_log(bs, 1, ""pic_order_present""); pps->slice_group_count = gf_bs_read_ue_log(bs, ""slice_group_count_minus1"") + 1; if (pps->slice_group_count > 1) { u32 iGroup; pps->mb_slice_group_map_type = gf_bs_read_ue_log(bs, ""mb_slice_group_map_type""); if (pps->mb_slice_group_map_type == 0) { for (iGroup = 0; iGroup <= pps->slice_group_count - 1; iGroup++) gf_bs_read_ue_log_idx(bs, ""run_length_minus1"", iGroup); } else if (pps->mb_slice_group_map_type == 2) { for (iGroup = 0; iGroup < pps->slice_group_count - 1; iGroup++) { gf_bs_read_ue_log_idx(bs, ""top_left"", iGroup); gf_bs_read_ue_log_idx(bs, ""bottom_right"", iGroup); } } else if (pps->mb_slice_group_map_type == 3 || pps->mb_slice_group_map_type == 4 || pps->mb_slice_group_map_type == 5) { gf_bs_read_int_log(bs, 1, ""slice_group_change_direction_flag""); gf_bs_read_ue_log(bs, ""slice_group_change_rate_minus1""); } else if (pps->mb_slice_group_map_type == 6) { u32 i; pps->pic_size_in_map_units_minus1 = gf_bs_read_ue_log(bs, ""pic_size_in_map_units_minus1""); for (i = 0; i <= pps->pic_size_in_map_units_minus1; i++) { gf_bs_read_int_log_idx(bs, (u32)ceil(log(pps->slice_group_count) / log(2)), ""slice_group_id"", i); } } } pps->num_ref_idx_l0_default_active_minus1 = gf_bs_read_ue_log(bs, ""num_ref_idx_l0_default_active_minus1""); pps->num_ref_idx_l1_default_active_minus1 = gf_bs_read_ue_log(bs, ""num_ref_idx_l1_default_active_minus1""); pps->weighted_pred_flag = gf_bs_read_int_log(bs, 1, ""weighted_pred_flag""); gf_bs_read_int_log(bs, 2, ""weighted_bipred_idc""); gf_bs_read_se_log(bs, ""init_qp_minus26""); gf_bs_read_se_log(bs, ""init_qs_minus26""); gf_bs_read_se_log(bs, ""chroma_qp_index_offset""); pps->deblocking_filter_control_present_flag = gf_bs_read_int_log(bs, 1, ""deblocking_filter_control_present_flag""); gf_bs_read_int_log(bs, 1, ""constrained_intra_pred""); pps->redundant_pic_cnt_present = gf_bs_read_int_log(bs, 1, ""redundant_pic_cnt_present""); return pps_id; }
Description: There is a integer overflow in media_tools/av_parsers.c in the hevc_parse_slice_segment function in GPAC 1.0.1 which results in a crash.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void Encode(Key, const Value& value) { AddToSummary(Key::key(), Key::Encode(value).size()); }
Description: There exists an vulnerability causing an abort() to be called in gRPC. 
The following headers cause gRPC's C++ implementation to abort() when called via http2:

te: x (x != trailers)

:scheme: x (x != http, https)

grpclb_client_stats: x (x == anything)

On top of sending one of those headers, a later header must be sent that gets the total header size past 8KB. We recommend upgrading past git commit 2485fa94bd8a723e5c977d55a3ce10b301b437f8 or v1.53 and above.


 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int stbi__shiftsigned(int v, int shift, int bits) { static unsigned int mul_table[9] = { 0, 0xff, 0x55, 0x49, 0x11, 0x21, 0x41, 0x81, 0x01, }; static unsigned int shift_table[9] = { 0, 0,0,1,0,2,4,6,0, }; if (shift < 0) v <<= -shift; else v >>= shift; STBI_ASSERT(v >= 0 && v < 256); v >>= (8-bits); if (bits < 0 || bits > 8) return (0);   return (int) ((unsigned) v * mul_table[bits]) >> shift_table[bits]; }
Description: stb_image.h (aka the stb image loader) 2.23, as used in libsixel and other products, has an assertion failure in stbi__shiftsigned.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static enum XML_Error processInternalEntity(XML_Parser parser, ENTITY *entity, XML_Bool betweenDecl) { const char *textStart, *textEnd; const char *next; enum XML_Error result; OPEN_INTERNAL_ENTITY *openEntity; if (parser->m_freeInternalEntities) { openEntity = parser->m_freeInternalEntities; parser->m_freeInternalEntities = openEntity->next; } else { openEntity = (OPEN_INTERNAL_ENTITY *)MALLOC(parser, sizeof(OPEN_INTERNAL_ENTITY)); if (! openEntity) return XML_ERROR_NO_MEMORY; } entity->open = XML_TRUE; entity->processed = 0; openEntity->next = parser->m_openInternalEntities; parser->m_openInternalEntities = openEntity; openEntity->entity = entity; openEntity->startTagLevel = parser->m_tagLevel; openEntity->betweenDecl = betweenDecl; openEntity->internalEventPtr = NULL; openEntity->internalEventEndPtr = NULL; textStart = (char *)entity->textPtr; textEnd = (char *)(entity->textPtr + entity->textLen); next = textStart; #ifdef XML_DTD if (entity->is_param) { int tok = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next); result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd, tok, next, &next, XML_FALSE); } else #endif  result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding, textStart, textEnd, &next, XML_FALSE); if (result == XML_ERROR_NONE) { if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) { entity->processed = (int)(next - textStart); parser->m_processor = internalEntityProcessor; } else { entity->open = XML_FALSE; parser->m_openInternalEntities = openEntity->next; openEntity->next = parser->m_freeInternalEntities; parser->m_freeInternalEntities = openEntity; } } return result; }
Description: In libexpat before 2.2.8, crafted XML input could fool the parser into changing from DTD parsing to document parsing too early; a consecutive call to XML_GetCurrentLineNumber (or XML_GetCurrentColumnNumber) then resulted in a heap-based buffer over-read.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void jsP_dumplist(js_State *J, js_Ast *prog) { minify = 0; if (prog->type == AST_LIST) sblock(0, prog); else snode(0, prog); nl(); }
Description: compile in regexp.c in Artifex MuJS through 1.2.0 results in stack consumption because of unlimited recursion, a different issue than CVE-2019-11413.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: GF_Err abst_Read(GF_Box *s, GF_BitStream *bs) { GF_AdobeBootstrapInfoBox *ptr = (GF_AdobeBootstrapInfoBox *)s; int i; u32 tmp_strsize; char *tmp_str; GF_Err e; ptr->bootstrapinfo_version = gf_bs_read_u32(bs); ptr->profile = gf_bs_read_int(bs, 2); ptr->live = gf_bs_read_int(bs, 1); ptr->update = gf_bs_read_int(bs, 1); ptr->reserved = gf_bs_read_int(bs, 4); ptr->time_scale = gf_bs_read_u32(bs); ptr->current_media_time = gf_bs_read_u64(bs); ptr->smpte_time_code_offset = gf_bs_read_u64(bs); i=0; if (ptr->size<8) return GF_ISOM_INVALID_FILE; tmp_strsize=(u32)ptr->size-8; tmp_str = gf_malloc(sizeof(char)*tmp_strsize); while (tmp_strsize) { tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) ptr->movie_identifier = gf_strdup(tmp_str); ptr->server_entry_count = gf_bs_read_u8(bs); for (i=0; i<ptr->server_entry_count; i++) { int j=0; tmp_strsize=(u32)ptr->size-8; while (tmp_strsize) { tmp_str[j] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[j]) break; j++; } gf_list_insert(ptr->server_entry_table, gf_strdup(tmp_str), i); } ptr->quality_entry_count = gf_bs_read_u8(bs); for (i=0; i<ptr->quality_entry_count; i++) { int j=0; tmp_strsize=(u32)ptr->size-8; while (tmp_strsize) { tmp_str[j] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[j]) break; j++; } gf_list_insert(ptr->quality_entry_table, gf_strdup(tmp_str), i); } i=0; tmp_strsize=(u32)ptr->size-8; while (tmp_strsize) { tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) ptr->drm_data = gf_strdup(tmp_str); i=0; tmp_strsize=(u32)ptr->size-8; while (tmp_strsize) { tmp_str[i] = gf_bs_read_u8(bs); tmp_strsize--; if (!tmp_str[i]) break; i++; } if (i) ptr->meta_data = gf_strdup(tmp_str); ptr->segment_run_table_count = gf_bs_read_u8(bs); for (i=0; i<ptr->segment_run_table_count; i++) { GF_AdobeSegmentRunTableBox *asrt = NULL; e = gf_isom_box_parse((GF_Box **)&asrt, bs); if (e) { if (asrt) gf_isom_box_del((GF_Box*)asrt); gf_free(tmp_str); return e; } gf_list_insert(ptr->segment_run_table_entries, asrt, i); } ptr->fragment_run_table_count = gf_bs_read_u8(bs); for (i=0; i<ptr->fragment_run_table_count; i++) { GF_AdobeFragmentRunTableBox *afrt = NULL; e = gf_isom_box_parse((GF_Box **)&afrt, bs); if (e) { if (afrt) gf_isom_box_del((GF_Box*)afrt); gf_free(tmp_str); return e; } gf_list_insert(ptr->fragment_run_table_entries, afrt, i); } gf_free(tmp_str); return GF_OK; }
Description: An issue was discovered in GPAC version 0.8.0 and 0.9.0-development-20191109. There are memory leaks in metx_New in isomedia/box_code_base.c and abst_Read in isomedia/box_code_adobe.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: OMX_ERRORTYPE omx_vdec::free_input_buffer(OMX_BUFFERHEADERTYPE *bufferHdr) { unsigned int index = 0; if (bufferHdr == NULL || m_inp_mem_ptr == NULL) { return OMX_ErrorBadParameter; } index = bufferHdr - m_inp_mem_ptr; DEBUG_PRINT_LOW(""Free Input Buffer index = %d"",index); if (index < drv_ctx.ip_buf.actualcount && drv_ctx.ptr_inputbuffer) { DEBUG_PRINT_LOW(""Free Input Buffer index = %d"",index); if (drv_ctx.ptr_inputbuffer[index].pmem_fd > 0) { struct vdec_setbuffer_cmd setbuffers; setbuffers.buffer_type = VDEC_BUFFER_TYPE_INPUT; memcpy (&setbuffers.buffer,&drv_ctx.ptr_inputbuffer[index], sizeof (vdec_bufferpayload)); if (!secure_mode) { DEBUG_PRINT_LOW(""unmap the input buffer fd=%d"", drv_ctx.ptr_inputbuffer[index].pmem_fd); DEBUG_PRINT_LOW(""unmap the input buffer size=%u  address = %p"", (unsigned int)drv_ctx.ptr_inputbuffer[index].mmaped_size, drv_ctx.ptr_inputbuffer[index].bufferaddr); munmap (drv_ctx.ptr_inputbuffer[index].bufferaddr, drv_ctx.ptr_inputbuffer[index].mmaped_size); } close (drv_ctx.ptr_inputbuffer[index].pmem_fd); drv_ctx.ptr_inputbuffer[index].pmem_fd = -1; if (m_desc_buffer_ptr && m_desc_buffer_ptr[index].buf_addr) { free(m_desc_buffer_ptr[index].buf_addr); m_desc_buffer_ptr[index].buf_addr = NULL; m_desc_buffer_ptr[index].desc_data_size = 0; } #ifdef USE_ION free_ion_memory(&drv_ctx.ip_buf_ion_info[index]); #endif } } return OMX_ErrorNone; }
Description: Use-after-free vulnerability in the mm-video-v4l2 vdec component in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27890802.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int run_post_create(const char *dirname) { if (!dir_is_in_dump_location(dirname)) { error_msg(""Bad problem directory name '%s', should start with: '%s'"", dirname, g_settings_dump_location); return 400;  } if (g_settings_privatereports) { struct stat statbuf; if (lstat(dirname, &statbuf) != 0 || !S_ISDIR(statbuf.st_mode)) { error_msg(""Path '%s' isn't directory"", dirname); return 404;  } struct group *gr = getgrnam(""abrt""); if (!gr) { error_msg(""Group 'abrt' does not exist""); return 500; } if (statbuf.st_uid != 0 || !(statbuf.st_gid == 0 || statbuf.st_gid == gr->gr_gid) || statbuf.st_mode & 07) { error_msg(""Problem directory '%s' isn't owned by root:abrt or others are not restricted from access"", dirname); return 403; } struct dump_dir *dd = dd_opendir(dirname, DD_OPEN_READONLY); const bool complete = dd && problem_dump_dir_is_complete(dd); dd_close(dd); if (complete) { error_msg(""Problem directory '%s' has already been processed"", dirname); return 403; } } else if (!dump_dir_accessible_by_uid(dirname, client_uid)) { if (errno == ENOTDIR) { error_msg(""Path '%s' isn't problem directory"", dirname); return 404;  } error_msg(""Problem directory '%s' can't be accessed by user with uid %ld"", dirname, (long)client_uid); return 403;  } int child_stdout_fd; int child_pid = spawn_event_handler_child(dirname, ""post-create"", &child_stdout_fd); char *dup_of_dir = NULL; struct strbuf *cmd_output = strbuf_new(); bool child_is_post_create = 1;  read_child_output: for (;;) { char buf[250];  errno = 0; int r = safe_read(child_stdout_fd, buf, sizeof(buf) - 1); if (r <= 0) break; buf[r] = '\0'; char *raw = buf; char *newline; while ((newline = strchr(raw, '\n')) != NULL) { *newline = '\0'; strbuf_append_str(cmd_output, raw); char *msg = cmd_output->buf; log(""%s"", msg); if (child_is_post_create && prefixcmp(msg, ""DUP_OF_DIR: "") == 0 ) { free(dup_of_dir); dup_of_dir = xstrdup(msg + strlen(""DUP_OF_DIR: "")); } strbuf_clear(cmd_output); raw = newline + 1; } strbuf_append_str(cmd_output, raw); } int status = 0; if (safe_waitpid(child_pid, &status, 0) <= 0) perror_msg(""waitpid(%d)"", child_pid); if (!child_is_post_create) goto ret; if (status != 0) { if (WIFSIGNALED(status)) { log(""'post-create' on '%s' killed by signal %d"", dirname, WTERMSIG(status)); goto delete_bad_dir; } if (!dup_of_dir) { log(""'post-create' on '%s' exited with %d"", dirname, WEXITSTATUS(status)); goto delete_bad_dir; } } const char *work_dir = (dup_of_dir ? dup_of_dir : dirname); struct dump_dir *dd = dd_opendir(work_dir,  0); if (!dd) goto delete_bad_dir; char *count_str = dd_load_text_ext(dd, FILENAME_COUNT, DD_FAIL_QUIETLY_ENOENT); unsigned long count = strtoul(count_str, NULL, 10); if ((status != 0 && dup_of_dir) || count == 0) { count++; char new_count_str[sizeof(long)*3 + 2]; sprintf(new_count_str, ""%lu"", count); dd_save_text(dd, FILENAME_COUNT, new_count_str); if (strcmp(dd->dd_dirname, dirname) != 0) { struct dump_dir *new_dd = dd_opendir(dirname, DD_OPEN_READONLY); char *last_ocr = NULL; if (new_dd) { last_ocr = dd_load_text_ext(new_dd, FILENAME_TIME, DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE | DD_FAIL_QUIETLY_ENOENT); dd_close(new_dd); } else {    error_msg(""Can't read the last occurrence file from the new dump directory.""); } if (!last_ocr) {    log(""Using current time for the last occurrence file which may be incorrect.""); time_t t = time(NULL); last_ocr = xasprintf(""%lu"", (long)t); } dd_save_text(dd, FILENAME_LAST_OCCURRENCE, last_ocr); free(last_ocr); } } dd_sanitize_mode_and_owner(dd); dd_close(dd); if (!dup_of_dir) log_notice(""New problem directory %s, processing"", work_dir); else { log_warning(""Deleting problem directory %s (dup of %s)"", strrchr(dirname, '/') + 1, strrchr(dup_of_dir, '/') + 1); delete_dump_dir(dirname); } int fd; child_pid = spawn_event_handler_child( work_dir, (dup_of_dir ? ""notify-dup"" : ""notify""), &fd ); xmove_fd(fd, child_stdout_fd); child_is_post_create = 0; strbuf_clear(cmd_output); free(dup_of_dir); dup_of_dir = NULL; goto read_child_output; delete_bad_dir: log_warning(""Deleting problem directory '%s'"", dirname); delete_dump_dir(dirname); ret: strbuf_free(cmd_output); free(dup_of_dir); close(child_stdout_fd); return 0; }
Description: abrt-dbus in Automatic Bug Reporting Tool (ABRT) allows local users to delete or change the ownership of arbitrary files via the problem directory argument to the (1) ChownProblemDir, (2) DeleteElement, or (3) DeleteProblem method.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev, struct packet_type *pt, struct net_device *orig_dev) { struct sock *sk; struct packet_sock *po; struct sockaddr_ll *sll; union tpacket_uhdr h; u8 *skb_head = skb->data; int skb_len = skb->len; unsigned int snaplen, res; unsigned long status = TP_STATUS_USER; unsigned short macoff, netoff, hdrlen; struct sk_buff *copy_skb = NULL; struct timespec ts; __u32 ts_status; bool is_drop_n_account = false; BUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h2)) != 32); BUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h3)) != 48); if (skb->pkt_type == PACKET_LOOPBACK) goto drop; sk = pt->af_packet_priv; po = pkt_sk(sk); if (!net_eq(dev_net(dev), sock_net(sk))) goto drop; if (dev->header_ops) { if (sk->sk_type != SOCK_DGRAM) skb_push(skb, skb->data - skb_mac_header(skb)); else if (skb->pkt_type == PACKET_OUTGOING) { skb_pull(skb, skb_network_offset(skb)); } } snaplen = skb->len; res = run_filter(skb, sk, snaplen); if (!res) goto drop_n_restore; if (skb->ip_summed == CHECKSUM_PARTIAL) status |= TP_STATUS_CSUMNOTREADY; else if (skb->pkt_type != PACKET_OUTGOING && (skb->ip_summed == CHECKSUM_COMPLETE || skb_csum_unnecessary(skb))) status |= TP_STATUS_CSUM_VALID; if (snaplen > res) snaplen = res; if (sk->sk_type == SOCK_DGRAM) { macoff = netoff = TPACKET_ALIGN(po->tp_hdrlen) + 16 + po->tp_reserve; } else { unsigned int maclen = skb_network_offset(skb); netoff = TPACKET_ALIGN(po->tp_hdrlen + (maclen < 16 ? 16 : maclen)) + po->tp_reserve; if (po->has_vnet_hdr) netoff += sizeof(struct virtio_net_hdr); macoff = netoff - maclen; } if (po->tp_version <= TPACKET_V2) { if (macoff + snaplen > po->rx_ring.frame_size) { if (po->copy_thresh && atomic_read(&sk->sk_rmem_alloc) < sk->sk_rcvbuf) { if (skb_shared(skb)) { copy_skb = skb_clone(skb, GFP_ATOMIC); } else { copy_skb = skb_get(skb); skb_head = skb->data; } if (copy_skb) skb_set_owner_r(copy_skb, sk); } snaplen = po->rx_ring.frame_size - macoff; if ((int)snaplen < 0) snaplen = 0; } } else if (unlikely(macoff + snaplen > GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len)) { u32 nval; nval = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len - macoff; pr_err_once(""tpacket_rcv: packet too big, clamped from %u to %u. macoff=%u\n"", snaplen, nval, macoff); snaplen = nval; if (unlikely((int)snaplen < 0)) { snaplen = 0; macoff = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len; } } spin_lock(&sk->sk_receive_queue.lock); h.raw = packet_current_rx_frame(po, skb, TP_STATUS_KERNEL, (macoff+snaplen)); if (!h.raw) goto drop_n_account; if (po->tp_version <= TPACKET_V2) { packet_increment_rx_head(po, &po->rx_ring); if (po->stats.stats1.tp_drops) status |= TP_STATUS_LOSING; } po->stats.stats1.tp_packets++; if (copy_skb) { status |= TP_STATUS_COPY; __skb_queue_tail(&sk->sk_receive_queue, copy_skb); } spin_unlock(&sk->sk_receive_queue.lock); if (po->has_vnet_hdr) { if (virtio_net_hdr_from_skb(skb, h.raw + macoff - sizeof(struct virtio_net_hdr), vio_le(), true)) { spin_lock(&sk->sk_receive_queue.lock); goto drop_n_account; } } skb_copy_bits(skb, 0, h.raw + macoff, snaplen); if (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp))) getnstimeofday(&ts); status |= ts_status; switch (po->tp_version) { case TPACKET_V1: h.h1->tp_len = skb->len; h.h1->tp_snaplen = snaplen; h.h1->tp_mac = macoff; h.h1->tp_net = netoff; h.h1->tp_sec = ts.tv_sec; h.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC; hdrlen = sizeof(*h.h1); break; case TPACKET_V2: h.h2->tp_len = skb->len; h.h2->tp_snaplen = snaplen; h.h2->tp_mac = macoff; h.h2->tp_net = netoff; h.h2->tp_sec = ts.tv_sec; h.h2->tp_nsec = ts.tv_nsec; if (skb_vlan_tag_present(skb)) { h.h2->tp_vlan_tci = skb_vlan_tag_get(skb); h.h2->tp_vlan_tpid = ntohs(skb->vlan_proto); status |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID; } else { h.h2->tp_vlan_tci = 0; h.h2->tp_vlan_tpid = 0; } memset(h.h2->tp_padding, 0, sizeof(h.h2->tp_padding)); hdrlen = sizeof(*h.h2); break; case TPACKET_V3: h.h3->tp_status |= status; h.h3->tp_len = skb->len; h.h3->tp_snaplen = snaplen; h.h3->tp_mac = macoff; h.h3->tp_net = netoff; h.h3->tp_sec  = ts.tv_sec; h.h3->tp_nsec = ts.tv_nsec; memset(h.h3->tp_padding, 0, sizeof(h.h3->tp_padding)); hdrlen = sizeof(*h.h3); break; default: BUG(); } sll = h.raw + TPACKET_ALIGN(hdrlen); sll->sll_halen = dev_parse_header(skb, sll->sll_addr); sll->sll_family = AF_PACKET; sll->sll_hatype = dev->type; sll->sll_protocol = skb->protocol; sll->sll_pkttype = skb->pkt_type; if (unlikely(po->origdev)) sll->sll_ifindex = orig_dev->ifindex; else sll->sll_ifindex = dev->ifindex; smp_mb(); #if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1 if (po->tp_version <= TPACKET_V2) { u8 *start, *end; end = (u8 *) PAGE_ALIGN((unsigned long) h.raw + macoff + snaplen); for (start = h.raw; start < end; start += PAGE_SIZE) flush_dcache_page(pgv_to_page(start)); } smp_wmb(); #endif if (po->tp_version <= TPACKET_V2) { __packet_set_status(po, h.raw, status); sk->sk_data_ready(sk); } else { prb_clear_blk_fill_status(&po->rx_ring); } drop_n_restore: if (skb_head != skb->data && skb_shared(skb)) { skb->data = skb_head; skb->len = skb_len; } drop: if (!is_drop_n_account) consume_skb(skb); else kfree_skb(skb); return 0; drop_n_account: is_drop_n_account = true; po->stats.stats1.tp_drops++; spin_unlock(&sk->sk_receive_queue.lock); sk->sk_data_ready(sk); kfree_skb(copy_skb); goto drop_n_restore; }
Description: The tpacket_rcv function in net/packet/af_packet.c in the Linux kernel before 4.13 mishandles vnet headers, which might allow local users to cause a denial of service (buffer overflow, and disk and memory corruption) or possibly have unspecified other impact via crafted system calls.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int mbfl_strpos( mbfl_string *haystack, mbfl_string *needle, int offset, int reverse) { int result; mbfl_string _haystack_u8, _needle_u8; const mbfl_string *haystack_u8, *needle_u8 = NULL; const unsigned char *u8_tbl; if (haystack == NULL || haystack->val == NULL || needle == NULL || needle->val == NULL) { return -8; } { const mbfl_encoding *u8_enc; u8_enc = mbfl_no2encoding(mbfl_no_encoding_utf8); if (u8_enc == NULL || u8_enc->mblen_table == NULL) { return -8; } u8_tbl = u8_enc->mblen_table; } if (haystack->no_encoding != mbfl_no_encoding_utf8) { mbfl_string_init(&_haystack_u8); haystack_u8 = mbfl_convert_encoding(haystack, &_haystack_u8, mbfl_no_encoding_utf8); if (haystack_u8 == NULL) { result = -4; goto out; } } else { haystack_u8 = haystack; } if (needle->no_encoding != mbfl_no_encoding_utf8) { mbfl_string_init(&_needle_u8); needle_u8 = mbfl_convert_encoding(needle, &_needle_u8, mbfl_no_encoding_utf8); if (needle_u8 == NULL) { result = -4; goto out; } } else { needle_u8 = needle; } if (needle_u8->len < 1) { result = -8; goto out; } result = -1; if (haystack_u8->len < needle_u8->len) { goto out; } if (!reverse) { unsigned int jtbl[1 << (sizeof(unsigned char) * 8)]; unsigned int needle_u8_len = needle_u8->len; unsigned int i; const unsigned char *p, *q, *e; const unsigned char *haystack_u8_val = haystack_u8->val, *needle_u8_val = needle_u8->val; for (i = 0; i < sizeof(jtbl) / sizeof(*jtbl); ++i) { jtbl[i] = needle_u8_len + 1; } for (i = 0; i < needle_u8_len - 1; ++i) { jtbl[needle_u8_val[i]] = needle_u8_len - i; } e = haystack_u8_val + haystack_u8->len; p = haystack_u8_val; while (--offset >= 0) { if (p >= e) { result = -16; goto out; } p += u8_tbl[*p]; } p += needle_u8_len; if (p > e) { goto out; } while (p <= e) { const unsigned char *pv = p; q = needle_u8_val + needle_u8_len; for (;;) { if (q == needle_u8_val) { result = 0; while (p > haystack_u8_val) { unsigned char c = *--p; if (c < 0x80) { ++result; } else if ((c & 0xc0) != 0x80) { ++result; } } goto out; } if (*--q != *--p) { break; } } p += jtbl[*p]; if (p <= pv) { p = pv + 1; } } } else { unsigned int jtbl[1 << (sizeof(unsigned char) * 8)]; unsigned int needle_u8_len = needle_u8->len, needle_len = 0; unsigned int i; const unsigned char *p, *e, *q, *qe; const unsigned char *haystack_u8_val = haystack_u8->val, *needle_u8_val = needle_u8->val; for (i = 0; i < sizeof(jtbl) / sizeof(*jtbl); ++i) { jtbl[i] = needle_u8_len; } for (i = needle_u8_len - 1; i > 0; --i) { unsigned char c = needle_u8_val[i]; jtbl[c] = i; if (c < 0x80) { ++needle_len; } else if ((c & 0xc0) != 0x80) { ++needle_len; } } { unsigned char c = needle_u8_val[0]; if (c < 0x80) { ++needle_len; } else if ((c & 0xc0) != 0x80) { ++needle_len; } } e = haystack_u8_val; p = e + haystack_u8->len; qe = needle_u8_val + needle_u8_len; if (offset < 0) { if (-offset > needle_len) { offset += needle_len;  while (offset < 0) { unsigned char c; if (p <= e) { result = -16; goto out; } c = *(--p); if (c < 0x80) { ++offset; } else if ((c & 0xc0) != 0x80) { ++offset; } } } } else { const unsigned char *ee = haystack_u8_val + haystack_u8->len; while (--offset >= 0) { if (e >= ee) { result = -16; goto out; } e += u8_tbl[*e]; } } if (p < e + needle_u8_len) { goto out; } p -= needle_u8_len; while (p >= e) { const unsigned char *pv = p; q = needle_u8_val; for (;;) { if (q == qe) { result = 0; p -= needle_u8_len; while (p > haystack_u8_val) { unsigned char c = *--p; if (c < 0x80) { ++result; } else if ((c & 0xc0) != 0x80) { ++result; } } goto out; } if (*q != *p) { break; } ++p, ++q; } p -= jtbl[*p]; if (p >= pv) { p = pv - 1; } } } out: if (haystack_u8 == &_haystack_u8) { mbfl_string_clear(&_haystack_u8); } if (needle_u8 == &_needle_u8) { mbfl_string_clear(&_needle_u8); } return result; }
Description: Multiple integer overflows in the mbfl_strcut function in ext/mbstring/libmbfl/mbfl/mbfilter.c in PHP before 5.5.34, 5.6.x before 5.6.20, and 7.x before 7.0.5 allow remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via a crafted mb_strcut call.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int wolfSSH_SFTP_RecvRMDIR(WOLFSSH* ssh, int reqId, byte* data, word32 maxSz) { word32 sz; int    ret = 0; char*  dir; word32 idx = 0; byte*  out; word32 outSz = 0; byte   type; char err[] = ""Remove Directory Error""; char suc[] = ""Removed Directory""; char* res  = NULL; if (ssh == NULL) { return WS_BAD_ARGUMENT; } WLOG(WS_LOG_SFTP, ""Receiving WOLFSSH_FTP_RMDIR""); ato32(data + idx, &sz); idx += UINT32_SZ; if (sz + idx > maxSz) { return WS_BUFFER_E; } dir = (char*)WMALLOC(sz + 1, ssh->ctx->heap, DYNTYPE_BUFFER); if (dir == NULL) { return WS_MEMORY_E; } WMEMCPY(dir, data + idx, sz); dir[sz] = '\0'; if (wolfSSH_CleanPath(ssh, dir) < 0) { ret = WS_FATAL_ERROR; } if (ret == 0) { #ifndef USE_WINDOWS_API ret = WRMDIR(ssh->fs, dir); #else  ret = WS_RemoveDirectoryA(dir, ssh->ctx->heap) == 0; #endif  } WFREE(dir, ssh->ctx->heap, DYNTYPE_BUFFER); res  = (ret != 0)? err : suc; type = (ret != 0)? WOLFSSH_FTP_FAILURE : WOLFSSH_FTP_OK; if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, ""English"", NULL, &outSz) != WS_SIZE_ONLY) { return WS_FATAL_ERROR; } out = (byte*)WMALLOC(outSz, ssh->ctx->heap, DYNTYPE_BUFFER); if (out == NULL) { return WS_MEMORY_E; } if (ret != 0) { WLOG(WS_LOG_SFTP, ""Error removing directory %s"", dir); ret = WS_BAD_FILE_E; } else { ret = WS_SUCCESS; } if (wolfSSH_SFTP_CreateStatus(ssh, type, reqId, res, ""English"", out, &outSz) != WS_SUCCESS) { WFREE(out, ssh->ctx->heap, DYNTYPE_BUFFER); return WS_FATAL_ERROR; } wolfSSH_SFTP_RecvSetSend(ssh, out, outSz); return ret; }
Description: WolfSSH v1.4.7 was discovered to contain an integer overflow via the function wolfSSH_SFTP_RecvRMDIR.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int gs_call_interp(i_ctx_t **pi_ctx_p, ref * pref, int user_errors, int *pexit_code, ref * perror_object) { ref *epref = pref; ref doref; ref *perrordict; ref error_name; int code, ccode; ref saref; i_ctx_t *i_ctx_p = *pi_ctx_p; int *gc_signal = &imemory_system->gs_lib_ctx->gcsignal; *pexit_code = 0; *gc_signal = 0; ialloc_reset_requested(idmemory); again: make_null(perror_object); o_stack.requested = e_stack.requested = d_stack.requested = 0; while (*gc_signal) {  gs_gc_root_t epref_root; *gc_signal = 0; gs_register_ref_root(imemory_system, &epref_root, (void **)&epref, ""gs_call_interp(epref)""); code = interp_reclaim(pi_ctx_p, -1); i_ctx_p = *pi_ctx_p; gs_unregister_root(imemory_system, &epref_root, ""gs_call_interp(epref)""); if (code < 0) return code; } code = interp(pi_ctx_p, epref, perror_object); i_ctx_p = *pi_ctx_p; if (!r_has_type(&i_ctx_p->error_object, t__invalid)) { *perror_object = i_ctx_p->error_object; make_t(&i_ctx_p->error_object, t__invalid); } *gc_signal = 0; set_gc_signal(i_ctx_p, 1); if (esp < esbot)             esp = esbot; switch (code) { case gs_error_Fatal: *pexit_code = 255; return code; case gs_error_Quit: *perror_object = osp[-1]; *pexit_code = code = osp->value.intval; osp -= 2; return (code == 0 ? gs_error_Quit : code < 0 && code > -100 ? code : gs_error_Fatal); case gs_error_InterpreterExit: return 0; case gs_error_ExecStackUnderflow: ref_stack_pop_block(&e_stack); doref = *perror_object; epref = &doref; goto again; case gs_error_VMreclaim: (void)interp_reclaim(pi_ctx_p, (osp->value.intval == 2 ? avm_global : avm_local)); i_ctx_p = *pi_ctx_p; make_oper(&doref, 0, zpop); epref = &doref; goto again; case gs_error_NeedInput: case gs_error_interrupt: return code; } if (osp < osbot - 1) osp = osbot - 1; switch (code) { case gs_error_dictstackoverflow: if (osp >= ostop) { if ((ccode = ref_stack_extend(&o_stack, 1)) < 0) return ccode; } ccode = copy_stack(i_ctx_p, &d_stack, min_dstack_size, &saref); if (ccode < 0) return ccode; ref_stack_pop_to(&d_stack, min_dstack_size); dict_set_top(); *++osp = saref; break; case gs_error_dictstackunderflow: if (ref_stack_pop_block(&d_stack) >= 0) { dict_set_top(); doref = *perror_object; epref = &doref; goto again; } break; case gs_error_execstackoverflow: if (osp >= ostop) { if ((ccode = ref_stack_extend(&o_stack, 1)) < 0) return ccode; } ccode = copy_stack(i_ctx_p, &e_stack, 0, &saref); if (ccode < 0) return ccode; { uint count = ref_stack_count(&e_stack); uint limit = ref_stack_max_count(&e_stack) - ES_HEADROOM; if (count > limit) { int skip = count - limit; int i; for (i = skip; i < skip + MIN_BLOCK_ESTACK; ++i) { const ref *ep = ref_stack_index(&e_stack, i); if (r_has_type_attrs(ep, t_null, a_executable)) { skip = i + 1; break; } } pop_estack(i_ctx_p, skip); } } *++osp = saref; break; case gs_error_stackoverflow: if (ref_stack_extend(&o_stack, o_stack.requested) >= 0) {    doref = *perror_object; if (r_is_proc(&doref)) { *++osp = doref; make_null_proc(&doref); } epref = &doref; goto again; } ccode = copy_stack(i_ctx_p, &o_stack, 0, &saref); if (ccode < 0) return ccode; ref_stack_clear(&o_stack); *++osp = saref; break; case gs_error_stackunderflow: if (ref_stack_pop_block(&o_stack) >= 0) { doref = *perror_object; epref = &doref; goto again; } break; } if (user_errors < 0) return code; if (gs_errorname(i_ctx_p, code, &error_name) < 0) return code;             if (dict_find_string(systemdict, ""gserrordict"", &perrordict) <= 0 || (dict_find(perrordict, &error_name, &epref) <= 0 && (dict_find_string(systemdict, ""errordict"", &perrordict) <= 0 || dict_find(perrordict, &error_name, &epref) <= 0)) ) return code;             doref = *epref; epref = &doref; if (!GS_ERROR_IS_INTERRUPT(code)) { osp++; if (osp >= ostop) { *pexit_code = gs_error_Fatal; return_error(gs_error_Fatal); } *osp = *perror_object; errorexec_find(i_ctx_p, osp); if (i_ctx_p->LockFilePermissions) { code = obj_cvs(imemory, osp, buf + 2, 256, &rlen, (const byte **)&bufptr); if (code < 0) { const char *unknownstr = ""--unknown--""; rlen = strlen(unknownstr); memcpy(buf, unknownstr, rlen); } else { buf[0] = buf[1] = buf[rlen + 2] = buf[rlen + 3] = '-'; rlen += 4; } code = name_ref(imemory, buf, rlen, osp, 1); if (code < 0) make_null(osp); } } goto again; }
Description: Artifex Ghostscript 9.25 and earlier allows attackers to bypass a sandbox protection mechanism via vectors involving errorhandler setup. NOTE: this issue exists because of an incomplete fix for CVE-2018-17183.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void Gobby::EditCommands::on_cut() { g_assert(m_current_view != NULL); g_assert(m_current_view->get_active_user() != NULL); gtk_text_buffer_cut_clipboard( GTK_TEXT_BUFFER(m_current_view->get_text_buffer()), gtk_clipboard_get(GDK_SELECTION_CLIPBOARD), TRUE); m_current_view->scroll_to_cursor_position(0.0); }
Description: Gobby 0.4.11 allows a NULL pointer dereference in the D-Bus handler for certain set_language calls.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void candump_write_packet(wtap_rec *rec, Buffer *buf, const msg_t *msg) { static const char can_proto_name[]   = ""can-hostendian""; static const char canfd_proto_name[] = ""canfd""; ws_buffer_clean(buf); if (msg->is_fd) { wtap_buffer_append_epdu_tag(buf, EXP_PDU_TAG_DISSECTOR_NAME, (const guint8 *)canfd_proto_name, sizeof canfd_proto_name - 1); } else { wtap_buffer_append_epdu_tag(buf, EXP_PDU_TAG_DISSECTOR_NAME, (const guint8 *)can_proto_name, sizeof can_proto_name - 1); } wtap_buffer_append_epdu_end(buf); if (msg->is_fd) { canfd_frame_t canfd_frame = {0}; canfd_frame.can_id = msg->id; canfd_frame.flags  = msg->flags; canfd_frame.len    = msg->data.length; memcpy(canfd_frame.data, msg->data.data, msg->data.length); ws_buffer_append(buf, (guint8 *)&canfd_frame, sizeof(canfd_frame)); } else { can_frame_t can_frame = {0}; can_frame.can_id  = msg->id; can_frame.can_dlc = msg->data.length; memcpy(can_frame.data, msg->data.data, msg->data.length); ws_buffer_append(buf, (guint8 *)&can_frame, sizeof(can_frame)); } rec->rec_type       = REC_TYPE_PACKET; rec->block          = wtap_block_create(WTAP_BLOCK_PACKET); rec->presence_flags = WTAP_HAS_TS; rec->ts             = msg->ts; rec->tsprec         = WTAP_TSPREC_USEC; rec->rec_header.packet_header.caplen = (guint32)ws_buffer_length(buf); rec->rec_header.packet_header.len    = (guint32)ws_buffer_length(buf); }
Description: Candump log parser crash in Wireshark 4.0.0 to 4.0.5 and 3.6.0 to 3.6.13 allows denial of service via crafted capture file
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static njs_int_t njs_json_parse(njs_vm_t *vm, njs_value_t *args, njs_uint_t nargs, njs_index_t unused) { njs_int_t             ret; njs_value_t           *text, value, lvalue; const u_char          *p, *end; njs_json_parse_t      *parse, json_parse; const njs_value_t     *reviver; njs_string_prop_t     string; njs_json_parse_ctx_t  ctx; parse = &json_parse; text = njs_lvalue_arg(&lvalue, args, nargs, 1); if (njs_slow_path(!njs_is_string(text))) { ret = njs_value_to_string(vm, text, text); if (njs_slow_path(ret != NJS_OK)) { return ret; } } (void) njs_string_prop(&string, text); p = string.start; end = p + string.size; ctx.vm = vm; ctx.pool = vm->mem_pool; ctx.depth = NJS_JSON_MAX_DEPTH; ctx.start = string.start; ctx.end = end; p = njs_json_skip_space(p, end); if (njs_slow_path(p == end)) { njs_json_parse_exception(&ctx, ""Unexpected end of input"", p); return NJS_ERROR; } p = njs_json_parse_value(&ctx, &value, p); if (njs_slow_path(p == NULL)) { return NJS_ERROR; } p = njs_json_skip_space(p, end); if (njs_slow_path(p != end)) { njs_json_parse_exception(&ctx, ""Unexpected token"", p); return NJS_ERROR; } reviver = njs_arg(args, nargs, 2); if (njs_slow_path(njs_is_function(reviver) && njs_is_object(&value))) { parse->function = njs_function(reviver); parse->depth = 0; return njs_json_parse_iterator(vm, parse, &value); } vm->retval = value; return NJS_OK; }
Description: Nginx NJS v0.7.2 was discovered to contain a heap-use-after-free bug caused by illegal memory copy in the function njs_json_parse_iterator_call at njs_json.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static gboolean candump_seek_read(wtap *wth , gint64 seek_off, wtap_rec *rec, Buffer *buf, int *err, gchar **err_info) { msg_t msg; #ifdef CANDUMP_DEBUG candump_debug_printf(""%s: Read at offset %"" PRIi64 ""\n"", G_STRFUNC, seek_off); #endif if (file_seek(wth->random_fh, seek_off, SEEK_SET, err) == -1) { *err      = errno; *err_info = g_strdup(g_strerror(errno)); return FALSE; } if (!candump_parse(wth->random_fh, &msg, NULL, err, err_info)) return FALSE; candump_write_packet(rec, buf, &msg); return TRUE; }
Description: Candump log parser crash in Wireshark 4.0.0 to 4.0.5 and 3.6.0 to 3.6.13 allows denial of service via crafted capture file
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int pgpPrtParams(const uint8_t * pkts, size_t pktlen, unsigned int pkttype, pgpDigParams * ret) { const uint8_t *p = pkts; const uint8_t *pend = pkts + pktlen; pgpDigParams digp = NULL; struct pgpPkt pkt; int rc = -1;  while (p < pend) { if (decodePkt(p, (pend - p), &pkt)) break; if (digp == NULL) { if (pkttype && pkt.tag != pkttype) { break; } else { digp = pgpDigParamsNew(pkt.tag); } } if (pgpPrtPkt(&pkt, digp)) break; p += (pkt.body - pkt.head) + pkt.blen; if (pkttype == PGPTAG_SIGNATURE) break; } rc = (digp && (p == pend)) ? 0 : -1; if (ret && rc == 0) { *ret = digp; } else { pgpDigParamsFree(digp); } return rc; }
Description: There is a flaw in RPM's signature functionality. OpenPGP subkeys are associated with a primary key via a ""binding signature."" RPM does not check the binding signature of subkeys prior to importing them. If an attacker is able to add or socially engineer another party to add a malicious subkey to a legitimate public key, RPM could wrongly trust a malicious signature. The greatest impact of this flaw is to data integrity. To exploit this flaw, an attacker must either compromise an RPM repository or convince an administrator to install an untrusted RPM or public key. It is strongly recommended to only use RPMs and public keys from trusted sources.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int inet_create(struct net *net, struct socket *sock, int protocol, int kern) { struct sock *sk; struct inet_protosw *answer; struct inet_sock *inet; struct proto *answer_prot; unsigned char answer_flags; int try_loading_module = 0; int err; sock->state = SS_UNCONNECTED; lookup_protocol: err = -ESOCKTNOSUPPORT; rcu_read_lock(); list_for_each_entry_rcu(answer, &inetsw[sock->type], list) { err = 0; if (protocol == answer->protocol) { if (protocol != IPPROTO_IP) break; } else { if (IPPROTO_IP == protocol) { protocol = answer->protocol; break; } if (IPPROTO_IP == answer->protocol) break; } err = -EPROTONOSUPPORT; } if (unlikely(err)) { if (try_loading_module < 2) { rcu_read_unlock(); if (++try_loading_module == 1) request_module(""net-pf-%d-proto-%d-type-%d"", PF_INET, protocol, sock->type); else request_module(""net-pf-%d-proto-%d"", PF_INET, protocol); goto lookup_protocol; } else goto out_rcu_unlock; } err = -EPERM; if (sock->type == SOCK_RAW && !kern && !ns_capable(net->user_ns, CAP_NET_RAW)) goto out_rcu_unlock; sock->ops = answer->ops; answer_prot = answer->prot; answer_flags = answer->flags; rcu_read_unlock(); WARN_ON(!answer_prot->slab); err = -ENOBUFS; sk = sk_alloc(net, PF_INET, GFP_KERNEL, answer_prot, kern); if (!sk) goto out; err = 0; if (INET_PROTOSW_REUSE & answer_flags) sk->sk_reuse = SK_CAN_REUSE; inet = inet_sk(sk); inet->is_icsk = (INET_PROTOSW_ICSK & answer_flags) != 0; inet->nodefrag = 0; if (SOCK_RAW == sock->type) { inet->inet_num = protocol; if (IPPROTO_RAW == protocol) inet->hdrincl = 1; } if (net->ipv4.sysctl_ip_no_pmtu_disc) inet->pmtudisc = IP_PMTUDISC_DONT; else inet->pmtudisc = IP_PMTUDISC_WANT; inet->inet_id = 0; sock_init_data(sock, sk); sk->sk_destruct   = inet_sock_destruct; sk->sk_protocol   = protocol; sk->sk_backlog_rcv = sk->sk_prot->backlog_rcv; inet->uc_ttl= -1; inet->mc_loop= 1; inet->mc_ttl= 1; inet->mc_all= 1; inet->mc_index= 0; inet->mc_list= NULL; inet->rcv_tos= 0; sk_refcnt_debug_inc(sk); if (inet->inet_num) { inet->inet_sport = htons(inet->inet_num); sk->sk_prot->hash(sk); } if (sk->sk_prot->init) { err = sk->sk_prot->init(sk); if (err) sk_common_release(sk); } out: return err; out_rcu_unlock: rcu_read_unlock(); goto out; }
Description: The networking implementation in the Linux kernel through 4.3.3, as used in Android and other products, does not validate protocol identifiers for certain protocol families, which allows local users to cause a denial of service (NULL function pointer dereference and system crash) or possibly gain privileges by leveraging CLONE_NEWUSER support to execute a crafted SOCK_RAW application.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: RList *r_bin_ne_get_entrypoints(r_bin_ne_obj_t *bin) { if (!bin->entry_table) { return NULL; } RList *entries = r_list_newf (free); if (!entries) { return NULL; } RList *segments = r_bin_ne_get_segments (bin); if (!segments) { r_list_free (entries); return NULL; } if (bin->ne_header->csEntryPoint) { RBinAddr *entry = R_NEW0 (RBinAddr); if (!entry) { r_list_free (entries); return NULL; } entry->bits = 16; ut32 entry_cs = bin->ne_header->csEntryPoint; RBinSection *s = r_list_get_n (segments, entry_cs - 1); entry->paddr = bin->ne_header->ipEntryPoint + (s? s->paddr: 0); r_list_append (entries, entry); } int off = 0; size_t tableat = bin->header_offset + bin->ne_header->EntryTableOffset; while (off < bin->ne_header->EntryTableLength) { if (tableat + off >= r_buf_size (bin->buf)) { break; } ut8 bundle_length = *(ut8 *)(bin->entry_table + off); if (!bundle_length) { break; } off++; ut8 bundle_type = *(ut8 *)(bin->entry_table + off); off++; int i; for (i = 0; i < bundle_length; i++) { if (tableat + off + 4 >= r_buf_size (bin->buf)) { break; } RBinAddr *entry = R_NEW0 (RBinAddr); if (!entry) { r_list_free (entries); return NULL; } off++; if (!bundle_type) { off--; free (entry); break; } else if (bundle_type == 0xff) { off += 2; ut8 segnum = *(bin->entry_table + off); off++; ut16 segoff = *(ut16 *)(bin->entry_table + off); if (segnum > 0) { entry->paddr = (ut64)bin->segment_entries[segnum - 1].offset * bin->alignment + segoff; } } else { if (bundle_type < bin->ne_header->SegCount) { entry->paddr = (ut64)bin->segment_entries[bundle_type - 1].offset * bin->alignment + *(ut16 *)(bin->entry_table + off); } } off += 2; r_list_append (entries, entry); } } r_list_free (segments); bin->entries = entries; return entries; }
Description: Out-of-bounds Read in r_bin_ne_get_entrypoints function in GitHub repository radareorg/radare2 prior to 5.6.8. This vulnerability may allow attackers to read sensitive information or cause a crash.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int createCroppedImage(struct image_data *image, struct crop_mask *crop, unsigned char **read_buff_ptr, unsigned char **crop_buff_ptr) { tsize_t cropsize; unsigned char *read_buff = NULL; unsigned char *crop_buff = NULL; unsigned char *new_buff = NULL; static tsize_t prev_cropsize = 0; read_buff = *read_buff_ptr; crop_buff = read_buff; *crop_buff_ptr = read_buff; crop->combined_width = image->width; crop->combined_length = image->length; cropsize = crop->bufftotal; crop_buff = *crop_buff_ptr; if (!crop_buff) { crop_buff = (unsigned char *)limitMalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES); if (!crop_buff) { TIFFError(""createCroppedImage"", ""Unable to allocate/reallocate crop buffer""); return (-1); } _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES); prev_cropsize = cropsize; } else { if (prev_cropsize < cropsize) { new_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES); if (!new_buff) { free(crop_buff); crop_buff = (unsigned char *)limitMalloc( cropsize + NUM_BUFF_OVERSIZE_BYTES); } else crop_buff = new_buff; if (!crop_buff) { TIFFError(""createCroppedImage"", ""Unable to allocate/reallocate crop buffer""); return (-1); } _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES); } } *crop_buff_ptr = crop_buff; if (crop->crop_mode & CROP_INVERT) { switch (crop->photometric) { case PHOTOMETRIC_MINISWHITE: case PHOTOMETRIC_MINISBLACK: image->photometric = crop->photometric; break; case INVERT_DATA_ONLY: case INVERT_DATA_AND_TAG: if (invertImage(image->photometric, image->spp, image->bps, crop->combined_width, crop->combined_length, crop_buff)) { TIFFError(""createCroppedImage"", ""Failed to invert colorspace for image or "" ""cropped selection""); return (-1); } if (crop->photometric == INVERT_DATA_AND_TAG) { switch (image->photometric) { case PHOTOMETRIC_MINISWHITE: image->photometric = PHOTOMETRIC_MINISBLACK; break; case PHOTOMETRIC_MINISBLACK: image->photometric = PHOTOMETRIC_MINISWHITE; break; default: break; } } break; default: break; } } if (crop->crop_mode & CROP_MIRROR) { if (mirrorImage(image->spp, image->bps, crop->mirror, crop->combined_width, crop->combined_length, crop_buff)) { TIFFError(""createCroppedImage"", ""Failed to mirror image or cropped selection %s"", (crop->rotation == MIRROR_HORIZ) ? ""horizontally"" : ""vertically""); return (-1); } } if (crop->crop_mode & CROP_ROTATE)  { if (rotateImage(crop->rotation, image, &crop->combined_width, &crop->combined_length, crop_buff_ptr, NULL)) { TIFFError(""createCroppedImage"", ""Failed to rotate image or cropped selection by %"" PRIu16 "" degrees"", crop->rotation); return (-1); } } if (crop_buff == read_buff)              *read_buff_ptr = NULL;  return (0); }
Description: LibTIFF 4.4.0 has an out-of-bounds read in tiffcrop in tools/tiffcrop.c:3488, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit afaabc3e.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int cypress_generic_port_probe(struct usb_serial_port *port) { struct usb_serial *serial = port->serial; struct cypress_private *priv; priv = kzalloc(sizeof(struct cypress_private), GFP_KERNEL); if (!priv) return -ENOMEM; priv->comm_is_ok = !0; spin_lock_init(&priv->lock); if (kfifo_alloc(&priv->write_fifo, CYPRESS_BUF_SIZE, GFP_KERNEL)) { kfree(priv); return -ENOMEM; } if (!is_frwd(serial->dev)) usb_reset_configuration(serial->dev); priv->cmd_ctrl = 0; priv->line_control = 0; priv->termios_initialized = 0; priv->rx_flags = 0; if (port->interrupt_out_size > 9) priv->pkt_fmt = packet_format_1; else priv->pkt_fmt = packet_format_2; if (interval > 0) { priv->write_urb_interval = interval; priv->read_urb_interval = interval; dev_dbg(&port->dev, ""%s - read & write intervals forced to %d\n"", __func__, interval); } else { priv->write_urb_interval = port->interrupt_out_urb->interval; priv->read_urb_interval = port->interrupt_in_urb->interval; dev_dbg(&port->dev, ""%s - intervals: read=%d write=%d\n"", __func__, priv->read_urb_interval, priv->write_urb_interval); } usb_set_serial_port_data(port, priv); port->port.drain_delay = 256; return 0; }
Description: drivers/usb/serial/cypress_m8.c in the Linux kernel before 4.5.1 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) via a USB device without both an interrupt-in and an interrupt-out endpoint descriptor, related to the cypress_generic_port_probe and cypress_open functions.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int main(int argc, char *argv[]) { FILE *fout = NULL; opj_dparameters_t parameters;            opj_image_t* image = NULL;                   opj_codec_t* l_codec = NULL;                 opj_stream_t *l_stream = NULL;               opj_codestream_info_v2_t* cstr_info = NULL; opj_codestream_index_t* cstr_index = NULL; OPJ_INT32 num_images, imageno; img_fol_t img_fol; dircnt_t *dirptr = NULL; opj_set_default_decoder_parameters(&parameters); memset(&img_fol, 0, sizeof(img_fol_t)); img_fol.flag = OPJ_IMG_INFO | OPJ_J2K_MH_INFO | OPJ_J2K_MH_IND; if (parse_cmdline_decoder(argc, argv, &parameters, &img_fol) == 1) { if (img_fol.imgdirpath) { free(img_fol.imgdirpath); } return EXIT_FAILURE; } if (img_fol.set_imgdir == 1) { int it_image; num_images = get_num_images(img_fol.imgdirpath); dirptr = (dircnt_t*)malloc(sizeof(dircnt_t)); if (!dirptr) { return EXIT_FAILURE; } dirptr->filename_buf = (char*)malloc((size_t)num_images * OPJ_PATH_LEN * sizeof( char));  if (!dirptr->filename_buf) { free(dirptr); return EXIT_FAILURE; } dirptr->filename = (char**) malloc((size_t)num_images * sizeof(char*)); if (!dirptr->filename) { goto fails; } for (it_image = 0; it_image < num_images; it_image++) { dirptr->filename[it_image] = dirptr->filename_buf + it_image * OPJ_PATH_LEN; } if (load_images(dirptr, img_fol.imgdirpath) == 1) { goto fails; } if (num_images == 0) { fprintf(stdout, ""Folder is empty\n""); goto fails; } } else { num_images = 1; } if (parameters.outfile[0] != 0) { fout = fopen(parameters.outfile, ""w""); if (!fout) { fprintf(stderr, ""ERROR -> failed to open %s for writing\n"", parameters.outfile); goto fails; } } else { fout = stdout; } for (imageno = 0; imageno < num_images ; imageno++) { fprintf(stderr, ""\n""); if (img_fol.set_imgdir == 1) { if (get_next_file(imageno, dirptr, &img_fol, &parameters)) { fprintf(stderr, ""skipping file...\n""); continue; } } l_stream = opj_stream_create_default_file_stream(parameters.infile, 1); if (!l_stream) { fprintf(stderr, ""ERROR -> failed to create the stream from the file %s\n"", parameters.infile); goto fails; } switch (parameters.decod_format) { case J2K_CFMT: {  l_codec = opj_create_decompress(OPJ_CODEC_J2K); break; } case JP2_CFMT: {  l_codec = opj_create_decompress(OPJ_CODEC_JP2); break; } case JPT_CFMT: {  l_codec = opj_create_decompress(OPJ_CODEC_JPT); break; } default: fprintf(stderr, ""skipping file..\n""); opj_stream_destroy(l_stream); continue; } opj_set_info_handler(l_codec, info_callback, 00); opj_set_warning_handler(l_codec, warning_callback, 00); opj_set_error_handler(l_codec, error_callback, 00); parameters.flags |= OPJ_DPARAMETERS_DUMP_FLAG; if (!opj_setup_decoder(l_codec, &parameters)) { fprintf(stderr, ""ERROR -> opj_dump: failed to setup the decoder\n""); opj_stream_destroy(l_stream); opj_destroy_codec(l_codec); fclose(fout); goto fails; } if (! opj_read_header(l_stream, l_codec, &image)) { fprintf(stderr, ""ERROR -> opj_dump: failed to read the header\n""); opj_stream_destroy(l_stream); opj_destroy_codec(l_codec); opj_image_destroy(image); fclose(fout); goto fails; } opj_dump_codec(l_codec, img_fol.flag, fout); cstr_info = opj_get_cstr_info(l_codec); cstr_index = opj_get_cstr_index(l_codec); opj_stream_destroy(l_stream); if (l_codec) { opj_destroy_codec(l_codec); } opj_image_destroy(image); opj_destroy_cstr_index(&cstr_index); opj_destroy_cstr_info(&cstr_info); } fclose(fout); return EXIT_SUCCESS; fails: if (dirptr) { if (dirptr->filename) { free(dirptr->filename); } if (dirptr->filename_buf) { free(dirptr->filename_buf); } free(dirptr); } return EXIT_FAILURE; }
Description: Integer Overflow in OpenJPEG v2.4.0 allows remote attackers to crash the application, causing a Denial of Service (DoS). This occurs when the attacker uses the command line option ""-ImgDir"" on a directory that contains 1048576 files.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: MagickPrivate MagickBooleanType OpenModule(const char *module, ExceptionInfo *exception) { char module_name[MagickPathExtent], name[MagickPathExtent], path[MagickPathExtent]; MagickBooleanType status; ModuleHandle handle; ModuleInfo *module_info; PolicyRights rights; const CoderInfo *p; size_t signature; assert(module != (const char *) NULL); module_info=(ModuleInfo *) GetModuleInfo(module,exception); if (module_info != (ModuleInfo *) NULL) return(MagickTrue); (void) CopyMagickString(module_name,module,MagickPathExtent); p=GetCoderInfo(module,exception); if (p != (CoderInfo *) NULL) (void) CopyMagickString(module_name,p->name,MagickPathExtent); rights=AllPolicyRights; if (IsRightsAuthorized(ModulePolicyDomain,rights,module_name) == MagickFalse) { errno=EPERM; (void) ThrowMagickException(exception,GetMagickModule(),PolicyError, ""NotAuthorized"",""`%s'"",module); return(MagickFalse); } if (GetValueFromSplayTree(module_list,module_name) != (void *) NULL) return(MagickTrue);   handle=(ModuleHandle) NULL; TagToCoderModuleName(module_name,name); (void) LogMagickEvent(ModuleEvent,GetMagickModule(), ""Searching for module \""%s\"" using filename \""%s\"""",module_name,name); *path='\0'; status=GetMagickModulePath(name,MagickImageCoderModule,path,exception); if (status == MagickFalse) return(MagickFalse); (void) LogMagickEvent(ModuleEvent,GetMagickModule(), ""Opening module at path \""%s\"""",path); handle=(ModuleHandle) lt_dlopen(path); if (handle == (ModuleHandle) NULL) { (void) ThrowMagickException(exception,GetMagickModule(),ModuleError, ""UnableToLoadModule"",""'%s': %s"",path,lt_dlerror()); return(MagickFalse); } module_info=AcquireModuleInfo(path,module_name); module_info->handle=handle; if (RegisterModule(module_info,exception) == (ModuleInfo *) NULL) return(MagickFalse); TagToModuleName(module_name,""Register%sImage"",name); module_info->register_module=(size_t (*)(void)) lt_dlsym(handle,name); if (module_info->register_module == (size_t (*)(void)) NULL) { (void) ThrowMagickException(exception,GetMagickModule(),ModuleError, ""UnableToRegisterImageFormat"",""'%s': %s"",module_name,lt_dlerror()); return(MagickFalse); } (void) LogMagickEvent(ModuleEvent,GetMagickModule(), ""Method \""%s\"" in module \""%s\"" at address %p"",name,module_name, (void *) module_info->register_module); TagToModuleName(module_name,""Unregister%sImage"",name); module_info->unregister_module=(void (*)(void)) lt_dlsym(handle,name); if (module_info->unregister_module == (void (*)(void)) NULL) { (void) ThrowMagickException(exception,GetMagickModule(),ModuleError, ""UnableToRegisterImageFormat"",""'%s': %s"",module_name,lt_dlerror()); return(MagickFalse); } (void) LogMagickEvent(ModuleEvent,GetMagickModule(), ""Method \""%s\"" in module \""%s\"" at address %p"",name,module_name, (void *) module_info->unregister_module); signature=module_info->register_module(); if (signature != MagickImageCoderSignature) { (void) ThrowMagickException(exception,GetMagickModule(),ModuleError, ""ImageCoderSignatureMismatch"",""'%s': %8lx != %8lx"",module_name, (unsigned long) signature,(unsigned long) MagickImageCoderSignature); return(MagickFalse); } return(MagickTrue); }
Description: ImageMagick is free software delivered as a ready-to-run binary distribution or as source code that you may use, copy, modify, and distribute in both open and proprietary applications. In affected versions and in certain cases, Postscript files could be read and written when specifically excluded by a `module` policy in `policy.xml`. ex. <policy domain=""module"" rights=""none"" pattern=""PS"" />. The issue has been resolved in ImageMagick 7.1.0-7 and in 6.9.12-22. Fortunately, in the wild, few users utilize the `module` policy and instead use the `coder` policy that is also our workaround recommendation: <policy domain=""coder"" rights=""none"" pattern=""{PS,EPI,EPS,EPSF,EPSI}"" />.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void flatpak_proxy_client_init (FlatpakProxyClient *client) { init_side (client, &client->client_side); init_side (client, &client->bus_side); client->auth_end_offset = AUTH_END_INIT_OFFSET; client->rewrite_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref); client->get_owner_reply = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_free); client->unique_id_policy = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, NULL); }
Description: In dbus-proxy/flatpak-proxy.c in Flatpak before 0.8.9, and 0.9.x and 0.10.x before 0.10.3, crafted D-Bus messages to the host can be used to break out of the sandbox, because whitespace handling in the proxy is not identical to whitespace handling in the daemon.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static jclass getClassAt(JNIEnv *env, jobject constantPoolOop, jint cpIndex, UDATA resolveFlags) { jclass returnValue = NULL; J9VMThread *vmThread = (J9VMThread *) env; J9InternalVMFunctions *vmFunctions = vmThread->javaVM->internalVMFunctions; SunReflectCPResult result = NULL_POINTER_EXCEPTION; if (NULL != constantPoolOop) { J9Class *clazz = NULL; vmFunctions->internalEnterVMFromJNI(vmThread); result = getJ9ClassAt(vmThread, constantPoolOop, cpIndex, resolveFlags, &clazz); if (NULL != clazz) { returnValue = vmFunctions->j9jni_createLocalRef(env, J9VM_J9CLASS_TO_HEAPCLASS(clazz)); } vmFunctions->internalExitVMToJNI(vmThread); } checkResult(env, result); return returnValue; }
Description: In Eclipse Openj9 to version 0.25.0, usage of the jdk.internal.reflect.ConstantPool API causes the JVM in some cases to pre-resolve certain constant pool entries. This allows a user to call static methods or access static members without running the class initialization method, and may allow a user to observe uninitialized values.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static pj_status_t parse_rr(pj_dns_parsed_rr *rr, pj_pool_t *pool, const pj_uint8_t *pkt, const pj_uint8_t *start, const pj_uint8_t *max, int *parsed_len) { const pj_uint8_t *p = start; int name_len, name_part_len; pj_status_t status; status = get_name_len(0, pkt, start, max, &name_part_len, &name_len); if (status != PJ_SUCCESS) return status; rr->name.ptr = (char*) pj_pool_alloc(pool, name_len+4); rr->name.slen = 0; status = get_name(0, pkt, start, max, &rr->name); if (status != PJ_SUCCESS) return status; p = (start + name_part_len); if (p+10 > max) return PJLIB_UTIL_EDNSINSIZE; pj_memcpy(&rr->type, p, 2); rr->type = pj_ntohs(rr->type); p += 2; pj_memcpy(&rr->dnsclass, p, 2); rr->dnsclass = pj_ntohs(rr->dnsclass); p += 2; if (rr->dnsclass != 1) { if (rr->type == PJ_DNS_TYPE_A     || rr->type == PJ_DNS_TYPE_AAAA  || rr->type == PJ_DNS_TYPE_CNAME || rr->type == PJ_DNS_TYPE_NS    || rr->type == PJ_DNS_TYPE_PTR   || rr->type == PJ_DNS_TYPE_SRV) { return PJLIB_UTIL_EDNSINCLASS; } } pj_memcpy(&rr->ttl, p, 4); rr->ttl = pj_ntohl(rr->ttl); p += 4; pj_memcpy(&rr->rdlength, p, 2); rr->rdlength = pj_ntohs(rr->rdlength); p += 2; if (p + rr->rdlength > max) return PJLIB_UTIL_EDNSINSIZE; if (rr->type == PJ_DNS_TYPE_A) { pj_memcpy(&rr->rdata.a.ip_addr, p, 4); p += 4; } else if (rr->type == PJ_DNS_TYPE_AAAA) { pj_memcpy(&rr->rdata.aaaa.ip_addr, p, 16); p += 16; } else if (rr->type == PJ_DNS_TYPE_CNAME || rr->type == PJ_DNS_TYPE_NS || rr->type == PJ_DNS_TYPE_PTR)  { status = get_name_len(0, pkt, p, max, &name_part_len, &name_len); if (status != PJ_SUCCESS) return status; rr->rdata.cname.name.ptr = (char*) pj_pool_alloc(pool, name_len); rr->rdata.cname.name.slen = 0; status = get_name(0, pkt, p, max, &rr->rdata.cname.name); if (status != PJ_SUCCESS) return status; p += name_part_len; } else if (rr->type == PJ_DNS_TYPE_SRV) { pj_memcpy(&rr->rdata.srv.prio, p, 2); rr->rdata.srv.prio = pj_ntohs(rr->rdata.srv.prio); p += 2; pj_memcpy(&rr->rdata.srv.weight, p, 2); rr->rdata.srv.weight = pj_ntohs(rr->rdata.srv.weight); p += 2; pj_memcpy(&rr->rdata.srv.port, p, 2); rr->rdata.srv.port = pj_ntohs(rr->rdata.srv.port); p += 2; status = get_name_len(0, pkt, p, max, &name_part_len, &name_len); if (status != PJ_SUCCESS) return status; rr->rdata.srv.target.ptr = (char*) pj_pool_alloc(pool, name_len); rr->rdata.srv.target.slen = 0; status = get_name(0, pkt, p, max, &rr->rdata.srv.target); if (status != PJ_SUCCESS) return status; p += name_part_len; } else { rr->data = pj_pool_alloc(pool, rr->rdlength); pj_memcpy(rr->data, p, rr->rdlength); p += rr->rdlength; } *parsed_len = (int)(p - start); return PJ_SUCCESS; }
Description: PJSIP is a free and open source multimedia communication library written in C. A buffer overflow vulnerability in versions 2.13 and prior affects applications that use PJSIP DNS resolver. It doesn't affect PJSIP users who do not utilise PJSIP DNS resolver. This vulnerability is related to CVE-2022-24793. The difference is that this issue is in parsing the query record `parse_query()`, while the issue in CVE-2022-24793 is in `parse_rr()`. A patch is available as commit `d1c5e4d` in the `master` branch. A workaround is to disable DNS resolution in PJSIP config (by setting `nameserver_count` to zero) or use an external resolver implementation instead.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int process_request(RGWRados* const store, RGWREST* const rest, RGWRequest* const req, const std::string& frontend_prefix, const rgw_auth_registry_t& auth_registry, RGWRestfulIO* const client_io, OpsLogSocket* const olog, int* http_ret) { int ret = 0; client_io->init(g_ceph_context); req->log_init(); dout(1) << ""====== starting new request req="" << hex << req << dec << "" ====="" << dendl; perfcounter->inc(l_rgw_req); RGWEnv& rgw_env = client_io->get_env(); RGWUserInfo userinfo; struct req_state rstate(g_ceph_context, &rgw_env, &userinfo); struct req_state *s = &rstate; RGWObjectCtx rados_ctx(store, s); s->obj_ctx = &rados_ctx; s->req_id = store->unique_id(req->id); s->trans_id = store->unique_trans_id(req->id); s->host_id = store->host_id; req->log_format(s, ""initializing for trans_id = %s"", s->trans_id.c_str()); RGWOp* op = NULL; int init_error = 0; bool should_log = false; RGWRESTMgr *mgr; RGWHandler_REST *handler = rest->get_handler(store, s, auth_registry, frontend_prefix, client_io, &mgr, &init_error); if (init_error != 0) { abort_early(s, NULL, init_error, NULL); goto done; } dout(10) << ""handler="" << typeid(*handler).name() << dendl; should_log = mgr->get_logging(); req->log_format(s, ""getting op %d"", s->op); op = handler->get_op(store); if (!op) { abort_early(s, NULL, -ERR_METHOD_NOT_ALLOWED, handler); goto done; } req->op = op; dout(10) << ""op="" << typeid(*op).name() << dendl; s->op_type = op->get_type(); req->log(s, ""verifying requester""); ret = op->verify_requester(auth_registry); if (ret < 0) { dout(10) << ""failed to authorize request"" << dendl; abort_early(s, NULL, ret, handler); goto done; } if (nullptr == s->auth.identity) { s->auth.identity = rgw::auth::transform_old_authinfo(s); } req->log(s, ""normalizing buckets and tenants""); ret = handler->postauth_init(); if (ret < 0) { dout(10) << ""failed to run post-auth init"" << dendl; abort_early(s, op, ret, handler); goto done; } if (s->user->suspended) { dout(10) << ""user is suspended, uid="" << s->user->user_id << dendl; abort_early(s, op, -ERR_USER_SUSPENDED, handler); goto done; } ret = rgw_process_authenticated(handler, op, req, s); if (ret < 0) { abort_early(s, op, ret, handler); goto done; } done: try { client_io->complete_request(); } catch (rgw::io::Exception& e) { dout(0) << ""ERROR: client_io->complete_request() returned "" << e.what() << dendl; } if (should_log) { rgw_log_op(store, rest, s, (op ? op->name() : ""unknown""), olog); } if (http_ret != nullptr) { *http_ret = s->err.http_ret; } int op_ret = 0; if (op) { op_ret = op->get_ret(); } req->log_format(s, ""op status=%d"", op_ret); req->log_format(s, ""http status=%d"", s->err.http_ret); if (handler) handler->put_op(op); rest->put_handler(handler); dout(1) << ""====== req done req="" << hex << req << dec << "" op status="" << op_ret << "" http_status="" << s->err.http_ret << "" ======"" << dendl; return (ret < 0 ? ret : s->err.ret); }
Description: In Ceph before 12.2.3 and 13.x through 13.0.1, the rgw_civetweb.cc RGWCivetWeb::init_env function in radosgw doesn't handle malformed HTTP headers properly, allowing for denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int X509_verify_cert(X509_STORE_CTX *ctx) { X509 *x, *xtmp, *xtmp2, *chain_ss = NULL; int bad_chain = 0; X509_VERIFY_PARAM *param = ctx->param; int depth, i, ok = 0; int num, j, retry; int (*cb) (int xok, X509_STORE_CTX *xctx); STACK_OF(X509) *sktmp = NULL; if (ctx->cert == NULL) { X509err(X509_F_X509_VERIFY_CERT, X509_R_NO_CERT_SET_FOR_US_TO_VERIFY); return -1; } cb = ctx->verify_cb; if (ctx->chain == NULL) { if (((ctx->chain = sk_X509_new_null()) == NULL) || (!sk_X509_push(ctx->chain, ctx->cert))) { X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE); goto end; } CRYPTO_add(&ctx->cert->references, 1, CRYPTO_LOCK_X509); ctx->last_untrusted = 1; } if (ctx->untrusted != NULL && (sktmp = sk_X509_dup(ctx->untrusted)) == NULL) { X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE); goto end; } num = sk_X509_num(ctx->chain); x = sk_X509_value(ctx->chain, num - 1); depth = param->depth; for (;;) { if (depth < num) break;               if (ctx->check_issued(ctx, x, x)) break; if (ctx->untrusted != NULL) { xtmp = find_issuer(ctx, sktmp, x); if (xtmp != NULL) { if (!sk_X509_push(ctx->chain, xtmp)) { X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE); goto end; } CRYPTO_add(&xtmp->references, 1, CRYPTO_LOCK_X509); (void)sk_X509_delete_ptr(sktmp, xtmp); ctx->last_untrusted++; x = xtmp; num++; continue; } } break; } j = num; do { i = sk_X509_num(ctx->chain); x = sk_X509_value(ctx->chain, i - 1); if (ctx->check_issued(ctx, x, x)) { if (sk_X509_num(ctx->chain) == 1) { ok = ctx->get_issuer(&xtmp, ctx, x); if ((ok <= 0) || X509_cmp(x, xtmp)) { ctx->error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT; ctx->current_cert = x; ctx->error_depth = i - 1; if (ok == 1) X509_free(xtmp); bad_chain = 1; ok = cb(0, ctx); if (!ok) goto end; } else { X509_free(x); x = xtmp; (void)sk_X509_set(ctx->chain, i - 1, x); ctx->last_untrusted = 0; } } else { chain_ss = sk_X509_pop(ctx->chain); ctx->last_untrusted--; num--; j--; x = sk_X509_value(ctx->chain, num - 1); } } for (;;) { if (depth < num) break; if (ctx->check_issued(ctx, x, x)) break; ok = ctx->get_issuer(&xtmp, ctx, x); if (ok < 0) return ok; if (ok == 0) break; x = xtmp; if (!sk_X509_push(ctx->chain, x)) { X509_free(xtmp); X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE); return 0; } num++; } retry = 0; if (j == ctx->last_untrusted && !(ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS)) { while (j-- > 1) { xtmp2 = sk_X509_value(ctx->chain, j - 1); ok = ctx->get_issuer(&xtmp, ctx, xtmp2); if (ok < 0) goto end; if (ok > 0) { X509_free(xtmp); while (num > j) { xtmp = sk_X509_pop(ctx->chain); X509_free(xtmp); num--; ctx->last_untrusted--; } retry = 1; break; } } } } while (retry); if (!ctx->check_issued(ctx, x, x)) { if ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss)) { if (ctx->last_untrusted >= num) ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY; else ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT; ctx->current_cert = x; } else { sk_X509_push(ctx->chain, chain_ss); num++; ctx->last_untrusted = num; ctx->current_cert = chain_ss; ctx->error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN; chain_ss = NULL; } ctx->error_depth = num - 1; bad_chain = 1; ok = cb(0, ctx); if (!ok) goto end; } ok = check_chain_extensions(ctx); if (!ok) goto end; ok = check_name_constraints(ctx); if (!ok) goto end; if (param->trust > 0) ok = check_trust(ctx); if (!ok) goto end; X509_get_pubkey_parameters(NULL, ctx->chain); ok = ctx->check_revocation(ctx); if (!ok) goto end; if (ctx->verify != NULL) ok = ctx->verify(ctx); else ok = internal_verify(ctx); if (!ok) goto end; #ifndef OPENSSL_NO_RFC3779 ok = v3_asid_validate_path(ctx); if (!ok) goto end; ok = v3_addr_validate_path(ctx); if (!ok) goto end; #endif if (!bad_chain && (ctx->param->flags & X509_V_FLAG_POLICY_CHECK)) ok = ctx->check_policy(ctx); if (!ok) goto end; if (0) { end: X509_get_pubkey_parameters(NULL, ctx->chain); } if (sktmp != NULL) sk_X509_free(sktmp); if (chain_ss != NULL) X509_free(chain_ss); return ok; }
Description: The X509_verify_cert function in crypto/x509/x509_vfy.c in OpenSSL 1.0.1n, 1.0.1o, 1.0.2b, and 1.0.2c does not properly process X.509 Basic Constraints cA values during identification of alternative certificate chains, which allows remote attackers to spoof a Certification Authority role and trigger unintended certificate verifications via a valid leaf certificate.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool_pdfioDictSetValue( pdfio_dict_t   *dict,    const char     *key,    _pdfio_value_t *value){ _pdfio_pair_t*pair; PDFIO_DEBUG(""_pdfioDictSetValue(dict=%p, key=\""%s\"", value=%p)\n"", dict, key, (void *)value); if (dict->num_pairs > 0) { _pdfio_pair_tpkey; pkey.key = key; if ((pair = (_pdfio_pair_t *)bsearch(&pkey, dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs)) != NULL) { PDFIO_DEBUG(""_pdfioDictSetValue: Replacing existing value.\n""); if (pair->value.type == PDFIO_VALTYPE_BINARY) free(pair->value.value.binary.data); pair->value = *value; return (true); } } if (dict->num_pairs >= dict->alloc_pairs) { _pdfio_pair_t *temp = (_pdfio_pair_t *)realloc(dict->pairs, (dict->alloc_pairs + 8) * sizeof(_pdfio_pair_t)); if (!temp) { PDFIO_DEBUG(""_pdfioDictSetValue: Out of memory.\n""); return (false); } dict->pairs       = temp; dict->alloc_pairs += 8; } pair = dict->pairs + dict->num_pairs; dict->num_pairs ++; pair->key   = key; pair->value = *value; if (dict->num_pairs > 1 && compare_pairs(pair - 1, pair) > 0) qsort(dict->pairs, dict->num_pairs, sizeof(_pdfio_pair_t), (int (*)(const void *, const void *))compare_pairs); #ifdef DEBUG PDFIO_DEBUG(""_pdfioDictSetValue(%p): %lu pairs\n"", (void *)dict, (unsigned long)dict->num_pairs); PDFIO_DEBUG(""_pdfioDictSetValue(%p): "", (void *)dict); PDFIO_DEBUG_DICT(dict); PDFIO_DEBUG(""\n""); #endif  return (true); }
Description:  PDFio is a C library for reading and writing PDF files. In versions prior to 1.1.0 a denial of service (DOS) vulnerability exists in the pdfio parser. Crafted pdf files can cause the program to run at 100% utilization and never terminate. The pdf which causes this crash found in testing is about 28kb in size and was discovered via fuzzing. Anyone who uses this library either as a standalone binary or as a library can be DOSed when attempting to parse this type of file. Web servers or other automated processes which rely on this code to turn pdf submissions into plaintext can be DOSed when an attacker uploads the pdf. Please see the linked GHSA for an example pdf. Users are advised to upgrade. There are no known workarounds for this vulnerability.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static bool load_buffer(RBinFile *bf, void **bin_obj, RBuffer *buf, ut64 loadaddr, Sdb *sdb) { RBuffer *fbuf = r_buf_ref (buf); struct MACH0_(opts_t) opts; MACH0_(opts_set_default) (&opts, bf); struct MACH0_(obj_t) *main_mach0 = MACH0_(new_buf) (fbuf, &opts); if (!main_mach0) { return false; } RRebaseInfo *rebase_info = r_rebase_info_new_from_mach0 (fbuf, main_mach0); RKernelCacheObj *obj = NULL; RPrelinkRange *prelink_range = get_prelink_info_range_from_mach0 (main_mach0); if (!prelink_range) { goto beach; } obj = R_NEW0 (RKernelCacheObj); if (!obj) { R_FREE (prelink_range); goto beach; } RCFValueDict *prelink_info = NULL; if (main_mach0->hdr.filetype != MH_FILESET && prelink_range->range.size) { prelink_info = r_cf_value_dict_parse (fbuf, prelink_range->range.offset, prelink_range->range.size, R_CF_OPTION_SKIP_NSDATA); if (!prelink_info) { R_FREE (prelink_range); R_FREE (obj); goto beach; } } if (!pending_bin_files) { pending_bin_files = r_list_new (); if (!pending_bin_files) { R_FREE (prelink_range); R_FREE (obj); R_FREE (prelink_info); goto beach; } } obj->mach0 = main_mach0; obj->rebase_info = rebase_info; obj->prelink_info = prelink_info; obj->cache_buf = fbuf; obj->pa2va_exec = prelink_range->pa2va_exec; obj->pa2va_data = prelink_range->pa2va_data; R_FREE (prelink_range); *bin_obj = obj; r_list_push (pending_bin_files, bf); if (rebase_info || main_mach0->chained_starts) { RIO *io = bf->rbin->iob.io; swizzle_io_read (obj, io); } return true; beach: r_buf_free (fbuf); obj->cache_buf = NULL; MACH0_(mach0_free) (main_mach0); return false; }
Description: NULL Pointer Dereference in GitHub repository radareorg/radare2 prior to 5.6.0.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void dcinit() { strsize=0; strmaxsize=DCSTRSIZE; dcstr=calloc(DCSTRSIZE,1); dcptr=dcstr; }
Description: A heap-based buffer overflow vulnerability was found in the function dcputs (called from decompileIMPLEMENTS) in util/decompile.c in Ming 0.4.8, which allows attackers to cause a denial of service via a crafted file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static s32 brcmf_cfg80211_start_ap(struct wiphy *wiphy, struct net_device *ndev, struct cfg80211_ap_settings *settings) { s32 ie_offset; struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy); struct brcmf_if *ifp = netdev_priv(ndev); const struct brcmf_tlv *ssid_ie; const struct brcmf_tlv *country_ie; struct brcmf_ssid_le ssid_le; s32 err = -EPERM; const struct brcmf_tlv *rsn_ie; const struct brcmf_vs_tlv *wpa_ie; struct brcmf_join_params join_params; enum nl80211_iftype dev_role; struct brcmf_fil_bss_enable_le bss_enable; u16 chanspec = chandef_to_chanspec(&cfg->d11inf, &settings->chandef); bool mbss; int is_11d; brcmf_dbg(TRACE, ""ctrlchn=%d, center=%d, bw=%d, beacon_interval=%d, dtim_period=%d,\n"", settings->chandef.chan->hw_value, settings->chandef.center_freq1, settings->chandef.width, settings->beacon_interval, settings->dtim_period); brcmf_dbg(TRACE, ""ssid=%s(%zu), auth_type=%d, inactivity_timeout=%d\n"", settings->ssid, settings->ssid_len, settings->auth_type, settings->inactivity_timeout); dev_role = ifp->vif->wdev.iftype; mbss = ifp->vif->mbss; brcmf_fil_cmd_int_get(ifp, BRCMF_C_GET_REGULATORY, &ifp->vif->is_11d); country_ie = brcmf_parse_tlvs((u8 *)settings->beacon.tail, settings->beacon.tail_len, WLAN_EID_COUNTRY); is_11d = country_ie ? 1 : 0; memset(&ssid_le, 0, sizeof(ssid_le)); if (settings->ssid == NULL || settings->ssid_len == 0) { ie_offset = DOT11_MGMT_HDR_LEN + DOT11_BCN_PRB_FIXED_LEN; ssid_ie = brcmf_parse_tlvs( (u8 *)&settings->beacon.head[ie_offset], settings->beacon.head_len - ie_offset, WLAN_EID_SSID); if (!ssid_ie) return -EINVAL; memcpy(ssid_le.SSID, ssid_ie->data, ssid_ie->len); ssid_le.SSID_len = cpu_to_le32(ssid_ie->len); brcmf_dbg(TRACE, ""SSID is (%s) in Head\n"", ssid_le.SSID); } else { memcpy(ssid_le.SSID, settings->ssid, settings->ssid_len); ssid_le.SSID_len = cpu_to_le32((u32)settings->ssid_len); } if (!mbss) { brcmf_set_mpc(ifp, 0); brcmf_configure_arp_nd_offload(ifp, false); } rsn_ie = brcmf_parse_tlvs((u8 *)settings->beacon.tail, settings->beacon.tail_len, WLAN_EID_RSN); wpa_ie = brcmf_find_wpaie((u8 *)settings->beacon.tail, settings->beacon.tail_len); if ((wpa_ie != NULL || rsn_ie != NULL)) { brcmf_dbg(TRACE, ""WPA(2) IE is found\n""); if (wpa_ie != NULL) { err = brcmf_configure_wpaie(ifp, wpa_ie, false); if (err < 0) goto exit; } else { struct brcmf_vs_tlv *tmp_ie; tmp_ie = (struct brcmf_vs_tlv *)rsn_ie; err = brcmf_configure_wpaie(ifp, tmp_ie, true); if (err < 0) goto exit; } } else { brcmf_dbg(TRACE, ""No WPA(2) IEs found\n""); brcmf_configure_opensecurity(ifp); } brcmf_config_ap_mgmt_ie(ifp->vif, &settings->beacon); if (!mbss) { if (is_11d != ifp->vif->is_11d) { err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_REGULATORY, is_11d); if (err < 0) { brcmf_err(""Regulatory Set Error, %d\n"", err); goto exit; } } if (settings->beacon_interval) { err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_BCNPRD, settings->beacon_interval); if (err < 0) { brcmf_err(""Beacon Interval Set Error, %d\n"", err); goto exit; } } if (settings->dtim_period) { err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_DTIMPRD, settings->dtim_period); if (err < 0) { brcmf_err(""DTIM Interval Set Error, %d\n"", err); goto exit; } } if ((dev_role == NL80211_IFTYPE_AP) && ((ifp->ifidx == 0) || !brcmf_feat_is_enabled(ifp, BRCMF_FEAT_RSDB))) { err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_DOWN, 1); if (err < 0) { brcmf_err(""BRCMF_C_DOWN error %d\n"", err); goto exit; } brcmf_fil_iovar_int_set(ifp, ""apsta"", 0); } err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_INFRA, 1); if (err < 0) { brcmf_err(""SET INFRA error %d\n"", err); goto exit; } } else if (WARN_ON(is_11d != ifp->vif->is_11d)) { err = -EINVAL; goto exit; } if (dev_role == NL80211_IFTYPE_AP) { if ((brcmf_feat_is_enabled(ifp, BRCMF_FEAT_MBSS)) && (!mbss)) brcmf_fil_iovar_int_set(ifp, ""mbss"", 1); err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_AP, 1); if (err < 0) { brcmf_err(""setting AP mode failed %d\n"", err); goto exit; } if (!mbss) { err = brcmf_fil_iovar_int_set(ifp, ""chanspec"", chanspec); if (err < 0) { brcmf_err(""Set Channel failed: chspec=%d, %d\n"", chanspec, err); goto exit; } } err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_UP, 1); if (err < 0) { brcmf_err(""BRCMF_C_UP error (%d)\n"", err); goto exit; } brcmf_cfg80211_reconfigure_wep(ifp); memset(&join_params, 0, sizeof(join_params)); memcpy(&join_params.ssid_le, &ssid_le, sizeof(ssid_le)); err = brcmf_fil_cmd_data_set(ifp, BRCMF_C_SET_SSID, &join_params, sizeof(join_params)); if (err < 0) { brcmf_err(""SET SSID error (%d)\n"", err); goto exit; } if (settings->hidden_ssid) { err = brcmf_fil_iovar_int_set(ifp, ""closednet"", 1); if (err) { brcmf_err(""closednet error (%d)\n"", err); goto exit; } } brcmf_dbg(TRACE, ""AP mode configuration complete\n""); } else if (dev_role == NL80211_IFTYPE_P2P_GO) { err = brcmf_fil_iovar_int_set(ifp, ""chanspec"", chanspec); if (err < 0) { brcmf_err(""Set Channel failed: chspec=%d, %d\n"", chanspec, err); goto exit; } err = brcmf_fil_bsscfg_data_set(ifp, ""ssid"", &ssid_le, sizeof(ssid_le)); if (err < 0) { brcmf_err(""setting ssid failed %d\n"", err); goto exit; } bss_enable.bsscfgidx = cpu_to_le32(ifp->bsscfgidx); bss_enable.enable = cpu_to_le32(1); err = brcmf_fil_iovar_data_set(ifp, ""bss"", &bss_enable, sizeof(bss_enable)); if (err < 0) { brcmf_err(""bss_enable config failed %d\n"", err); goto exit; } brcmf_dbg(TRACE, ""GO mode configuration complete\n""); } else { WARN_ON(1); } set_bit(BRCMF_VIF_STATUS_AP_CREATED, &ifp->vif->sme_state); brcmf_net_setcarrier(ifp, true); exit: if ((err) && (!mbss)) { brcmf_set_mpc(ifp, 1); brcmf_configure_arp_nd_offload(ifp, true); } return err; }
Description: Stack-based buffer overflow in the brcmf_cfg80211_start_ap function in drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c in the Linux kernel before 4.7.5 allows local users to cause a denial of service (system crash) or possibly have unspecified other impact via a long SSID Information Element in a command to a Netlink socket.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void initServerConfig() { server.port = REDIS_SERVERPORT; server.bindaddr = NULL; server.unixsocket = NULL; server.ipfd = -1; server.sofd = -1; server.dbnum = REDIS_DEFAULT_DBNUM; server.verbosity = REDIS_VERBOSE; server.maxidletime = REDIS_MAXIDLETIME; server.saveparams = NULL; server.loading = 0; server.logfile = NULL;  server.syslog_enabled = 0; server.syslog_ident = zstrdup(""redis""); server.syslog_facility = LOG_LOCAL0; server.glueoutputbuf = 1; server.daemonize = 0; server.appendonly = 0; server.appendfsync = APPENDFSYNC_EVERYSEC; server.no_appendfsync_on_rewrite = 0; server.lastfsync = time(NULL); server.appendfd = -1; server.appendseldb = -1;  server.pidfile = zstrdup(""/var/run/redis.pid""); server.dbfilename = zstrdup(""dump.rdb""); server.appendfilename = zstrdup(""appendonly.aof""); server.requirepass = NULL; server.rdbcompression = 1; server.activerehashing = 1; server.maxclients = 0; server.bpop_blocked_clients = 0; server.maxmemory = 0; server.maxmemory_policy = REDIS_MAXMEMORY_VOLATILE_LRU; server.maxmemory_samples = 3; server.vm_enabled = 0; server.vm_swap_file = zstrdup(""/tmp/redis-%p.vm""); server.vm_page_size = 256;           server.vm_pages = 1024*1024*100;     server.vm_max_memory = 1024LL*1024*1024*1;  server.vm_max_threads = 4; server.vm_blocked_clients = 0; server.hash_max_zipmap_entries = REDIS_HASH_MAX_ZIPMAP_ENTRIES; server.hash_max_zipmap_value = REDIS_HASH_MAX_ZIPMAP_VALUE; server.list_max_ziplist_entries = REDIS_LIST_MAX_ZIPLIST_ENTRIES; server.list_max_ziplist_value = REDIS_LIST_MAX_ZIPLIST_VALUE; server.set_max_intset_entries = REDIS_SET_MAX_INTSET_ENTRIES; server.shutdown_asap = 0; updateLRUClock(); resetServerSaveParams(); appendServerSaveParams(60*60,1);   appendServerSaveParams(300,100);   appendServerSaveParams(60,10000);  server.isslave = 0; server.masterauth = NULL; server.masterhost = NULL; server.masterport = 6379; server.master = NULL; server.replstate = REDIS_REPL_NONE; server.repl_serve_stale_data = 1; R_Zero = 0.0; R_PosInf = 1.0/R_Zero; R_NegInf = -1.0/R_Zero; R_Nan = R_Zero/R_Zero; server.commands = dictCreate(&commandTableDictType,NULL); populateCommandTable(); server.delCommand = lookupCommandByCString(""del""); server.multiCommand = lookupCommandByCString(""multi""); }
Description: Insecure temporary file vulnerability in Redis before 2.6 related to /tmp/redis-%p.vm.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void ModifiablePixelBuffer::fillRect(const Rect& r, const void* pix) { int stride; U8 *buf; int w, h, b; w = r.width(); h = r.height(); b = format.bpp/8; if (h == 0) return; buf = getBufferRW(r, &stride); if (b == 1) { while (h--) { memset(buf, *(const U8*)pix, w); buf += stride * b; } } else { U8 *start; int w1; start = buf; w1 = w; while (w1--) { memcpy(buf, pix, b); buf += b; } buf += (stride - w) * b; h--; while (h--) { memcpy(buf, start, w * b); buf += stride * b; } } commitBufferRW(r); }
Description: Buffer overflow in the ModifiablePixelBuffer::fillRect function in TigerVNC before 1.7.1 allows remote servers to execute arbitrary code via an RRE message with subrectangle outside framebuffer boundaries.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static gboolean handle_get_connection (GVfsDBusDaemon *object, GDBusMethodInvocation *invocation, gpointer user_data) { GVfsDaemon *daemon = G_VFS_DAEMON (user_data); GDBusServer *server; GError *error; gchar *address1; NewConnectionData *data; char *socket_dir; gchar *guid; generate_address (&address1, &socket_dir); data = g_new (NewConnectionData, 1); data->daemon = daemon; data->socket_dir = socket_dir; data->conn = NULL; guid = g_dbus_generate_guid (); error = NULL; server = g_dbus_server_new_sync (address1, G_DBUS_SERVER_FLAGS_NONE, guid, NULL,  NULL,  &error); g_free (guid); if (server == NULL) { g_dbus_method_invocation_return_gerror (invocation, error); g_printerr (""daemon: Error creating server at address %s: %s\n"", address1, error->message); g_error_free (error); goto error_out; } g_dbus_server_start (server); data->server = server; g_signal_connect (server, ""new-connection"", G_CALLBACK (daemon_new_connection_func), data); gvfs_dbus_daemon_complete_get_connection (object, invocation, address1, """"); g_free (address1); return TRUE; error_out: new_connection_data_free (data); g_free (address1); return TRUE; }
Description: daemon/gvfsdaemon.c in gvfsd from GNOME gvfs before 1.38.3, 1.40.x before 1.40.2, and 1.41.x before 1.41.3 opened a private D-Bus server socket without configuring an authorization rule. A local attacker could connect to this server socket and issue D-Bus method calls. (Note that the server socket only accepts a single connection, so the attacker would have to discover the server and connect to the socket before its owner does.)
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: inline int MatchingDim(const RuntimeShape& shape1, int index1, const RuntimeShape& shape2, int index2) { TFLITE_DCHECK_EQ(shape1.Dims(index1), shape2.Dims(index2)); return shape1.Dims(index1); }
Description: In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, when determining the common dimension size of two tensors, TFLite uses a `DCHECK` which is no-op outside of debug compilation modes. Since the function always returns the dimension of the first tensor, malicious attackers can craft cases where this is larger than that of the second tensor. In turn, this would result in reads/writes outside of bounds since the interpreter will wrongly assume that there is enough data in both tensors. The issue is patched in commit 8ee24e7949a203d234489f9da2c5bf45a7d5157d, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int ProcXkbGetKbdByName(ClientPtr client) { DeviceIntPtr dev; DeviceIntPtr tmpd; DeviceIntPtr master; xkbGetKbdByNameReply rep = { 0 }; xkbGetMapReply mrep = { 0 }; xkbGetCompatMapReply crep = { 0 }; xkbGetIndicatorMapReply irep = { 0 }; xkbGetNamesReply nrep = { 0 }; xkbGetGeometryReply grep = { 0 }; XkbComponentNamesRec names = { 0 }; XkbDescPtr xkb, new; XkbEventCauseRec cause; unsigned char *str; char mapFile[PATH_MAX]; unsigned len; unsigned fwant, fneed, reported; int status; Bool geom_changed; XkbSrvLedInfoPtr old_sli; XkbSrvLedInfoPtr sli; Mask access_mode = DixGetAttrAccess | DixManageAccess; REQUEST(xkbGetKbdByNameReq); REQUEST_AT_LEAST_SIZE(xkbGetKbdByNameReq); if (!(client->xkbClientFlags & _XkbClientInitialized)) return BadAccess; CHK_KBD_DEVICE(dev, stuff->deviceSpec, client, access_mode); master = GetMaster(dev, MASTER_KEYBOARD); xkb = dev->key->xkbInfo->desc; status = Success; str = (unsigned char *) &stuff[1]; if (GetComponentSpec(&str, TRUE, &status))   return BadMatch; names.keycodes = GetComponentSpec(&str, TRUE, &status); names.types = GetComponentSpec(&str, TRUE, &status); names.compat = GetComponentSpec(&str, TRUE, &status); names.symbols = GetComponentSpec(&str, TRUE, &status); names.geometry = GetComponentSpec(&str, TRUE, &status); if (status != Success) return status; len = str - ((unsigned char *) stuff); if ((XkbPaddedSize(len) / 4) != stuff->length) return BadLength; CHK_MASK_LEGAL(0x01, stuff->want, XkbGBN_AllComponentsMask); CHK_MASK_LEGAL(0x02, stuff->need, XkbGBN_AllComponentsMask); if (stuff->load) fwant = XkbGBN_AllComponentsMask; else fwant = stuff->want | stuff->need; if ((!names.compat) && (fwant & (XkbGBN_CompatMapMask | XkbGBN_IndicatorMapMask))) { names.compat = Xstrdup(""%""); } if ((!names.types) && (fwant & (XkbGBN_TypesMask))) { names.types = Xstrdup(""%""); } if ((!names.symbols) && (fwant & XkbGBN_SymbolsMask)) { names.symbols = Xstrdup(""%""); } geom_changed = ((names.geometry != NULL) && (strcmp(names.geometry, ""%"") != 0)); if ((!names.geometry) && (fwant & XkbGBN_GeometryMask)) { names.geometry = Xstrdup(""%""); geom_changed = FALSE; } memset(mapFile, 0, PATH_MAX); rep.type = X_Reply; rep.deviceID = dev->id; rep.sequenceNumber = client->sequence; rep.length = 0; rep.minKeyCode = xkb->min_key_code; rep.maxKeyCode = xkb->max_key_code; rep.loaded = FALSE; fwant = XkbConvertGetByNameComponents(TRUE, stuff->want) | XkmVirtualModsMask; fneed = XkbConvertGetByNameComponents(TRUE, stuff->need); rep.reported = XkbConvertGetByNameComponents(FALSE, fwant | fneed); if (stuff->load) { fneed |= XkmKeymapRequired; fwant |= XkmKeymapLegal; } if ((fwant | fneed) & XkmSymbolsMask) { fneed |= XkmKeyNamesIndex | XkmTypesIndex; fwant |= XkmIndicatorsIndex; } rep.found = XkbDDXLoadKeymapByNames(dev, &names, fwant, fneed, &new, mapFile, PATH_MAX); rep.newKeyboard = FALSE; rep.pad1 = rep.pad2 = rep.pad3 = rep.pad4 = 0; stuff->want |= stuff->need; if (new == NULL) rep.reported = 0; else { if (stuff->load) rep.loaded = TRUE; if (stuff->load || ((rep.reported & XkbGBN_SymbolsMask) && (new->compat))) { XkbChangesRec changes; memset(&changes, 0, sizeof(changes)); XkbUpdateDescActions(new, new->min_key_code, XkbNumKeys(new), &changes); } if (new->map == NULL) rep.reported &= ~(XkbGBN_SymbolsMask | XkbGBN_TypesMask); else if (rep.reported & (XkbGBN_SymbolsMask | XkbGBN_TypesMask)) { mrep.type = X_Reply; mrep.deviceID = dev->id; mrep.sequenceNumber = client->sequence; mrep.length = ((SIZEOF(xkbGetMapReply) - SIZEOF(xGenericReply)) >> 2); mrep.minKeyCode = new->min_key_code; mrep.maxKeyCode = new->max_key_code; mrep.present = 0; mrep.totalSyms = mrep.totalActs = mrep.totalKeyBehaviors = mrep.totalKeyExplicit = mrep.totalModMapKeys = mrep.totalVModMapKeys = 0; if (rep.reported & (XkbGBN_TypesMask | XkbGBN_ClientSymbolsMask)) { mrep.present |= XkbKeyTypesMask; mrep.firstType = 0; mrep.nTypes = mrep.totalTypes = new->map->num_types; } else { mrep.firstType = mrep.nTypes = 0; mrep.totalTypes = 0; } if (rep.reported & XkbGBN_ClientSymbolsMask) { mrep.present |= (XkbKeySymsMask | XkbModifierMapMask); mrep.firstKeySym = mrep.firstModMapKey = new->min_key_code; mrep.nKeySyms = mrep.nModMapKeys = XkbNumKeys(new); } else { mrep.firstKeySym = mrep.firstModMapKey = 0; mrep.nKeySyms = mrep.nModMapKeys = 0; } if (rep.reported & XkbGBN_ServerSymbolsMask) { mrep.present |= XkbAllServerInfoMask; mrep.virtualMods = ~0; mrep.firstKeyAct = mrep.firstKeyBehavior = mrep.firstKeyExplicit = new->min_key_code; mrep.nKeyActs = mrep.nKeyBehaviors = mrep.nKeyExplicit = XkbNumKeys(new); mrep.firstVModMapKey = new->min_key_code; mrep.nVModMapKeys = XkbNumKeys(new); } else { mrep.virtualMods = 0; mrep.firstKeyAct = mrep.firstKeyBehavior = mrep.firstKeyExplicit = 0; mrep.nKeyActs = mrep.nKeyBehaviors = mrep.nKeyExplicit = 0; } XkbComputeGetMapReplySize(new, &mrep); rep.length += SIZEOF(xGenericReply) / 4 + mrep.length; } if (new->compat == NULL) rep.reported &= ~XkbGBN_CompatMapMask; else if (rep.reported & XkbGBN_CompatMapMask) { crep.type = X_Reply; crep.deviceID = dev->id; crep.sequenceNumber = client->sequence; crep.length = 0; crep.groups = XkbAllGroupsMask; crep.firstSI = 0; crep.nSI = crep.nTotalSI = new->compat->num_si; XkbComputeGetCompatMapReplySize(new->compat, &crep); rep.length += SIZEOF(xGenericReply) / 4 + crep.length; } if (new->indicators == NULL) rep.reported &= ~XkbGBN_IndicatorMapMask; else if (rep.reported & XkbGBN_IndicatorMapMask) { irep.type = X_Reply; irep.deviceID = dev->id; irep.sequenceNumber = client->sequence; irep.length = 0; irep.which = XkbAllIndicatorsMask; XkbComputeGetIndicatorMapReplySize(new->indicators, &irep); rep.length += SIZEOF(xGenericReply) / 4 + irep.length; } if (new->names == NULL) rep.reported &= ~(XkbGBN_OtherNamesMask | XkbGBN_KeyNamesMask); else if (rep.reported & (XkbGBN_OtherNamesMask | XkbGBN_KeyNamesMask)) { nrep.type = X_Reply; nrep.deviceID = dev->id; nrep.sequenceNumber = client->sequence; nrep.length = 0; nrep.minKeyCode = new->min_key_code; nrep.maxKeyCode = new->max_key_code; if (rep.reported & XkbGBN_OtherNamesMask) { nrep.which = XkbAllNamesMask; if (new->map != NULL) nrep.nTypes = new->map->num_types; else nrep.nTypes = 0; nrep.nKTLevels = 0; nrep.groupNames = XkbAllGroupsMask; nrep.virtualMods = XkbAllVirtualModsMask; nrep.indicators = XkbAllIndicatorsMask; nrep.nRadioGroups = new->names->num_rg; } else { nrep.which = 0; nrep.nTypes = 0; nrep.nKTLevels = 0; nrep.groupNames = 0; nrep.virtualMods = 0; nrep.indicators = 0; nrep.nRadioGroups = 0; } if (rep.reported & XkbGBN_KeyNamesMask) { nrep.which |= XkbKeyNamesMask; nrep.firstKey = new->min_key_code; nrep.nKeys = XkbNumKeys(new); nrep.nKeyAliases = new->names->num_key_aliases; if (nrep.nKeyAliases) nrep.which |= XkbKeyAliasesMask; } else { nrep.which &= ~(XkbKeyNamesMask | XkbKeyAliasesMask); nrep.firstKey = nrep.nKeys = 0; nrep.nKeyAliases = 0; } XkbComputeGetNamesReplySize(new, &nrep); rep.length += SIZEOF(xGenericReply) / 4 + nrep.length; } if (new->geom == NULL) rep.reported &= ~XkbGBN_GeometryMask; else if (rep.reported & XkbGBN_GeometryMask) { grep.type = X_Reply; grep.deviceID = dev->id; grep.sequenceNumber = client->sequence; grep.length = 0; grep.found = TRUE; grep.pad = 0; grep.widthMM = grep.heightMM = 0; grep.nProperties = grep.nColors = grep.nShapes = 0; grep.nSections = grep.nDoodads = 0; grep.baseColorNdx = grep.labelColorNdx = 0; XkbComputeGetGeometryReplySize(new->geom, &grep, None); rep.length += SIZEOF(xGenericReply) / 4 + grep.length; } } reported = rep.reported; if (client->swapped) { swaps(&rep.sequenceNumber); swapl(&rep.length); swaps(&rep.found); swaps(&rep.reported); } WriteToClient(client, SIZEOF(xkbGetKbdByNameReply), &rep); if (reported & (XkbGBN_SymbolsMask | XkbGBN_TypesMask)) XkbSendMap(client, new, &mrep); if (reported & XkbGBN_CompatMapMask) XkbSendCompatMap(client, new->compat, &crep); if (reported & XkbGBN_IndicatorMapMask) XkbSendIndicatorMap(client, new->indicators, &irep); if (reported & (XkbGBN_KeyNamesMask | XkbGBN_OtherNamesMask)) XkbSendNames(client, new, &nrep); if (reported & XkbGBN_GeometryMask) XkbSendGeometry(client, new->geom, &grep, FALSE); if (rep.loaded) { XkbDescPtr old_xkb; xkbNewKeyboardNotify nkn; old_xkb = xkb; xkb = new; dev->key->xkbInfo->desc = xkb; new = old_xkb;           XkbCopyControls(xkb, old_xkb); nkn.deviceID = nkn.oldDeviceID = dev->id; nkn.minKeyCode = new->min_key_code; nkn.maxKeyCode = new->max_key_code; nkn.oldMinKeyCode = xkb->min_key_code; nkn.oldMaxKeyCode = xkb->max_key_code; nkn.requestMajor = XkbReqCode; nkn.requestMinor = X_kbGetKbdByName; nkn.changed = XkbNKN_KeycodesMask; if (geom_changed) nkn.changed |= XkbNKN_GeometryMask; XkbSendNewKeyboardNotify(dev, &nkn); for (tmpd = inputInfo.devices; tmpd; tmpd = tmpd->next) { if (tmpd != dev && GetMaster(tmpd, MASTER_KEYBOARD) != dev && (tmpd != master || dev != master->lastSlave)) continue; if (tmpd != dev) XkbDeviceApplyKeymap(tmpd, xkb); if (tmpd->kbdfeed && tmpd->kbdfeed->xkb_sli) { old_sli = tmpd->kbdfeed->xkb_sli; tmpd->kbdfeed->xkb_sli = NULL; sli = XkbAllocSrvLedInfo(tmpd, tmpd->kbdfeed, NULL, 0); if (sli) { sli->explicitState = old_sli->explicitState; sli->effectiveState = old_sli->effectiveState; } tmpd->kbdfeed->xkb_sli = sli; XkbFreeSrvLedInfo(old_sli); } } } if ((new != NULL) && (new != xkb)) { XkbFreeKeyboard(new, XkbAllComponentsMask, TRUE); new = NULL; } XkbFreeComponentNames(&names, FALSE); XkbSetCauseXkbReq(&cause, X_kbGetKbdByName, client); XkbUpdateAllDeviceIndicators(NULL, &cause); return Success; }
Description: A vulnerability, which was classified as problematic, has been found in X.org Server. Affected by this issue is the function ProcXkbGetKbdByName of the file xkb/xkb.c. The manipulation leads to memory leak. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211052.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int steal_page( struct domain *d, struct page_info *page, unsigned int memflags) { unsigned long x, y; bool_t drop_dom_ref = 0; const struct domain *owner = dom_xen; spin_lock(&d->page_alloc_lock); if ( is_xen_heap_page(page) || ((owner = page_get_owner(page)) != d) ) goto fail; y = page->count_info; do { x = y; if ( (x & (PGC_count_mask|PGC_allocated)) != (1 | PGC_allocated) ) goto fail; y = cmpxchg(&page->count_info, x, x & ~PGC_count_mask); } while ( y != x ); BUG_ON(page->u.inuse.type_info & (PGT_count_mask | PGT_locked | PGT_pinned)); page->u.inuse.type_info = 0; page_set_owner(page, NULL); y = page->count_info; do { x = y; BUG_ON((x & (PGC_count_mask|PGC_allocated)) != PGC_allocated); } while ( (y = cmpxchg(&page->count_info, x, x | 1)) != x ); if ( !(memflags & MEMF_no_refcount) && !domain_adjust_tot_pages(d, -1) ) drop_dom_ref = 1; page_list_del(page, &d->page_list); spin_unlock(&d->page_alloc_lock); if ( unlikely(drop_dom_ref) ) put_domain(d); return 0; fail: spin_unlock(&d->page_alloc_lock); gdprintk(XENLOG_WARNING, ""Bad steal mfn %"" PRI_mfn "" from d%d (owner d%d) caf=%08lx taf=%"" PRtype_info ""\n"", page_to_mfn(page), d->domain_id, owner ? owner->domain_id : DOMID_INVALID, page->count_info, page->u.inuse.type_info); return -1; }
Description: Xen through 4.8.x mishandles page transfer, which allows guest OS users to obtain privileged host OS access, aka XSA-217.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static ssize_t drop_sync(QIOChannel *ioc, size_t size) { ssize_t ret = 0; char small[1024]; char *buffer; buffer = sizeof(small) < size ? small : g_malloc(MIN(65536, size)); while (size > 0) { ssize_t count = read_sync(ioc, buffer, MIN(65536, size)); if (count <= 0) { goto cleanup; } assert(count <= size); size -= count; ret += count; } cleanup: if (buffer != small) { g_free(buffer); } return ret; }
Description: A stack buffer overflow flaw was found in the Quick Emulator (QEMU) before 2.9 built with the Network Block Device (NBD) client support. The flaw could occur while processing server's response to a 'NBD_OPT_LIST' request. A malicious NBD server could use this issue to crash a remote NBD client resulting in DoS or potentially execute arbitrary code on client host with privileges of the QEMU process.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void clear() { req = crow::request(); header_field.clear(); header_value.clear(); header_building_state = 0; qs_point = 0; }
Description: HTTP applications (servers) based on Crow through 1.0+4 may allow a Use-After-Free and code execution when HTTP pipelining is used. The HTTP parser supports HTTP pipelining, but the asynchronous Connection layer is unaware of HTTP pipelining. Specifically, the Connection layer is unaware that it has begun processing a later request before it has finished processing an earlier request.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool L2NormalizeReduceAxis(Value sq_op, DenseElementsAttr axis) { if (sq_op.getType().cast<ShapedType>().getRank() - 1 == *axis.getValues<int>().begin() || *axis.getValues<int>().begin() == -1) { return true; } if (sq_op.getType().cast<ShapedType>().getRank() != axis.getNumElements()) { return false; } auto shape = sq_op.getType().cast<ShapedType>(); SmallVector<int, 4> elems{axis.getValues<int>().begin(), axis.getValues<int>().end()}; for (int i = 0; i < shape.getRank(); ++i) { if (i != elems[i]) return false; } return true; }
Description: TensorFlow is an end-to-end open source platform for machine learning. In affected versions an attacker can craft a TFLite model that would trigger a null pointer dereference, which would result in a crash and denial of service. This is caused by the MLIR optimization of `L2NormalizeReduceAxis` operator. The [implementation](https://github.com/tensorflow/tensorflow/blob/149562d49faa709ea80df1d99fc41d005b81082a/tensorflow/compiler/mlir/lite/transforms/optimize.cc#L67-L70) unconditionally dereferences a pointer to an iterator to a vector without checking that the vector has elements. We have patched the issue in GitHub commit d6b57f461b39fd1aa8c1b870f1b974aac3554955. The fix will be included in TensorFlow 2.6.0. We will also cherrypick this commit on TensorFlow 2.5.1, TensorFlow 2.4.3, and TensorFlow 2.3.4, as these are also affected and still in supported range.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: unsigned find_file(const StringList & sl, String & filename) { StringListEnumeration els = sl.elements_obj(); const char * dir; String path; while ( (dir = els.next()) != 0 )  { path = dir; if (path.back() != '/') path += '/'; unsigned dir_len = path.size(); path += filename; if (file_exists(path)) { filename.swap(path); return dir_len; } } return 0; }
Description: libaspell.a in GNU Aspell before 0.60.8 has a stack-based buffer over-read in acommon::unescape in common/getdata.cpp via an isolated \ character.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: OPJ_BOOL opj_tcd_update_tile_data ( opj_tcd_t *p_tcd, OPJ_BYTE * p_dest, OPJ_UINT32 p_dest_length ) { OPJ_UINT32 i,j,k,l_data_size = 0; opj_image_comp_t * l_img_comp = 00; opj_tcd_tilecomp_t * l_tilec = 00; opj_tcd_resolution_t * l_res; OPJ_UINT32 l_size_comp, l_remaining; OPJ_UINT32 l_stride, l_width,l_height; l_data_size = opj_tcd_get_decoded_tile_size(p_tcd); if (l_data_size > p_dest_length) { return OPJ_FALSE; } l_tilec = p_tcd->tcd_image->tiles->comps; l_img_comp = p_tcd->image->comps; for (i=0;i<p_tcd->image->numcomps;++i) { l_size_comp = l_img_comp->prec >> 3;  l_remaining = l_img_comp->prec & 7;   l_res = l_tilec->resolutions + l_img_comp->resno_decoded; l_width = (OPJ_UINT32)(l_res->x1 - l_res->x0); l_height = (OPJ_UINT32)(l_res->y1 - l_res->y0); l_stride = (OPJ_UINT32)(l_tilec->x1 - l_tilec->x0) - l_width; if (l_remaining) { ++l_size_comp; } if (l_size_comp == 3) { l_size_comp = 4; } switch (l_size_comp) { case 1: { OPJ_CHAR * l_dest_ptr = (OPJ_CHAR *) p_dest; const OPJ_INT32 * l_src_ptr = l_tilec->data; if (l_img_comp->sgnd) { for (j=0;j<l_height;++j) { for (k=0;k<l_width;++k) { *(l_dest_ptr++) = (OPJ_CHAR) (*(l_src_ptr++)); } l_src_ptr += l_stride; } } else { for (j=0;j<l_height;++j) { for     (k=0;k<l_width;++k) { *(l_dest_ptr++) = (OPJ_CHAR) ((*(l_src_ptr++))&0xff); } l_src_ptr += l_stride; } } p_dest = (OPJ_BYTE *)l_dest_ptr; } break; case 2: { const OPJ_INT32 * l_src_ptr = l_tilec->data; OPJ_INT16 * l_dest_ptr = (OPJ_INT16 *) p_dest; if (l_img_comp->sgnd) { for (j=0;j<l_height;++j) { for (k=0;k<l_width;++k) { *(l_dest_ptr++) = (OPJ_INT16) (*(l_src_ptr++)); } l_src_ptr += l_stride; } } else { for (j=0;j<l_height;++j) { for (k=0;k<l_width;++k) { *(l_dest_ptr++) = (OPJ_INT16) ((*(l_src_ptr++))&0xffff); } l_src_ptr += l_stride; } } p_dest = (OPJ_BYTE*) l_dest_ptr; } break; case 4: { OPJ_INT32 * l_dest_ptr = (OPJ_INT32 *) p_dest; OPJ_INT32 * l_src_ptr = l_tilec->data; for (j=0;j<l_height;++j) { for (k=0;k<l_width;++k) { *(l_dest_ptr++) = (*(l_src_ptr++)); } l_src_ptr += l_stride; } p_dest = (OPJ_BYTE*) l_dest_ptr; } break; } ++l_img_comp; ++l_tilec; } return OPJ_TRUE; }
Description: Integer overflow in the opj_tcd_get_decoded_tile_size function in tcd.c in OpenJPEG, as used in PDFium in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux, allows remote attackers to cause a denial of service (heap-based buffer overflow) or possibly have unspecified other impact via crafted JPEG 2000 data.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int ksmbd_conn_handler_loop(void *p) { struct ksmbd_conn *conn = (struct ksmbd_conn *)p; struct ksmbd_transport *t = conn->transport; unsigned int pdu_size, max_allowed_pdu_size; char hdr_buf[4] = {0,}; int size; mutex_init(&conn->srv_mutex); __module_get(THIS_MODULE); if (t->ops->prepare && t->ops->prepare(t)) goto out; conn->last_active = jiffies; while (ksmbd_conn_alive(conn)) { if (try_to_freeze()) continue; kvfree(conn->request_buf); conn->request_buf = NULL; size = t->ops->read(t, hdr_buf, sizeof(hdr_buf), -1); if (size != sizeof(hdr_buf)) break; pdu_size = get_rfc1002_len(hdr_buf); ksmbd_debug(CONN, ""RFC1002 header %u bytes\n"", pdu_size); if (ksmbd_conn_good(conn)) max_allowed_pdu_size = SMB3_MAX_MSGSIZE + conn->vals->max_write_size; else max_allowed_pdu_size = SMB3_MAX_MSGSIZE; if (pdu_size > max_allowed_pdu_size) { pr_err_ratelimited(""PDU length(%u) exceeded maximum allowed pdu size(%u) on connection(%d)\n"", pdu_size, max_allowed_pdu_size, READ_ONCE(conn->status)); break; } if (pdu_size > MAX_STREAM_PROT_LEN) break; size = pdu_size + 4 + 1; conn->request_buf = kvmalloc(size, GFP_KERNEL); if (!conn->request_buf) break; memcpy(conn->request_buf, hdr_buf, sizeof(hdr_buf)); if (!ksmbd_smb_request(conn)) break; size = t->ops->read(t, conn->request_buf + 4, pdu_size, 2); if (size < 0) { pr_err(""sock_read failed: %d\n"", size); break; } if (size != pdu_size) { pr_err(""PDU error. Read: %d, Expected: %d\n"", size, pdu_size); continue; } if (!default_conn_ops.process_fn) { pr_err(""No connection request callback\n""); break; } if (default_conn_ops.process_fn(conn)) { pr_err(""Cannot handle request\n""); break; } } out: ksmbd_conn_set_releasing(conn); wait_event(conn->r_count_q, atomic_read(&conn->r_count) == 0); if (IS_ENABLED(CONFIG_UNICODE)) utf8_unload(conn->um); unload_nls(conn->local_nls); if (default_conn_ops.terminate_fn) default_conn_ops.terminate_fn(conn); t->ops->disconnect(t); module_put(THIS_MODULE); return 0; }
Description: An issue was discovered in the Linux kernel before 6.3.8. fs/smb/server/connection.c in ksmbd does not validate the relationship between the NetBIOS header's length field and the SMB header sizes, via pdu_size in ksmbd_conn_handler_loop, leading to an out-of-bounds read.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int vfio_pci_create_msix_table(struct kvm *kvm, struct vfio_device *vdev) { int ret; size_t i; size_t map_size; size_t nr_entries; struct vfio_pci_msi_entry *entries; struct vfio_pci_device *pdev = &vdev->pci; struct vfio_pci_msix_pba *pba = &pdev->msix_pba; struct vfio_pci_msix_table *table = &pdev->msix_table; struct msix_cap *msix = PCI_CAP(&pdev->hdr, pdev->msix.pos); struct vfio_region_info info; table->bar = msix->table_offset & PCI_MSIX_TABLE_BIR; pba->bar = msix->pba_offset & PCI_MSIX_TABLE_BIR; nr_entries = (msix->ctrl & PCI_MSIX_FLAGS_QSIZE) + 1; table->size = ALIGN(nr_entries * PCI_MSIX_ENTRY_SIZE, 8); pba->size = ALIGN(DIV_ROUND_UP(nr_entries, 64), 8); entries = calloc(nr_entries, sizeof(struct vfio_pci_msi_entry)); if (!entries) return -ENOMEM; for (i = 0; i < nr_entries; i++) entries[i].config.ctrl = PCI_MSIX_ENTRY_CTRL_MASKBIT; ret = vfio_pci_get_region_info(vdev, table->bar, &info); if (ret) return ret; if (!info.size) return -EINVAL; map_size = ALIGN(info.size, PAGE_SIZE); table->guest_phys_addr = pci_get_mmio_block(map_size); if (!table->guest_phys_addr) { pr_err(""cannot allocate MMIO space""); ret = -ENOMEM; goto out_free; } if (table->bar == pba->bar) { u32 pba_bar_offset = msix->pba_offset & PCI_MSIX_PBA_OFFSET; if (table->size > pba_bar_offset) die(""MSIX table overlaps with PBA""); if (pba_bar_offset + pba->size > info.size) die(""PBA exceeds the size of the region""); pba->guest_phys_addr = table->guest_phys_addr + pba_bar_offset; } else { ret = vfio_pci_get_region_info(vdev, pba->bar, &info); if (ret) return ret; if (!info.size) return -EINVAL; map_size = ALIGN(info.size, PAGE_SIZE); pba->guest_phys_addr = pci_get_mmio_block(map_size); if (!pba->guest_phys_addr) { pr_err(""cannot allocate MMIO space""); ret = -ENOMEM; goto out_free; } } pdev->msix.entries = entries; pdev->msix.nr_entries = nr_entries; return 0; out_free: free(entries); return ret; }
Description: kvmtool through 39181fc allows an out-of-bounds write, related to virtio/balloon.c and virtio/pci.c. This allows a guest OS user to execute arbitrary code on the host machine.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static status encodeJsonStructure(const void *src, const UA_DataType *type, CtxJson *ctx) { if(ctx->depth > UA_JSON_ENCODING_MAX_RECURSION) return UA_STATUSCODE_BADENCODINGERROR; ctx->depth++; status ret = writeJsonObjStart(ctx); uintptr_t ptr = (uintptr_t) src; u8 membersSize = type->membersSize; const UA_DataType * typelists[2] = {UA_TYPES, &type[-type->typeIndex]}; for(size_t i = 0; i < membersSize && ret == UA_STATUSCODE_GOOD; ++i) { const UA_DataTypeMember *m = &type->members[i]; const UA_DataType *mt = &typelists[!m->namespaceZero][m->memberTypeIndex]; if(m->memberName != NULL && *m->memberName != 0) ret |= writeJsonKey(ctx, m->memberName); if(!m->isArray) { ptr += m->padding; size_t memSize = mt->memSize; ret |= encodeJsonJumpTable[mt->typeKind]((const void*) ptr, mt, ctx); ptr += memSize; } else { ptr += m->padding; const size_t length = *((const size_t*) ptr); ptr += sizeof (size_t); ret |= encodeJsonArray(ctx, *(void * const *)ptr, length, mt); ptr += sizeof (void*); } } ret |= writeJsonObjEnd(ctx); ctx->depth--; return ret; }
Description: Variant_encodeJson in open62541 1.x before 1.0.4 has an out-of-bounds write for a large recursion depth.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void print_timer(struct seq_file *m, struct hrtimer *taddr, struct hrtimer *timer, int idx, u64 now) { #ifdef CONFIG_TIMER_STATS char tmp[TASK_COMM_LEN + 1]; #endif SEQ_printf(m, "" #%d: "", idx); print_name_offset(m, taddr); SEQ_printf(m, "", ""); print_name_offset(m, timer->function); SEQ_printf(m, "", S:%02x"", timer->state); #ifdef CONFIG_TIMER_STATS SEQ_printf(m, "", ""); print_name_offset(m, timer->start_site); memcpy(tmp, timer->start_comm, TASK_COMM_LEN); tmp[TASK_COMM_LEN] = 0; SEQ_printf(m, "", %s/%d"", tmp, timer->start_pid); #endif SEQ_printf(m, ""\n""); SEQ_printf(m, "" # expires at %Lu-%Lu nsecs [in %Ld to %Ld nsecs]\n"", (unsigned long long)ktime_to_ns(hrtimer_get_softexpires(timer)), (unsigned long long)ktime_to_ns(hrtimer_get_expires(timer)), (long long)(ktime_to_ns(hrtimer_get_softexpires(timer)) - now), (long long)(ktime_to_ns(hrtimer_get_expires(timer)) - now)); }
Description: The time subsystem in the Linux kernel through 4.9.9, when CONFIG_TIMER_STATS is enabled, allows local users to discover real PID values (as distinguished from PID values inside a PID namespace) by reading the /proc/timer_list file, related to the print_timer function in kernel/time/timer_list.c and the __timer_stats_timer_set_start_info function in kernel/time/timer.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception) { char **attribute, **attributes, *tag, *utf8; int c, terminal; MagickBooleanType status; register char *p; register ssize_t i; size_t ignore_depth, length; ssize_t j, l; XMLTreeRoot *root; if ((xml == (const char *) NULL) || (strlen(xml) == 0)) { (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning, ""ParseError"",""root tag missing""); return((XMLTreeInfo *) NULL); } root=(XMLTreeRoot *) NewXMLTreeTag((char *) NULL); length=strlen(xml); utf8=ConvertUTF16ToUTF8(xml,&length); if (utf8 == (char *) NULL) { (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning, ""ParseError"",""UTF16 to UTF8 failed""); return((XMLTreeInfo *) NULL); } terminal=utf8[length-1]; utf8[length-1]='\0'; p=utf8; while ((*p != '\0') && (*p != '<')) p++; if (*p == '\0') { (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning, ""ParseError"",""root tag missing""); utf8=DestroyString(utf8); return((XMLTreeInfo *) NULL); } attribute=(char **) NULL; l=0; ignore_depth=0; for (p++; ; p++) { attributes=(char **) sentinel; tag=p; c=(*p); if ((isalpha((int) ((unsigned char) *p)) !=0) || (*p == '_') || (*p == ':') || (c < '\0')) { if (root->node == (XMLTreeInfo *) NULL) { (void) ThrowMagickException(exception,GetMagickModule(), OptionWarning,""ParseError"",""root tag missing""); utf8=DestroyString(utf8); return(&root->root); } p+=strcspn(p,XMLWhitespace ""/>""); while (isspace((int) ((unsigned char) *p)) != 0) *p++='\0'; if (ignore_depth == 0) { if ((*p != '\0') && (*p != '/') && (*p != '>')) { i=0; while ((root->attributes[i] != (char **) NULL) && (strcmp(root->attributes[i][0],tag) != 0)) i++; attribute=root->attributes[i]; } for (l=0; (*p != '\0') && (*p != '/') && (*p != '>'); l+=2) { if (l == 0) attributes=(char **) AcquireQuantumMemory(4, sizeof(*attributes)); else attributes=(char **) ResizeQuantumMemory(attributes, (size_t) (l+4),sizeof(*attributes)); if (attributes == (char **) NULL) { (void) ThrowMagickException(exception,GetMagickModule(), ResourceLimitError,""MemoryAllocationFailed"",""`%s'"",""""); utf8=DestroyString(utf8); return(&root->root); } attributes[l+2]=(char *) NULL; attributes[l+1]=(char *) NULL; attributes[l]=p; p+=strcspn(p,XMLWhitespace ""=/>""); if ((*p != '=') && (isspace((int) ((unsigned char) *p)) == 0)) attributes[l]=ConstantString(""""); else { *p++='\0'; p+=strspn(p,XMLWhitespace ""=""); c=(*p); if ((c == '""') || (c == '\'')) { p++; attributes[l+1]=p; while ((*p != '\0') && (*p != c)) p++; if (*p != '\0') *p++='\0'; else { attributes[l]=ConstantString(""""); attributes[l+1]=ConstantString(""""); (void) DestroyXMLTreeAttributes(attributes); (void) ThrowMagickException(exception, GetMagickModule(),OptionWarning,""ParseError"", ""missing %c"",c); utf8=DestroyString(utf8); return(&root->root); } j=1; while ((attribute != (char **) NULL) && (attribute[j] != (char *) NULL) && (strcmp(attribute[j],attributes[l]) != 0)) j+=3; attributes[l+1]=ParseEntities(attributes[l+1], root->entities,(attribute != (char **) NULL) && (attribute[j] != (char *) NULL) ? *attribute[j+2] : ' '); } attributes[l]=ConstantString(attributes[l]); } while (isspace((int) ((unsigned char) *p)) != 0) p++; } } else { while((*p != '\0') && (*p != '/') && (*p != '>')) p++; } if (*p == '/') { *p++='\0'; if (((*p != '\0') && (*p != '>')) || ((*p == '\0') && (terminal != '>'))) { if (l != 0) (void) DestroyXMLTreeAttributes(attributes); (void) ThrowMagickException(exception,GetMagickModule(), OptionWarning,""ParseError"",""missing >""); utf8=DestroyString(utf8); return(&root->root); } if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse)) { ParseOpenTag(root,tag,attributes); (void) ParseCloseTag(root,tag,exception); } } else { c=(*p); if ((*p == '>') || ((*p == '\0') && (terminal == '>'))) { *p='\0'; if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse)) ParseOpenTag(root,tag,attributes); else ignore_depth++; *p=c; } else { if (l != 0) (void) DestroyXMLTreeAttributes(attributes); (void) ThrowMagickException(exception,GetMagickModule(), OptionWarning,""ParseError"",""missing >""); utf8=DestroyString(utf8); return(&root->root); } } } else if (*p == '/') { tag=p+1; p+=strcspn(tag,XMLWhitespace "">"")+1; c=(*p); if ((c == '\0') && (terminal != '>')) { (void) ThrowMagickException(exception,GetMagickModule(), OptionWarning,""ParseError"",""missing >""); utf8=DestroyString(utf8); return(&root->root); } *p='\0'; if (ignore_depth == 0 && ParseCloseTag(root,tag,exception) != (XMLTreeInfo *) NULL) { utf8=DestroyString(utf8); return(&root->root); } if (ignore_depth > 0) ignore_depth--; *p=c; if (isspace((int) ((unsigned char) *p)) != 0) p+=strspn(p,XMLWhitespace); } else if (strncmp(p,""!--"",3) == 0) { p=strstr(p+3,""--""); if ((p == (char *) NULL) || ((*(p+=2) != '>') && (*p != '\0')) || ((*p == '\0') && (terminal != '>'))) { (void) ThrowMagickException(exception,GetMagickModule(), OptionWarning,""ParseError"",""unclosed <!--""); utf8=DestroyString(utf8); return(&root->root); } } else if (strncmp(p,""![CDATA["",8) == 0) { p=strstr(p,""]]>""); if (p != (char *) NULL) { p+=2; if (ignore_depth == 0) ParseCharacterContent(root,tag+8,(size_t) (p-tag-10),'c'); } else { (void) ThrowMagickException(exception,GetMagickModule(), OptionWarning,""ParseError"",""unclosed <![CDATA[""); utf8=DestroyString(utf8); return(&root->root); } } else if (strncmp(p,""!DOCTYPE"",8) == 0) { for (l=0; (*p != '\0') && (((l == 0) && (*p != '>')) || ((l != 0) && ((*p != ']') || (*(p+strspn(p+1,XMLWhitespace)+1) != '>')))); l=(ssize_t) ((*p == '[') ? 1 : l)) p+=strcspn(p+1,""[]>"")+1; if ((*p == '\0') && (terminal != '>')) { (void) ThrowMagickException(exception,GetMagickModule(), OptionWarning,""ParseError"",""unclosed <!DOCTYPE""); utf8=DestroyString(utf8); return(&root->root); } if (l != 0) tag=strchr(tag,'[')+1; if (l != 0) { status=ParseInternalDoctype(root,tag,(size_t) (p-tag), exception); if (status == MagickFalse) { utf8=DestroyString(utf8); return(&root->root); } p++; } } else if (*p == '?') { do { p=strchr(p,'?'); if (p == (char *) NULL) break; p++; } while ((*p != '\0') && (*p != '>')); if ((p == (char *) NULL) || ((*p == '\0') && (terminal != '>'))) { (void) ThrowMagickException(exception,GetMagickModule(), OptionWarning,""ParseError"",""unclosed <?""); utf8=DestroyString(utf8); return(&root->root); } ParseProcessingInstructions(root,tag+1,(size_t) (p-tag-2)); } else { (void) ThrowMagickException(exception,GetMagickModule(), OptionWarning,""ParseError"",""unexpected <""); utf8=DestroyString(utf8); return(&root->root); } if ((p == (char *) NULL) || (*p == '\0')) break; *p++='\0'; tag=p; if ((*p != '\0') && (*p != '<')) { while ((*p != '\0') && (*p != '<')) p++; if (*p == '\0') break; if (ignore_depth == 0) ParseCharacterContent(root,tag,(size_t) (p-tag),'&'); } else if (*p == '\0') break; } utf8=DestroyString(utf8); if (root->node == (XMLTreeInfo *) NULL) return(&root->root); if (root->node->tag == (char *) NULL) { (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning, ""ParseError"",""root tag missing""); return(&root->root); } (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning, ""ParseError"",""unclosed tag: `%s'"",root->node->tag); return(&root->root); }
Description: Memory leak in the NewXMLTree function in magick/xml-tree.c in ImageMagick before 6.9.4-7 allows remote attackers to cause a denial of service (memory consumption) via a crafted XML file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void vmx_vcpu_load_vmcs(struct kvm_vcpu *vcpu, int cpu, struct loaded_vmcs *buddy) { struct vcpu_vmx *vmx = to_vmx(vcpu); bool already_loaded = vmx->loaded_vmcs->cpu == cpu; struct vmcs *prev; if (!already_loaded) { loaded_vmcs_clear(vmx->loaded_vmcs); local_irq_disable(); smp_rmb(); list_add(&vmx->loaded_vmcs->loaded_vmcss_on_cpu_link, &per_cpu(loaded_vmcss_on_cpu, cpu)); local_irq_enable(); } prev = per_cpu(current_vmcs, cpu); if (prev != vmx->loaded_vmcs->vmcs) { per_cpu(current_vmcs, cpu) = vmx->loaded_vmcs->vmcs; vmcs_load(vmx->loaded_vmcs->vmcs); if (!buddy || WARN_ON_ONCE(buddy->vmcs != prev)) indirect_branch_prediction_barrier(); } if (!already_loaded) { void *gdt = get_current_gdt_ro(); kvm_make_request(KVM_REQ_TLB_FLUSH, vcpu); vmcs_writel(HOST_TR_BASE, (unsigned long)&get_cpu_entry_area(cpu)->tss.x86_tss); vmcs_writel(HOST_GDTR_BASE, (unsigned long)gdt);    if (IS_ENABLED(CONFIG_IA32_EMULATION) || IS_ENABLED(CONFIG_X86_32)) { vmcs_writel(HOST_IA32_SYSENTER_ESP, (unsigned long)(cpu_entry_stack(cpu) + 1)); } vmx->loaded_vmcs->cpu = cpu; } }
Description: A regression exists in the Linux Kernel within KVM: nVMX that allowed for speculative execution attacks. L2 can carry out Spectre v2 attacks on L1 due to L1 thinking it doesn't need retpolines or IBPB after running L2 due to KVM (L0) advertising eIBRS support to L1. An attacker at L2 with code execution can execute code on an indirect branch on the host machine. We recommend upgrading to Kernel 6.2 or past commit 2e7eab81425a

 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static BOOL handle_SSH2_newkeys(PTInstVar pvar) { logputs(LOG_LEVEL_VERBOSE, ""SSH2_MSG_NEWKEYS was received(DH key generation is completed).""); if (LogLevel(pvar, LOG_LEVEL_SSHDUMP)) { save_memdump(LOGDUMP); } finish_memdump(); pvar->kex_status |= KEX_FLAG_NEWKEYS_RECEIVED; ssh2_set_newkeys(pvar, MODE_IN); if (!CRYPT_start_encryption(pvar, 0, 1)) { } pvar->ssh2_keys[MODE_IN].mac.enabled = 1; pvar->ssh2_keys[MODE_IN].comp.enabled = 1; enable_recv_compression(pvar); SSH2_dispatch_add_message(SSH2_MSG_EXT_INFO); if (pvar->kex_status & KEX_FLAG_NEWKEYS_SENT) { if (pvar->kex_status & KEX_FLAG_REKEYING) { int i; Channel_t *c; do_SSH2_dispatch_setup_for_transfer(pvar); for (i = 0 ; i < CHANNEL_MAX ; i++) { c = &channels[i]; if (c->used) { ssh2_channel_retry_send_bufchain(pvar, c); } } } else { ssh2_finish_encryption_setup(pvar); ssh2_prep_userauth(pvar); } pvar->kex_status = KEX_FLAG_KEXDONE; } return TRUE; }
Description: The SSH transport protocol with certain OpenSSH extensions, found in OpenSSH before 9.6 and other products, allows remote attackers to bypass integrity checks such that some packets are omitted (from the extension negotiation message), and a client and server may consequently end up with a connection for which some security features have been downgraded or disabled, aka a Terrapin attack. This occurs because the SSH Binary Packet Protocol (BPP), implemented by these extensions, mishandles the handshake phase and mishandles use of sequence numbers. For example, there is an effective attack against SSH's use of ChaCha20-Poly1305 (and CBC with Encrypt-then-MAC). The bypass occurs in chacha20-poly1305@openssh.com and (if CBC is used) the -etm@openssh.com MAC algorithms. This also affects Maverick Synergy Java SSH API before 3.1.0-SNAPSHOT, Dropbear through 2022.83, Ssh before 5.1.1 in Erlang/OTP, PuTTY before 0.80, AsyncSSH before 2.14.2, golang.org/x/crypto before 0.17.0, libssh before 0.10.6, libssh2 through 1.11.0, Thorn Tech SFTP Gateway before 3.4.6, Tera Term before 5.1, Paramiko before 3.4.0, jsch before 0.2.15, SFTPGo before 2.5.6, Netgate pfSense Plus through 23.09.1, Netgate pfSense CE through 2.7.2, HPN-SSH through 18.2.0, ProFTPD before 1.3.8b (and before 1.3.9rc2), ORYX CycloneSSH before 2.3.4, NetSarang XShell 7 before Build 0144, CrushFTP before 10.6.0, ConnectBot SSH library before 2.2.22, Apache MINA sshd through 2.11.0, sshj through 0.37.0, TinySSH through 20230101, trilead-ssh2 6401, LANCOM LCOS and LANconfig, FileZilla before 3.66.4, Nova before 11.8, PKIX-SSH before 14.4, SecureCRT before 9.4.3, Transmit5 before 5.10.4, Win32-OpenSSH before 9.5.0.0p1-Beta, WinSCP before 6.2.2, Bitvise SSH Server before 9.32, Bitvise SSH Client before 9.33, KiTTY through 0.76.1.13, the net-ssh gem 7.2.0 for Ruby, the mscdex ssh2 module before 1.15.0 for Node.js, the thrussh library before 0.35.1 for Rust, and the Russh crate before 0.40.2 for Rust.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: const char* CardReader::diveToFile(SdFile*& curDir, const char * const path, const bool echo) { SdFile myDir; if (path[0] != '/') { curDir = &workDir; return path; } curDir = &root; const char *dirname_start = &path[1]; while (dirname_start) { char * const dirname_end = strchr(dirname_start, '/'); if (dirname_end <= dirname_start) break; char dosSubdirname[FILENAME_LENGTH]; const uint8_t len = dirname_end - dirname_start; strncpy(dosSubdirname, dirname_start, len); dosSubdirname[len] = 0; if (echo) SERIAL_ECHOLN(dosSubdirname); if (!myDir.open(curDir, dosSubdirname, O_READ)) { SERIAL_PROTOCOLPAIR(MSG_SD_OPEN_FILE_FAIL, dosSubdirname); SERIAL_PROTOCOLCHAR('.'); SERIAL_EOL(); return NULL; } curDir = &myDir; dirname_start = dirname_end + 1; } return dirname_start; }
Description: Marlin Firmware Marlin version 1.1.x and earlier contains a Buffer Overflow vulnerability in cardreader.cpp (Depending on branch/version) that can result in Arbitrary code execution. This attack appear to be exploitable via Crafted G-Code instruction/file is sent to the printer.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void module_free_common(struct lys_module *module, void (*private_destructor)(const struct lys_node *node, void *priv)) { struct ly_ctx *ctx; struct lys_node *next, *iter; unsigned int i; assert(module->ctx); ctx = module->ctx; for (i = 0; i < module->imp_size; i++) { lydict_remove(ctx, module->imp[i].prefix); lydict_remove(ctx, module->imp[i].dsc); lydict_remove(ctx, module->imp[i].ref); lys_extension_instances_free(ctx, module->imp[i].ext, module->imp[i].ext_size, private_destructor); } free(module->imp); if (!module->type) { LY_TREE_FOR_SAFE(module->data, next, iter) { lys_node_free(iter, private_destructor, 0); } } lydict_remove(ctx, module->dsc); lydict_remove(ctx, module->ref); lydict_remove(ctx, module->org); lydict_remove(ctx, module->contact); lydict_remove(ctx, module->filepath); for (i = 0; i < module->rev_size; i++) { lys_extension_instances_free(ctx, module->rev[i].ext, module->rev[i].ext_size, private_destructor); lydict_remove(ctx, module->rev[i].dsc); lydict_remove(ctx, module->rev[i].ref); } free(module->rev); for (i = 0; i < module->ident_size; i++) { lys_ident_free(ctx, &module->ident[i], private_destructor); } module->ident_size = 0; free(module->ident); for (i = 0; i < module->tpdf_size; i++) { lys_tpdf_free(ctx, &module->tpdf[i], private_destructor); } free(module->tpdf); lys_extension_instances_free(ctx, module->ext, module->ext_size, private_destructor); for (i = 0; i < module->augment_size; i++) { lys_augment_free(ctx, &module->augment[i], private_destructor); } free(module->augment); for (i = 0; i < module->features_size; i++) { lys_feature_free(ctx, &module->features[i], private_destructor); } free(module->features); for (i = 0; i < module->deviation_size; i++) { lys_deviation_free(module, &module->deviation[i], private_destructor); } free(module->deviation); for (i = 0; i < module->extensions_size; i++) { lys_extension_free(ctx, &module->extensions[i], private_destructor); } free(module->extensions); lydict_remove(ctx, module->name); lydict_remove(ctx, module->prefix); }
Description: In function lys_node_free() in libyang <= v1.0.225, it asserts that the value of node->module can't be NULL. But in some cases, node->module can be null, which triggers a reachable assertion (CWE-617).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void Server::connectionClosed(QAbstractSocket::SocketError err, const QString &reason) { Connection *c = qobject_cast<Connection *>(sender()); if (! c) return; if (c->bDisconnectedEmitted) return; c->bDisconnectedEmitted = true; ServerUser *u = static_cast<ServerUser *>(c); log(u, QString(""Connection closed: %1 [%2]"").arg(reason).arg(err)); if (u->sState == ServerUser::Authenticated) { MumbleProto::UserRemove mpur; mpur.set_session(u->uiSession); sendExcept(u, mpur); emit userDisconnected(u); } Channel *old = u->cChannel; { QWriteLocker wl(&qrwlVoiceThread); qhUsers.remove(u->uiSession); qhHostUsers[u->haAddress].remove(u); quint16 port = (u->saiUdpAddress.ss_family == AF_INET6) ? (reinterpret_cast<sockaddr_in6 *>(&u->saiUdpAddress)->sin6_port) : (reinterpret_cast<sockaddr_in *>(&u->saiUdpAddress)->sin_port); const QPair<HostAddress, quint16> &key = QPair<HostAddress, quint16>(u->haAddress, port); qhPeerUsers.remove(key); if (old) old->removeUser(u); } if (old && old->bTemporary && old->qlUsers.isEmpty()) QCoreApplication::instance()->postEvent(this, new ExecEvent(boost::bind(&Server::removeChannel, this, old->iId))); if (static_cast<int>(u->uiSession) < iMaxUsers * 2) qqIds.enqueue(u->uiSession);  if (u->sState == ServerUser::Authenticated) { clearTempGroups(u); recheckCodecVersions(); } u->deleteLater(); if (qhUsers.isEmpty()) stopThread(); }
Description: Qt 5.12.2 through 5.14.2, as used in unofficial builds of Mumble 1.3.0 and other products, mishandles OpenSSL's error queue, which can cause a denial of service to QSslSocket users. Because errors leak in unrelated TLS sessions, an unrelated session may be disconnected when any handshake fails. (Mumble 1.3.1 is not affected, regardless of the Qt version.)
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int crypto_rng_init_tfm(struct crypto_tfm *tfm) { struct crypto_rng *rng = __crypto_rng_cast(tfm); struct rng_alg *alg = crypto_rng_alg(rng); struct old_rng_alg *oalg = crypto_old_rng_alg(rng); if (oalg->rng_make_random) { rng->generate = generate; rng->seed = rngapi_reset; rng->seedsize = oalg->seedsize; return 0; } rng->generate = alg->generate; rng->seed = alg->seed; rng->seedsize = alg->seedsize; return 0; }
Description: The rngapi_reset function in crypto/rng.c in the Linux kernel before 4.2 allows attackers to cause a denial of service (NULL pointer dereference).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int em_ret_far(struct x86_emulate_ctxt *ctxt) { int rc; unsigned long eip, cs; u16 old_cs; int cpl = ctxt->ops->cpl(ctxt); struct desc_struct old_desc, new_desc; const struct x86_emulate_ops *ops = ctxt->ops; if (ctxt->mode == X86EMUL_MODE_PROT64) ops->get_segment(ctxt, &old_cs, &old_desc, NULL, VCPU_SREG_CS); rc = emulate_pop(ctxt, &eip, ctxt->op_bytes); if (rc != X86EMUL_CONTINUE) return rc; rc = emulate_pop(ctxt, &cs, ctxt->op_bytes); if (rc != X86EMUL_CONTINUE) return rc; if (ctxt->mode >= X86EMUL_MODE_PROT16 && (cs & 3) > cpl) return X86EMUL_UNHANDLEABLE; rc = __load_segment_descriptor(ctxt, (u16)cs, VCPU_SREG_CS, cpl, X86_TRANSFER_RET, &new_desc); if (rc != X86EMUL_CONTINUE) return rc; rc = assign_eip_far(ctxt, eip, &new_desc); if (rc != X86EMUL_CONTINUE) { WARN_ON(ctxt->mode != X86EMUL_MODE_PROT64); ops->set_segment(ctxt, old_cs, &old_desc, 0, VCPU_SREG_CS); } return rc; }
Description: arch/x86/kvm/emulate.c in the Linux kernel before 4.8.12 does not properly initialize Code Segment (CS) in certain error cases, which allows local users to obtain sensitive information from kernel stack memory via a crafted application.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int caf_desc(caf_reader_t *reader, int64_t chunk_size) { double mSampleRate; uint32_t mFormatID, mFormatFlags, mBytesPerPacket, mFramesPerPacket, mChannelsPerFrame, mBitsPerChannel; pcm_sample_description_t *desc = &reader->sample_format; ENSURE(chunk_size >= 32); TRY_IO(pcm_scanb(&reader->io, ""QLLLLLL"", &mSampleRate, &mFormatID, &mFormatFlags, &mBytesPerPacket, &mFramesPerPacket, &mChannelsPerFrame, &mBitsPerChannel) != 7); ENSURE(mFormatID == M4AF_FOURCC('l','p','c','m')); ENSURE(mSampleRate && mBytesPerPacket && mChannelsPerFrame >= 1 && mChannelsPerFrame <= 8 && mBitsPerChannel && mFramesPerPacket == 1 && mBytesPerPacket % mChannelsPerFrame == 0 && mBytesPerPacket >= mChannelsPerFrame * ((mBitsPerChannel + 7) / 8)); desc->sample_rate        = mSampleRate; desc->bits_per_channel   = mBitsPerChannel; desc->bytes_per_frame    = mBytesPerPacket; desc->channels_per_frame = mChannelsPerFrame; switch (mFormatFlags) { case 0: desc->sample_type = PCM_TYPE_SINT_BE;  break; case 1: desc->sample_type = PCM_TYPE_FLOAT_BE; break; case 2: desc->sample_type = PCM_TYPE_SINT;     break; case 3: desc->sample_type = PCM_TYPE_FLOAT;    break; default: goto FAIL; } TRY_IO(pcm_skip(&reader->io, chunk_size - 32)); return 0; FAIL: return -1; }
Description: fdkaac v1.0.3 was discovered to contain a heap buffer overflow via __interceptor_memcpy.part.46 at /sanitizer_common/sanitizer_common_interceptors.inc.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static struct vrend_linked_shader_program *add_shader_program(struct vrend_context *ctx, struct vrend_shader *vs, struct vrend_shader *fs, struct vrend_shader *gs) { struct vrend_linked_shader_program *sprog = CALLOC_STRUCT(vrend_linked_shader_program); char name[16]; int i; GLuint prog_id; GLint lret; int id; int last_shader; if (!sprog) return NULL; if ((gs && gs->compiled_fs_id != fs->id) || (!gs && vs->compiled_fs_id != fs->id)) { bool ret; if (gs) vrend_patch_vertex_shader_interpolants(gs->glsl_prog, &gs->sel->sinfo, &fs->sel->sinfo, true, fs->key.flatshade); else vrend_patch_vertex_shader_interpolants(vs->glsl_prog, &vs->sel->sinfo, &fs->sel->sinfo, false, fs->key.flatshade); ret = vrend_compile_shader(ctx, gs ? gs : vs); if (ret == false) { glDeleteShader(gs ? gs->id : vs->id); free(sprog); return NULL; } if (gs) gs->compiled_fs_id = fs->id; else vs->compiled_fs_id = fs->id; } prog_id = glCreateProgram(); glAttachShader(prog_id, vs->id); if (gs) { if (gs->id > 0) glAttachShader(prog_id, gs->id); set_stream_out_varyings(prog_id, &gs->sel->sinfo); } else set_stream_out_varyings(prog_id, &vs->sel->sinfo); glAttachShader(prog_id, fs->id); if (fs->sel->sinfo.num_outputs > 1) { if (util_blend_state_is_dual(&ctx->sub->blend_state, 0)) { glBindFragDataLocationIndexed(prog_id, 0, 0, ""fsout_c0""); glBindFragDataLocationIndexed(prog_id, 0, 1, ""fsout_c1""); sprog->dual_src_linked = true; } else { glBindFragDataLocationIndexed(prog_id, 0, 0, ""fsout_c0""); glBindFragDataLocationIndexed(prog_id, 1, 0, ""fsout_c1""); sprog->dual_src_linked = false; } } else sprog->dual_src_linked = false; if (vrend_state.have_vertex_attrib_binding) { uint32_t mask = vs->sel->sinfo.attrib_input_mask; while (mask) { i = u_bit_scan(&mask); snprintf(name, 10, ""in_%d"", i); glBindAttribLocation(prog_id, i, name); } } glLinkProgram(prog_id); glGetProgramiv(prog_id, GL_LINK_STATUS, &lret); if (lret == GL_FALSE) { char infolog[65536]; int len; glGetProgramInfoLog(prog_id, 65536, &len, infolog); fprintf(stderr,""got error linking\n%s\n"", infolog); report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_SHADER, 0); fprintf(stderr,""vert shader: %d GLSL\n%s\n"", vs->id, vs->glsl_prog); if (gs) fprintf(stderr,""geom shader: %d GLSL\n%s\n"", gs->id, gs->glsl_prog); fprintf(stderr,""frag shader: %d GLSL\n%s\n"", fs->id, fs->glsl_prog); glDeleteProgram(prog_id); return NULL; } sprog->ss[PIPE_SHADER_VERTEX] = vs; sprog->ss[PIPE_SHADER_FRAGMENT] = fs; sprog->ss[PIPE_SHADER_GEOMETRY] = gs; list_add(&sprog->sl[PIPE_SHADER_VERTEX], &vs->programs); list_add(&sprog->sl[PIPE_SHADER_FRAGMENT], &fs->programs); if (gs) list_add(&sprog->sl[PIPE_SHADER_GEOMETRY], &gs->programs); last_shader = gs ? PIPE_SHADER_GEOMETRY : PIPE_SHADER_FRAGMENT; sprog->id = prog_id; list_addtail(&sprog->head, &ctx->sub->programs); if (fs->key.pstipple_tex) sprog->fs_stipple_loc = glGetUniformLocation(prog_id, ""pstipple_sampler""); else sprog->fs_stipple_loc = -1; sprog->vs_ws_adjust_loc = glGetUniformLocation(prog_id, ""winsys_adjust""); for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) { if (sprog->ss[id]->sel->sinfo.samplers_used_mask) { uint32_t mask = sprog->ss[id]->sel->sinfo.samplers_used_mask; int nsamp = util_bitcount(sprog->ss[id]->sel->sinfo.samplers_used_mask); int index; sprog->shadow_samp_mask[id] = sprog->ss[id]->sel->sinfo.shadow_samp_mask; if (sprog->ss[id]->sel->sinfo.shadow_samp_mask) { sprog->shadow_samp_mask_locs[id] = calloc(nsamp, sizeof(uint32_t)); sprog->shadow_samp_add_locs[id] = calloc(nsamp, sizeof(uint32_t)); } else { sprog->shadow_samp_mask_locs[id] = sprog->shadow_samp_add_locs[id] = NULL; } sprog->samp_locs[id] = calloc(nsamp, sizeof(uint32_t)); if (sprog->samp_locs[id]) { const char *prefix = pipe_shader_to_prefix(id); index = 0; while(mask) { i = u_bit_scan(&mask); snprintf(name, 10, ""%ssamp%d"", prefix, i); sprog->samp_locs[id][index] = glGetUniformLocation(prog_id, name); if (sprog->ss[id]->sel->sinfo.shadow_samp_mask & (1 << i)) { snprintf(name, 14, ""%sshadmask%d"", prefix, i); sprog->shadow_samp_mask_locs[id][index] = glGetUniformLocation(prog_id, name); snprintf(name, 14, ""%sshadadd%d"", prefix, i); sprog->shadow_samp_add_locs[id][index] = glGetUniformLocation(prog_id, name); } index++; } } } else { sprog->samp_locs[id] = NULL; sprog->shadow_samp_mask_locs[id] = NULL; sprog->shadow_samp_add_locs[id] = NULL; sprog->shadow_samp_mask[id] = 0; } sprog->samplers_used_mask[id] = sprog->ss[id]->sel->sinfo.samplers_used_mask; } for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) { if (sprog->ss[id]->sel->sinfo.num_consts) { sprog->const_locs[id] = calloc(sprog->ss[id]->sel->sinfo.num_consts, sizeof(uint32_t)); if (sprog->const_locs[id]) { const char *prefix = pipe_shader_to_prefix(id); for (i = 0; i < sprog->ss[id]->sel->sinfo.num_consts; i++) { snprintf(name, 16, ""%sconst0[%d]"", prefix, i); sprog->const_locs[id][i] = glGetUniformLocation(prog_id, name); } } } else sprog->const_locs[id] = NULL; } if (!vrend_state.have_vertex_attrib_binding) { if (vs->sel->sinfo.num_inputs) { sprog->attrib_locs = calloc(vs->sel->sinfo.num_inputs, sizeof(uint32_t)); if (sprog->attrib_locs) { for (i = 0; i < vs->sel->sinfo.num_inputs; i++) { snprintf(name, 10, ""in_%d"", i); sprog->attrib_locs[i] = glGetAttribLocation(prog_id, name); } } } else sprog->attrib_locs = NULL; } for (id = PIPE_SHADER_VERTEX; id <= last_shader; id++) { if (sprog->ss[id]->sel->sinfo.num_ubos) { const char *prefix = pipe_shader_to_prefix(id); sprog->ubo_locs[id] = calloc(sprog->ss[id]->sel->sinfo.num_ubos, sizeof(uint32_t)); for (i = 0; i < sprog->ss[id]->sel->sinfo.num_ubos; i++) { snprintf(name, 16, ""%subo%d"", prefix, i + 1); sprog->ubo_locs[id][i] = glGetUniformBlockIndex(prog_id, name); } } else sprog->ubo_locs[id] = NULL; } if (vs->sel->sinfo.num_ucp) { for (i = 0; i < vs->sel->sinfo.num_ucp; i++) { snprintf(name, 10, ""clipp[%d]"", i); sprog->clip_locs[i] = glGetUniformLocation(prog_id, name); } } return sprog; }
Description: Memory leak in the add_shader_program function in vrend_renderer.c in virglrenderer before 0.6.0 allows local guest OS users to cause a denial of service (host memory consumption) via vectors involving the sprog variable.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: LuacBinInfo *luac_build_info(LuaProto *proto) { if (!proto) { RZ_LOG_ERROR(""Invalid luac file\n""); return NULL; } LuacBinInfo *ret = RZ_NEW0(LuacBinInfo); if (!ret) { return NULL; } ret->entry_list = rz_list_newf((RzListFree)free_rz_addr); ret->symbol_list = rz_list_newf((RzListFree)rz_bin_symbol_free); ret->section_list = rz_list_newf((RzListFree)free_rz_section); ret->string_list = rz_list_newf((RzListFree)free_rz_string); if (!(ret->entry_list && ret->symbol_list && ret->section_list && ret->string_list)) { try_free_empty_list(ret->entry_list); try_free_empty_list(ret->symbol_list); try_free_empty_list(ret->section_list); try_free_empty_list(ret->string_list); } _luac_build_info(proto, ret); ut64 main_entry_offset; main_entry_offset = proto->code_offset + proto->code_skipped; luac_add_entry(ret->entry_list, main_entry_offset, RZ_BIN_ENTRY_TYPE_PROGRAM); return ret; }
Description: Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting data from Luac files. A user opening a malicious Luac file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commits 07b43bc8aa1ffebd9b68d60624c9610cf7e460c7 and 05bbd147caccc60162d6fba9baaaf24befa281cd contain fixes for the issue.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static ssize_t qib_write(struct file *fp, const char __user *data, size_t count, loff_t *off) { const struct qib_cmd __user *ucmd; struct qib_ctxtdata *rcd; const void __user *src; size_t consumed, copy = 0; struct qib_cmd cmd; ssize_t ret = 0; void *dest; if (count < sizeof(cmd.type)) { ret = -EINVAL; goto bail; } ucmd = (const struct qib_cmd __user *) data; if (copy_from_user(&cmd.type, &ucmd->type, sizeof(cmd.type))) { ret = -EFAULT; goto bail; } consumed = sizeof(cmd.type); switch (cmd.type) { case QIB_CMD_ASSIGN_CTXT: case QIB_CMD_USER_INIT: copy = sizeof(cmd.cmd.user_info); dest = &cmd.cmd.user_info; src = &ucmd->cmd.user_info; break; case QIB_CMD_RECV_CTRL: copy = sizeof(cmd.cmd.recv_ctrl); dest = &cmd.cmd.recv_ctrl; src = &ucmd->cmd.recv_ctrl; break; case QIB_CMD_CTXT_INFO: copy = sizeof(cmd.cmd.ctxt_info); dest = &cmd.cmd.ctxt_info; src = &ucmd->cmd.ctxt_info; break; case QIB_CMD_TID_UPDATE: case QIB_CMD_TID_FREE: copy = sizeof(cmd.cmd.tid_info); dest = &cmd.cmd.tid_info; src = &ucmd->cmd.tid_info; break; case QIB_CMD_SET_PART_KEY: copy = sizeof(cmd.cmd.part_key); dest = &cmd.cmd.part_key; src = &ucmd->cmd.part_key; break; case QIB_CMD_DISARM_BUFS: case QIB_CMD_PIOAVAILUPD:  copy = 0; src = NULL; dest = NULL; break; case QIB_CMD_POLL_TYPE: copy = sizeof(cmd.cmd.poll_type); dest = &cmd.cmd.poll_type; src = &ucmd->cmd.poll_type; break; case QIB_CMD_ARMLAUNCH_CTRL: copy = sizeof(cmd.cmd.armlaunch_ctrl); dest = &cmd.cmd.armlaunch_ctrl; src = &ucmd->cmd.armlaunch_ctrl; break; case QIB_CMD_SDMA_INFLIGHT: copy = sizeof(cmd.cmd.sdma_inflight); dest = &cmd.cmd.sdma_inflight; src = &ucmd->cmd.sdma_inflight; break; case QIB_CMD_SDMA_COMPLETE: copy = sizeof(cmd.cmd.sdma_complete); dest = &cmd.cmd.sdma_complete; src = &ucmd->cmd.sdma_complete; break; case QIB_CMD_ACK_EVENT: copy = sizeof(cmd.cmd.event_mask); dest = &cmd.cmd.event_mask; src = &ucmd->cmd.event_mask; break; default: ret = -EINVAL; goto bail; } if (copy) { if ((count - consumed) < copy) { ret = -EINVAL; goto bail; } if (copy_from_user(dest, src, copy)) { ret = -EFAULT; goto bail; } consumed += copy; } rcd = ctxt_fp(fp); if (!rcd && cmd.type != QIB_CMD_ASSIGN_CTXT) { ret = -EINVAL; goto bail; } switch (cmd.type) { case QIB_CMD_ASSIGN_CTXT: ret = qib_assign_ctxt(fp, &cmd.cmd.user_info); if (ret) goto bail; break; case QIB_CMD_USER_INIT: ret = qib_do_user_init(fp, &cmd.cmd.user_info); if (ret) goto bail; ret = qib_get_base_info(fp, (void __user *) (unsigned long) cmd.cmd.user_info.spu_base_info, cmd.cmd.user_info.spu_base_info_size); break; case QIB_CMD_RECV_CTRL: ret = qib_manage_rcvq(rcd, subctxt_fp(fp), cmd.cmd.recv_ctrl); break; case QIB_CMD_CTXT_INFO: ret = qib_ctxt_info(fp, (struct qib_ctxt_info __user *) (unsigned long) cmd.cmd.ctxt_info); break; case QIB_CMD_TID_UPDATE: ret = qib_tid_update(rcd, fp, &cmd.cmd.tid_info); break; case QIB_CMD_TID_FREE: ret = qib_tid_free(rcd, subctxt_fp(fp), &cmd.cmd.tid_info); break; case QIB_CMD_SET_PART_KEY: ret = qib_set_part_key(rcd, cmd.cmd.part_key); break; case QIB_CMD_DISARM_BUFS: (void)qib_disarm_piobufs_ifneeded(rcd); ret = disarm_req_delay(rcd); break; case QIB_CMD_PIOAVAILUPD: qib_force_pio_avail_update(rcd->dd); break; case QIB_CMD_POLL_TYPE: rcd->poll_type = cmd.cmd.poll_type; break; case QIB_CMD_ARMLAUNCH_CTRL: rcd->dd->f_set_armlaunch(rcd->dd, cmd.cmd.armlaunch_ctrl); break; case QIB_CMD_SDMA_INFLIGHT: ret = qib_sdma_get_inflight(user_sdma_queue_fp(fp), (u32 __user *) (unsigned long) cmd.cmd.sdma_inflight); break; case QIB_CMD_SDMA_COMPLETE: ret = qib_sdma_get_complete(rcd->ppd, user_sdma_queue_fp(fp), (u32 __user *) (unsigned long) cmd.cmd.sdma_complete); break; case QIB_CMD_ACK_EVENT: ret = qib_user_event_ack(rcd, subctxt_fp(fp), cmd.cmd.event_mask); break; } if (ret >= 0) ret = consumed; bail: return ret; }
Description: The InfiniBand (aka IB) stack in the Linux kernel before 4.5.3 incorrectly relies on the write system call, which allows local users to cause a denial of service (kernel memory write operation) or possibly have unspecified other impact via a uAPI interface.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int decode_preamble(void *p, struct ceph_frame_desc *desc) { void *crcp = p + CEPH_PREAMBLE_LEN - CEPH_CRC_LEN; u32 crc, expected_crc; int i; crc = crc32c(0, p, crcp - p); expected_crc = get_unaligned_le32(crcp); if (crc != expected_crc) { pr_err(""bad preamble crc, calculated %u, expected %u\n"", crc, expected_crc); return -EBADMSG; } memset(desc, 0, sizeof(*desc)); desc->fd_tag = ceph_decode_8(&p); desc->fd_seg_cnt = ceph_decode_8(&p); if (desc->fd_seg_cnt < 1 || desc->fd_seg_cnt > CEPH_FRAME_MAX_SEGMENT_COUNT) { pr_err(""bad segment count %d\n"", desc->fd_seg_cnt); return -EINVAL; } for (i = 0; i < desc->fd_seg_cnt; i++) { desc->fd_lens[i] = ceph_decode_32(&p); desc->fd_aligns[i] = ceph_decode_16(&p); } if (!desc->fd_lens[desc->fd_seg_cnt - 1]) { pr_err(""last segment empty\n""); return -EINVAL; } if (desc->fd_lens[0] > CEPH_MSG_MAX_CONTROL_LEN) { pr_err(""control segment too big %d\n"", desc->fd_lens[0]); return -EINVAL; } if (desc->fd_lens[1] > CEPH_MSG_MAX_FRONT_LEN) { pr_err(""front segment too big %d\n"", desc->fd_lens[1]); return -EINVAL; } if (desc->fd_lens[2] > CEPH_MSG_MAX_MIDDLE_LEN) { pr_err(""middle segment too big %d\n"", desc->fd_lens[2]); return -EINVAL; } if (desc->fd_lens[3] > CEPH_MSG_MAX_DATA_LEN) { pr_err(""data segment too big %d\n"", desc->fd_lens[3]); return -EINVAL; } return 0; }
Description: An issue was discovered in net/ceph/messenger_v2.c in the Linux kernel before 6.4.5. There is an integer signedness error, leading to a buffer overflow and remote code execution via HELLO or one of the AUTH frames. This occurs because of an untrusted length taken from a TCP packet in ceph_decode_32.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static ssize_t snd_seq_write(struct file *file, const char __user *buf, size_t count, loff_t *offset) { struct snd_seq_client *client = file->private_data; int written = 0, len; int err = -EINVAL; struct snd_seq_event event; if (!(snd_seq_file_flags(file) & SNDRV_SEQ_LFLG_OUTPUT)) return -ENXIO; if (snd_BUG_ON(!client)) return -ENXIO; if (!client->accept_output || client->pool == NULL) return -ENXIO; if (client->pool->size > 0 && !snd_seq_write_pool_allocated(client)) { if (snd_seq_pool_init(client->pool) < 0) return -ENOMEM; } while (count >= sizeof(struct snd_seq_event)) { len = sizeof(event); if (copy_from_user(&event, buf, len)) { err = -EFAULT; break; } event.source.client = client->number; if (check_event_type_and_length(&event)) { err = -EINVAL; break; } if (event.type == SNDRV_SEQ_EVENT_NONE) goto __skip_event; else if (snd_seq_ev_is_reserved(&event)) { err = -EINVAL; break; } if (snd_seq_ev_is_variable(&event)) { int extlen = event.data.ext.len & ~SNDRV_SEQ_EXT_MASK; if ((size_t)(extlen + len) > count) { err = -EINVAL; break; } event.data.ext.len = extlen | SNDRV_SEQ_EXT_USRPTR; event.data.ext.ptr = (char __force *)buf + sizeof(struct snd_seq_event); len += extlen;  } else { #ifdef CONFIG_COMPAT if (client->convert32 && snd_seq_ev_is_varusr(&event)) { void *ptr = (void __force *)compat_ptr(event.data.raw32.d[1]); event.data.ext.ptr = ptr; } #endif } err = snd_seq_client_enqueue_event(client, &event, file, !(file->f_flags & O_NONBLOCK), 0, 0); if (err < 0) break; __skip_event: count -= len; buf += len; written += len; } return written ? written : err; }
Description: The Linux kernel 4.15 has a Buffer Overflow via an SNDRV_SEQ_IOCTL_SET_CLIENT_POOL ioctl write operation to /dev/snd/seq by a local user.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: tvbuff_t * tvb_uncompress(tvbuff_t *tvb, const int offset, int comprlen) { gint       err; guint      bytes_out      = 0; guint8    *compr; guint8    *uncompr        = NULL; tvbuff_t  *uncompr_tvb    = NULL; z_streamp  strm; Bytef     *strmbuf; guint      inits_done     = 0; gint       wbits          = MAX_WBITS; guint8    *next; guint      bufsiz; #ifdef TVB_Z_DEBUG guint      inflate_passes = 0; guint      bytes_in       = tvb_captured_length_remaining(tvb, offset); #endif if (tvb == NULL) { return NULL; } compr = (guint8 *)g_malloc(comprlen); tvb_memcpy(tvb, compr, offset, comprlen); if (!compr) return NULL; bufsiz = tvb_captured_length_remaining(tvb, offset) * 2; bufsiz = CLAMP(bufsiz, TVB_Z_MIN_BUFSIZ, TVB_Z_MAX_BUFSIZ); #ifdef TVB_Z_DEBUG printf(""bufsiz: %u bytes\n"", bufsiz); #endif next = compr; strm            = g_new0(z_stream, 1); strm->next_in   = next; strm->avail_in  = comprlen; strmbuf         = (Bytef *)g_malloc0(bufsiz); strm->next_out  = strmbuf; strm->avail_out = bufsiz; err = inflateInit2(strm, wbits); inits_done = 1; if (err != Z_OK) { inflateEnd(strm); g_free(strm); g_free(compr); g_free(strmbuf); return NULL; } while (1) { memset(strmbuf, '\0', bufsiz); strm->next_out  = strmbuf; strm->avail_out = bufsiz; err = inflate(strm, Z_SYNC_FLUSH); if (err == Z_OK || err == Z_STREAM_END) { guint bytes_pass = bufsiz - strm->avail_out; #ifdef TVB_Z_DEBUG ++inflate_passes; #endif if (uncompr == NULL) { uncompr = (guint8 *)((bytes_pass || err != Z_STREAM_END) ? g_memdup(strmbuf, bytes_pass) : g_strdup("""")); } else { guint8 *new_data = (guint8 *)g_malloc0(bytes_out + bytes_pass); memcpy(new_data, uncompr, bytes_out); memcpy(new_data + bytes_out, strmbuf, bytes_pass); g_free(uncompr); uncompr = new_data; } bytes_out += bytes_pass; if (err == Z_STREAM_END) { inflateEnd(strm); g_free(strm); g_free(strmbuf); break; } } else if (err == Z_BUF_ERROR) { inflateEnd(strm); g_free(strm); g_free(strmbuf); if (uncompr != NULL) { break; } else { g_free(compr); return NULL; } } else if (err == Z_DATA_ERROR && inits_done == 1 && uncompr == NULL && comprlen >= 2 && (*compr  == 0x1f) && (*(compr + 1) == 0x8b)) { Bytef *c = compr + 2; Bytef  flags = 0; if (comprlen < 10 || *c != Z_DEFLATED) { inflateEnd(strm); g_free(strm); g_free(compr); g_free(strmbuf); return NULL; } c++; flags = *c; c++; c += 6; if (flags & (1 << 2)) { guint16 xsize = 0; if (c-compr < comprlen) { xsize += *c; c++; } if (c-compr < comprlen) { xsize += *c << 8; c++; } c += xsize; } if (flags & (1 << 3)) { while ((c - compr) < comprlen && *c != '\0') { c++; } c++; } if (flags & (1 << 4)) { while ((c - compr) < comprlen && *c != '\0') { c++; } c++; } if (c - compr > comprlen) { inflateEnd(strm); g_free(strm); g_free(compr); g_free(strmbuf); return NULL; } comprlen -= (int) (c - compr); next = c; inflateReset(strm); strm->next_in   = next; strm->avail_in  = comprlen; inflateEnd(strm); inflateInit2(strm, wbits); inits_done++; } else if (err == Z_DATA_ERROR && uncompr == NULL && inits_done <= 3) { wbits = -MAX_WBITS; inflateReset(strm); strm->next_in   = next; strm->avail_in  = comprlen; inflateEnd(strm); memset(strmbuf, '\0', bufsiz); strm->next_out  = strmbuf; strm->avail_out = bufsiz; err = inflateInit2(strm, wbits); inits_done++; if (err != Z_OK) { g_free(strm); g_free(strmbuf); g_free(compr); g_free(uncompr); return NULL; } } else { inflateEnd(strm); g_free(strm); g_free(strmbuf); if (uncompr == NULL) { g_free(compr); return NULL; } break; } } #ifdef TVB_Z_DEBUG printf(""inflate() total passes: %u\n"", inflate_passes); printf(""bytes  in: %u\nbytes out: %u\n\n"", bytes_in, bytes_out); #endif if (uncompr != NULL) { uncompr_tvb =  tvb_new_real_data((guint8*) uncompr, bytes_out, bytes_out); tvb_set_free_cb(uncompr_tvb, g_free); } g_free(compr); return uncompr_tvb; }
Description: In Wireshark 2.6.0 to 2.6.1, 2.4.0 to 2.4.7, and 2.2.0 to 2.2.15, dissectors that support zlib decompression could crash. This was addressed in epan/tvbuff_zlib.c by rejecting negative lengths to avoid a buffer over-read.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int userfaultfd_release(struct inode *inode, struct file *file) { struct userfaultfd_ctx *ctx = file->private_data; struct mm_struct *mm = ctx->mm; struct vm_area_struct *vma, *prev; struct userfaultfd_wake_range range = { .len = 0, }; unsigned long new_flags; WRITE_ONCE(ctx->released, true); if (!mmget_not_zero(mm)) goto wakeup; down_write(&mm->mmap_sem); prev = NULL; for (vma = mm->mmap; vma; vma = vma->vm_next) { cond_resched(); BUG_ON(!!vma->vm_userfaultfd_ctx.ctx ^ !!(vma->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP))); if (vma->vm_userfaultfd_ctx.ctx != ctx) { prev = vma; continue; } new_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP); prev = vma_merge(mm, prev, vma->vm_start, vma->vm_end, new_flags, vma->anon_vma, vma->vm_file, vma->vm_pgoff, vma_policy(vma), NULL_VM_UFFD_CTX); if (prev) vma = prev; else prev = vma; vma->vm_flags = new_flags; vma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX; } up_write(&mm->mmap_sem); mmput(mm); wakeup: spin_lock(&ctx->fault_pending_wqh.lock); __wake_up_locked_key(&ctx->fault_pending_wqh, TASK_NORMAL, &range); __wake_up(&ctx->fault_wqh, TASK_NORMAL, 1, &range); spin_unlock(&ctx->fault_pending_wqh.lock); wake_up_all(&ctx->event_wqh); wake_up_poll(&ctx->fd_wqh, EPOLLHUP); userfaultfd_ctx_put(ctx); return 0; }
Description: The coredump implementation in the Linux kernel before 5.0.10 does not use locking or other mechanisms to prevent vma layout or vma flags changes while it runs, which allows local users to obtain sensitive information, cause a denial of service, or possibly have unspecified other impact by triggering a race condition with mmget_not_zero or get_task_mm calls. This is related to fs/userfaultfd.c, mm/mmap.c, fs/proc/task_mmu.c, and drivers/infiniband/core/uverbs_main.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static bool wasm_loader_push_pop_frame_ref_offset(WASMLoaderContext *ctx, uint8 pop_cnt, uint8 type_push, uint8 type_pop, bool disable_emit, int16 operand_offset, char *error_buf, uint32 error_buf_size) { if (!wasm_loader_push_pop_frame_offset(ctx, pop_cnt, type_push, type_pop, disable_emit, operand_offset, error_buf, error_buf_size)) return false; if (!wasm_loader_push_pop_frame_ref(ctx, pop_cnt, type_push, type_pop, error_buf, error_buf_size)) return false; return true; }
Description: Bytecode Alliance wasm-micro-runtime (aka WebAssembly Micro Runtime or WAMR) before 1.3.0 can have an ""double free or corruption"" error for a valid WebAssembly module because push_pop_frame_ref_offset is mishandled.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: char ** XListFonts( register Display *dpy, _Xconst char *pattern,   int maxNames, int *actualCount) { register long nbytes; register unsigned i; register int length; char **flist = NULL; char *ch = NULL; char *chend; int count = 0; xListFontsReply rep; register xListFontsReq *req; unsigned long rlen = 0; LockDisplay(dpy); GetReq(ListFonts, req); req->maxNames = maxNames; nbytes = req->nbytes = pattern ? strlen (pattern) : 0; req->length += (nbytes + 3) >> 2; _XSend (dpy, pattern, nbytes); if (!_XReply (dpy, (xReply *)&rep, 0, xFalse)) { *actualCount = 0; UnlockDisplay(dpy); SyncHandle(); return (char **) NULL; } if (rep.nFonts) { flist = Xmalloc (rep.nFonts * sizeof(char *)); if (rep.length < (INT_MAX >> 2)) { rlen = rep.length << 2; ch = Xmalloc(rlen + 1); } if ((! flist) || (! ch)) { Xfree(flist); Xfree(ch); _XEatDataWords(dpy, rep.length); *actualCount = 0; UnlockDisplay(dpy); SyncHandle(); return (char **) NULL; } _XReadPad (dpy, ch, rlen); chend = ch + (rlen + 1); length = *(unsigned char *)ch; *ch = 1;  for (i = 0; i < rep.nFonts; i++) { if (ch + length < chend) { flist[i] = ch + 1;   ch += length + 1;   length = *(unsigned char *)ch; *ch = '\0';   count++; } else flist[i] = NULL; } } *actualCount = count; UnlockDisplay(dpy); SyncHandle(); return (flist); }
Description: The XListFonts function in X.org libX11 before 1.6.4 might allow remote X servers to gain privileges via vectors involving length fields, which trigger out-of-bounds write operations.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int validate_camera_metadata_structure(const camera_metadata_t *metadata, const size_t *expected_size) { if (metadata == NULL) { ALOGE(""%s: metadata is null!"", __FUNCTION__); return ERROR; } { static const struct { const char *name; size_t alignment; } alignments[] = { { .name = ""camera_metadata"", .alignment = METADATA_ALIGNMENT }, { .name = ""camera_metadata_buffer_entry"", .alignment = ENTRY_ALIGNMENT }, { .name = ""camera_metadata_data"", .alignment = DATA_ALIGNMENT }, }; for (size_t i = 0; i < sizeof(alignments)/sizeof(alignments[0]); ++i) { uintptr_t aligned_ptr = ALIGN_TO(metadata, alignments[i].alignment); if ((uintptr_t)metadata != aligned_ptr) { ALOGE(""%s: Metadata pointer is not aligned (actual %p, "" ""expected %p) to type %s"", __FUNCTION__, metadata, (void*)aligned_ptr, alignments[i].name); return ERROR; } } } if (expected_size != NULL && metadata->size > *expected_size) { ALOGE(""%s: Metadata size (%"" PRIu32 "") should be <= expected size (%zu)"", __FUNCTION__, metadata->size, *expected_size); return ERROR; } if (metadata->entry_count > metadata->entry_capacity) { ALOGE(""%s: Entry count (%"" PRIu32 "") should be <= entry capacity "" ""(%"" PRIu32 "")"", __FUNCTION__, metadata->entry_count, metadata->entry_capacity); return ERROR; } const metadata_uptrdiff_t entries_end = metadata->entries_start + metadata->entry_capacity; if (entries_end < metadata->entries_start ||         entries_end > metadata->data_start) { ALOGE(""%s: Entry start + capacity (%"" PRIu32 "") should be <= data start "" ""(%"" PRIu32 "")"", __FUNCTION__, (metadata->entries_start + metadata->entry_capacity), metadata->data_start); return ERROR; } const metadata_uptrdiff_t data_end = metadata->data_start + metadata->data_capacity; if (data_end < metadata->data_start ||         data_end > metadata->size) { ALOGE(""%s: Data start + capacity (%"" PRIu32 "") should be <= total size "" ""(%"" PRIu32 "")"", __FUNCTION__, (metadata->data_start + metadata->data_capacity), metadata->size); return ERROR; } const metadata_size_t entry_count = metadata->entry_count; camera_metadata_buffer_entry_t *entries = get_entries(metadata); for (size_t i = 0; i < entry_count; ++i) { if ((uintptr_t)&entries[i] != ALIGN_TO(&entries[i], ENTRY_ALIGNMENT)) { ALOGE(""%s: Entry index %zu had bad alignment (address %p),"" "" expected alignment %zu"", __FUNCTION__, i, &entries[i], ENTRY_ALIGNMENT); return ERROR; } camera_metadata_buffer_entry_t entry = entries[i]; if (entry.type >= NUM_TYPES) { ALOGE(""%s: Entry index %zu had a bad type %d"", __FUNCTION__, i, entry.type); return ERROR; } uint32_t tag_section = entry.tag >> 16; int tag_type = get_camera_metadata_tag_type(entry.tag); if (tag_type != (int)entry.type && tag_section < VENDOR_SECTION) { ALOGE(""%s: Entry index %zu had tag type %d, but the type was %d"", __FUNCTION__, i, tag_type, entry.type); return ERROR; } size_t data_size; if (validate_and_calculate_camera_metadata_entry_data_size(&data_size, entry.type, entry.count) != OK) { ALOGE(""%s: Entry data size is invalid. type: %u count: %u"", __FUNCTION__, entry.type, entry.count); return ERROR; } if (data_size != 0) { camera_metadata_data_t *data = (camera_metadata_data_t*) (get_data(metadata) + entry.data.offset); if ((uintptr_t)data != ALIGN_TO(data, DATA_ALIGNMENT)) { ALOGE(""%s: Entry index %zu had bad data alignment (address %p),"" "" expected align %zu, (tag name %s, data size %zu)"", __FUNCTION__, i, data, DATA_ALIGNMENT, get_camera_metadata_tag_name(entry.tag) ?: ""unknown"", data_size); return ERROR; } size_t data_entry_end = entry.data.offset + data_size; if (data_entry_end < entry.data.offset ||                 data_entry_end > metadata->data_capacity) { ALOGE(""%s: Entry index %zu data ends (%zu) beyond the capacity "" ""%"" PRIu32, __FUNCTION__, i, data_entry_end, metadata->data_capacity); return ERROR; } } else if (entry.count == 0) { if (entry.data.offset != 0) { ALOGE(""%s: Entry index %zu had 0 items, but offset was non-0 "" ""(%"" PRIu32 ""), tag name: %s"", __FUNCTION__, i, entry.data.offset, get_camera_metadata_tag_name(entry.tag) ?: ""unknown""); return ERROR; } }     } return OK; }
Description: camera/src/camera_metadata.c in the Camera service in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 allows attackers to gain privileges via a crafted application, aka internal bug 30591838.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void Compute(OpKernelContext* context) override { std::unordered_map<int64, int64> old_row_to_new_row_map; std::vector<bool> row_id_present; const Tensor* row_remapping_t; OP_REQUIRES_OK(context, context->input(""row_remapping"", &row_remapping_t)); const auto row_remapping = row_remapping_t->vec<int64>(); OP_REQUIRES(context, row_remapping.size() == num_rows_, errors::InvalidArgument(strings::StrCat( ""Size of row_remapping is "", row_remapping.size(), "" instead of being equal to num_rows="", num_rows_))); OP_REQUIRES_OK(context, RemapVectorToMap(row_remapping, &row_id_present, &old_row_to_new_row_map)); int64 min_old_row = -1; int64 max_old_row = -1; for (int i = 0; i < row_remapping.size(); ++i) { if (min_old_row < 0 || (row_remapping(i) >= 0 && row_remapping(i) < min_old_row)) { min_old_row = row_remapping(i); } if (max_old_row < 0 || (row_remapping(i) >= 0 && row_remapping(i) > max_old_row)) { max_old_row = row_remapping(i); } } std::unordered_map<int64, int64> old_col_to_new_col_map; std::vector<bool> col_id_present; const Tensor* col_remapping_t; OP_REQUIRES_OK(context, context->input(""col_remapping"", &col_remapping_t)); const auto col_remapping = col_remapping_t->vec<int64>(); const bool remap_cols = col_remapping.size() > 0; if (remap_cols) { OP_REQUIRES( context, col_remapping.size() == num_cols_, errors::InvalidArgument(strings::StrCat( ""Provided col_remapping, but its size is "", col_remapping.size(), "" instead of being equal to num_cols="", num_cols_))); OP_REQUIRES_OK(context, RemapVectorToMap(col_remapping, &col_id_present, &old_col_to_new_col_map)); } else { col_id_present.clear(); col_id_present.resize(num_cols_, true); } const Tensor* ckpt_path_t; OP_REQUIRES_OK(context, context->input(""ckpt_path"", &ckpt_path_t)); const string& ckpt_path = ckpt_path_t->scalar<tstring>()(); const Tensor* old_tensor_name_t; OP_REQUIRES_OK(context, context->input(""old_tensor_name"", &old_tensor_name_t)); const string& old_tensor_name = old_tensor_name_t->scalar<tstring>()(); LOG(INFO) << ""Processing checkpoint : "" << ckpt_path; BundleReader reader(context->env(), ckpt_path); OP_REQUIRES_OK(context, reader.status()); DataType tensor_type; TensorShape tensor_shape; OP_REQUIRES_OK(context, reader.LookupDtypeAndShape( old_tensor_name, &tensor_type, &tensor_shape)); OP_REQUIRES(context, tensor_type == DT_FLOAT, errors::InvalidArgument(strings::StrCat( ""Tensor "", old_tensor_name, "" has invalid type "", DataTypeString(tensor_type), "" instead of expected type "", DataTypeString(DT_FLOAT)))); OP_REQUIRES( context, tensor_shape.dims() == 2, errors::InvalidArgument(strings::StrCat( ""Tensor "", old_tensor_name, "" has shape "", tensor_shape.DebugString(), "" of invalid rank "", tensor_shape.dims(), "" instead of expected shape of rank 2.""))); if (!remap_cols) { OP_REQUIRES(context, num_cols_ == tensor_shape.dim_size(1), errors::InvalidArgument(strings::StrCat( ""Tensor "", old_tensor_name, "" has shape "", tensor_shape.DebugString(), "", where the size of its 2nd dimension is "", tensor_shape.dim_size(1), "" instead of being equal to num_cols="", num_cols_))); } std::vector<TensorSlice> tensor_slices; TensorSlice slice(tensor_shape.dims()); if (min_old_row >= 0 && max_old_row >= 0) { int64 row_start = min_old_row; while (row_start <= max_old_row) { const int64 slice_length = max_rows_in_memory_ <= 0 ? max_old_row - row_start + 1 : std::min(max_rows_in_memory_, max_old_row - row_start + 1); slice.set_start(0, row_start); slice.set_length(0, slice_length); tensor_slices.push_back(slice); row_start += slice_length; } } Tensor* output_matrix_t = nullptr; OP_REQUIRES_OK(context, context->allocate_output(""output_matrix"", TensorShape({num_rows_, num_cols_}), &output_matrix_t)); auto output_matrix = output_matrix_t->matrix<float>(); int64 row_index = min_old_row; int64 rows_copied = 0; Tensor loaded_tensor_t; for (const TensorSlice& tensor_slice : tensor_slices) { LOG(INFO) << ""Loading slice "" << tensor_slice.DebugString(); TensorShape slice_shape; OP_REQUIRES_OK(context, tensor_slice.SliceTensorShape(tensor_shape, &slice_shape)); if (loaded_tensor_t.shape() != slice_shape) { loaded_tensor_t = Tensor(DT_FLOAT, slice_shape); } OP_REQUIRES_OK(context, reader.LookupSlice(old_tensor_name, tensor_slice, &loaded_tensor_t)); for (int row = 0; row < loaded_tensor_t.dim_size(0); ++row, ++row_index) { if (row_index % 500000 == min_old_row) { LOG(INFO) << ""Processing old row "" << row_index; } const int64* new_row_ptr = gtl::FindOrNull(old_row_to_new_row_map, row_index); if (new_row_ptr == nullptr) { continue; } ++rows_copied; const int64 new_row = *new_row_ptr; const auto& loaded_tensor = loaded_tensor_t.matrix<float>(); for (int old_col = 0; old_col < loaded_tensor_t.dim_size(1); ++old_col) { int64 new_col = old_col; if (remap_cols) { const int64* new_col_ptr = gtl::FindOrNull(old_col_to_new_col_map, old_col); if (new_col_ptr == nullptr) { continue; } new_col = *new_col_ptr; } OP_REQUIRES(context, new_row < num_rows_ && new_col < num_cols_ && new_row >= 0 && new_col >= 0, errors::Internal(strings::StrCat( ""new_row="", new_row, "" and new_col="", new_col, "" should have been less than num_rows_="", num_rows_, "" and num_cols_="", num_cols_, "" and non-negative. This should never have happened "" ""if the code were correct. Please file a bug.""))); output_matrix(new_row, new_col) = loaded_tensor(row, old_col); } } } LOG(INFO) << ""Copied "" << rows_copied << "" rows from old matrix (with "" << tensor_shape.dim_size(0) << "" rows) to new matrix (with "" << num_rows_ << "" rows).""; const Tensor* initializing_values_t; OP_REQUIRES_OK( context, context->input(""initializing_values"", &initializing_values_t)); const auto initializing_values = initializing_values_t->flat<float>(); int64 initializing_values_index = 0; for (int i = 0; i < num_rows_; ++i) { for (int j = 0; j < num_cols_; ++j) { if (row_id_present[i] && col_id_present[j]) continue; OP_REQUIRES( context, initializing_values_index < initializing_values.size(), errors::InvalidArgument( ""initializing_values contained "", initializing_values.size(), "" elements, but more missing values remain."")); output_matrix(i, j) = initializing_values(initializing_values_index); ++initializing_values_index; } } OP_REQUIRES( context, initializing_values_index == initializing_values.size(), errors::InvalidArgument( ""initializing_values contained "", initializing_values.size(), "" elements, but only "", initializing_values_index, "" elements were used to fill in missing values."")); }
Description: TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service by exploiting a `CHECK`-failure coming from `tf.raw_ops.LoadAndRemapMatrix`. This is because the implementation(https://github.com/tensorflow/tensorflow/blob/d94227d43aa125ad8b54115c03cece54f6a1977b/tensorflow/core/kernels/ragged_tensor_to_tensor_op.cc#L219-L222) assumes that the `ckpt_path` is always a valid scalar. However, an attacker can send any other tensor as the first argument of `LoadAndRemapMatrix`. This would cause the rank `CHECK` in `scalar<T>()()` to trigger and terminate the process. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: FriBidiStrIndex fribidi_cap_rtl_to_unicode ( const char *s, FriBidiStrIndex len, FriBidiChar *us ) { FriBidiStrIndex i, j; if (!caprtl_to_unicode) init_cap_rtl (); j = 0; for (i = 0; i < len; i++) { char ch; ch = s[i]; if (ch == '_') { switch (ch = s[++i]) { case '>': us[j++] = FRIBIDI_CHAR_LRM; break; case '<': us[j++] = FRIBIDI_CHAR_RLM; break; case 'l': us[j++] = FRIBIDI_CHAR_LRE; break; case 'r': us[j++] = FRIBIDI_CHAR_RLE; break; case 'o': us[j++] = FRIBIDI_CHAR_PDF; break; case 'L': us[j++] = FRIBIDI_CHAR_LRO; break; case 'R': us[j++] = FRIBIDI_CHAR_RLO; break; case 'i': us[j++] = FRIBIDI_CHAR_LRI; break; case 'y': us[j++] = FRIBIDI_CHAR_RLI; break; case 'f': us[j++] = FRIBIDI_CHAR_FSI; break; case 'I': us[j++] = FRIBIDI_CHAR_PDI; break; case '_': us[j++] = '_'; break; default: us[j++] = '_'; i--; break; } } else us[j++] = caprtl_to_unicode[(int) s[i]]; } return j; }
Description: A heap-based buffer overflow flaw was found in the Fribidi package and affects the fribidi_cap_rtl_to_unicode() function of the fribidi-char-sets-cap-rtl.c file. This flaw allows an attacker to pass a specially crafted file to the Fribidi application with the '--caprtl' option, leading to a crash and causing a denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext) { struct f2fs_sb_info *sbi = F2FS_I_SB(inode); struct extent_tree *et; struct extent_node *en; struct extent_info ei; if (!f2fs_may_extent_tree(inode)) { if (i_ext && i_ext->len) { i_ext->len = 0; return true; } return false; } et = __grab_extent_tree(inode); if (!i_ext || !i_ext->len) return false; get_extent_info(&ei, i_ext); write_lock(&et->lock); if (atomic_read(&et->node_cnt)) goto out; en = __init_extent_tree(sbi, et, &ei); if (en) { spin_lock(&sbi->extent_lock); list_add_tail(&en->list, &sbi->extent_list); spin_unlock(&sbi->extent_lock); } out: write_unlock(&et->lock); return false; }
Description: fs/f2fs/extent_cache.c in the Linux kernel before 4.13 mishandles extent trees, which allows local users to cause a denial of service (BUG) via an application with multiple threads.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static bool io_identity_cow(struct io_kiocb *req) { struct io_uring_task *tctx = current->io_uring; const struct cred *creds = NULL; struct io_identity *id; if (req->work.flags & IO_WQ_WORK_CREDS) creds = req->work.identity->creds; id = kmemdup(req->work.identity, sizeof(*id), GFP_KERNEL); if (unlikely(!id)) { req->work.flags |= IO_WQ_WORK_CANCEL; return false; } io_init_identity(id); if (creds) id->creds = creds; refcount_inc(&id->count); if (tctx->identity != &tctx->__identity && refcount_dec_and_test(&tctx->identity->count)) kfree(tctx->identity); if (req->work.identity != &tctx->__identity && refcount_dec_and_test(&req->work.identity->count)) kfree(req->work.identity); req->work.identity = id; tctx->identity = id; return true; }
Description: In io_identity_cow of io_uring.c, there is a possible way to corrupt memory due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-238177383References: Upstream kernel
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static SIXELSTATUS gif_load_next( gif_context_t  *s, gif_t          *g, unsigned char  *bgcolor ) { SIXELSTATUS status = SIXEL_FALSE; unsigned char buffer[256]; int x; int y; int w; int h; int len; for (;;) { switch (gif_get8(s)) { case 0x2C:   x = gif_get16le(s);   y = gif_get16le(s);   w = gif_get16le(s);   h = gif_get16le(s);   if (((x + w) > (g->w)) || ((y + h) > (g->h))) { sixel_helper_set_additional_message( ""corrupt GIF (reason: bad Image Separator).""); status = SIXEL_RUNTIME_ERROR; goto end; } g->line_size = g->w; g->start_x = x; g->start_y = y; g->max_x   = g->start_x + w; g->max_y   = g->start_y + h; g->cur_x   = g->start_x; g->cur_y   = g->start_y; g->actual_width   = g->start_x; g->actual_height   = g->start_y; g->lflags = gif_get8(s); if (g->lflags & 0x40) { g->step = 8;  g->parse = 3; } else { g->step = 1; g->parse = 0; } if (g->lflags & 0x80) { gif_parse_colortable(s, g->lpal, 2 << (g->lflags & 7)); g->color_table = (unsigned char *) g->lpal; } else if (g->flags & 0x80) { if (g->transparent >= 0 && (g->eflags & 0x01)) { if (bgcolor) { g->pal[g->transparent][0] = bgcolor[2]; g->pal[g->transparent][1] = bgcolor[1]; g->pal[g->transparent][2] = bgcolor[0]; } } g->color_table = (unsigned char *)g->pal; } else { sixel_helper_set_additional_message( ""corrupt GIF (reason: missing color table).""); status = SIXEL_RUNTIME_ERROR; goto end; } status = gif_process_raster(s, g); if (SIXEL_FAILED(status)) { goto end; } goto end; case 0x21:   switch (gif_get8(s)) { case 0x01:   break; case 0x21:   break; case 0xF9:   len = gif_get8(s);  if (len == 4) { g->eflags = gif_get8(s); g->delay = gif_get16le(s);  g->transparent = gif_get8(s); } else { s->img_buffer += len; break; } break; case 0xFF:   len = gif_get8(s);   if (s->img_buffer + len > s->img_buffer_end) { status = SIXEL_RUNTIME_ERROR; goto end; } memcpy(buffer, s->img_buffer, (size_t)len); s->img_buffer += len; buffer[len] = 0; if (len == 11 && strcmp((char *)buffer, ""NETSCAPE2.0"") == 0) { if (gif_get8(s) == 0x03) { switch (gif_get8(s)) { case 0x00: g->loop_count = 1; break; case 0x01: g->loop_count = gif_get16le(s); break; default: g->loop_count = 1; break; } } } break; default: break; } while ((len = gif_get8(s)) != 0) { s->img_buffer += len; } break; case 0x3B:   g->is_terminated = 1; status = SIXEL_OK; goto end; default: sixel_helper_set_additional_message( ""corrupt GIF (reason: unknown code).""); status = SIXEL_RUNTIME_ERROR; goto end; } } status = SIXEL_OK; end: return status; }
Description: An issue was discovered in libsixel 1.8.4. There is a heap-based buffer overflow in the function gif_out_code at fromgif.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void stub_recv_cmd_submit(struct stub_device *sdev, struct usbip_header *pdu) { int ret; struct stub_priv *priv; struct usbip_device *ud = &sdev->ud; struct usb_device *udev = sdev->udev; int pipe = get_pipe(sdev, pdu->base.ep, pdu->base.direction); if (pipe == -1) return; priv = stub_priv_alloc(sdev, pdu); if (!priv) return; if (usb_pipeisoc(pipe)) priv->urb = usb_alloc_urb(pdu->u.cmd_submit.number_of_packets, GFP_KERNEL); else priv->urb = usb_alloc_urb(0, GFP_KERNEL); if (!priv->urb) { usbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC); return; } if (pdu->u.cmd_submit.transfer_buffer_length > 0) { priv->urb->transfer_buffer = kzalloc(pdu->u.cmd_submit.transfer_buffer_length, GFP_KERNEL); if (!priv->urb->transfer_buffer) { usbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC); return; } } priv->urb->setup_packet = kmemdup(&pdu->u.cmd_submit.setup, 8, GFP_KERNEL); if (!priv->urb->setup_packet) { dev_err(&udev->dev, ""allocate setup_packet\n""); usbip_event_add(ud, SDEV_EVENT_ERROR_MALLOC); return; } priv->urb->context                = (void *) priv; priv->urb->dev                    = udev; priv->urb->pipe                   = pipe; priv->urb->complete               = stub_complete; usbip_pack_pdu(pdu, priv->urb, USBIP_CMD_SUBMIT, 0); if (usbip_recv_xbuff(ud, priv->urb) < 0) return; if (usbip_recv_iso(ud, priv->urb) < 0) return; tweak_special_requests(priv->urb); masking_bogus_flags(priv->urb); ret = usb_submit_urb(priv->urb, GFP_KERNEL); if (ret == 0) usbip_dbg_stub_rx(""submit urb ok, seqnum %u\n"", pdu->base.seqnum); else { dev_err(&udev->dev, ""submit_urb error, %d\n"", ret); usbip_dump_header(pdu); usbip_dump_urb(priv->urb); usbip_event_add(ud, SDEV_EVENT_ERROR_SUBMIT); } usbip_dbg_stub_rx(""Leave\n""); }
Description: The ""stub_recv_cmd_submit()"" function (drivers/usb/usbip/stub_rx.c) in the Linux Kernel before version 4.14.8, 4.9.71, and 4.4.114 when handling CMD_SUBMIT packets allows attackers to cause a denial of service (arbitrary memory allocation) via a specially crafted USB over IP packet.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void qf_fill_buffer(qf_list_T *qfl, buf_T *buf, qfline_T *old_last, int qf_winid) { linenr_Tlnum; qfline_T*qfp; intold_KeyTyped = KeyTyped; list_T*qftf_list = NULL; listitem_T*qftf_li = NULL; if (old_last == NULL) { if (buf != curbuf) { internal_error(""qf_fill_buffer()""); return; } while ((curbuf->b_ml.ml_flags & ML_EMPTY) == 0) (void)ml_delete((linenr_T)1); } if (qfl != NULL) { char_udirname[MAXPATHL]; intinvalid_val = FALSE; intprev_bufnr = -1; *dirname = NUL; if (old_last == NULL) { qfp = qfl->qf_start; lnum = 0; } else { if (old_last->qf_next != NULL) qfp = old_last->qf_next; else qfp = old_last; lnum = buf->b_ml.ml_line_count; } qftf_list = call_qftf_func(qfl, qf_winid, (long)(lnum + 1), (long)qfl->qf_count); if (qftf_list != NULL) qftf_li = qftf_list->lv_first; while (lnum < qfl->qf_count) { char_u*qftf_str = NULL; if (qftf_li != NULL && !invalid_val) { qftf_str = tv_get_string_chk(&qftf_li->li_tv); if (qftf_str == NULL) invalid_val = TRUE; } if (qf_buf_add_line(buf, lnum, qfp, dirname, prev_bufnr != qfp->qf_fnum, qftf_str) == FAIL) break; prev_bufnr = qfp->qf_fnum; ++lnum; qfp = qfp->qf_next; if (qfp == NULL) break; if (qftf_li != NULL) qftf_li = qftf_li->li_next; } if (old_last == NULL) (void)ml_delete(lnum + 1); } check_lnums(TRUE); if (old_last == NULL) { ++curbuf_lock; set_option_value_give_err((char_u *)""ft"", 0L, (char_u *)""qf"", OPT_LOCAL); curbuf->b_p_ma = FALSE; keep_filetype = TRUE;apply_autocmds(EVENT_BUFREADPOST, (char_u *)""quickfix"", NULL, FALSE, curbuf); apply_autocmds(EVENT_BUFWINENTER, (char_u *)""quickfix"", NULL, FALSE, curbuf); keep_filetype = FALSE; --curbuf_lock; redraw_curbuf_later(UPD_NOT_VALID); } KeyTyped = old_KeyTyped; }
Description: Use After Free in GitHub repository vim/vim prior to 9.0.0322.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool CRtspSession::ParseRtspRequest(char const * aRequest, unsigned aRequestSize) { unsigned CurRequestSize; Init(); CurRequestSize = aRequestSize; memcpy(CurRequest,aRequest,aRequestSize); char * ClientPortPtr; char * TmpPtr; char CP[128];     char * pCP; ClientPortPtr = strstr(CurRequest,""client_port""); if (ClientPortPtr != nullptr) { TmpPtr = strstr(ClientPortPtr,""\r\n""); if (TmpPtr != nullptr) { TmpPtr[0] = 0x00; strcpy(CP,ClientPortPtr); pCP = strstr(CP,""=""); if (pCP != nullptr) { pCP++; strcpy(CP,pCP); pCP = strstr(CP,""-""); if (pCP != nullptr) { pCP[0] = 0x00; m_ClientRTPPort  = atoi(CP); m_ClientRTCPPort = m_ClientRTPPort + 1; }; }; }; }; bool parseSucceeded = false; unsigned i; for (i = 0; i < sizeof(CmdName)-1 && i < CurRequestSize; ++i) { char c = CurRequest[i]; if (c == ' ' || c == '\t') { parseSucceeded = true; break; } CmdName[i] = c; } CmdName[i] = '\0'; if (!parseSucceeded) { printf(""failed to parse RTSP\n""); return false; } printf(""RTSP received %s\n"", CmdName); if (strstr(CmdName,""OPTIONS"")   != nullptr) m_RtspCmdType = RTSP_OPTIONS; else if (strstr(CmdName,""DESCRIBE"")  != nullptr) m_RtspCmdType = RTSP_DESCRIBE; else if (strstr(CmdName,""SETUP"")     != nullptr) m_RtspCmdType = RTSP_SETUP; else if (strstr(CmdName,""PLAY"")      != nullptr) m_RtspCmdType = RTSP_PLAY; else if (strstr(CmdName,""TEARDOWN"")  != nullptr) m_RtspCmdType = RTSP_TEARDOWN; if (m_RtspCmdType == RTSP_SETUP) { TmpPtr = strstr(CurRequest,""RTP/AVP/TCP""); if (TmpPtr != nullptr) m_TcpTransport = true; else m_TcpTransport = false; }; unsigned j = i+1; while (j < CurRequestSize && (CurRequest[j] == ' ' || CurRequest[j] == '\t')) ++j;     for (; (int)j < (int)(CurRequestSize-8); ++j) { if ((CurRequest[j]   == 'r' || CurRequest[j]   == 'R')   && (CurRequest[j+1] == 't' || CurRequest[j+1] == 'T') && (CurRequest[j+2] == 's' || CurRequest[j+2] == 'S') && (CurRequest[j+3] == 'p' || CurRequest[j+3] == 'P') && CurRequest[j+4] == ':' && CurRequest[j+5] == '/') { j += 6; if (CurRequest[j] == '/') {                   ++j; unsigned uidx = 0; while (j < CurRequestSize && CurRequest[j] != '/' && CurRequest[j] != ' ' && uidx < sizeof(m_URLHostPort) - 1) {                       m_URLHostPort[uidx] = CurRequest[j]; uidx++; ++j; }; } else --j; i = j; break; } } parseSucceeded = false; for (unsigned k = i+1; (int)k < (int)(CurRequestSize-5); ++k) { if (CurRequest[k]   == 'R'   && CurRequest[k+1] == 'T'   && CurRequest[k+2] == 'S'   && CurRequest[k+3] == 'P'   && CurRequest[k+4] == '/') { while (--k >= i && CurRequest[k] == ' ') {} unsigned k1 = k; while (k1 > i && CurRequest[k1] != '/') --k1; if (k - k1 + 1 > sizeof(m_URLSuffix)) return false; unsigned n = 0, k2 = k1+1; while (k2 <= k) m_URLSuffix[n++] = CurRequest[k2++]; m_URLSuffix[n] = '\0'; if (k1 - i > sizeof(m_URLPreSuffix)) return false; n = 0; k2 = i + 1; while (k2 <= k1 - 1) m_URLPreSuffix[n++] = CurRequest[k2++]; m_URLPreSuffix[n] = '\0'; i = k + 7; parseSucceeded = true; break; } } if (!parseSucceeded) return false; parseSucceeded = false; for (j = i; (int)j < (int)(CurRequestSize-5); ++j) { if (CurRequest[j]   == 'C' && CurRequest[j+1] == 'S' && CurRequest[j+2] == 'e' && CurRequest[j+3] == 'q' && CurRequest[j+4] == ':') { j += 5; while (j < CurRequestSize && (CurRequest[j] ==  ' ' || CurRequest[j] == '\t')) ++j; unsigned n; for (n = 0; n < sizeof(m_CSeq)-1 && j < CurRequestSize; ++n,++j) { char c = CurRequest[j]; if (c == '\r' || c == '\n') { parseSucceeded = true; break; } m_CSeq[n] = c; } m_CSeq[n] = '\0'; break; } } if (!parseSucceeded) return false; for (j = i; (int)j < (int)(CurRequestSize-15); ++j) { if (CurRequest[j]    == 'C'  && CurRequest[j+1]  == 'o'  && CurRequest[j+2]  == 'n'  && CurRequest[j+3]  == 't'  && CurRequest[j+4]  == 'e'  && CurRequest[j+5]  == 'n'  && CurRequest[j+6]  == 't'  && CurRequest[j+7]  == '-'  && (CurRequest[j+8] == 'L' || CurRequest[j+8]   == 'l') && CurRequest[j+9]  == 'e'  && CurRequest[j+10] == 'n' && CurRequest[j+11] == 'g' && CurRequest[j+12]  == 't' && CurRequest[j+13] == 'h' && CurRequest[j+14] == ':') { j += 15; while (j < CurRequestSize && (CurRequest[j] ==  ' ' || CurRequest[j] == '\t')) ++j; unsigned num; if (sscanf(&CurRequest[j], ""%u"", &num) == 1) m_ContentLength = num; } } return true; }
Description: Tasmota before commit 066878da4d4762a9b6cb169fdf353e804d735cfd was discovered to contain a stack overflow via the ClientPortPtr parameter at lib/libesp32/rtsp/CRtspSession.cpp.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int dmg_open(BlockDriverState *bs, QDict *options, int flags, Error **errp) { BDRVDMGState *s = bs->opaque; uint64_t info_begin, info_end, last_in_offset, last_out_offset; uint32_t count, tmp; uint32_t max_compressed_size = 1, max_sectors_per_chunk = 1, i; int64_t offset; int ret; bs->read_only = 1; s->n_chunks = 0; s->offsets = s->lengths = s->sectors = s->sectorcounts = NULL; offset = bdrv_getlength(bs->file); if (offset < 0) { ret = offset; goto fail; } offset -= 0x1d8; ret = read_uint64(bs, offset, &info_begin); if (ret < 0) { goto fail; } else if (info_begin == 0) { ret = -EINVAL; goto fail; } ret = read_uint32(bs, info_begin, &tmp); if (ret < 0) { goto fail; } else if (tmp != 0x100) { ret = -EINVAL; goto fail; } ret = read_uint32(bs, info_begin + 4, &count); if (ret < 0) { goto fail; } else if (count == 0) { ret = -EINVAL; goto fail; } info_end = info_begin + count; offset = info_begin + 0x100; last_in_offset = last_out_offset = 0; while (offset < info_end) { uint32_t type; ret = read_uint32(bs, offset, &count); if (ret < 0) { goto fail; } else if (count == 0) { ret = -EINVAL; goto fail; } offset += 4; ret = read_uint32(bs, offset, &type); if (ret < 0) { goto fail; } if (type == 0x6d697368 && count >= 244) { size_t new_size; uint32_t chunk_count; offset += 4; offset += 200; chunk_count = (count - 204) / 40; new_size = sizeof(uint64_t) * (s->n_chunks + chunk_count); s->types = g_realloc(s->types, new_size / 2); s->offsets = g_realloc(s->offsets, new_size); s->lengths = g_realloc(s->lengths, new_size); s->sectors = g_realloc(s->sectors, new_size); s->sectorcounts = g_realloc(s->sectorcounts, new_size); for (i = s->n_chunks; i < s->n_chunks + chunk_count; i++) { ret = read_uint32(bs, offset, &s->types[i]); if (ret < 0) { goto fail; } offset += 4; if (s->types[i] != 0x80000005 && s->types[i] != 1 && s->types[i] != 2) { if (s->types[i] == 0xffffffff && i > 0) { last_in_offset = s->offsets[i - 1] + s->lengths[i - 1]; last_out_offset = s->sectors[i - 1] + s->sectorcounts[i - 1]; } chunk_count--; i--; offset += 36; continue; } offset += 4; ret = read_uint64(bs, offset, &s->sectors[i]); if (ret < 0) { goto fail; } s->sectors[i] += last_out_offset; offset += 8; ret = read_uint64(bs, offset, &s->sectorcounts[i]); if (ret < 0) { goto fail; } offset += 8; ret = read_uint64(bs, offset, &s->offsets[i]); if (ret < 0) { goto fail; } s->offsets[i] += last_in_offset; offset += 8; ret = read_uint64(bs, offset, &s->lengths[i]); if (ret < 0) { goto fail; } offset += 8; if (s->lengths[i] > max_compressed_size) { max_compressed_size = s->lengths[i]; } if (s->sectorcounts[i] > max_sectors_per_chunk) { max_sectors_per_chunk = s->sectorcounts[i]; } } s->n_chunks += chunk_count; } } s->compressed_chunk = g_malloc(max_compressed_size + 1); s->uncompressed_chunk = g_malloc(512 * max_sectors_per_chunk); if (inflateInit(&s->zstream) != Z_OK) { ret = -EINVAL; goto fail; } s->current_chunk = s->n_chunks; qemu_co_mutex_init(&s->lock); return 0; fail: g_free(s->types); g_free(s->offsets); g_free(s->lengths); g_free(s->sectors); g_free(s->sectorcounts); g_free(s->compressed_chunk); g_free(s->uncompressed_chunk); return ret; }
Description: Multiple buffer overflows in QEMU before 1.7.2 and 2.x before 2.0.0, allow local users to cause a denial of service (crash) or possibly execute arbitrary code via a large (1) L1 table in the qcow2_snapshot_load_tmp in the QCOW 2 block driver (block/qcow2-snapshot.c) or (2) uncompressed chunk, (3) chunk length, or (4) number of sectors in the DMG block driver (block/dmg.c).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static bfd_boolean process_mips_specific (FILE * file) { Elf_Internal_Dyn * entry; Elf_Internal_Shdr *sect = NULL; size_t liblist_offset = 0; size_t liblistno = 0; size_t conflictsno = 0; size_t options_offset = 0; size_t conflicts_offset = 0; size_t pltrelsz = 0; size_t pltrel = 0; bfd_vma pltgot = 0; bfd_vma mips_pltgot = 0; bfd_vma jmprel = 0; bfd_vma local_gotno = 0; bfd_vma gotsym = 0; bfd_vma symtabno = 0; bfd_boolean res = TRUE; if (! process_attributes (file, NULL, SHT_GNU_ATTRIBUTES, NULL, display_mips_gnu_attribute)) res = FALSE; sect = find_section ("".MIPS.abiflags""); if (sect != NULL) { Elf_External_ABIFlags_v0 *abiflags_ext; Elf_Internal_ABIFlags_v0 abiflags_in; if (sizeof (Elf_External_ABIFlags_v0) != sect->sh_size) { error (_(""Corrupt MIPS ABI Flags section.\n"")); res = FALSE; } else { abiflags_ext = get_data (NULL, file, sect->sh_offset, 1, sect->sh_size, _(""MIPS ABI Flags section"")); if (abiflags_ext) { abiflags_in.version = BYTE_GET (abiflags_ext->version); abiflags_in.isa_level = BYTE_GET (abiflags_ext->isa_level); abiflags_in.isa_rev = BYTE_GET (abiflags_ext->isa_rev); abiflags_in.gpr_size = BYTE_GET (abiflags_ext->gpr_size); abiflags_in.cpr1_size = BYTE_GET (abiflags_ext->cpr1_size); abiflags_in.cpr2_size = BYTE_GET (abiflags_ext->cpr2_size); abiflags_in.fp_abi = BYTE_GET (abiflags_ext->fp_abi); abiflags_in.isa_ext = BYTE_GET (abiflags_ext->isa_ext); abiflags_in.ases = BYTE_GET (abiflags_ext->ases); abiflags_in.flags1 = BYTE_GET (abiflags_ext->flags1); abiflags_in.flags2 = BYTE_GET (abiflags_ext->flags2); printf (""\nMIPS ABI Flags Version: %d\n"", abiflags_in.version); printf (""\nISA: MIPS%d"", abiflags_in.isa_level); if (abiflags_in.isa_rev > 1) printf (""r%d"", abiflags_in.isa_rev); printf (""\nGPR size: %d"", get_mips_reg_size (abiflags_in.gpr_size)); printf (""\nCPR1 size: %d"", get_mips_reg_size (abiflags_in.cpr1_size)); printf (""\nCPR2 size: %d"", get_mips_reg_size (abiflags_in.cpr2_size)); fputs (""\nFP ABI: "", stdout); print_mips_fp_abi_value (abiflags_in.fp_abi); fputs (""ISA Extension: "", stdout); print_mips_isa_ext (abiflags_in.isa_ext); fputs (""\nASEs:"", stdout); print_mips_ases (abiflags_in.ases); printf (""\nFLAGS 1: %8.8lx"", abiflags_in.flags1); printf (""\nFLAGS 2: %8.8lx"", abiflags_in.flags2); fputc ('\n', stdout); free (abiflags_ext); } } } if (dynamic_section == NULL) return res; for (entry = dynamic_section; entry < dynamic_section + dynamic_nent && entry->d_tag != DT_NULL; ++entry) switch (entry->d_tag) { case DT_MIPS_LIBLIST: liblist_offset = offset_from_vma (file, entry->d_un.d_val, liblistno * sizeof (Elf32_External_Lib)); break; case DT_MIPS_LIBLISTNO: liblistno = entry->d_un.d_val; break; case DT_MIPS_OPTIONS: options_offset = offset_from_vma (file, entry->d_un.d_val, 0); break; case DT_MIPS_CONFLICT: conflicts_offset = offset_from_vma (file, entry->d_un.d_val, conflictsno * sizeof (Elf32_External_Conflict)); break; case DT_MIPS_CONFLICTNO: conflictsno = entry->d_un.d_val; break; case DT_PLTGOT: pltgot = entry->d_un.d_ptr; break; case DT_MIPS_LOCAL_GOTNO: local_gotno = entry->d_un.d_val; break; case DT_MIPS_GOTSYM: gotsym = entry->d_un.d_val; break; case DT_MIPS_SYMTABNO: symtabno = entry->d_un.d_val; break; case DT_MIPS_PLTGOT: mips_pltgot = entry->d_un.d_ptr; break; case DT_PLTREL: pltrel = entry->d_un.d_val; break; case DT_PLTRELSZ: pltrelsz = entry->d_un.d_val; break; case DT_JMPREL: jmprel = entry->d_un.d_ptr; break; default: break; } if (liblist_offset != 0 && liblistno != 0 && do_dynamic) { Elf32_External_Lib * elib; size_t cnt; elib = (Elf32_External_Lib *) get_data (NULL, file, liblist_offset, liblistno, sizeof (Elf32_External_Lib), _(""liblist section data"")); if (elib) { printf (_(""\nSection '.liblist' contains %lu entries:\n""), (unsigned long) liblistno); fputs (_(""     Library              Time Stamp          Checksum   Version Flags\n""), stdout); for (cnt = 0; cnt < liblistno; ++cnt) { Elf32_Lib liblist; time_t atime; char timebuf[128]; struct tm * tmp; liblist.l_name = BYTE_GET (elib[cnt].l_name); atime = BYTE_GET (elib[cnt].l_time_stamp); liblist.l_checksum = BYTE_GET (elib[cnt].l_checksum); liblist.l_version = BYTE_GET (elib[cnt].l_version); liblist.l_flags = BYTE_GET (elib[cnt].l_flags); tmp = gmtime (&atime); snprintf (timebuf, sizeof (timebuf), ""%04u-%02u-%02uT%02u:%02u:%02u"", tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday, tmp->tm_hour, tmp->tm_min, tmp->tm_sec); printf (""%3lu: "", (unsigned long) cnt); if (VALID_DYNAMIC_NAME (liblist.l_name)) print_symbol (20, GET_DYNAMIC_NAME (liblist.l_name)); else printf (_(""<corrupt: %9ld>""), liblist.l_name); printf ("" %s %#10lx %-7ld"", timebuf, liblist.l_checksum, liblist.l_version); if (liblist.l_flags == 0) puts (_("" NONE"")); else { static const struct { const char * name; int bit; } l_flags_vals[] = { { "" EXACT_MATCH"", LL_EXACT_MATCH }, { "" IGNORE_INT_VER"", LL_IGNORE_INT_VER }, { "" REQUIRE_MINOR"", LL_REQUIRE_MINOR }, { "" EXPORTS"", LL_EXPORTS }, { "" DELAY_LOAD"", LL_DELAY_LOAD }, { "" DELTA"", LL_DELTA } }; int flags = liblist.l_flags; size_t fcnt; for (fcnt = 0; fcnt < ARRAY_SIZE (l_flags_vals); ++fcnt) if ((flags & l_flags_vals[fcnt].bit) != 0) { fputs (l_flags_vals[fcnt].name, stdout); flags ^= l_flags_vals[fcnt].bit; } if (flags != 0) printf ("" %#x"", (unsigned int) flags); puts (""""); } } free (elib); } else res = FALSE; } if (options_offset != 0) { Elf_External_Options * eopt; Elf_Internal_Options * iopt; Elf_Internal_Options * option; size_t offset; int cnt; sect = section_headers; sect = find_section_by_type (SHT_MIPS_OPTIONS); if (sect == NULL) { error (_(""No MIPS_OPTIONS header found\n"")); return FALSE; } eopt = (Elf_External_Options *) get_data (NULL, file, options_offset, 1, sect->sh_size, _(""options"")); if (eopt) { iopt = (Elf_Internal_Options *) cmalloc ((sect->sh_size / sizeof (eopt)), sizeof (* iopt)); if (iopt == NULL) { error (_(""Out of memory allocating space for MIPS options\n"")); return FALSE; } offset = cnt = 0; option = iopt; while (offset <= sect->sh_size - sizeof (* eopt)) { Elf_External_Options * eoption; eoption = (Elf_External_Options *) ((char *) eopt + offset); option->kind = BYTE_GET (eoption->kind); option->size = BYTE_GET (eoption->size); option->section = BYTE_GET (eoption->section); option->info = BYTE_GET (eoption->info); if (option->size < sizeof (* eopt) || offset + option->size > sect->sh_size) { error (_(""Invalid size (%u) for MIPS option\n""), option->size); return FALSE; } offset += option->size; ++option; ++cnt; } printf (_(""\nSection '%s' contains %d entries:\n""), printable_section_name (sect), cnt); option = iopt; offset = 0; while (cnt-- > 0) { size_t len; switch (option->kind) { case ODK_NULL: printf ("" NULL       %d %lx"", option->section, option->info); break; case ODK_REGINFO: printf ("" REGINFO    ""); if (elf_header.e_machine == EM_MIPS) { Elf32_External_RegInfo * ereg; Elf32_RegInfo reginfo; ereg = (Elf32_External_RegInfo *) (option + 1); reginfo.ri_gprmask = BYTE_GET (ereg->ri_gprmask); reginfo.ri_cprmask[0] = BYTE_GET (ereg->ri_cprmask[0]); reginfo.ri_cprmask[1] = BYTE_GET (ereg->ri_cprmask[1]); reginfo.ri_cprmask[2] = BYTE_GET (ereg->ri_cprmask[2]); reginfo.ri_cprmask[3] = BYTE_GET (ereg->ri_cprmask[3]); reginfo.ri_gp_value = BYTE_GET (ereg->ri_gp_value); printf (""GPR %08lx  GP 0x%lx\n"", reginfo.ri_gprmask, (unsigned long) reginfo.ri_gp_value); printf (""            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\n"", reginfo.ri_cprmask[0], reginfo.ri_cprmask[1], reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]); } else { Elf64_External_RegInfo * ereg; Elf64_Internal_RegInfo reginfo; ereg = (Elf64_External_RegInfo *) (option + 1); reginfo.ri_gprmask    = BYTE_GET (ereg->ri_gprmask); reginfo.ri_cprmask[0] = BYTE_GET (ereg->ri_cprmask[0]); reginfo.ri_cprmask[1] = BYTE_GET (ereg->ri_cprmask[1]); reginfo.ri_cprmask[2] = BYTE_GET (ereg->ri_cprmask[2]); reginfo.ri_cprmask[3] = BYTE_GET (ereg->ri_cprmask[3]); reginfo.ri_gp_value   = BYTE_GET (ereg->ri_gp_value); printf (""GPR %08lx  GP 0x"", reginfo.ri_gprmask); printf_vma (reginfo.ri_gp_value); printf (""\n""); printf (""            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\n"", reginfo.ri_cprmask[0], reginfo.ri_cprmask[1], reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]); } ++option; continue; case ODK_EXCEPTIONS: fputs ("" EXCEPTIONS fpe_min("", stdout); process_mips_fpe_exception (option->info & OEX_FPU_MIN); fputs ("") fpe_max("", stdout); process_mips_fpe_exception ((option->info & OEX_FPU_MAX) >> 8); fputs ("")"", stdout); if (option->info & OEX_PAGE0) fputs ("" PAGE0"", stdout); if (option->info & OEX_SMM) fputs ("" SMM"", stdout); if (option->info & OEX_FPDBUG) fputs ("" FPDBUG"", stdout); if (option->info & OEX_DISMISS) fputs ("" DISMISS"", stdout); break; case ODK_PAD: fputs ("" PAD       "", stdout); if (option->info & OPAD_PREFIX) fputs ("" PREFIX"", stdout); if (option->info & OPAD_POSTFIX) fputs ("" POSTFIX"", stdout); if (option->info & OPAD_SYMBOL) fputs ("" SYMBOL"", stdout); break; case ODK_HWPATCH: fputs ("" HWPATCH   "", stdout); if (option->info & OHW_R4KEOP) fputs ("" R4KEOP"", stdout); if (option->info & OHW_R8KPFETCH) fputs ("" R8KPFETCH"", stdout); if (option->info & OHW_R5KEOP) fputs ("" R5KEOP"", stdout); if (option->info & OHW_R5KCVTL) fputs ("" R5KCVTL"", stdout); break; case ODK_FILL: fputs ("" FILL       "", stdout); break; case ODK_TAGS: fputs ("" TAGS       "", stdout); break; case ODK_HWAND: fputs ("" HWAND     "", stdout); if (option->info & OHWA0_R4KEOP_CHECKED) fputs ("" R4KEOP_CHECKED"", stdout); if (option->info & OHWA0_R4KEOP_CLEAN) fputs ("" R4KEOP_CLEAN"", stdout); break; case ODK_HWOR: fputs ("" HWOR      "", stdout); if (option->info & OHWA0_R4KEOP_CHECKED) fputs ("" R4KEOP_CHECKED"", stdout); if (option->info & OHWA0_R4KEOP_CLEAN) fputs ("" R4KEOP_CLEAN"", stdout); break; case ODK_GP_GROUP: printf ("" GP_GROUP  %#06lx  self-contained %#06lx"", option->info & OGP_GROUP, (option->info & OGP_SELF) >> 16); break; case ODK_IDENT: printf ("" IDENT     %#06lx  self-contained %#06lx"", option->info & OGP_GROUP, (option->info & OGP_SELF) >> 16); break; default: printf ("" %3d ???     %d %lx"", option->kind, option->section, option->info); break; } len = sizeof (* eopt); while (len < option->size) { unsigned char datum = * ((unsigned char *) eopt + offset + len); if (ISPRINT (datum)) printf (""%c"", datum); else printf (""\\%03o"", datum); len ++; } fputs (""\n"", stdout); offset += option->size; ++option; } free (eopt); } else res = FALSE; } if (conflicts_offset != 0 && conflictsno != 0) { Elf32_Conflict * iconf; size_t cnt; if (dynamic_symbols == NULL) { error (_(""conflict list found without a dynamic symbol table\n"")); return FALSE; } iconf = (Elf32_Conflict *) cmalloc (conflictsno, sizeof (* iconf)); if (iconf == NULL) { error (_(""Out of memory allocating space for dynamic conflicts\n"")); return FALSE; } if (is_32bit_elf) { Elf32_External_Conflict * econf32; econf32 = (Elf32_External_Conflict *) get_data (NULL, file, conflicts_offset, conflictsno, sizeof (* econf32), _(""conflict"")); if (!econf32) return FALSE; for (cnt = 0; cnt < conflictsno; ++cnt) iconf[cnt] = BYTE_GET (econf32[cnt]); free (econf32); } else { Elf64_External_Conflict * econf64; econf64 = (Elf64_External_Conflict *) get_data (NULL, file, conflicts_offset, conflictsno, sizeof (* econf64), _(""conflict"")); if (!econf64) return FALSE; for (cnt = 0; cnt < conflictsno; ++cnt) iconf[cnt] = BYTE_GET (econf64[cnt]); free (econf64); } printf (_(""\nSection '.conflict' contains %lu entries:\n""), (unsigned long) conflictsno); puts (_(""  Num:    Index       Value  Name"")); for (cnt = 0; cnt < conflictsno; ++cnt) { printf (""%5lu: %8lu  "", (unsigned long) cnt, iconf[cnt]); if (iconf[cnt] >= num_dynamic_syms) printf (_(""<corrupt symbol index>"")); else { Elf_Internal_Sym * psym; psym = & dynamic_symbols[iconf[cnt]]; print_vma (psym->st_value, FULL_HEX); putchar (' '); if (VALID_DYNAMIC_NAME (psym->st_name)) print_symbol (25, GET_DYNAMIC_NAME (psym->st_name)); else printf (_(""<corrupt: %14ld>""), psym->st_name); } putchar ('\n'); } free (iconf); } if (pltgot != 0 && local_gotno != 0) { bfd_vma ent, local_end, global_end; size_t i, offset; unsigned char * data; unsigned char * data_end; int addr_size; ent = pltgot; addr_size = (is_32bit_elf ? 4 : 8); local_end = pltgot + local_gotno * addr_size; if (symtabno < gotsym) { error (_(""The GOT symbol offset (%lu) is greater than the symbol table size (%lu)\n""), (unsigned long) gotsym, (unsigned long) symtabno); return FALSE; } global_end = local_end + (symtabno - gotsym) * addr_size; if (global_end < local_end) { error (_(""Too many GOT symbols: %lu\n""), (unsigned long) symtabno); return FALSE; } offset = offset_from_vma (file, pltgot, global_end - pltgot); data = (unsigned char *) get_data (NULL, file, offset, global_end - pltgot, 1, _(""Global Offset Table data"")); if (data == NULL) return FALSE; data_end = data + (global_end - pltgot); printf (_(""\nPrimary GOT:\n"")); printf (_("" Canonical gp value: "")); print_vma (pltgot + 0x7ff0, LONG_HEX); printf (""\n\n""); printf (_("" Reserved entries:\n"")); printf (_(""  %*s %10s %*s Purpose\n""), addr_size * 2, _(""Address""), _(""Access""), addr_size * 2, _(""Initial"")); ent = print_mips_got_entry (data, pltgot, ent, data_end); printf (_("" Lazy resolver\n"")); if (ent == (bfd_vma) -1) goto got_print_fail; if (data && (byte_get (data + ent - pltgot, addr_size) >> (addr_size * 8 - 1)) != 0) { ent = print_mips_got_entry (data, pltgot, ent, data_end); printf (_("" Module pointer (GNU extension)\n"")); if (ent == (bfd_vma) -1) goto got_print_fail; } printf (""\n""); if (ent < local_end) { printf (_("" Local entries:\n"")); printf (""  %*s %10s %*s\n"", addr_size * 2, _(""Address""), _(""Access""), addr_size * 2, _(""Initial"")); while (ent < local_end) { ent = print_mips_got_entry (data, pltgot, ent, data_end); printf (""\n""); if (ent == (bfd_vma) -1) goto got_print_fail; } printf (""\n""); } if (gotsym < symtabno) { int sym_width; printf (_("" Global entries:\n"")); printf (""  %*s %10s %*s %*s %-7s %3s %s\n"", addr_size * 2, _(""Address""), _(""Access""), addr_size * 2, _(""Initial""), addr_size * 2, _(""Sym.Val.""), _(""Type""), _(""Ndx""), _(""Name"")); sym_width = (is_32bit_elf ? 80 : 160) - 28 - addr_size * 6 - 1; for (i = gotsym; i < symtabno; i++) { ent = print_mips_got_entry (data, pltgot, ent, data_end); printf ("" ""); if (dynamic_symbols == NULL) printf (_(""<no dynamic symbols>"")); else if (i < num_dynamic_syms) { Elf_Internal_Sym * psym = dynamic_symbols + i; print_vma (psym->st_value, LONG_HEX); printf ("" %-7s %3s "", get_symbol_type (ELF_ST_TYPE (psym->st_info)), get_symbol_index_type (psym->st_shndx)); if (VALID_DYNAMIC_NAME (psym->st_name)) print_symbol (sym_width, GET_DYNAMIC_NAME (psym->st_name)); else printf (_(""<corrupt: %14ld>""), psym->st_name); } else printf (_(""<symbol index %lu exceeds number of dynamic symbols>""), (unsigned long) i); printf (""\n""); if (ent == (bfd_vma) -1) break; } printf (""\n""); } got_print_fail: if (data) free (data); } if (mips_pltgot != 0 && jmprel != 0 && pltrel != 0 && pltrelsz != 0) { bfd_vma ent, end; size_t offset, rel_offset; unsigned long count, i; unsigned char * data; int addr_size, sym_width; Elf_Internal_Rela * rels; rel_offset = offset_from_vma (file, jmprel, pltrelsz); if (pltrel == DT_RELA) { if (!slurp_rela_relocs (file, rel_offset, pltrelsz, &rels, &count)) return FALSE; } else { if (!slurp_rel_relocs (file, rel_offset, pltrelsz, &rels, &count)) return FALSE; } ent = mips_pltgot; addr_size = (is_32bit_elf ? 4 : 8); end = mips_pltgot + (2 + count) * addr_size; offset = offset_from_vma (file, mips_pltgot, end - mips_pltgot); data = (unsigned char *) get_data (NULL, file, offset, end - mips_pltgot, 1, _(""Procedure Linkage Table data"")); if (data == NULL) return FALSE; printf (""\nPLT GOT:\n\n""); printf (_("" Reserved entries:\n"")); printf (_(""  %*s %*s Purpose\n""), addr_size * 2, _(""Address""), addr_size * 2, _(""Initial"")); ent = print_mips_pltgot_entry (data, mips_pltgot, ent); printf (_("" PLT lazy resolver\n"")); ent = print_mips_pltgot_entry (data, mips_pltgot, ent); printf (_("" Module pointer\n"")); printf (""\n""); printf (_("" Entries:\n"")); printf (""  %*s %*s %*s %-7s %3s %s\n"", addr_size * 2, _(""Address""), addr_size * 2, _(""Initial""), addr_size * 2, _(""Sym.Val.""), _(""Type""), _(""Ndx""), _(""Name"")); sym_width = (is_32bit_elf ? 80 : 160) - 17 - addr_size * 6 - 1; for (i = 0; i < count; i++) { unsigned long idx = get_reloc_symindex (rels[i].r_info); ent = print_mips_pltgot_entry (data, mips_pltgot, ent); printf ("" ""); if (idx >= num_dynamic_syms) printf (_(""<corrupt symbol index: %lu>""), idx); else { Elf_Internal_Sym * psym = dynamic_symbols + idx; print_vma (psym->st_value, LONG_HEX); printf ("" %-7s %3s "", get_symbol_type (ELF_ST_TYPE (psym->st_info)), get_symbol_index_type (psym->st_shndx)); if (VALID_DYNAMIC_NAME (psym->st_name)) print_symbol (sym_width, GET_DYNAMIC_NAME (psym->st_name)); else printf (_(""<corrupt: %14ld>""), psym->st_name); } printf (""\n""); } printf (""\n""); if (data) free (data); free (rels); } return res; }
Description: GNU Binutils 2.28 allows remote attackers to cause a denial of service (heap-based buffer over-read and application crash) via a crafted ELF file, related to MIPS GOT mishandling in the process_mips_specific function in readelf.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: DataBuf PngChunk::readRawProfile(const DataBuf& text,bool iTXt) { DataBuf                 info; unsigned char           unhex[103]={0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,1, 2,3,4,5,6,7,8,9,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,10,11,12, 13,14,15}; if (text.size_ == 0) { return DataBuf(); } if ( iTXt ) { info.alloc(text.size_); ::memcpy(info.pData_,text.pData_,text.size_); return  info; } const char *sp = (char*)text.pData_+1; int pointerPos = 1; while (*sp != '\n' && pointerPos < (text.size_ - 1)) { sp++; pointerPos++; } while ((*sp == '\0' || *sp == ' ' || *sp == '\n') && pointerPos < (text.size_ - 1)) { sp++; pointerPos++; } if (pointerPos == (text.size_ - 1)) { return DataBuf(); } long length = (long) atol(sp); while (*sp != ' ' && *sp != '\n' && pointerPos < (text.size_ - 1)) { sp++; pointerPos++; } if (pointerPos == (text.size_ - 1)) { return DataBuf(); } if (length == 0) { #ifdef DEBUG std::cerr << ""Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: invalid profile length\n""; #endif } info.alloc(length); if (info.size_ != length) { #ifdef DEBUG std::cerr << ""Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: cannot allocate memory\n""; #endif return DataBuf(); } unsigned char *dp = (unsigned char*)info.pData_; unsigned int nibbles = length * 2; for (long i = 0; i < (long) nibbles; i++) { while (*sp < '0' || (*sp > '9' && *sp < 'a') || *sp > 'f') { if (*sp == '\0') { #ifdef DEBUG std::cerr << ""Exiv2::PngChunk::readRawProfile: Unable To Copy Raw Profile: ran out of data\n""; #endif return DataBuf(); } sp++; } if (i%2 == 0) *dp = (unsigned char) (16*unhex[(int) *sp++]); else (*dp++) += unhex[(int) *sp++]; } return info; }
Description: In Exiv2 0.26 and previous versions, PngChunk::readRawProfile in pngchunk_int.cpp may cause a denial of service (application crash due to a heap-based buffer over-read) via a crafted PNG file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int stream_process(struct sip_msg * msg, struct sdp_stream_cell *cell, str * s, str* ss, regex_t* re, int op,int description) { static sdp_payload_attr_t static_payloads[] = { { NULL,0,{ ""3"",1},{ ""GSM"",3},{ ""8000"",4},{NULL,0},{NULL,0} },    { NULL,0,{ ""4"",1},{""G723"",4},{ ""8000"",4},{NULL,0},{NULL,0} },    { NULL,0,{ ""5"",1},{""DVI4"",4},{ ""8000"",4},{NULL,0},{NULL,0} },    { NULL,0,{ ""6"",1},{""DVI4"",4},{""16000"",5},{NULL,0},{NULL,0} },    { NULL,0,{ ""7"",1},{ ""LPC"",3},{ ""8000"",4},{NULL,0},{NULL,0} },    { NULL,0,{ ""8"",1},{""PCMA"",4},{ ""8000"",4},{NULL,0},{NULL,0} },    { NULL,0,{ ""9"",1},{""G722"",4},{ ""8000"",4},{NULL,0},{NULL,0} },    { NULL,0,{""10"",2},{ ""L16"",3},{""44100"",5},{NULL,0},{NULL,0} },    { NULL,0,{""11"",2},{ ""L16"",3},{""44100"",5},{NULL,0},{NULL,0} },    { NULL,0,{""12"",2},{""QCELP"",5},{""8000"",4},{NULL,0},{NULL,0} },    { NULL,0,{""13"",2},{  ""CN"",2},{ ""8000"",4},{NULL,0},{NULL,0} },    { NULL,0,{""14"",2},{ ""MPA"",3},{""90000"",5},{NULL,0},{NULL,0} },    { NULL,0,{""15"",2},{""G728"",4},{ ""8000"",4},{NULL,0},{NULL,0} },    { NULL,0,{""16"",2},{""DVI4"",4},{""11025"",5},{NULL,0},{NULL,0} },    { NULL,0,{""17"",2},{""DVI4"",4},{""22050"",5},{NULL,0},{NULL,0} },    { NULL,0,{""18"",2},{""G729"",4},{ ""8000"",4},{NULL,0},{NULL,0} },    { NULL,0,{""25"",2},{""CelB"",4},{ ""8000"",4},{NULL,0},{NULL,0} },    { NULL,0,{""26"",2},{""JPEG"",4},{""90000"",5},{NULL,0},{NULL,0} },    { NULL,0,{""28"",2},{  ""nv"",2},{""90000"",5},{NULL,0},{NULL,0} },    { NULL,0,{""31"",2},{""H261"",4},{""90000"",5},{NULL,0},{NULL,0} },    { NULL,0,{""32"",2},{ ""MPV"",3},{""90000"",5},{NULL,0},{NULL,0} },    { NULL,0,{""33"",2},{""MP2T"",4},{""90000"",5},{NULL,0},{NULL,0} },    { NULL,0,{""34"",2},{""H263"",4},{""90000"",5},{NULL,0},{NULL,0} },    { NULL,0,{""t38"",3},{""t38"",3},{     """",0},{NULL,0},{NULL,0} },    { NULL,0,{NULL,0},{  NULL,0},{   NULL,0},{NULL,0},{NULL,0} } }; sdp_payload_attr_t *payload; char *cur, *tmp, *buff, temp; struct lump * lmp; str found; int ret, i,match, buff_len, is_static; regmatch_t pmatch; lmp = get_associated_lump(msg, cell); if( lmp == NULL) { LM_ERR(""There is no lump for this sdp cell\n""); return -1; } if (lmp->len == 0) return -1; buff_len = 0; ret = 0; buff = pkg_malloc(lmp->len+1); if( buff == NULL) { LM_ERR(""Out of memory\n""); return -1; } is_static = 0; payload = cell->payload_attr; while(payload) { if( payload->rtp_enc.s == NULL || (payload->rtp_clock.s == NULL && ss != NULL) || payload->rtp_payload.s == NULL) { goto next_payload; } match = 0; if( description == DESC_REGEXP ||description == DESC_REGEXP_COMPLEMENT ) { if (is_static) { match = regexec( re, payload->rtp_enc.s, 1, &pmatch, 0) == 0; } else { temp = payload->rtp_enc.s[payload->rtp_enc.len]; payload->rtp_enc.s[payload->rtp_enc.len] = 0; match = regexec( re, payload->rtp_enc.s, 1, &pmatch, 0) == 0; payload->rtp_enc.s[payload->rtp_enc.len] = temp; } } if( description == DESC_REGEXP_COMPLEMENT) match = !match; if( description == DESC_NAME  ) { match = s->len == payload->rtp_enc.len && strncasecmp( s->s, payload->rtp_enc.s ,payload->rtp_enc.len) == 0; } if( description == DESC_NAME_AND_CLOCK) { match = s->len == payload->rtp_enc.len && strncasecmp( s->s, payload->rtp_enc.s , payload->rtp_enc.len) == 0 && (ss == NULL || ( ss->len == payload->rtp_clock.len && strncasecmp( ss->s, payload->rtp_clock.s , payload->rtp_clock.len) == 0 ) ); } if (match) { match = 0; cur = lmp->u.value; while( !match && cur < lmp->u.value + lmp->len) { found.s = cur; while(  cur < lmp->u.value + lmp->len &&  *cur != ' ' ) cur++; found.len = cur - found.s; if ( found.len == payload->rtp_payload.len && strncmp( found.s,payload->rtp_payload.s,found.len) == 0) { match = 1; } else { while( cur < lmp->u.value + lmp->len && * cur == ' '  ) cur++; } } if (match) { if(op == FIND) { ret = 1; goto end; } if( op == DELETE && !is_static ) { if( delete_sdp_line( msg, payload->rtp_enc.s, cell) < 0 ) { LM_ERR(""Unable to add delete lump for a=\n""); ret = -1; goto end; } if( delete_sdp_line( msg, payload->fmtp_string.s, cell) < 0 ) { LM_ERR(""Unable to add delete lump for a=\n""); ret = -1; goto end; } } { while (found.s > lmp->u.value && *(found.s - 1) == ' ') { found.s--; found.len++; } if (cur == lmp->u.value + lmp->len) { tmp = found.s; while (*(--tmp) == ' ') { found.s--; found.len++; } } for(tmp=found.s ; tmp< lmp->u.value + lmp->len ; tmp++ ) *tmp  = *(tmp+found.len); lmp->len -= found.len; } if( op == ADD_TO_FRONT  || op == ADD_TO_BACK) { memcpy(&buff[buff_len],"" "",1); buff_len++; memcpy(&buff[buff_len],payload->rtp_payload.s, payload->rtp_payload.len); buff_len += payload->rtp_payload.len; } ret = 1; } } next_payload: if (!is_static) { payload = payload->next; if (payload==NULL) { payload = static_payloads; is_static = 1; } } else { payload ++; if (payload->rtp_payload.s==NULL) payload=NULL; } } if( op == ADD_TO_FRONT && buff_len >0 ) { lmp->u.value = (char*)pkg_realloc(lmp->u.value, lmp->len+buff_len); if(!lmp->u.value) { LM_ERR(""No more pkg memory\n""); ret = -1; goto end; } for( i = lmp->len -1 ; i>=0;i--) lmp->u.value[i+buff_len] = lmp->u.value[i]; memcpy(lmp->u.value,buff,buff_len); lmp->len += buff_len; } if( op == ADD_TO_BACK && buff_len >0 ) { lmp->u.value = (char*)pkg_realloc(lmp->u.value, lmp->len+buff_len); if(!lmp->u.value) { LM_ERR(""No more pkg memory\n""); ret = -1; goto end; } memcpy(&lmp->u.value[lmp->len],buff,buff_len); lmp->len += buff_len; } if (lmp->len == 0) { lmp = del_lump(msg, cell->port.s - msg->buf - 1, cell->port.len + 2, 0); if (!lmp) { LM_ERR(""could not add lump to disable stream!\n""); goto end; } tmp = pkg_malloc(3); if (!tmp) { LM_ERR(""oom for port 0\n""); goto end; } memcpy(tmp, "" 0 "", 3); if (!insert_new_lump_after(lmp, tmp, 3, 0)) LM_ERR(""could not insert lump to disable stream!\n""); } end: pkg_free(buff); return ret; }
Description: OpenSIPS is a Session Initiation Protocol (SIP) server implementation. Prior to versions 3.1.8 and 3.2.5, OpenSIPS crashes when a malformed SDP body is sent multiple times to an OpenSIPS configuration that makes use of the `stream_process` function. This issue was discovered during coverage guided fuzzing of the function `codec_delete_except_re`. By abusing this vulnerability, an attacker is able to crash the server. It affects configurations containing functions that rely on the affected code, such as the function `codec_delete_except_re`. This issue has been fixed in version 3.1.8 and 3.2.5.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void print_cfs_stats(struct seq_file *m, int cpu) { struct cfs_rq *cfs_rq, *pos; rcu_read_lock(); for_each_leaf_cfs_rq_safe(cpu_rq(cpu), cfs_rq, pos) print_cfs_rq(m, cpu, cfs_rq); rcu_read_unlock(); }
Description: In the Linux kernel before 4.20.2, kernel/sched/fair.c mishandles leaf cfs_rq's, which allows attackers to cause a denial of service (infinite loop in update_blocked_averages) or possibly have unspecified other impact by inducing a high load.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static VALUE cState_object_nl_set(VALUE self, VALUE object_nl) { unsigned long len; GET_STATE(self); Check_Type(object_nl, T_STRING); len = RSTRING_LEN(object_nl); if (len == 0) { if (state->object_nl) { ruby_xfree(state->object_nl); state->object_nl = NULL; } } else { if (state->object_nl) ruby_xfree(state->object_nl); state->object_nl = strdup(RSTRING_PTR(object_nl)); state->object_nl_len = len; } return Qnil; }
Description: Ruby through 2.2.7, 2.3.x through 2.3.4, and 2.4.x through 2.4.1 can expose arbitrary memory during a JSON.generate call. The issues lies in using strdup in ext/json/ext/generator/generator.c, which will stop after encountering a '\0' byte, returning a pointer to a string of length zero, which is not the length stored in space_len.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Str process_button(struct parsed_tag *tag) { Str tmp = NULL; char *p, *q, *r, *qq = """"; int qlen, v; if (cur_form_id < 0) { char *s = ""<form_int method=internal action=none>""; tmp = process_form(parse_tag(&s, TRUE)); } if (tmp == NULL) tmp = Strnew(); p = ""submit""; parsedtag_get_value(tag, ATTR_TYPE, &p); q = NULL; parsedtag_get_value(tag, ATTR_VALUE, &q); r = """"; parsedtag_get_value(tag, ATTR_NAME, &r); v = formtype(p); if (v == FORM_UNKNOWN) return NULL; if (!q) { switch (v) { case FORM_INPUT_SUBMIT: case FORM_INPUT_BUTTON: q = ""SUBMIT""; break; case FORM_INPUT_RESET: q = ""RESET""; break; } } if (q) { qq = html_quote(q); qlen = strlen(q); } Strcat(tmp, Sprintf(""<input_alt hseq=\""%d\"" fid=\""%d\"" type=\""%s\"" "" ""name=\""%s\"" value=\""%s\"">"", cur_hseq++, cur_form_id, html_quote(p), html_quote(r), qq)); return tmp; }
Description: An issue was discovered in the Tatsuya Kinoshita w3m fork before 0.5.3-31. w3m allows remote attackers to cause a denial of service (segmentation fault and crash) and possibly memory corruption via a crafted HTML page.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: njs_int_t njs_value_property_delete(njs_vm_t *vm, njs_value_t *value, njs_value_t *key, njs_value_t *removed, njs_bool_t thrw) { double                num; uint32_t              index; njs_int_t             ret; njs_array_t           *array; njs_object_prop_t     *prop; njs_property_query_t  pq; njs_assert(njs_is_index_or_key(key)); if (njs_fast_path(njs_is_number(key))) { if (njs_slow_path(!(njs_is_fast_array(value)))) { goto slow_path; } num = njs_number(key); if (njs_slow_path(!njs_number_is_integer_index(num))) { goto slow_path; } index = (uint32_t) num; array = njs_array(value); if (njs_slow_path(index >= array->length)) { goto slow_path; } njs_value_assign(&array->start[index], &njs_value_invalid); return NJS_OK; } slow_path: njs_property_query_init(&pq, NJS_PROPERTY_QUERY_DELETE, 0, 1); ret = njs_property_query(vm, &pq, value, key); if (njs_slow_path(ret != NJS_OK)) { return ret; } prop = pq.lhq.value; if (njs_slow_path(!prop->configurable)) { if (thrw) { njs_key_string_get(vm, &pq.key,  &pq.lhq.key); njs_type_error(vm, ""Cannot delete property \""%V\"" of %s"", &pq.lhq.key, njs_type_string(value->type)); return NJS_ERROR; } return NJS_OK; } switch (prop->type) { case NJS_PROPERTY_HANDLER: if (njs_is_object(value) && njs_object_slots(value) != NULL) { ret = njs_prop_handler(prop)(vm, prop, value, NULL, NULL); if (njs_slow_path(ret != NJS_DECLINED)) { return ret; } } case NJS_PROPERTY: break; case NJS_ACCESSOR: if (removed == NULL) { break; } if (njs_prop_getter(prop) == NULL) { njs_set_undefined(removed); break; } return njs_function_apply(vm, njs_prop_getter(prop), value, 1, removed); case NJS_PROPERTY_REF: case NJS_PROPERTY_PLACE_REF: if (removed != NULL) { njs_value_assign(removed, njs_prop_ref(prop)); } njs_set_invalid(njs_prop_ref(prop)); return NJS_OK; default: njs_internal_error(vm, ""unexpected property type \""%s\"" "" ""while deleting"", njs_prop_type_string(prop->type)); return NJS_ERROR; } if (removed != NULL) { njs_value_assign(removed, njs_prop_value(prop)); } prop->type = NJS_WHITEOUT; njs_set_invalid(njs_prop_value(prop)); return NJS_OK; }
Description: Nginx NJS v0.7.10 was discovered to contain a segmentation violation via the function njs_function_frame at src/njs_function.h.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static s16 swf_get_s16(SWFReader *read) { s16 val; u8 v1; v1 = swf_read_int(read, 8); val = swf_read_sint(read, 8); val = (val<<8)&0xFF00; val |= (v1&0xFF); return val; }
Description: Floating Point Comparison with Incorrect Operator in GitHub repository gpac/gpac prior to 2.3-DEV.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void pcd_init_units(void) { struct pcd_unit *cd; int unit; pcd_drive_count = 0; for (unit = 0, cd = pcd; unit < PCD_UNITS; unit++, cd++) { struct gendisk *disk = alloc_disk(1); if (!disk) continue; disk->queue = blk_mq_init_sq_queue(&cd->tag_set, &pcd_mq_ops, 1, BLK_MQ_F_SHOULD_MERGE); if (IS_ERR(disk->queue)) { disk->queue = NULL; continue; } INIT_LIST_HEAD(&cd->rq_list); disk->queue->queuedata = cd; blk_queue_bounce_limit(disk->queue, BLK_BOUNCE_HIGH); cd->disk = disk; cd->pi = &cd->pia; cd->present = 0; cd->last_sense = 0; cd->changed = 1; cd->drive = (*drives[unit])[D_SLV]; if ((*drives[unit])[D_PRT]) pcd_drive_count++; cd->name = &cd->info.name[0]; snprintf(cd->name, sizeof(cd->info.name), ""%s%d"", name, unit); cd->info.ops = &pcd_dops; cd->info.handle = cd; cd->info.speed = 0; cd->info.capacity = 1; cd->info.mask = 0; disk->major = major; disk->first_minor = unit; strcpy(disk->disk_name, cd->name); disk->fops = &pcd_bdops; disk->flags = GENHD_FL_BLOCK_EVENTS_ON_EXCL_WRITE; } }
Description: An issue was discovered in the Linux kernel before 5.0.9. There is a NULL pointer dereference for a cd data structure if alloc_disk fails in drivers/block/paride/pf.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int ReadJpegSections (FILE * infile, ReadMode_t ReadMode) { int a; int HaveCom = FALSE; a = fgetc(infile); if (a != 0xff || fgetc(infile) != M_SOI){ return FALSE; } ImageInfo.JfifHeader.XDensity = ImageInfo.JfifHeader.YDensity = 300; ImageInfo.JfifHeader.ResolutionUnits = 1; for(;;){ int itemlen; int prev; int marker = 0; int ll,lh, got; uchar * Data; CheckSectionsAllocated(); prev = 0; for (a=0;;a++){ marker = fgetc(infile); if (marker != 0xff && prev == 0xff) break; if (marker == EOF){ ErrFatal(""Unexpected end of file""); } prev = marker; } if (a > 10){ ErrNonfatal(""Extraneous %d padding bytes before section %02X"",a-1,marker); } Sections[SectionsRead].Type = marker; lh = fgetc(infile); ll = fgetc(infile); if (lh == EOF || ll == EOF){ ErrFatal(""Unexpected end of file""); } itemlen = (lh << 8) | ll; if (itemlen < 2){ ErrFatal(""invalid marker""); } Sections[SectionsRead].Size = itemlen; Data = (uchar *)malloc(itemlen); if (Data == NULL){ ErrFatal(""Could not allocate memory""); } Sections[SectionsRead].Data = Data; Data[0] = (uchar)lh; Data[1] = (uchar)ll; got = fread(Data+2, 1, itemlen-2, infile);         if (got != itemlen-2){ ErrFatal(""Premature end of file?""); } SectionsRead += 1; switch(marker){ case M_SOS:                                   if (ReadMode & READ_IMAGE){ int cp, ep, size; cp = ftell(infile); fseek(infile, 0, SEEK_END); ep = ftell(infile); fseek(infile, cp, SEEK_SET); size = ep-cp; Data = (uchar *)malloc(size); if (Data == NULL){ ErrFatal(""could not allocate data for entire image""); } got = fread(Data, 1, size, infile); if (got != size){ ErrFatal(""could not read the rest of the image""); } CheckSectionsAllocated(); Sections[SectionsRead].Data = Data; Sections[SectionsRead].Size = size; Sections[SectionsRead].Type = PSEUDO_IMAGE_MARKER; SectionsRead ++; HaveAll = 1; } return TRUE; case M_DQT: process_DQT(Data, itemlen); break; case M_DHT:    process_DHT(Data, itemlen); break; case M_EOI:                   fprintf(stderr,""No image in jpeg!\n""); return FALSE; case M_COM:                 if (HaveCom || ((ReadMode & READ_METADATA) == 0)){ free(Sections[--SectionsRead].Data); }else{ process_COM(Data, itemlen); HaveCom = TRUE; } break; case M_JFIF: if (itemlen < 16){ fprintf(stderr,""Jfif header too short\n""); goto ignore; } if (memcmp(Data+2, ""JFIF\0"",5)){ fprintf(stderr,""Header missing JFIF marker\n""); } ImageInfo.JfifHeader.Present = TRUE; ImageInfo.JfifHeader.ResolutionUnits = Data[9]; ImageInfo.JfifHeader.XDensity = (Data[10]<<8) | Data[11]; ImageInfo.JfifHeader.YDensity = (Data[12]<<8) | Data[13]; if (ShowTags){ printf(""JFIF SOI marker: Units: %d "",ImageInfo.JfifHeader.ResolutionUnits); switch(ImageInfo.JfifHeader.ResolutionUnits){ case 0: printf(""(aspect ratio)""); break; case 1: printf(""(dots per inch)""); break; case 2: printf(""(dots per cm)""); break; default: printf(""(unknown)""); break; } printf(""  X-density=%d Y-density=%d\n"",ImageInfo.JfifHeader.XDensity, ImageInfo.JfifHeader.YDensity); if (Data[14] || Data[15]){ fprintf(stderr,""Ignoring jfif header thumbnail\n""); } } ignore: free(Sections[--SectionsRead].Data); break; case M_EXIF: if (ReadMode & READ_METADATA){ if (memcmp(Data+2, ""Exif"", 4) == 0){ process_EXIF(Data, itemlen); break; }else if (memcmp(Data+2, ""http:"", 5) == 0){ Sections[SectionsRead-1].Type = M_XMP;                         if (ShowTags){ printf(""Image contains XMP section, %d bytes long\n"", itemlen); if (ShowTags){ ShowXmp(Sections[SectionsRead-1]); } } break; } } free(Sections[--SectionsRead].Data); break; case M_IPTC: if (ReadMode & READ_METADATA){ if (ShowTags){ printf(""Image contains IPTC section, %d bytes long\n"", itemlen); } }else{ free(Sections[--SectionsRead].Data); } break; case M_SOF0:  case M_SOF1:  case M_SOF2:  case M_SOF3:  case M_SOF5:  case M_SOF6:  case M_SOF7:  case M_SOF9:  case M_SOF10: case M_SOF11: case M_SOF13: case M_SOF14: case M_SOF15: if (itemlen < 8){ fprintf(stderr,""Section too short\n""); break; } process_SOFn(Data, marker); break; default: if (ShowTags){ printf(""Jpeg section marker 0x%02x size %d\n"",marker, itemlen); } break; } } return TRUE; }
Description: JHEAD is a simple command line tool for displaying and some manipulation of EXIF header data embedded in Jpeg images from digital cameras. In affected versions there is a heap-buffer-overflow on jhead-3.04/jpgfile.c:285 ReadJpegSections. Crafted jpeg images can be provided to the user resulting in a program crash or potentially incorrect exif information retrieval. Users are advised to upgrade. There is no known workaround for this issue.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static bool getCoverageFormat4(vector<uint32_t>& coverage, const uint8_t* data, size_t size) { const size_t kSegCountOffset = 6; const size_t kEndCountOffset = 14; const size_t kHeaderSize = 16; const size_t kSegmentSize = 8;      if (kEndCountOffset > size) { return false; } size_t segCount = readU16(data, kSegCountOffset) >> 1; if (kHeaderSize + segCount * kSegmentSize > size) { return false; } for (size_t i = 0; i < segCount; i++) { int end = readU16(data, kEndCountOffset + 2 * i); int start = readU16(data, kHeaderSize + 2 * (segCount + i)); int rangeOffset = readU16(data, kHeaderSize + 2 * (3 * segCount + i)); if (rangeOffset == 0) { int delta = readU16(data, kHeaderSize + 2 * (2 * segCount + i)); if (((end + delta) & 0xffff) > end - start) { addRange(coverage, start, end + 1); } else { for (int j = start; j < end + 1; j++) { if (((j + delta) & 0xffff) != 0) { addRange(coverage, j, j + 1); } } } } else { for (int j = start; j < end + 1; j++) { uint32_t actualRangeOffset = kHeaderSize + 6 * segCount + rangeOffset + (i + j - start) * 2; if (actualRangeOffset + 2 > size) { return false; } int glyphId = readU16(data, actualRangeOffset); if (glyphId != 0) { addRange(coverage, j, j + 1); } } } } return true; }
Description: The Minikin library in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 does not properly consider negative size values in font data, which allows remote attackers to cause a denial of service (memory corruption and reboot loop) via a crafted font, aka internal bug 26413177.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen) { return crypto_skcipher_setkey(private, key, keylen); }
Description: crypto/algif_skcipher.c in the Linux kernel before 4.4.2 does not verify that a setkey operation has been performed on an AF_ALG socket before an accept system call is processed, which allows local users to cause a denial of service (NULL pointer dereference and system crash) via a crafted application that does not supply a key, related to the lrw_crypt function in crypto/lrw.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: uint8_t _ReadStaticFiles(HTTPReqMessage *req, HTTPResMessage *res) { uint8_t found = 0; int8_t depth = 0; char *uri = req->Header.URI; size_t n = strlen(uri); size_t i; FILE *fp; int size; char path[128] = {STATIC_FILE_FOLDER}; char header[] = ""HTTP/1.1 200 OK\r\nConnection: close\r\n"" ""Content-Type: text/html; charset=UTF-8\r\n\r\n""; for(i=0; i<n; i++) { if(uri[i] == '/') { if(((n-i) > 2) && (uri[i+1] == '.') && ((uri[i+2] == '.'))) { depth -= 1; if(depth < 0) break; } else if (((n-i) > 1) && (uri[i+1] == '.')) continue; else depth += 1; } } if((depth >= 0) && (uri[i-1] != '/')) { memcpy(path + strlen(STATIC_FILE_FOLDER), uri, strlen(uri)); fp = fopen(path, ""r""); if(fp != NULL) { fseek(fp, 0, SEEK_END); size = ftell(fp); fseek(fp, 0, SEEK_SET); if(size < MAX_BODY_SIZE) { n = strlen(header); memcpy(res->_buf, header, n); i = n; n = fread(res->_buf + i, 1, size, fp); i += n; res->_index = i; found = 1; } fclose(fp); } } return found; }
Description: In MicroHttpServer (aka Micro HTTP Server) through 4398570, _ReadStaticFiles in lib/middleware.c allows a stack-based buffer overflow and potentially remote code execution via a long URI.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void jpc_qmfb_split_colres(jpc_fix_t *a, int numrows, int numcols, int stride, int parity) { int bufsize = JPC_CEILDIVPOW2(numrows, 1); jpc_fix_t splitbuf[QMFB_SPLITBUFSIZE * JPC_QMFB_COLGRPSIZE]; jpc_fix_t *buf = splitbuf; jpc_fix_t *srcptr; jpc_fix_t *dstptr; register jpc_fix_t *srcptr2; register jpc_fix_t *dstptr2; register int n; register int i; int m; int hstartcol; if (bufsize > QMFB_SPLITBUFSIZE) { if (!(buf = jas_alloc2(bufsize, sizeof(jpc_fix_t)))) { abort(); } } if (numrows >= 2) { hstartcol = (numrows + 1 - parity) >> 1; m = numrows - hstartcol; n = m; dstptr = buf; srcptr = &a[(1 - parity) * stride]; while (n-- > 0) { dstptr2 = dstptr; srcptr2 = srcptr; for (i = 0; i < numcols; ++i) { *dstptr2 = *srcptr2; ++dstptr2; ++srcptr2; } dstptr += numcols; srcptr += stride << 1; } dstptr = &a[(1 - parity) * stride]; srcptr = &a[(2 - parity) * stride]; n = numrows - m - (!parity); while (n-- > 0) { dstptr2 = dstptr; srcptr2 = srcptr; for (i = 0; i < numcols; ++i) { *dstptr2 = *srcptr2; ++dstptr2; ++srcptr2; } dstptr += stride; srcptr += stride << 1; } dstptr = &a[hstartcol * stride]; srcptr = buf; n = m; while (n-- > 0) { dstptr2 = dstptr; srcptr2 = srcptr; for (i = 0; i < numcols; ++i) { *dstptr2 = *srcptr2; ++dstptr2; ++srcptr2; } dstptr += stride; srcptr += numcols; } } if (buf != splitbuf) { jas_free(buf); } }
Description: A heap-buffer overflow vulnerability was found in QMFB code in JPC codec caused by buffer being allocated with too small size. jasper versions before 2.0.0 are affected.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void declareArguments() { ::arg().set(""local-port"",""The port on which we listen"")=""53""; ::arg().setSwitch(""experimental-dnsupdate"",""Enable/Disable DNS update (RFC2136) support. Default is no."")=""no""; ::arg().set(""allow-dnsupdate-from"",""A global setting to allow DNS updates from these IP ranges."")=""127.0.0.0/8,::1""; ::arg().setSwitch(""forward-dnsupdate"",""A global setting to allow DNS update packages that are for a Slave domain, to be forwarded to the master."")=""yes""; ::arg().setSwitch(""log-dns-details"",""If PDNS should log DNS non-erroneous details"")=""no""; ::arg().setSwitch(""log-dns-queries"",""If PDNS should log all incoming DNS queries"")=""no""; ::arg().set(""local-address"",""Local IP addresses to which we bind"")=""0.0.0.0""; ::arg().setSwitch(""local-address-nonexist-fail"",""Fail to start if one or more of the local-address's do not exist on this server"")=""yes""; ::arg().set(""local-ipv6"",""Local IP address to which we bind"")=""""; ::arg().setSwitch(""reuseport"",""Enable higher performance on compliant kernels by using SO_REUSEPORT allowing each receiver thread to open its own socket"")=""no""; ::arg().setSwitch(""local-ipv6-nonexist-fail"",""Fail to start if one or more of the local-ipv6 addresses do not exist on this server"")=""yes""; ::arg().set(""query-local-address"",""Source IP address for sending queries"")=""0.0.0.0""; ::arg().set(""query-local-address6"",""Source IPv6 address for sending queries"")=""::""; ::arg().set(""overload-queue-length"",""Maximum queuelength moving to packetcache only"")=""0""; ::arg().set(""max-queue-length"",""Maximum queuelength before considering situation lost"")=""5000""; ::arg().set(""retrieval-threads"", ""Number of AXFR-retrieval threads for slave operation"")=""2""; ::arg().setSwitch(""experimental-json-interface"", ""If the webserver should serve JSON data"")=""no""; ::arg().setSwitch(""experimental-api-readonly"", ""If the JSON API should disallow data modification"")=""no""; ::arg().set(""experimental-api-key"", ""REST API Static authentication key (required for API use)"")=""""; ::arg().setSwitch(""experimental-dname-processing"", ""If we should support DNAME records"")=""no""; ::arg().setCmd(""help"",""Provide a helpful message""); ::arg().setCmd(""version"",""Output version and compilation date""); ::arg().setCmd(""config"",""Provide configuration file on standard output""); ::arg().setCmd(""list-modules"",""Lists all modules available""); ::arg().setCmd(""no-config"",""Don't parse configuration file""); ::arg().set(""version-string"",""PowerDNS version in packets - full, anonymous, powerdns or custom"")=""full"";  ::arg().set(""control-console"",""Debugging switch - don't use"")=""no"";   ::arg().set(""loglevel"",""Amount of logging. Higher is more. Do not set below 3"")=""4""; ::arg().set(""disable-syslog"",""Disable logging to syslog, useful when running inside a supervisor that logs stdout"")=""no""; ::arg().set(""default-soa-name"",""name to insert in the SOA record if none set in the backend"")=""a.misconfigured.powerdns.server""; ::arg().set(""default-soa-mail"",""mail address to insert in the SOA record if none set in the backend"")=""""; ::arg().set(""distributor-threads"",""Default number of Distributor (backend) threads to start"")=""3""; ::arg().set(""signing-threads"",""Default number of signer threads to start"")=""3""; ::arg().set(""receiver-threads"",""Default number of receiver threads to start"")=""1""; ::arg().set(""queue-limit"",""Maximum number of milliseconds to queue a query"")=""1500"";  ::arg().set(""recursor"",""If recursion is desired, IP address of a recursing nameserver"")=""no"";  ::arg().set(""allow-recursion"",""List of subnets that are allowed to recurse"")=""0.0.0.0/0""; ::arg().set(""pipebackend-abi-version"",""Version of the pipe backend ABI"")=""1""; ::arg().set(""udp-truncation-threshold"", ""Maximum UDP response size before we truncate"")=""1680""; ::arg().set(""disable-tcp"",""Do not listen to TCP queries"")=""no""; ::arg().set(""config-name"",""Name of this virtual configuration - will rename the binary image"")=""""; ::arg().set(""load-modules"",""Load this module - supply absolute or relative path"")=""""; ::arg().set(""launch"",""Which backends to launch and order to query them in"")=""""; ::arg().setSwitch(""disable-axfr"",""Disable zonetransfers but do allow TCP queries"")=""no""; ::arg().set(""allow-axfr-ips"",""Allow zonetransfers only to these subnets"")=""127.0.0.0/8,::1""; ::arg().set(""only-notify"", ""Only send AXFR NOTIFY to these IP addresses or netmasks"")=""0.0.0.0/0,::/0""; ::arg().set(""also-notify"", ""When notifying a domain, also notify these nameservers"")=""""; ::arg().set(""allow-notify-from"",""Allow AXFR NOTIFY from these IP ranges. If empty, drop all incoming notifies."")=""0.0.0.0/0,::/0""; ::arg().set(""slave-cycle-interval"",""Schedule slave freshness checks once every .. seconds"")=""60""; ::arg().set(""tcp-control-address"",""If set, PowerDNS can be controlled over TCP on this address"")=""""; ::arg().set(""tcp-control-port"",""If set, PowerDNS can be controlled over TCP on this address"")=""53000""; ::arg().set(""tcp-control-secret"",""If set, PowerDNS can be controlled over TCP after passing this secret"")=""""; ::arg().set(""tcp-control-range"",""If set, remote control of PowerDNS is possible over these networks only"")=""127.0.0.0/8, 10.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, ::1/128, fe80::/10""; ::arg().setSwitch(""slave"",""Act as a slave"")=""no""; ::arg().setSwitch(""master"",""Act as a master"")=""no""; ::arg().setSwitch(""disable-axfr-rectify"",""Disable the rectify step during an outgoing AXFR. Only required for regression testing."")=""no""; ::arg().setSwitch(""guardian"",""Run within a guardian process"")=""no""; ::arg().setSwitch(""send-root-referral"",""Send out old-fashioned root-referral instead of ServFail in case of no authority"")=""no""; ::arg().setSwitch(""prevent-self-notification"",""Don't send notifications to what we think is ourself"")=""yes""; ::arg().setSwitch(""webserver"",""Start a webserver for monitoring"")=""no"";  ::arg().setSwitch(""webserver-print-arguments"",""If the webserver should print arguments"")=""no"";  ::arg().setSwitch(""edns-subnet-processing"",""If we should act on EDNS Subnet options"")=""no"";  ::arg().setSwitch(""any-to-tcp"",""Answer ANY queries with tc=1, shunting to TCP"")=""no"";  ::arg().set(""webserver-address"",""IP Address of webserver to listen on"")=""127.0.0.1""; ::arg().set(""webserver-port"",""Port of webserver to listen on"")=""8081""; ::arg().set(""webserver-password"",""Password required for accessing the webserver"")=""""; ::arg().set(""webserver-allow-from"",""Webserver access is only allowed from these subnets"")=""0.0.0.0/0,::/0""; ::arg().setSwitch(""out-of-zone-additional-processing"",""Do out of zone additional processing"")=""yes""; ::arg().setSwitch(""do-ipv6-additional-processing"", ""Do AAAA additional processing"")=""yes""; ::arg().setSwitch(""query-logging"",""Hint backends that queries should be logged"")=""no""; ::arg().set(""carbon-ourname"", ""If set, overrides our reported hostname for carbon stats"")=""""; ::arg().set(""carbon-server"", ""If set, send metrics in carbon (graphite) format to this server"")=""""; ::arg().set(""carbon-interval"", ""Number of seconds between carbon (graphite) updates"")=""30""; ::arg().set(""cache-ttl"",""Seconds to store packets in the PacketCache"")=""20""; ::arg().set(""recursive-cache-ttl"",""Seconds to store packets for recursive queries in the PacketCache"")=""10""; ::arg().set(""negquery-cache-ttl"",""Seconds to store negative query results in the QueryCache"")=""60""; ::arg().set(""query-cache-ttl"",""Seconds to store query results in the QueryCache"")=""20""; ::arg().set(""soa-minimum-ttl"",""Default SOA minimum ttl"")=""3600""; ::arg().set(""server-id"", ""Returned when queried for 'server.id' TXT or NSID, defaults to hostname - disabled or custom"")=""""; ::arg().set(""soa-refresh-default"",""Default SOA refresh"")=""10800""; ::arg().set(""soa-retry-default"",""Default SOA retry"")=""3600""; ::arg().set(""soa-expire-default"",""Default SOA expire"")=""604800""; ::arg().set(""default-soa-edit"",""Default SOA-EDIT value"")=""""; ::arg().set(""default-soa-edit-signed"",""Default SOA-EDIT value for signed zones"")=""""; ::arg().set(""trusted-notification-proxy"", ""IP address of incoming notification proxy"")=""""; ::arg().set(""slave-renotify"", ""If we should send out notifications for slaved updates"")=""no""; ::arg().set(""default-ttl"",""Seconds a result is valid if not set otherwise"")=""3600""; ::arg().set(""max-tcp-connections"",""Maximum number of TCP connections"")=""10""; ::arg().setSwitch(""no-shuffle"",""Set this to prevent random shuffling of answers - for regression testing"")=""off""; ::arg().set(""experimental-logfile"", ""Filename of the log file for JSON parser"" )= ""/var/log/pdns.log""; ::arg().set(""setuid"",""If set, change user id to this uid for more security"")=""""; ::arg().set(""setgid"",""If set, change group id to this gid for more security"")=""""; ::arg().set(""max-cache-entries"", ""Maximum number of cache entries"")=""1000000""; ::arg().set(""max-signature-cache-entries"", ""Maximum number of signatures cache entries"")=""""; ::arg().set(""max-ent-entries"", ""Maximum number of empty non-terminals in a zone"")=""100000""; ::arg().set(""entropy-source"", ""If set, read entropy from this file"")=""/dev/urandom""; ::arg().set(""lua-prequery-script"", ""Lua script with prequery handler"")=""""; ::arg().setSwitch(""traceback-handler"",""Enable the traceback handler (Linux only)"")=""yes""; ::arg().setSwitch(""direct-dnskey"",""Fetch DNSKEY RRs from backend during DNSKEY synthesis"")=""no""; ::arg().set(""default-ksk-algorithms"",""Default KSK algorithms"")=""rsasha256""; ::arg().set(""default-ksk-size"",""Default KSK size (0 means default)"")=""0""; ::arg().set(""default-zsk-algorithms"",""Default ZSK algorithms"")=""rsasha256""; ::arg().set(""default-zsk-size"",""Default ZSK size (0 means default)"")=""0""; ::arg().set(""max-nsec3-iterations"",""Limit the number of NSEC3 hash iterations"")=""500"";  ::arg().set(""include-dir"",""Include *.conf files from this directory""); ::arg().set(""security-poll-suffix"",""Domain name from which to query security update notifications"")=""secpoll.powerdns.com.""; }
Description: PowerDNS (aka pdns) Authoritative Server before 4.0.1 allows remote primary DNS servers to cause a denial of service (memory exhaustion and secondary DNS server crash) via a large (1) AXFR or (2) IXFR response.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static tvbuff_t* decompress(packet_info* pinfo, tvbuff_t* tvb, gint offset, gint length) { if(PINFO_FD_VISITED(pinfo)) { const slice_t* saved_data = (slice_t *)p_get_proto_data(wmem_file_scope(), pinfo, proto_blip, 0); tvbuff_t* decompressedChild = tvb_new_child_real_data(tvb, (guint8 *)saved_data->buf, (gint)saved_data->size, (gint)saved_data->size); add_new_data_source(pinfo, decompressedChild, ""Decompressed Payload""); return decompressedChild; } const guint8* buf = tvb_get_ptr(tvb, offset, length); z_stream* decompress_stream = get_decompress_stream(pinfo); static Byte trailer[4] = { 0x00, 0x00, 0xff, 0xff }; if(!decompress_stream->next_out) { decompress_stream->zalloc = 0; decompress_stream->zfree = 0; decompress_stream->opaque = 0; int err = inflateInit2(decompress_stream, -MAX_WBITS); if(err != Z_OK) { decompress_stream->next_out = 0; REPORT_DISSECTOR_BUG(""Unable to create INFLATE context to decompress messages""); return NULL; } } Bytef* decompress_buffer = (Bytef*)wmem_alloc(wmem_file_scope(), BLIP_INFLATE_BUFFER_SIZE); decompress_stream->next_in = (Bytef*)buf; decompress_stream->avail_in = length; decompress_stream->next_out = decompress_buffer; decompress_stream->avail_out = BLIP_INFLATE_BUFFER_SIZE; uLong start = decompress_stream->total_out; int err = inflate(decompress_stream, Z_NO_FLUSH); if(err < 0) { return NULL; } decompress_stream->next_in = trailer; decompress_stream->avail_in = 4; err = inflate(decompress_stream, Z_SYNC_FLUSH); if(err < 0) { return NULL; } uLong bodyLength = decompress_stream->total_out - start; tvbuff_t* decompressedChild = tvb_new_child_real_data(tvb, decompress_buffer, (guint)bodyLength, (gint)bodyLength); add_new_data_source(pinfo, decompressedChild, ""Decompressed Payload""); slice_t* data_to_save = wmem_new0(wmem_file_scope(), slice_t); data_to_save->size = (size_t)bodyLength; data_to_save->buf = decompress_buffer; p_add_proto_data(wmem_file_scope(), pinfo, proto_blip, 0, data_to_save); return decompressedChild; }
Description: In Wireshark 3.2.0 to 3.2.6 and 3.0.0 to 3.0.13, the BLIP protocol dissector has a NULL pointer dereference because a buffer was sized for compressed (not uncompressed) messages. This was addressed in epan/dissectors/packet-blip.c by allowing reasonable compression ratios and rejecting ZIP bombs.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static NTLM_AV_PAIR* ntlm_av_pair_next(NTLM_AV_PAIR* pAvPair, size_t* pcbAvPair) { size_t offset; if (!pcbAvPair) return NULL; if (!ntlm_av_pair_check(pAvPair, *pcbAvPair)) return NULL; offset = ntlm_av_pair_get_next_offset(pAvPair); *pcbAvPair -= offset; return (NTLM_AV_PAIR*)((PBYTE)pAvPair + offset); }
Description: In FreeRDP before version 2.1.2, an out of bounds read occurs resulting in accessing a memory location that is outside of the boundaries of the static array PRIMARY_DRAWING_ORDER_FIELD_BYTES. This is fixed in version 2.1.2.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int display_extension_block(proto_tree *tree, tvbuff_t *tvb, packet_info *pinfo, int offset, gchar *bundle_custodian, gboolean *lastheader) { proto_item   *block_item, *ti, *block_flag_replicate_item, *block_flag_eid_reference_item; proto_tree   *block_tree; int           sdnv_length; int           block_length; int           block_overhead; int           bundle_age; guint8        type; unsigned int  control_flags; proto_tree   *block_flag_tree; proto_item   *block_flag_item; type = tvb_get_guint8(tvb, offset); block_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_metadata_hdr, &block_item, ""Extension Block""); proto_tree_add_item(block_tree, hf_bundle_block_type_code, tvb, offset, 1, ENC_BIG_ENDIAN); ++offset; block_overhead = 1; control_flags = (unsigned int)evaluate_sdnv(tvb, offset, &sdnv_length); if (control_flags & BLOCK_CONTROL_LAST_BLOCK) { *lastheader = TRUE; } else { *lastheader = FALSE; } block_flag_item = proto_tree_add_uint(block_tree, hf_block_control_flags_sdnv, tvb, offset, sdnv_length, control_flags); block_flag_tree = proto_item_add_subtree(block_flag_item, ett_block_flags); block_flag_replicate_item = proto_tree_add_boolean(block_flag_tree, hf_block_control_replicate, tvb, offset, sdnv_length, control_flags); proto_tree_add_boolean(block_flag_tree, hf_block_control_transmit_status, tvb, offset, sdnv_length, control_flags); proto_tree_add_boolean(block_flag_tree, hf_block_control_delete_bundle, tvb, offset, sdnv_length, control_flags); proto_tree_add_boolean(block_flag_tree, hf_block_control_last_block, tvb, offset, sdnv_length, control_flags); proto_tree_add_boolean(block_flag_tree, hf_block_control_discard_block, tvb, offset, sdnv_length, control_flags); proto_tree_add_boolean(block_flag_tree, hf_block_control_not_processed, tvb, offset, sdnv_length, control_flags); block_flag_eid_reference_item = proto_tree_add_boolean(block_flag_tree, hf_block_control_eid_reference, tvb, offset, sdnv_length, control_flags); offset += sdnv_length; block_overhead += sdnv_length; if (control_flags & BLOCK_CONTROL_EID_REFERENCE) { int i; int num_eid_ref; num_eid_ref = evaluate_sdnv(tvb, offset, &sdnv_length); offset += sdnv_length; block_overhead += sdnv_length; for (i = 0; i < num_eid_ref; i++) { if (evaluate_sdnv(tvb, offset, &sdnv_length) < 0) break; offset += sdnv_length; block_overhead += sdnv_length; if (evaluate_sdnv(tvb, offset, &sdnv_length) < 0) break; offset += sdnv_length; block_overhead += sdnv_length; } } block_length = evaluate_sdnv(tvb, offset, &sdnv_length); ti = proto_tree_add_int(block_tree, hf_block_control_block_length, tvb, offset, sdnv_length, block_length); if (block_length < 0) { expert_add_info_format(pinfo, ti, &ei_bundle_offset_error, ""Metadata Block Length Error""); *lastheader = TRUE; return offset; } offset += sdnv_length; block_overhead += sdnv_length; proto_item_set_len(block_item, block_overhead + block_length); switch (type) { case BUNDLE_BLOCK_TYPE_AUTHENTICATION: case BUNDLE_BLOCK_TYPE_METADATA_EXTENSION: case BUNDLE_BLOCK_TYPE_EXTENSION_SECURITY: { proto_tree_add_string(block_tree, hf_bundle_unprocessed_block_data, tvb, offset, block_length, ""Block data""); offset += block_length; break; } case BUNDLE_BLOCK_TYPE_BUNDLE_AGE: { bundle_age = evaluate_sdnv(tvb, offset, &sdnv_length); proto_tree_add_int(block_tree, hf_bundle_age_extension_block_code, tvb, offset, sdnv_length, bundle_age/1000000); offset += block_length; break; } case BUNDLE_BLOCK_TYPE_PREVIOUS_HOP_INSERT: { int scheme_length; proto_tree_add_item_ret_length(block_tree, hf_bundle_block_previous_hop_scheme, tvb, offset, 4, ENC_ASCII, &scheme_length); offset += scheme_length; proto_tree_add_item(block_tree, hf_bundle_block_previous_hop_eid, tvb, offset, block_length-scheme_length, ENC_ASCII); if (block_length - scheme_length < 1) { expert_add_info_format(pinfo, ti, &ei_bundle_offset_error, ""Metadata Block Length Error""); *lastheader = TRUE; return offset; } offset += block_length - scheme_length; break; } case BUNDLE_BLOCK_TYPE_INTEGRITY: case BUNDLE_BLOCK_TYPE_CONFIDENTIALITY: { int target_block_type; int target_block_occurrence; int ciphersuite_type; unsigned int ciphersuite_flags; target_block_type = evaluate_sdnv(tvb, offset, &sdnv_length); proto_tree_add_int(block_tree, hf_bundle_target_block_type, tvb, offset, sdnv_length, target_block_type); offset += sdnv_length; target_block_occurrence = evaluate_sdnv(tvb, offset, &sdnv_length); proto_tree_add_int(block_tree, hf_bundle_target_block_occurrence, tvb, offset, sdnv_length, target_block_occurrence); offset += sdnv_length; ciphersuite_type = evaluate_sdnv(tvb, offset, &sdnv_length); proto_tree_add_int(block_tree, hf_bundle_ciphersuite_type, tvb, offset, sdnv_length, ciphersuite_type); offset += sdnv_length; ciphersuite_flags = (unsigned int)evaluate_sdnv(tvb, offset, &sdnv_length); block_flag_item = proto_tree_add_uint(block_tree, hf_bundle_ciphersuite_flags, tvb, offset, sdnv_length, ciphersuite_flags); block_flag_tree = proto_item_add_subtree(block_flag_item, ett_block_flags); proto_tree_add_boolean(block_flag_tree, hf_block_ciphersuite_params, tvb, offset, sdnv_length, ciphersuite_flags); offset += sdnv_length; int range_offset; int range_length; if (ciphersuite_flags & BLOCK_CIPHERSUITE_PARAMS) { int params_length; int param_type; int item_length; proto_tree   *param_tree; expert_field *ei = NULL; params_length = evaluate_sdnv_ei(tvb, offset, &sdnv_length, &ei); if (ei) { proto_tree_add_expert(block_tree, pinfo, ei, tvb, offset, -1); *lastheader = TRUE; return offset; } param_tree = proto_tree_add_subtree(block_tree, tvb, offset, params_length+1, ett_sec_block_param_data, NULL, ""Ciphersuite Parameters Data""); proto_tree_add_int(param_tree, hf_block_ciphersuite_params_length, tvb, offset, sdnv_length, params_length); offset += sdnv_length; for(int i = 0; i < params_length; i+=item_length+2) { param_type = evaluate_sdnv(tvb, offset, &sdnv_length); proto_tree_add_int(param_tree, hf_block_ciphersuite_param_type, tvb, offset, sdnv_length, param_type); offset += sdnv_length; ei = NULL; item_length = evaluate_sdnv_ei(tvb, offset, &sdnv_length, &ei); proto_tree_add_int(param_tree, hf_block_ciphersuite_params_item_length, tvb, offset, sdnv_length, item_length); if (ei) { proto_tree_add_expert(param_tree, pinfo, ei, tvb, offset, -1); *lastheader = TRUE; return offset; } offset += sdnv_length; switch (param_type) { case 1: case 3: case 5: case 7: case 8: proto_tree_add_item(param_tree, hf_block_ciphersuite_param_data, tvb, offset, item_length, ENC_NA); offset += item_length; break; case 4: range_offset = evaluate_sdnv(tvb, offset, &sdnv_length); proto_tree_add_int(param_tree, hf_block_ciphersuite_range_offset, tvb, offset, sdnv_length, range_offset); offset += sdnv_length; range_length = evaluate_sdnv(tvb, offset, &sdnv_length); proto_tree_add_int(param_tree, hf_block_ciphersuite_range_length, tvb, offset, sdnv_length, range_length); offset += sdnv_length; break; default: break; } } } int result_length; int result_type; int result_item_length; proto_tree   *result_tree; result_length = evaluate_sdnv(tvb, offset, &sdnv_length); result_tree = proto_tree_add_subtree(block_tree, tvb, offset, result_length+1, ett_sec_block_param_data, NULL, ""Security Results Data""); proto_tree_add_int(result_tree, hf_block_ciphersuite_result_length, tvb, offset, sdnv_length, result_length); offset += sdnv_length; for(int i = 0; i < result_length; i+=result_item_length+2) { result_type = evaluate_sdnv(tvb, offset, &sdnv_length); proto_tree_add_int(result_tree, hf_block_ciphersuite_result_type, tvb, offset, sdnv_length, result_type); offset += sdnv_length; expert_field *ei = NULL; result_item_length = evaluate_sdnv_ei(tvb, offset, &sdnv_length, &ei); proto_tree_add_int(result_tree, hf_block_ciphersuite_result_item_length, tvb, offset, sdnv_length, result_item_length); if (ei) { proto_tree_add_expert(result_tree, pinfo, ei, tvb, offset, -1); offset = tvb_reported_length_remaining(tvb, offset); break; } offset += sdnv_length; switch (result_type) { case 1: case 3: case 5: case 7: case 8: proto_tree_add_item(result_tree, hf_block_ciphersuite_result_data, tvb, offset, result_item_length, ENC_NA); offset += result_item_length; break; case 4: range_offset = evaluate_sdnv(tvb, offset, &sdnv_length); proto_tree_add_int(result_tree, hf_block_ciphersuite_range_offset, tvb, offset, sdnv_length, range_offset); offset += sdnv_length; range_length = evaluate_sdnv(tvb, offset, &sdnv_length); proto_tree_add_int(result_tree, hf_block_ciphersuite_range_length, tvb, offset, sdnv_length, range_length); offset += sdnv_length; break; default: break; } } break; } case BUNDLE_BLOCK_TYPE_CUSTODY_TRANSFER: { int custody_id; const guint8 *cteb_creator_custodian_eid; int cteb_creator_custodian_eid_length; if ((control_flags & BLOCK_CONTROL_REPLICATE) != 0) { expert_add_info_format(pinfo, block_flag_replicate_item, &ei_bundle_block_control_flags, ""ERROR: Replicate must be clear for CTEB""); } if ((control_flags & BLOCK_CONTROL_EID_REFERENCE) != 0) { expert_add_info_format(pinfo, block_flag_eid_reference_item, &ei_bundle_block_control_flags, ""ERROR: EID-Reference must be clear for CTEB""); } custody_id = evaluate_sdnv(tvb, offset, &sdnv_length); proto_tree_add_int(block_tree, hf_block_control_block_cteb_custody_id, tvb, offset, sdnv_length, custody_id); offset += sdnv_length; if (block_length - sdnv_length < 1) { expert_add_info_format(pinfo, ti, &ei_bundle_offset_error, ""Metadata Block Length Error""); *lastheader = TRUE; return offset; } cteb_creator_custodian_eid_length = block_length - sdnv_length; ti = proto_tree_add_item_ret_string(block_tree, hf_block_control_block_cteb_creator_custodian_eid, tvb, offset, cteb_creator_custodian_eid_length, ENC_ASCII, pinfo->pool, &cteb_creator_custodian_eid); if (bundle_custodian == NULL) { expert_add_info_format(pinfo, ti, &ei_block_control_block_cteb_invalid, ""CTEB Is NOT Valid (Bundle Custodian NULL)""); } else if (strlen(cteb_creator_custodian_eid) != strlen(bundle_custodian)) { expert_add_info_format(pinfo, ti, &ei_block_control_block_cteb_invalid, ""CTEB Is NOT Valid (Bundle Custodian [%s] != CTEB Custodian [%s])"", bundle_custodian, cteb_creator_custodian_eid); } else if (memcmp(cteb_creator_custodian_eid, bundle_custodian, strlen(bundle_custodian)) != 0) { expert_add_info_format(pinfo, ti, &ei_block_control_block_cteb_invalid, ""CTEB Is NOT Valid (Bundle Custodian [%s] != CTEB Custodian [%s])"", bundle_custodian, cteb_creator_custodian_eid); } else { expert_add_info(pinfo, ti, &ei_block_control_block_cteb_valid); } offset += cteb_creator_custodian_eid_length; break; } case BUNDLE_BLOCK_TYPE_EXTENDED_COS: { int flags; static int * const ecos_flags_fields[] = { &hf_ecos_flags_critical, &hf_ecos_flags_streaming, &hf_ecos_flags_flowlabel, &hf_ecos_flags_reliable, NULL }; if ((control_flags & BLOCK_CONTROL_REPLICATE) == 0) { expert_add_info_format(pinfo, block_flag_replicate_item, &ei_bundle_block_control_flags, ""ERROR: Replicate must be set for ECOS""); } if ((control_flags & BLOCK_CONTROL_EID_REFERENCE) != 0) { expert_add_info_format(pinfo, block_flag_eid_reference_item, &ei_bundle_block_control_flags, ""ERROR: EID-Reference must be clear for ECOS""); } flags = (int)tvb_get_guint8(tvb, offset); proto_tree_add_bitmask(block_tree, tvb, offset, hf_ecos_flags, ett_block_flags, ecos_flags_fields, ENC_BIG_ENDIAN); offset += 1; proto_tree_add_item(block_tree, hf_ecos_ordinal, tvb, offset, 1, ENC_BIG_ENDIAN); offset += 1; if ((flags & ECOS_FLAGS_FLOWLABEL) != 0) { int flow_label; flow_label = evaluate_sdnv(tvb, offset, &sdnv_length); ti = proto_tree_add_int(block_tree, hf_ecos_flow_label, tvb, offset, sdnv_length, flow_label); if (flow_label < 0) { expert_add_info_format(pinfo, ti, &ei_bundle_sdnv_length, ""ECOS Flow Label Error""); *lastheader = TRUE; return offset; } offset += sdnv_length; } break; } default: { proto_tree_add_string(block_tree, hf_bundle_unprocessed_block_data, tvb, offset, block_length, ""Block data""); offset += block_length; break; } } return offset; }
Description: Excessive loops in multiple dissectors in Wireshark 4.0.0 to 4.0.2 and 3.6.0 to 3.6.10 and allows denial of service via packet injection or crafted capture file
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int read_fru_area_section(struct ipmi_intf * intf, struct fru_info *fru, uint8_t id, uint32_t offset, uint32_t length, uint8_t *frubuf) { static uint32_t fru_data_rqst_size = 20; uint32_t off = offset, tmp, finish; struct ipmi_rs * rsp; struct ipmi_rq req; uint8_t msg_data[4]; if (offset > fru->size) { lprintf(LOG_ERR, ""Read FRU Area offset incorrect: %d > %d"", offset, fru->size); return -1; } finish = offset + length; if (finish > fru->size) { finish = fru->size; lprintf(LOG_NOTICE, ""Read FRU Area length %d too large, "" ""Adjusting to %d"", offset + length, finish - offset); } memset(&req, 0, sizeof(req)); req.msg.netfn = IPMI_NETFN_STORAGE; req.msg.cmd = GET_FRU_DATA; req.msg.data = msg_data; req.msg.data_len = 4; #ifdef LIMIT_ALL_REQUEST_SIZE if (fru_data_rqst_size > 16) #else if (fru->access && fru_data_rqst_size > 16) #endif fru_data_rqst_size = 16; do { tmp = fru->access ? off >> 1 : off; msg_data[0] = id; msg_data[1] = (uint8_t)(tmp & 0xff); msg_data[2] = (uint8_t)(tmp >> 8); tmp = finish - off; if (tmp > fru_data_rqst_size) msg_data[3] = (uint8_t)fru_data_rqst_size; else msg_data[3] = (uint8_t)tmp; rsp = intf->sendrecv(intf, &req); if (!rsp) { lprintf(LOG_NOTICE, ""FRU Read failed""); break; } if (rsp->ccode) { if (fru_cc_rq2big(rsp->ccode) && (--fru_data_rqst_size > FRU_BLOCK_SZ)) { lprintf(LOG_INFO, ""Retrying FRU read with request size %d"", fru_data_rqst_size); continue; } lprintf(LOG_NOTICE, ""FRU Read failed: %s"", val2str(rsp->ccode, completion_code_vals)); break; } tmp = fru->access ? rsp->data[0] << 1 : rsp->data[0]; memcpy((frubuf + off)-offset, rsp->data + 1, tmp); off += tmp; if (tmp == 0 && off < finish) return 0; } while (off < finish); if (off < finish) return -1; return 0; }
Description: It's been found that multiple functions in ipmitool before 1.8.19 neglect proper checking of the data received from a remote LAN party, which may lead to buffer overflows and potentially to remote code execution on the ipmitool side. This is especially dangerous if ipmitool is run as a privileged user. This problem is fixed in version 1.8.19.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int nfc_enable_se(struct nfc_dev *dev, u32 se_idx) { struct nfc_se *se; int rc; pr_debug(""%s se index %d\n"", dev_name(&dev->dev), se_idx); device_lock(&dev->dev); if (!device_is_registered(&dev->dev)) { rc = -ENODEV; goto error; } if (!dev->dev_up) { rc = -ENODEV; goto error; } if (dev->polling) { rc = -EBUSY; goto error; } if (!dev->ops->enable_se || !dev->ops->disable_se) { rc = -EOPNOTSUPP; goto error; } se = nfc_find_se(dev, se_idx); if (!se) { rc = -EINVAL; goto error; } if (se->state == NFC_SE_ENABLED) { rc = -EALREADY; goto error; } rc = dev->ops->enable_se(dev, se_idx); if (rc >= 0) se->state = NFC_SE_ENABLED; error: device_unlock(&dev->dev); return rc; }
Description: A use-after-free flaw was found in the Linux kernel's NFC core functionality due to a race condition between kobject creation and delete. This vulnerability allows a local attacker with CAP_NET_ADMIN privilege to leak kernel information.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static bool getCoverageFormat12(vector<uint32_t>& coverage, const uint8_t* data, size_t size) { const size_t kNGroupsOffset = 12; const size_t kFirstGroupOffset = 16; const size_t kGroupSize = 12; const size_t kStartCharCodeOffset = 0; const size_t kEndCharCodeOffset = 4; const size_t kMaxNGroups = 0xfffffff0 / kGroupSize;          if (kFirstGroupOffset > size) { return false; } uint32_t nGroups = readU32(data, kNGroupsOffset); if (nGroups >= kMaxNGroups || kFirstGroupOffset + nGroups * kGroupSize > size) { return false; } for (uint32_t i = 0; i < nGroups; i++) { uint32_t groupOffset = kFirstGroupOffset + i * kGroupSize; uint32_t start = readU32(data, groupOffset + kStartCharCodeOffset); uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset); if (end < start) { return false; } addRange(coverage, start, end + 1);      } return true; }
Description: The Minikin library in Android 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-04-01 does not properly consider negative size values in font data, which allows remote attackers to cause a denial of service (memory corruption and reboot loop) via a crafted font, aka internal bug 26413177.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce) { long elements; elements = parse_iv2((*p) + 2, p); (*p) += 2; if (ce->serialize == NULL) { object_init_ex(*rval, ce); } else { zend_error(E_WARNING, ""Erroneous data format for unserializing '%s'"", ce->name); return 0; } return elements; }
Description: The object_common1 function in ext/standard/var_unserializer.c in PHP before 5.6.30, 7.0.x before 7.0.15, and 7.1.x before 7.1.1 allows remote attackers to cause a denial of service (buffer over-read and application crash) via crafted serialized data that is mishandled in a finish_nested_data call.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int validate_event(struct pmu_hw_events *hw_events, struct perf_event *event) { struct arm_pmu *armpmu = to_arm_pmu(event->pmu); struct hw_perf_event fake_event = event->hw; struct pmu *leader_pmu = event->group_leader->pmu; if (is_software_event(event)) return 1; if (event->pmu != leader_pmu || event->state < PERF_EVENT_STATE_OFF) return 1; if (event->state == PERF_EVENT_STATE_OFF && !event->attr.enable_on_exec) return 1; return armpmu->get_event_idx(hw_events, &fake_event) >= 0; }
Description: arch/arm64/kernel/perf_event.c in the Linux kernel before 4.1 on arm64 platforms allows local users to gain privileges or cause a denial of service (invalid pointer dereference) via vectors involving events that are mishandled during a span of multiple HW PMUs.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: uchar* FillColorRow1( uchar* data, uchar* indices, int len, PaletteEntry* palette ) { uchar* end = data + len*3; while( (data += 24) < end ) { int idx = *indices++; *((PaletteEntry*)(data - 24)) = palette[(idx & 128) != 0]; *((PaletteEntry*)(data - 21)) = palette[(idx & 64) != 0]; *((PaletteEntry*)(data - 18)) = palette[(idx & 32) != 0]; *((PaletteEntry*)(data - 15)) = palette[(idx & 16) != 0]; *((PaletteEntry*)(data - 12)) = palette[(idx & 8) != 0]; *((PaletteEntry*)(data - 9)) = palette[(idx & 4) != 0]; *((PaletteEntry*)(data - 6)) = palette[(idx & 2) != 0]; *((PaletteEntry*)(data - 3)) = palette[(idx & 1) != 0]; } int idx = indices[0] << 24; for( data -= 24; data < end; data += 3, idx += idx ) { PaletteEntry clr = palette[idx < 0]; WRITE_PIX( data, clr ); } return data; }
Description: OpenCV (Open Source Computer Vision Library) 3.3 has an out-of-bounds write error in the function FillColorRow1 in utils.cpp when reading an image file by using cv::imread. NOTE: this vulnerability exists because of an incomplete fix for CVE-2017-12597.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void* reset(size_t size, SkAutoMalloc::OnShrink shrink = SkAutoMalloc::kAlloc_OnShrink, bool* didChangeAlloc = nullptr) { size = (size < kSize) ? kSize : size; bool alloc = size != fSize && (SkAutoMalloc::kAlloc_OnShrink == shrink || size > fSize); if (didChangeAlloc) { *didChangeAlloc = alloc; } if (alloc) { if (fPtr != (void*)fStorage) { sk_free(fPtr); } if (size == kSize) { SkASSERT(fPtr != fStorage);                 fPtr = fStorage; } else { fPtr = sk_malloc_flags(size, SK_MALLOC_THROW | SK_MALLOC_TEMP); } fSize = size; } SkASSERT(fSize >= size && fSize >= kSize); SkASSERT((fPtr == fStorage) || fSize > kSize); return fPtr; }
Description: In SkSampler::Fill of SkSampler.cpp, there is a possible out of bounds write due to an integer overflow. This could lead to remote code execution with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android ID: A-78354855
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool HOGDescriptor::read(FileNode& obj) { CV_Assert(!obj[""winSize""].empty()); if( !obj.isMap() ) return false; FileNodeIterator it = obj[""winSize""].begin(); it >> winSize.width >> winSize.height; it = obj[""blockSize""].begin(); it >> blockSize.width >> blockSize.height; it = obj[""blockStride""].begin(); it >> blockStride.width >> blockStride.height; it = obj[""cellSize""].begin(); it >> cellSize.width >> cellSize.height; obj[""nbins""] >> nbins; obj[""derivAperture""] >> derivAperture; obj[""winSigma""] >> winSigma; obj[""histogramNormType""] >> histogramNormType; obj[""L2HysThreshold""] >> L2HysThreshold; obj[""gammaCorrection""] >> gammaCorrection; obj[""nlevels""] >> nlevels; if (obj[""signedGradient""].empty()) signedGradient = false; else obj[""signedGradient""] >> signedGradient; FileNode vecNode = obj[""SVMDetector""]; if( vecNode.isSeq() ) { std::vector<float> _svmDetector; vecNode >> _svmDetector; setSVMDetector(_svmDetector); } return true; }
Description: An issue was discovered in OpenCV 4.1.0. There is a divide-by-zero error in cv::HOGDescriptor::getDescriptorSize in modules/objdetect/src/hog.cpp.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void output(code_int code, GifCtx *ctx) { ctx->cur_accum &= masks[ctx->cur_bits]; if(ctx->cur_bits > 0) { ctx->cur_accum |= ((long)code << ctx->cur_bits); } else { ctx->cur_accum = code; } ctx->cur_bits += ctx->n_bits; while(ctx->cur_bits >= 8) { char_out((unsigned int)(ctx->cur_accum & 0xff), ctx); ctx->cur_accum >>= 8; ctx->cur_bits -= 8; } if(ctx->free_ent > ctx->maxcode || ctx->clear_flg) { if(ctx->clear_flg) { ctx->maxcode = MAXCODE (ctx->n_bits = ctx->g_init_bits); ctx->clear_flg = 0; } else { ++(ctx->n_bits); if(ctx->n_bits == maxbits) { ctx->maxcode = maxmaxcode; } else { ctx->maxcode = MAXCODE(ctx->n_bits); } } } if(code == ctx->EOFCode) { while(ctx->cur_bits > 0) { char_out((unsigned int)(ctx->cur_accum & 0xff), ctx); ctx->cur_accum >>= 8; ctx->cur_bits -= 8; } flush_char(ctx); } }
Description: The output function in gd_gif_out.c in the GD Graphics Library (aka libgd) allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted image.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void FrameLoader::startLoad(FrameLoadRequest& frameLoadRequest, FrameLoadType type, NavigationPolicy navigationPolicy) { ASSERT(client()->hasWebView()); if (m_frame->document()->pageDismissalEventBeingDispatched() != Document::NoDismissal) return; NavigationType navigationType = determineNavigationType(type, frameLoadRequest.resourceRequest().httpBody() || frameLoadRequest.form(), frameLoadRequest.triggeringEvent()); frameLoadRequest.resourceRequest().setRequestContext(determineRequestContextFromNavigationType(navigationType)); frameLoadRequest.resourceRequest().setFrameType(m_frame->isMainFrame() ? WebURLRequest::FrameTypeTopLevel : WebURLRequest::FrameTypeNested); ResourceRequest& request = frameLoadRequest.resourceRequest(); if (!shouldContinueForNavigationPolicy(request, frameLoadRequest.substituteData(), nullptr, frameLoadRequest.shouldCheckMainWorldContentSecurityPolicy(), navigationType, navigationPolicy, type == FrameLoadTypeReplaceCurrentItem, frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect)) return; m_frame->document()->cancelParsing(); if (m_provisionalDocumentLoader) { FrameNavigationDisabler navigationDisabler(*m_frame); detachDocumentLoader(m_provisionalDocumentLoader); } if (!m_frame->host()) return; m_provisionalDocumentLoader = client()->createDocumentLoader(m_frame, request, frameLoadRequest.substituteData().isValid() ? frameLoadRequest.substituteData() : defaultSubstituteDataForURL(request.url())); m_provisionalDocumentLoader->setNavigationType(navigationType); m_provisionalDocumentLoader->setReplacesCurrentHistoryItem(type == FrameLoadTypeReplaceCurrentItem); m_provisionalDocumentLoader->setIsClientRedirect(frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect); InspectorInstrumentation::didStartProvisionalLoad(m_frame); m_frame->navigationScheduler().cancel(); m_checkTimer.stop(); m_loadType = type; if (frameLoadRequest.form()) client()->dispatchWillSubmitForm(frameLoadRequest.form()); m_progressTracker->progressStarted(); if (m_provisionalDocumentLoader->isClientRedirect()) m_provisionalDocumentLoader->appendRedirect(m_frame->document()->url()); m_provisionalDocumentLoader->appendRedirect(m_provisionalDocumentLoader->request().url()); double triggeringEventTime = frameLoadRequest.triggeringEvent() ? frameLoadRequest.triggeringEvent()->platformTimeStamp() : 0; client()->dispatchDidStartProvisionalLoad(triggeringEventTime); ASSERT(m_provisionalDocumentLoader); m_provisionalDocumentLoader->startLoadingMainResource(); takeObjectSnapshot(); }
Description: WebKit/Source/core/loader/FrameLoader.cpp in Blink, as used in Google Chrome before 52.0.2743.82, does not disable frame navigation during a detach operation on a DocumentLoader object, which allows remote attackers to bypass the Same Origin Policy via a crafted web site.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int SecureSocket::secureAccept(int socket) { createSSL(); SSL_set_fd(m_ssl->m_ssl, socket); LOG((CLOG_DEBUG2 ""accepting secure socket"")); int r = SSL_accept(m_ssl->m_ssl); static int retry; checkResult(r, retry); if (isFatal()) { LOG((CLOG_ERR ""failed to accept secure socket"")); LOG((CLOG_INFO ""client connection may not be secure"")); m_secureReady = false; ARCH->sleep(1); retry = 0; return -1;     } if (retry == 0) { m_secureReady = true; LOG((CLOG_INFO ""accepted secure socket"")); if (CLOG->getFilter() >= kDEBUG1) { showSecureCipherInfo(); } showSecureConnectInfo(); return 1; } if (retry > 0) { LOG((CLOG_DEBUG2 ""retry accepting secure socket"")); m_secureReady = false; ARCH->sleep(s_retryDelay); return 0; } LOG((CLOG_ERR ""unexpected state attempting to accept connection"")); return -1; }
Description: An issue was discovered in Barrier before 2.4.0. An attacker can enter an active session state with the barriers component (aka the server-side implementation of Barrier) simply by supplying a client label that identifies a valid client configuration. This label is ""Unnamed"" by default but could instead be guessed from hostnames or other publicly available information. In the active session state, an attacker can capture input device events from the server, and also modify the clipboard content on the server.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int evtchn_reset(struct domain *d) { unsigned int i; int rc = 0; if ( d != current->domain && !d->controller_pause_count ) return -EINVAL; for ( i = 0; port_is_valid(d, i); i++ ) evtchn_close(d, i, 1); spin_lock(&d->event_lock); if ( d->active_evtchns > d->xen_evtchns ) rc = -EAGAIN; else if ( d->evtchn_fifo ) { evtchn_fifo_destroy(d); evtchn_2l_init(d); } spin_unlock(&d->event_lock); return rc; }
Description: An issue was discovered in Xen through 4.14.x. There is a lack of preemption in evtchn_reset() / evtchn_destroy(). In particular, the FIFO event channel model allows guests to have a large number of event channels active at a time. Closing all of these (when resetting all event channels or when cleaning up after the guest) may take extended periods of time. So far, there was no arrangement for preemption at suitable intervals, allowing a CPU to spend an almost unbounded amount of time in the processing of these operations. Malicious or buggy guest kernels can mount a Denial of Service (DoS) attack affecting the entire system. All Xen versions are vulnerable in principle. Whether versions 4.3 and older are vulnerable depends on underlying hardware characteristics.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void toggle_count_cache_flush(bool enable) { if (!enable || !security_ftr_enabled(SEC_FTR_FLUSH_COUNT_CACHE)) { patch_instruction_site(&patch__call_flush_count_cache, PPC_INST_NOP); count_cache_flush_type = COUNT_CACHE_FLUSH_NONE; pr_info(""count-cache-flush: software flush disabled.\n""); return; } patch_branch_site(&patch__call_flush_count_cache, (u64)&flush_count_cache, BRANCH_SET_LINK); if (!security_ftr_enabled(SEC_FTR_BCCTR_FLUSH_ASSIST)) { count_cache_flush_type = COUNT_CACHE_FLUSH_SW; pr_info(""count-cache-flush: full software flush sequence enabled.\n""); return; } patch_instruction_site(&patch__flush_count_cache_return, PPC_INST_BLR); count_cache_flush_type = COUNT_CACHE_FLUSH_HW; pr_info(""count-cache-flush: hardware assisted flush sequence enabled\n""); }
Description: The Linux kernel before 5.4.1 on powerpc allows Information Exposure because the Spectre-RSB mitigation is not in place for all applicable CPUs, aka CID-39e72bf96f58. This is related to arch/powerpc/kernel/entry_64.S and arch/powerpc/kernel/security.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static inline void bss_ref_get(struct cfg80211_registered_device *rdev, struct cfg80211_internal_bss *bss) { lockdep_assert_held(&rdev->bss_lock); bss->refcount++; if (bss->pub.hidden_beacon_bss) { bss = container_of(bss->pub.hidden_beacon_bss, struct cfg80211_internal_bss, pub); bss->refcount++; } if (bss->pub.transmitted_bss) { bss = container_of(bss->pub.transmitted_bss, struct cfg80211_internal_bss, pub); bss->refcount++; } }
Description: Various refcounting bugs in the multi-BSS handling in the mac80211 stack in the Linux kernel 5.1 through 5.19.x before 5.19.16 could be used by local attackers (able to inject WLAN frames) to trigger use-after-free conditions to potentially execute code.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void SkipRGBMipmaps(Image *image, DDSInfo *dds_info, int pixel_size) { MagickOffsetType offset; register ssize_t i; size_t h, w; if (dds_info->ddscaps1 & DDSCAPS_MIPMAP && (dds_info->ddscaps1 & DDSCAPS_TEXTURE || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP)) { w = DIV2(dds_info->width); h = DIV2(dds_info->height); for (i=1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++) { offset = (MagickOffsetType) w * h * pixel_size; (void) SeekBlob(image, offset, SEEK_CUR); w = DIV2(w); h = DIV2(h); } } }
Description: coders/dds.c in ImageMagick allows remote attackers to cause a denial of service via a crafted DDS file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: size_t jsvGetString(const JsVar *v, char *str, size_t len) { assert(len>0); const char *s = jsvGetConstString(v); if (s) { len--; int l = 0; while (*s && l<len) { str[l] = s[l]; l++; } str[l] = 0; return l; } else if (jsvIsInt(v)) { itostr(v->varData.integer, str, 10); return strlen(str); } else if (jsvIsFloat(v)) { ftoa_bounded(v->varData.floating, str, len); return strlen(str); } else if (jsvHasCharacterData(v)) { assert(!jsvIsStringExt(v)); size_t l = len; JsvStringIterator it; jsvStringIteratorNewConst(&it, v, 0); while (jsvStringIteratorHasChar(&it)) { if (l--<=1) { *str = 0; jsvStringIteratorFree(&it); return len; } *(str++) = jsvStringIteratorGetChar(&it); jsvStringIteratorNext(&it); } jsvStringIteratorFree(&it); *str = 0; return len-l; } else { JsVar *stringVar = jsvAsString((JsVar*)v, false);     if (stringVar) { size_t l = jsvGetString(stringVar, str, len);       jsvUnLock(stringVar); return l; } else { str[0] = 0; jsExceptionHere(JSET_INTERNALERROR, ""Variable type cannot be converted to string""); return 0; } } }
Description: Espruino before 1.99 allows attackers to cause a denial of service (application crash) with a user crafted input file via a Buffer Overflow during syntax parsing because a check for '\0' is made for the wrong array element in jsvar.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void copy_move_file (CopyMoveJob   *copy_job, GFile         *src, GFile         *dest_dir, gboolean       same_fs, gboolean       unique_names, char         **dest_fs_type, SourceInfo    *source_info, TransferInfo  *transfer_info, GHashTable    *debuting_files, GdkPoint      *position, gboolean       overwrite, gboolean      *skipped_file, gboolean       readonly_source_fs) { GFile *dest, *new_dest; g_autofree gchar *dest_uri = NULL; GError *error; GFileCopyFlags flags; char *primary, *secondary, *details; int response; ProgressData pdata; gboolean would_recurse, is_merge; CommonJob *job; gboolean res; int unique_name_nr; gboolean handled_invalid_filename; job = (CommonJob *) copy_job; if (should_skip_file (job, src)) { *skipped_file = TRUE; return; } unique_name_nr = 1; handled_invalid_filename = *dest_fs_type != NULL; if (unique_names) { dest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr++); } else if (copy_job->target_name != NULL) { dest = get_target_file_with_custom_name (src, dest_dir, *dest_fs_type, same_fs, copy_job->target_name); } else { dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs); } if (test_dir_is_parent (dest_dir, src)) { if (job->skip_all_error) { goto out; } primary = copy_job->is_move ? g_strdup (_(""You cannot move a folder into itself."")) : g_strdup (_(""You cannot copy a folder into itself."")); secondary = g_strdup (_(""The destination folder is inside the source folder."")); response = run_cancel_or_skip_warning (job, primary, secondary, NULL, source_info->num_files, source_info->num_files - transfer_info->num_files); if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) { abort_job (job); } else if (response == 1)              { job->skip_all_error = TRUE; } else if (response == 2)              {                } else { g_assert_not_reached (); } goto out; } if (test_dir_is_parent (src, dest)) { if (job->skip_all_error) { goto out; } primary = copy_job->is_move ? g_strdup (_(""You cannot move a file over itself."")) : g_strdup (_(""You cannot copy a file over itself."")); secondary = g_strdup (_(""The source file would be overwritten by the destination."")); response = run_cancel_or_skip_warning (job, primary, secondary, NULL, source_info->num_files, source_info->num_files - transfer_info->num_files); if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) { abort_job (job); } else if (response == 1)              { job->skip_all_error = TRUE; } else if (response == 2)              {                } else { g_assert_not_reached (); } goto out; } retry: error = NULL; flags = G_FILE_COPY_NOFOLLOW_SYMLINKS; if (overwrite) { flags |= G_FILE_COPY_OVERWRITE; } if (readonly_source_fs) { flags |= G_FILE_COPY_TARGET_DEFAULT_PERMS; } pdata.job = copy_job; pdata.last_size = 0; pdata.source_info = source_info; pdata.transfer_info = transfer_info; if (copy_job->is_move) { res = g_file_move (src, dest, flags, job->cancellable, copy_file_progress_callback, &pdata, &error); } else { res = g_file_copy (src, dest, flags, job->cancellable, copy_file_progress_callback, &pdata, &error); } if (res) { GFile *real; real = map_possibly_volatile_file_to_real (dest, job->cancellable, &error); if (real == NULL) { res = FALSE; } else { g_object_unref (dest); dest = real; } } if (res) { transfer_info->num_files++; report_copy_progress (copy_job, source_info, transfer_info); if (debuting_files) { dest_uri = g_file_get_uri (dest); if (position) { nautilus_file_changes_queue_schedule_position_set (dest, *position, job->screen_num); } else if (eel_uri_is_desktop (dest_uri)) { nautilus_file_changes_queue_schedule_position_remove (dest); } g_hash_table_replace (debuting_files, g_object_ref (dest), GINT_TO_POINTER (TRUE)); } if (copy_job->is_move) { nautilus_file_changes_queue_file_moved (src, dest); } else { nautilus_file_changes_queue_file_added (dest); } if (copy_job->desktop_location != NULL && g_file_equal (copy_job->desktop_location, dest_dir) && is_trusted_desktop_file (src, job->cancellable)) { mark_desktop_file_trusted (job, job->cancellable, dest, FALSE); } if (job->undo_info != NULL) { nautilus_file_undo_info_ext_add_origin_target_pair (NAUTILUS_FILE_UNDO_INFO_EXT (job->undo_info), src, dest); } g_object_unref (dest); return; } if (!handled_invalid_filename && IS_IO_ERROR (error, INVALID_FILENAME)) { handled_invalid_filename = TRUE; g_assert (*dest_fs_type == NULL); *dest_fs_type = query_fs_type (dest_dir, job->cancellable); if (unique_names) { new_dest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr); } else { new_dest = get_target_file (src, dest_dir, *dest_fs_type, same_fs); } if (!g_file_equal (dest, new_dest)) { g_object_unref (dest); dest = new_dest; g_error_free (error); goto retry; } else { g_object_unref (new_dest); } } if (!overwrite && IS_IO_ERROR (error, EXISTS)) { gboolean is_merge; FileConflictResponse *response; g_error_free (error); if (unique_names) { g_object_unref (dest); dest = get_unique_target_file (src, dest_dir, same_fs, *dest_fs_type, unique_name_nr++); goto retry; } is_merge = FALSE; if (is_dir (dest) && is_dir (src)) { is_merge = TRUE; } if ((is_merge && job->merge_all) || (!is_merge && job->replace_all)) { overwrite = TRUE; goto retry; } if (job->skip_all_conflict) { goto out; } response = handle_copy_move_conflict (job, src, dest, dest_dir); if (response->id == GTK_RESPONSE_CANCEL || response->id == GTK_RESPONSE_DELETE_EVENT) { file_conflict_response_free (response); abort_job (job); } else if (response->id == CONFLICT_RESPONSE_SKIP) { if (response->apply_to_all) { job->skip_all_conflict = TRUE; } file_conflict_response_free (response); } else if (response->id == CONFLICT_RESPONSE_REPLACE)              { if (response->apply_to_all) { if (is_merge) { job->merge_all = TRUE; } else { job->replace_all = TRUE; } } overwrite = TRUE; file_conflict_response_free (response); goto retry; } else if (response->id == CONFLICT_RESPONSE_RENAME) { g_object_unref (dest); dest = get_target_file_for_display_name (dest_dir, response->new_name); file_conflict_response_free (response); goto retry; } else { g_assert_not_reached (); } } else if (overwrite && IS_IO_ERROR (error, IS_DIRECTORY)) { gboolean existing_file_deleted; DeleteExistingFileData data; g_error_free (error); data.job = job; data.source = src; existing_file_deleted = delete_file_recursively (dest, job->cancellable, existing_file_removed_callback, &data); if (existing_file_deleted) { goto retry; } } else if (IS_IO_ERROR (error, WOULD_RECURSE) || IS_IO_ERROR (error, WOULD_MERGE)) { is_merge = error->code == G_IO_ERROR_WOULD_MERGE; would_recurse = error->code == G_IO_ERROR_WOULD_RECURSE; g_error_free (error); if (overwrite && would_recurse) { error = NULL; if (!g_file_delete (dest, job->cancellable, &error) && !IS_IO_ERROR (error, NOT_FOUND)) { if (job->skip_all_error) { g_error_free (error); goto out; } if (copy_job->is_move) { primary = f (_(""Error while moving “%B”.""), src); } else { primary = f (_(""Error while copying “%B”.""), src); } secondary = f (_(""Could not remove the already existing file with the same name in %F.""), dest_dir); details = error->message; response = run_warning (job, primary, secondary, details, TRUE, CANCEL, SKIP_ALL, SKIP, NULL); g_error_free (error); if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) { abort_job (job); } else if (response == 1)                      { job->skip_all_error = TRUE; } else if (response == 2)                      {                        } else { g_assert_not_reached (); } goto out; } if (error) { g_error_free (error); error = NULL; } nautilus_file_changes_queue_file_removed (dest); } if (is_merge) { same_fs = FALSE; } if (!copy_move_directory (copy_job, src, &dest, same_fs, would_recurse, dest_fs_type, source_info, transfer_info, debuting_files, skipped_file, readonly_source_fs)) { g_assert (*dest_fs_type != NULL); handled_invalid_filename = TRUE; goto retry; } g_object_unref (dest); return; } else if (IS_IO_ERROR (error, CANCELLED)) { g_error_free (error); } else { if (job->skip_all_error) { g_error_free (error); goto out; } primary = f (_(""Error while copying “%B”.""), src); secondary = f (_(""There was an error copying the file into %F.""), dest_dir); details = error->message; response = run_cancel_or_skip_warning (job, primary, secondary, details, source_info->num_files, source_info->num_files - transfer_info->num_files); g_error_free (error); if (response == 0 || response == GTK_RESPONSE_DELETE_EVENT) { abort_job (job); } else if (response == 1)              { job->skip_all_error = TRUE; } else if (response == 2)              {                } else { g_assert_not_reached (); } } out: *skipped_file = TRUE;      g_object_unref (dest); }
Description: GNOME Nautilus before 3.23.90 allows attackers to spoof a file type by using the .desktop file extension, as demonstrated by an attack in which a .desktop file's Name field ends in .pdf but this file's Exec field launches a malicious ""sh -c"" command. In other words, Nautilus provides no UI indication that a file actually has the potentially unsafe .desktop extension; instead, the UI only shows the .pdf extension. One (slightly) mitigating factor is that an attack requires the .desktop file to have execute permission. The solution is to ask the user to confirm that the file is supposed to be treated as a .desktop file, and then remember the user's answer in the metadata::trusted field.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static uint64_t read_indexed_address (uint64_t idx, struct comp_unit *unit) { struct dwarf2_debug *stash = unit->stash; struct dwarf2_debug_file *file = unit->file; bfd_byte *info_ptr; size_t offset; if (stash == NULL) return 0; if (!read_section (unit->abfd, &stash->debug_sections[debug_addr], file->syms, 0, &file->dwarf_addr_buffer, &file->dwarf_addr_size)) return 0; if (_bfd_mul_overflow (idx, unit->addr_size, &offset)) return 0; offset += unit->dwarf_addr_offset; if (offset < unit->dwarf_addr_offset || offset > file->dwarf_addr_size || file->dwarf_addr_size - offset < unit->offset_size) return 0; info_ptr = file->dwarf_addr_buffer + offset; if (unit->addr_size == 4) return bfd_get_32 (unit->abfd, info_ptr); else if (unit->addr_size == 8) return bfd_get_64 (unit->abfd, info_ptr); else return 0; }
Description: Heap based buffer overflow in binutils-gdb/bfd/libbfd.c in bfd_getl64.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void migrate_vma_unmap(struct migrate_vma *migrate) { const unsigned long npages = migrate->npages; unsigned long i, restore = 0; bool allow_drain = true; lru_add_drain(); for (i = 0; i < npages; i++) { struct page *page = migrate_pfn_to_page(migrate->src[i]); struct folio *folio; if (!page) continue; if (!is_zone_device_page(page)) { if (!PageLRU(page) && allow_drain) { lru_add_drain_all(); allow_drain = false; } if (isolate_lru_page(page)) { migrate->src[i] &= ~MIGRATE_PFN_MIGRATE; migrate->cpages--; restore++; continue; } put_page(page); } folio = page_folio(page); if (folio_mapped(folio)) try_to_migrate(folio, 0); if (page_mapped(page) || !migrate_vma_check_page(page)) { if (!is_zone_device_page(page)) { get_page(page); putback_lru_page(page); } migrate->src[i] &= ~MIGRATE_PFN_MIGRATE; migrate->cpages--; restore++; continue; } } for (i = 0; i < npages && restore; i++) { struct page *page = migrate_pfn_to_page(migrate->src[i]); struct folio *folio; if (!page || (migrate->src[i] & MIGRATE_PFN_MIGRATE)) continue; folio = page_folio(page); remove_migration_ptes(folio, folio, false); migrate->src[i] = 0; folio_unlock(folio); folio_put(folio); restore--; } }
Description: A vulnerability was found in Linux Kernel. It has been classified as problematic. Affected is an unknown function of the file mm/memory.c of the component Driver Handler. The manipulation leads to use after free. It is possible to launch the attack remotely. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211020.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static inline void io_req_work_grab_env(struct io_kiocb *req, const struct io_op_def *def) { if (!req->work.mm && def->needs_mm) { mmgrab(current->mm); req->work.mm = current->mm; } if (!req->work.creds) req->work.creds = get_current_cred(); }
Description: An issue was discovered in fs/io_uring.c in the Linux kernel before 5.6. It unsafely handles the root directory during path lookups, and thus a process inside a mount namespace can escape to unintended filesystem locations, aka CID-ff002b30181d.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int DoTls13Finished(WOLFSSL* ssl, const byte* input, word32* inOutIdx, word32 size, word32 totalSz, int sniff) { int    ret; word32 finishedSz = 0; byte*  secret; byte   mac[WC_MAX_DIGEST_SIZE]; WOLFSSL_START(WC_FUNC_FINISHED_DO); WOLFSSL_ENTER(""DoTls13Finished""); #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_CLIENT_AUTH) if (ssl->options.side == WOLFSSL_SERVER_END && (ssl->options.mutualAuth || ssl->options.failNoCert)) { if (!ssl->options.havePeerVerify && !ssl->options.resuming) { ret = NO_PEER_CERT; DoCertFatalAlert(ssl, ret); return ret; } } #endif if (*inOutIdx + size + ssl->keys.padSz > totalSz) return BUFFER_E; if (ssl->options.handShakeDone) { ret = DeriveFinishedSecret(ssl, ssl->clientSecret, ssl->keys.client_write_MAC_secret); if (ret != 0) return ret; secret = ssl->keys.client_write_MAC_secret; } else if (ssl->options.side == WOLFSSL_CLIENT_END) { ret = DeriveFinishedSecret(ssl, ssl->clientSecret, ssl->keys.client_write_MAC_secret); if (ret != 0) return ret; ret = DeriveFinishedSecret(ssl, ssl->serverSecret, ssl->keys.server_write_MAC_secret); if (ret != 0) return ret; secret = ssl->keys.server_write_MAC_secret; } else { secret = ssl->keys.client_write_MAC_secret; } if (sniff == NO_SNIFF) { ret = BuildTls13HandshakeHmac(ssl, secret, mac, &finishedSz); #if defined(OPENSSL_ALL) || defined(WOLFSSL_HAPROXY) || defined(WOLFSSL_WPAS) if (ssl->options.side == WOLFSSL_CLIENT_END) { XMEMCPY(ssl->serverFinished, mac, finishedSz); ssl->serverFinished_len = finishedSz; } else { XMEMCPY(ssl->clientFinished, mac, finishedSz); ssl->clientFinished_len = finishedSz; } #endif if (ret != 0) return ret; if (size != finishedSz) return BUFFER_ERROR; } #ifdef WOLFSSL_CALLBACKS if (ssl->hsInfoOn) AddPacketName(ssl, ""Finished""); if (ssl->toInfoOn) AddLateName(""Finished"", &ssl->timeoutInfo); #endif if (sniff == NO_SNIFF) { if (XMEMCMP(input + *inOutIdx, mac, size) != 0){ WOLFSSL_MSG(""Verify finished error on hashes""); SendAlert(ssl, alert_fatal, decrypt_error); return VERIFY_FINISHED_ERROR; } } *inOutIdx += size + ssl->keys.padSz; if (ssl->options.side == WOLFSSL_SERVER_END && !ssl->options.handShakeDone) { #ifdef WOLFSSL_EARLY_DATA if (ssl->earlyData != no_early_data) { if ((ret = DeriveTls13Keys(ssl, no_key, DECRYPT_SIDE_ONLY, 1)) != 0) return ret; } #endif if ((ret = SetKeysSide(ssl, DECRYPT_SIDE_ONLY)) != 0) return ret; } #ifndef NO_WOLFSSL_CLIENT if (ssl->options.side == WOLFSSL_CLIENT_END) ssl->options.serverState = SERVER_FINISHED_COMPLETE; #endif #ifndef NO_WOLFSSL_SERVER if (ssl->options.side == WOLFSSL_SERVER_END) { ssl->options.clientState = CLIENT_FINISHED_COMPLETE; ssl->options.handShakeState = HANDSHAKE_DONE; ssl->options.handShakeDone  = 1; } #endif WOLFSSL_LEAVE(""DoTls13Finished"", 0); WOLFSSL_END(WC_FUNC_FINISHED_DO); return 0; }
Description: In wolfSSL before 5.2.0, a TLS 1.3 server cannot properly enforce a requirement for mutual authentication. A client can simply omit the certificate_verify message from the handshake, and never present a certificate.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int _is_absW(const WCHAR *path) { return path[0] == L'\\' || path[0] == L'/' || path[1] == L':'; }
Description: Python Software Foundation CPython version From 3.2 until 3.6.4 on Windows contains a Buffer Overflow vulnerability in os.symlink() function on Windows that can result in Arbitrary code execution, likely escalation of privilege. This attack appears to be exploitable via a python script that creates a symlink with an attacker controlled name or location. This vulnerability appears to have been fixed in 3.7.0 and 3.6.5.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: BUILT_IN(selector_append) { List_Ptr arglist = ARG(""$selectors"", List); if( arglist->length() == 0 ) error(""$selectors: At least one selector must be passed for `selector-append'"", pstate, traces); SelectorStack parsedSelectors; for (size_t i = 0, L = arglist->length(); i < L; ++i) { Expression_Obj exp = Cast<Expression>(arglist->value_at_index(i)); if (exp->concrete_type() == Expression::NULL_VAL) { std::stringstream msg; msg << ""$selectors: null is not a valid selector: it must be a string,\n""; msg << ""a list of strings, or a list of lists of strings for 'selector-append'""; error(msg.str(), pstate, traces); } if (String_Constant_Ptr str = Cast<String_Constant>(exp)) { str->quote_mark(0); } std::string exp_src = exp->to_string(); Selector_List_Obj sel = Parser::parse_selector(exp_src.c_str(), ctx, traces, exp->pstate(), pstate.src, false); parsedSelectors.push_back(sel); } if( parsedSelectors.empty() ) { return SASS_MEMORY_NEW(Null, pstate); } SelectorStack::iterator itr = parsedSelectors.begin(); Selector_List_Obj result = *itr; ++itr; for(;itr != parsedSelectors.end(); ++itr) { Selector_List_Obj child = *itr; std::vector<Complex_Selector_Obj> newElements; for (size_t i = 0, resultLen = result->length(); i < resultLen; ++i) { for (size_t j = 0, childLen = child->length(); j < childLen; ++j) { Complex_Selector_Obj parentSeqClone = SASS_MEMORY_CLONE((*result)[i]); Complex_Selector_Obj childSeq = (*child)[j]; Complex_Selector_Obj base = childSeq->tail(); if( childSeq->combinator() != Complex_Selector::Combinator::ANCESTOR_OF ) { std::string msg(""Can't append \""""); msg += childSeq->to_string(); msg += ""\"" to \""""; msg += parentSeqClone->to_string(); msg += ""\"" for `selector-append'""; error(msg, pstate, traces); } Element_Selector_Obj pType = Cast<Element_Selector>(childSeq->head()->first()); if(pType && pType->name() == ""*"") { std::string msg(""Can't append \""""); msg += childSeq->to_string(); msg += ""\"" to \""""; msg += parentSeqClone->to_string(); msg += ""\"" for `selector-append'""; error(msg, pstate, traces); } parentSeqClone->mutable_last()->head()->concat(base->head()); parentSeqClone->mutable_last()->tail( base->tail() ); newElements.push_back(parentSeqClone); } } result->elements(newElements); } Listize listize; return Cast<Value>(result->perform(&listize)); }
Description: An issue was discovered in LibSass through 3.5.4. A NULL pointer dereference was found in the function Sass::Functions::selector_append which could be leveraged by an attacker to cause a denial of service (application crash) or possibly have unspecified other impact.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: IByteReader* DecryptionHelper::CreateDefaultDecryptionFilterForStream(PDFStreamInput* inStream, IByteReader* inToWrapStream) { if (!IsEncrypted() || !CanDecryptDocument() || HasCryptFilterDefinition(mParser, inStream) || !mXcryptStreams) return NULL; void* savedEcnryptionKey = inStream->GetMetadata(scEcnryptionKeyMetadataKey); if (savedEcnryptionKey) { return CreateDecryptionReader(inToWrapStream, *((ByteList*)savedEcnryptionKey), mXcryptStreams->IsUsingAES()); } else  return NULL; }
Description: The package muhammara before 2.6.1, from 3.0.0 and before 3.1.1; all versions of package hummus are vulnerable to Denial of Service (DoS) when supplied with a maliciously crafted PDF file to be parsed.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static LY_ERR lysp_stmt_validate_value(struct lysp_ctx *ctx, enum yang_arg val_type, const char *val) { uint8_t prefix = 0; ly_bool first = 1; uint32_t c; size_t utf8_char_len; while (*val) { LY_CHECK_ERR_RET(ly_getutf8(&val, &c, &utf8_char_len), LOGVAL_PARSER(ctx, LY_VCODE_INCHAR, (val)[-utf8_char_len]), LY_EVALID); switch (val_type) { case Y_IDENTIF_ARG: LY_CHECK_RET(lysp_check_identifierchar(ctx, c, first, NULL)); break; case Y_PREF_IDENTIF_ARG: LY_CHECK_RET(lysp_check_identifierchar(ctx, c, first, &prefix)); break; case Y_STR_ARG: case Y_MAYBE_STR_ARG: LY_CHECK_RET(lysp_check_stringchar(ctx, c)); break; } first = 0; } return LY_SUCCESS; }
Description: libyang from v2.0.164 to v2.1.30 was discovered to contain a NULL pointer dereference via the function lysp_stmt_validate_value at lys_parse_mem.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int fbcon_set_font(struct vc_data *vc, struct console_font *font, unsigned int flags) { struct fb_info *info = fbcon_info_from_console(vc->vc_num); unsigned charcount = font->charcount; int w = font->width; int h = font->height; int size; int i, csum; u8 *new_data, *data = font->data; int pitch = PITCH(font->width); if (charcount != 256 && charcount != 512) return -EINVAL; if (!(info->pixmap.blit_x & (1 << (font->width - 1))) || !(info->pixmap.blit_y & (1 << (font->height - 1)))) return -EINVAL; if (fbcon_invalid_charcount(info, charcount)) return -EINVAL; size = CALC_FONTSZ(h, pitch, charcount); new_data = kmalloc(FONT_EXTRA_WORDS * sizeof(int) + size, GFP_USER); if (!new_data) return -ENOMEM; memset(new_data, 0, FONT_EXTRA_WORDS * sizeof(int)); new_data += FONT_EXTRA_WORDS * sizeof(int); FNTSIZE(new_data) = size; REFCOUNT(new_data) = 0; for (i=0; i< charcount; i++) { memcpy(new_data + i*h*pitch, data +  i*32*pitch, h*pitch); } csum = crc32(0, new_data, size); FNTSUM(new_data) = csum; for (i = first_fb_vc; i <= last_fb_vc; i++) { struct vc_data *tmp = vc_cons[i].d; if (fb_display[i].userfont && fb_display[i].fontdata && FNTSUM(fb_display[i].fontdata) == csum && FNTSIZE(fb_display[i].fontdata) == size && tmp->vc_font.width == w && !memcmp(fb_display[i].fontdata, new_data, size)) { kfree(new_data - FONT_EXTRA_WORDS * sizeof(int)); new_data = (u8 *)fb_display[i].fontdata; break; } } return fbcon_do_set_font(vc, font->width, font->height, charcount, new_data, 1); }
Description: When sending malicous data to kernel by ioctl cmd FBIOPUT_VSCREENINFO,kernel will write memory out of bounds.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: CFFL_ComboBox::~CFFL_ComboBox() { delete m_pFontMap; }
Description: Multiple use-after-free vulnerabilities in the formfiller implementation in PDFium, as used in Google Chrome before 48.0.2564.82, allow remote attackers to cause a denial of service or possibly have unspecified other impact via a crafted PDF document, related to improper tracking of the destruction of (1) IPWL_FocusHandler and (2) IPWL_Provider objects.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int dvb_frontend_release(struct inode *inode, struct file *file) { struct dvb_device *dvbdev = file->private_data; struct dvb_frontend *fe = dvbdev->priv; struct dvb_frontend_private *fepriv = fe->frontend_priv; int ret; dev_dbg(fe->dvb->device, ""%s:\n"", __func__); if ((file->f_flags & O_ACCMODE) != O_RDONLY) { fepriv->release_jiffies = jiffies; mb(); } ret = dvb_generic_release(inode, file); if (dvbdev->users == -1) { wake_up(&fepriv->wait_queue); #ifdef CONFIG_MEDIA_CONTROLLER_DVB mutex_lock(&fe->dvb->mdev_lock); if (fe->dvb->mdev) { mutex_lock(&fe->dvb->mdev->graph_mutex); if (fe->dvb->mdev->disable_source) fe->dvb->mdev->disable_source(dvbdev->entity); mutex_unlock(&fe->dvb->mdev->graph_mutex); } mutex_unlock(&fe->dvb->mdev_lock); #endif if (fe->exit != DVB_FE_NO_EXIT) wake_up(&dvbdev->wait_queue); if (fe->ops.ts_bus_ctrl) fe->ops.ts_bus_ctrl(fe, 0); } dvb_frontend_put(fe); return ret; }
Description: An issue was discovered in the Linux kernel through 6.0.9. drivers/media/dvb-core/dvb_frontend.c has a race condition that can cause a use-after-free when a device is disconnected.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: GF_EXPORT GF_VVCConfig *gf_isom_vvc_config_get(GF_ISOFile *the_file, u32 trackNumber, u32 DescriptionIndex) { GF_TrackBox *trak; GF_MPEGVisualSampleEntryBox *entry; trak = gf_isom_get_track_from_file(the_file, trackNumber); if (!trak || !trak->Media || !DescriptionIndex) return NULL; if (gf_isom_get_vvc_type(the_file, trackNumber, DescriptionIndex)==GF_ISOM_VVCTYPE_NONE) return NULL; entry = (GF_MPEGVisualSampleEntryBox*)gf_list_get(trak->Media->information->sampleTable->SampleDescription->child_boxes, DescriptionIndex-1); if (!entry) return NULL; if (!entry->vvc_config) return NULL; return VVC_DuplicateConfig(entry->vvc_config->config); }
Description: A heap-based buffer overflow vulnerability exists in GPAC v1.0.1 in the gf_isom_dovi_config_get function in MP4Box, which causes a denial of service or execute arbitrary code via a crafted file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static ssize_t fuse_dev_splice_write(struct pipe_inode_info *pipe, struct file *out, loff_t *ppos, size_t len, unsigned int flags) { unsigned nbuf; unsigned idx; struct pipe_buffer *bufs; struct fuse_copy_state cs; struct fuse_conn *fc; size_t rem; ssize_t ret; fc = fuse_get_conn(out); if (!fc) return -EPERM; bufs = kmalloc(pipe->buffers * sizeof(struct pipe_buffer), GFP_KERNEL); if (!bufs) return -ENOMEM; pipe_lock(pipe); nbuf = 0; rem = 0; for (idx = 0; idx < pipe->nrbufs && rem < len; idx++) rem += pipe->bufs[(pipe->curbuf + idx) & (pipe->buffers - 1)].len; ret = -EINVAL; if (rem < len) { pipe_unlock(pipe); goto out; } rem = len; while (rem) { struct pipe_buffer *ibuf; struct pipe_buffer *obuf; BUG_ON(nbuf >= pipe->buffers); BUG_ON(!pipe->nrbufs); ibuf = &pipe->bufs[pipe->curbuf]; obuf = &bufs[nbuf]; if (rem >= ibuf->len) { *obuf = *ibuf; ibuf->ops = NULL; pipe->curbuf = (pipe->curbuf + 1) & (pipe->buffers - 1); pipe->nrbufs--; } else { ibuf->ops->get(pipe, ibuf); *obuf = *ibuf; obuf->flags &= ~PIPE_BUF_FLAG_GIFT; obuf->len = rem; ibuf->offset += obuf->len; ibuf->len -= obuf->len; } nbuf++; rem -= obuf->len; } pipe_unlock(pipe); fuse_copy_init(&cs, 0, NULL); cs.pipebufs = bufs; cs.nr_segs = nbuf; cs.pipe = pipe; if (flags & SPLICE_F_MOVE) cs.move_pages = 1; ret = fuse_dev_do_write(fc, &cs, len); for (idx = 0; idx < nbuf; idx++) { struct pipe_buffer *buf = &bufs[idx]; buf->ops->release(pipe, buf); } out: kfree(bufs); return ret; }
Description: Memory leak in the cuse_channel_release function in fs/fuse/cuse.c in the Linux kernel before 4.4 allows local users to cause a denial of service (memory consumption) or possibly have unspecified other impact by opening /dev/cuse many times.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void fli_read_lc(FILE *f, s_fli_header *fli_header, unsigned char *old_framebuf, unsigned char *framebuf) { unsigned short yc, firstline, numline; unsigned char *pos; memcpy(framebuf, old_framebuf, fli_header->width * fli_header->height); firstline = fli_read_short(f); numline = fli_read_short(f); for (yc=0; yc < numline; yc++) { unsigned short xc, pc, pcnt; pc=fli_read_char(f); xc=0; pos=framebuf+(fli_header->width * (firstline+yc)); for (pcnt=pc; pcnt>0; pcnt--) { unsigned short ps,skip; skip=fli_read_char(f); ps=fli_read_char(f); xc+=skip; if (ps & 0x80) { unsigned char val; ps=-(signed char)ps; val=fli_read_char(f); memset(&(pos[xc]), val, ps); xc+=ps; } else { fread(&(pos[xc]), ps, 1, f); xc+=ps; } } } }
Description: In GIMP 2.8.22, there is a heap-based buffer overflow in the fli_read_brun function in plug-ins/file-fli/fli.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: struct xt_table_info * xt_replace_table(struct xt_table *table, unsigned int num_counters, struct xt_table_info *newinfo, int *error) { struct xt_table_info *private; unsigned int cpu; int ret; ret = xt_jumpstack_alloc(newinfo); if (ret < 0) { *error = ret; return NULL; } local_bh_disable(); private = table->private; if (num_counters != private->number) { pr_debug(""num_counters != table->private->number (%u/%u)\n"", num_counters, private->number); local_bh_enable(); *error = -EAGAIN; return NULL; } newinfo->initial_entries = private->initial_entries; smp_wmb(); table->private = newinfo; smp_wmb(); local_bh_enable(); for_each_possible_cpu(cpu) { seqcount_t *s = &per_cpu(xt_recseq, cpu); u32 seq = raw_read_seqcount(s); if (seq & 1) { do { cond_resched(); cpu_relax(); } while (seq == raw_read_seqcount(s)); } } audit_log_nfcfg(table->name, table->af, private->number, !private->number ? AUDIT_XT_OP_REGISTER : AUDIT_XT_OP_REPLACE, GFP_KERNEL); return private; }
Description: An issue was discovered in netfilter in the Linux kernel before 5.10. There can be a use-after-free in the packet processing context, because the per-CPU sequence count is mishandled during concurrent iptables rules replacement. This could be exploited with the CAP_NET_ADMIN capability in an unprivileged namespace. NOTE: cc00bca was reverted in 5.12.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int exif_process_IFD_in_MAKERNOTE(image_info_type *ImageInfo, char * value_ptr, int value_len, char *offset_base, size_t IFDlength, size_t displacement) { size_t i; int de, section_index = SECTION_MAKERNOTE; int NumDirEntries, old_motorola_intel; #ifdef KALLE_0 int offset_diff; #endif const maker_note_type *maker_note; char *dir_start; int data_len; for (i=0; i<=sizeof(maker_note_array)/sizeof(maker_note_type); i++) { if (i==sizeof(maker_note_array)/sizeof(maker_note_type)) { #ifdef EXIF_DEBUG exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""No maker note data found. Detected maker: %s (length = %d)"", ImageInfo->make, strlen(ImageInfo->make)); #endif return TRUE; } maker_note = maker_note_array+i; if (maker_note->make && (!ImageInfo->make || strcmp(maker_note->make, ImageInfo->make))) continue; if (maker_note->id_string && strncmp(maker_note->id_string, value_ptr, maker_note->id_string_len)) continue; break; } if (value_len < 2 || maker_note->offset >= value_len - 1) { exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""IFD data too short: 0x%04X offset 0x%04X"", value_len, maker_note->offset); return FALSE; } dir_start = value_ptr + maker_note->offset; #ifdef EXIF_DEBUG exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Process %s @x%04X + 0x%04X=%d: %s"", exif_get_sectionname(section_index), (int)dir_start-(int)offset_base+maker_note->offset+displacement, value_len, value_len, exif_char_dump(value_ptr, value_len, (int)dir_start-(int)offset_base+maker_note->offset+displacement)); #endif ImageInfo->sections_found |= FOUND_MAKERNOTE; old_motorola_intel = ImageInfo->motorola_intel; switch (maker_note->byte_order) { case MN_ORDER_INTEL: ImageInfo->motorola_intel = 0; break; case MN_ORDER_MOTOROLA: ImageInfo->motorola_intel = 1; break; default: case MN_ORDER_NORMAL: break; } NumDirEntries = php_ifd_get16u(dir_start, ImageInfo->motorola_intel); switch (maker_note->offset_mode) { case MN_OFFSET_MAKER: offset_base = value_ptr; data_len = value_len; break; #ifdef KALLE_0 case MN_OFFSET_GUESS: if (maker_note->offset + 10 + 4 >= value_len) { exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""IFD data too short: 0x%04X"", value_len); return FALSE; } offset_diff = 2 + NumDirEntries*12 + 4 - php_ifd_get32u(dir_start+10, ImageInfo->motorola_intel); #ifdef EXIF_DEBUG exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Using automatic offset correction: 0x%04X"", ((int)dir_start-(int)offset_base+maker_note->offset+displacement) + offset_diff); #endif if (offset_diff < 0 || offset_diff >= value_len ) { exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""IFD data bad offset: 0x%04X length 0x%04X"", offset_diff, value_len); return FALSE; } offset_base = value_ptr + offset_diff; data_len = value_len - offset_diff; break; #endif default: case MN_OFFSET_NORMAL: data_len = value_len; break; } if ((2+NumDirEntries*12) > value_len) { exif_error_docref(""exif_read_data#error_ifd"" EXIFERR_CC, ImageInfo, E_WARNING, ""Illegal IFD size: 2 + 0x%04X*12 = 0x%04X > 0x%04X"", NumDirEntries, 2+NumDirEntries*12, value_len); return FALSE; } for (de=0;de<NumDirEntries;de++) { if (!exif_process_IFD_TAG(ImageInfo, dir_start + 2 + 12 * de, offset_base, data_len, displacement, section_index, 0, maker_note->tag_table)) { return FALSE; } } ImageInfo->motorola_intel = old_motorola_intel; #ifdef EXIF_DEBUG exif_error_docref(NULL EXIFERR_CC, ImageInfo, E_NOTICE, ""Subsection %s done"", exif_get_sectionname(SECTION_MAKERNOTE)); #endif return TRUE; }
Description: When processing certain files, PHP EXIF extension in versions 7.1.x below 7.1.28, 7.2.x below 7.2.17 and 7.3.x below 7.3.4 can be caused to read past allocated buffer in exif_process_IFD_TAG function. This may lead to information disclosure or crash.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int forward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s, UChar* range, UChar** low, UChar** high, UChar** low_prev) { UChar *p, *pprev = (UChar* )NULL; #ifdef ONIG_DEBUG_SEARCH fprintf(stderr, ""forward_search_range: str: %d, end: %d, s: %d, range: %d\n"", (int )str, (int )end, (int )s, (int )range); #endif p = s; if (reg->dmin > 0) { if (ONIGENC_IS_SINGLEBYTE(reg->enc)) { p += reg->dmin; } else { UChar *q = p + reg->dmin; while (p < q) p += enclen(reg->enc, p); } } retry: switch (reg->optimize) { case ONIG_OPTIMIZE_EXACT: p = slow_search(reg->enc, reg->exact, reg->exact_end, p, end, range); break; case ONIG_OPTIMIZE_EXACT_IC: p = slow_search_ic(reg->enc, reg->case_fold_flag, reg->exact, reg->exact_end, p, end, range); break; case ONIG_OPTIMIZE_EXACT_BM: p = bm_search(reg, reg->exact, reg->exact_end, p, end, range); break; case ONIG_OPTIMIZE_EXACT_BM_NOT_REV: p = bm_search_notrev(reg, reg->exact, reg->exact_end, p, end, range); break; case ONIG_OPTIMIZE_MAP: p = map_search(reg->enc, reg->map, p, range); break; } if (p && p < range) { if (p - reg->dmin < s) { retry_gate: pprev = p; p += enclen(reg->enc, p); goto retry; } if (reg->sub_anchor) { UChar* prev; switch (reg->sub_anchor) { case ANCHOR_BEGIN_LINE: if (!ON_STR_BEGIN(p)) { prev = onigenc_get_prev_char_head(reg->enc, (pprev ? pprev : str), p); if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end)) goto retry_gate; } break; case ANCHOR_END_LINE: if (ON_STR_END(p)) { #ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE prev = (UChar* )onigenc_get_prev_char_head(reg->enc, (pprev ? pprev : str), p); if (prev && ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end)) goto retry_gate; #endif } else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end) #ifdef USE_CRNL_AS_LINE_TERMINATOR && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end) #endif ) goto retry_gate; break; } } if (reg->dmax == 0) { *low = p; if (low_prev) { if (*low > s) *low_prev = onigenc_get_prev_char_head(reg->enc, s, p); else *low_prev = onigenc_get_prev_char_head(reg->enc, (pprev ? pprev : str), p); } } else { if (reg->dmax != ONIG_INFINITE_DISTANCE) { *low = p - reg->dmax; if (*low > s) { *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s, *low, (const UChar** )low_prev); if (low_prev && IS_NULL(*low_prev)) *low_prev = onigenc_get_prev_char_head(reg->enc, (pprev ? pprev : s), *low); } else { if (low_prev) *low_prev = onigenc_get_prev_char_head(reg->enc, (pprev ? pprev : str), *low); } } } *high = p - reg->dmin; #ifdef ONIG_DEBUG_SEARCH fprintf(stderr, ""forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\n"", (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax); #endif return 1;  } return 0;  }
Description: An issue was discovered in Oniguruma 6.2.0, as used in Oniguruma-mod in Ruby through 2.4.1 and mbstring in PHP through 7.1.5. A stack out-of-bounds read occurs in mbc_enc_len() during regular expression searching. Invalid handling of reg->dmin in forward_search_range() could result in an invalid pointer dereference, as an out-of-bounds read from a stack buffer.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int bm_puts(Bitmap *b, int x, int y, const char *text) { if(!b->font || !b->font->puts) return 0; return b->font->puts(b, x, y, text); }
Description: wernsey/bitmap before 2018-08-18 allows a NULL pointer dereference via a 4-bit image.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int xmkstemp(char **tmpname, char *dir) { char *localtmp; char *tmpenv; mode_t old_mode; int fd, rc; if (dir != NULL) tmpenv = dir; else tmpenv = getenv(""TMPDIR""); if (tmpenv) rc = asprintf(&localtmp, ""%s/%s.XXXXXX"", tmpenv, program_invocation_short_name); else rc = asprintf(&localtmp, ""%s/%s.XXXXXX"", _PATH_TMP, program_invocation_short_name); if (rc < 0) return -1; old_mode = umask(077); fd = mkostemp(localtmp, O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC); umask(old_mode); if (fd == -1) { free(localtmp); localtmp = NULL; } *tmpname = localtmp; return fd; }
Description: The mkostemp function in login-utils in util-linux when used incorrectly allows remote attackers to cause file name collision and possibly other attacks.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void _php_image_convert(INTERNAL_FUNCTION_PARAMETERS, int image_type ) { char *f_org, *f_dest; int f_org_len, f_dest_len; long height, width, threshold; gdImagePtr im_org, im_dest, im_tmp; char *fn_org = NULL; char *fn_dest = NULL; FILE *org, *dest; int dest_height = -1; int dest_width = -1; int org_height, org_width; int white, black; int color, color_org, median; int int_threshold; int x, y; float x_ratio, y_ratio; long ignore_warning; if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""pplll"", &f_org, &f_org_len, &f_dest, &f_dest_len, &height, &width, &threshold) == FAILURE) { return; } fn_org  = f_org; fn_dest = f_dest; dest_height = height; dest_width = width; int_threshold = threshold; if (int_threshold < 0 || int_threshold > 8) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Invalid threshold value '%d'"", int_threshold); RETURN_FALSE; } PHP_GD_CHECK_OPEN_BASEDIR(fn_org, ""Invalid origin filename""); PHP_GD_CHECK_OPEN_BASEDIR(fn_dest, ""Invalid destination filename""); org = VCWD_FOPEN(fn_org, ""rb""); if (!org) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to open '%s' for reading"", fn_org); RETURN_FALSE; } dest = VCWD_FOPEN(fn_dest, ""wb""); if (!dest) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to open '%s' for writing"", fn_dest); RETURN_FALSE; } switch (image_type) { case PHP_GDIMG_TYPE_GIF: im_org = gdImageCreateFromGif(org); if (im_org == NULL) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to open '%s' Not a valid GIF file"", fn_dest); RETURN_FALSE; } break; #ifdef HAVE_GD_JPG case PHP_GDIMG_TYPE_JPG: ignore_warning = INI_INT(""gd.jpeg_ignore_warning""); im_org = gdImageCreateFromJpegEx(org, ignore_warning); if (im_org == NULL) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to open '%s' Not a valid JPEG file"", fn_dest); RETURN_FALSE; } break; #endif  #ifdef HAVE_GD_PNG case PHP_GDIMG_TYPE_PNG: im_org = gdImageCreateFromPng(org); if (im_org == NULL) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to open '%s' Not a valid PNG file"", fn_dest); RETURN_FALSE; } break; #endif  default: php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Format not supported""); RETURN_FALSE; break; } org_width  = gdImageSX (im_org); org_height = gdImageSY (im_org); x_ratio = (float) org_width / (float) dest_width; y_ratio = (float) org_height / (float) dest_height; if (x_ratio > 1 && y_ratio > 1) { if (y_ratio > x_ratio) { x_ratio = y_ratio; } else { y_ratio = x_ratio; } dest_width = (int) (org_width / x_ratio); dest_height = (int) (org_height / y_ratio); } else { x_ratio = (float) dest_width / (float) org_width; y_ratio = (float) dest_height / (float) org_height; if (y_ratio < x_ratio) { x_ratio = y_ratio; } else { y_ratio = x_ratio; } dest_width = (int) (org_width * x_ratio); dest_height = (int) (org_height * y_ratio); } im_tmp = gdImageCreate (dest_width, dest_height); if (im_tmp == NULL ) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to allocate temporary buffer""); RETURN_FALSE; } gdImageCopyResized (im_tmp, im_org, 0, 0, 0, 0, dest_width, dest_height, org_width, org_height); gdImageDestroy(im_org); fclose(org); im_dest = gdImageCreate(dest_width, dest_height); if (im_dest == NULL) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to allocate destination buffer""); RETURN_FALSE; } white = gdImageColorAllocate(im_dest, 255, 255, 255); if (white == -1) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to allocate the colors for the destination buffer""); RETURN_FALSE; } black = gdImageColorAllocate(im_dest, 0, 0, 0); if (black == -1) { php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to allocate the colors for the destination buffer""); RETURN_FALSE; } int_threshold = int_threshold * 32; for (y = 0; y < dest_height; y++) { for (x = 0; x < dest_width; x++) { color_org = gdImageGetPixel (im_tmp, x, y); median = (im_tmp->red[color_org] + im_tmp->green[color_org] + im_tmp->blue[color_org]) / 3; if (median < int_threshold) { color = black; } else { color = white; } gdImageSetPixel (im_dest, x, y, color); } } gdImageDestroy (im_tmp ); gdImageWBMP(im_dest, black , dest); fflush(dest); fclose(dest); gdImageDestroy(im_dest); RETURN_TRUE; }
Description: PHP before 5.4.42, 5.5.x before 5.5.26, and 5.6.x before 5.6.10 does not ensure that pathnames lack %00 sequences, which might allow remote attackers to read or write to arbitrary files via crafted input to an application that calls (1) a DOMDocument save method or (2) the GD imagepsloadfont function, as demonstrated by a filename\0.html attack that bypasses an intended configuration in which client users may write to only .html files.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void jp2_box_dump(jp2_box_t *box, FILE *out) { jp2_boxinfo_t *boxinfo; boxinfo = jp2_boxinfolookup(box->type); assert(boxinfo); fprintf(out, ""JP2 box: ""); fprintf(out, ""type=%c%s%c (0x%08""PRIxFAST32""); length=%""PRIuFAST32""\n"", '""', boxinfo->name, '""', box->type, box->len); if (box->ops->dumpdata) { (*box->ops->dumpdata)(box, out); } }
Description: The jp2_colr_destroy function in jp2_cod.c in JasPer before 1.900.13 allows remote attackers to cause a denial of service (NULL pointer dereference) by leveraging incorrect cleanup of JP2 box data on error. NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-8887.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: EStatusCode PDFParser::ParseLastXrefPosition() { EStatusCode status = PDFHummus::eSuccess; do { if(!GoBackTillToken()) { status = PDFHummus::eFailure; TRACE_LOG(""PDFParser::ParseXrefPosition, couldn't find xref position token""); break; } GoBackTillLineStart(); mStream->SetPositionFromEnd(GetCurrentPositionFromEnd()); mObjectParser.ResetReadState(); RefCountPtr<PDFObject> anObject(mObjectParser.ParseNewObject()); if(anObject->GetType() == PDFObject::ePDFObjectInteger) { mLastXrefPosition = (LongFilePositionType)((PDFInteger*)anObject.GetPtr())->GetValue(); if(!GoBackTillToken()) { status = PDFHummus::eFailure; TRACE_LOG(""PDFParser::ParseXrefPosition, couldn't find startxref keyword""); break; } GoBackTillLineStart(); mStream->SetPositionFromEnd(GetCurrentPositionFromEnd()); mObjectParser.ResetReadState(); PDFObjectCastPtr<PDFSymbol> startxRef(mObjectParser.ParseNewObject()); if(!startxRef || startxRef->GetValue() != scStartxref) { status = PDFHummus::eFailure; TRACE_LOG(""PDFParser::ParseXrefPosition, syntax error in reading xref position""); break; } } else { bool foundStartXref = (anObject->GetType() == PDFObject::ePDFObjectSymbol) && (((PDFSymbol*)anObject.GetPtr())->GetValue() == scStartxref); while(!foundStartXref && mStream->NotEnded()) { PDFObjectCastPtr<PDFSymbol> startxRef(mObjectParser.ParseNewObject()); foundStartXref = startxRef.GetPtr() && (startxRef->GetValue() == scStartxref); } if(!foundStartXref) { status = PDFHummus::eFailure; TRACE_LOG(""PDFParser::ParseXrefPosition, could not find startxref keyword""); break; } PDFObjectCastPtr<PDFInteger> xrefPosition(mObjectParser.ParseNewObject()); if(!xrefPosition) { status = PDFHummus::eFailure; TRACE_LOG(""PDFParser::ParseXrefPosition, syntax error in reading xref position""); break; } mLastXrefPosition = xrefPosition->GetValue(); } }while(false); return status; }
Description: The package muhammara before 2.6.1, from 3.0.0 and before 3.1.1; all versions of package hummus are vulnerable to Denial of Service (DoS) when supplied with a maliciously crafted PDF file to be parsed.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int valid_entry_name(const char *filename) { return *filename != '\0' && strchr(filename, '/') == NULL && (*filename != '.' || (strcmp(filename, ""."") != 0 && strcmp(filename, "".."") != 0 && strcmp(filename, DOT_GIT) != 0)); }
Description: Git before 1.8.5.6, 1.9.x before 1.9.5, 2.0.x before 2.0.5, 2.1.x before 2.1.4, and 2.2.x before 2.2.1 on Windows and OS X; Mercurial before 3.2.3 on Windows and OS X; Apple Xcode before 6.2 beta 3; mine all versions before 08-12-2014; libgit2 all versions up to 0.21.2; Egit all versions before 08-12-2014; and JGit all versions before 08-12-2014 allow remote Git servers to execute arbitrary commands via a tree containing a crafted .git/config file with (1) an ignorable Unicode codepoint, (2) a git~1/config representation, or (3) mixed case that is improperly handled on a case-insensitive filesystem.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void unix_notinflight(struct file *fp) { struct sock *s = unix_get_socket(fp); if (s) { struct unix_sock *u = unix_sk(s); spin_lock(&unix_gc_lock); BUG_ON(list_empty(&u->link)); if (atomic_long_dec_and_test(&u->inflight)) list_del_init(&u->link); unix_tot_inflight--; spin_unlock(&unix_gc_lock); } }
Description: The Linux kernel before 4.4.1 allows local users to bypass file-descriptor limits and cause a denial of service (memory consumption) by sending each descriptor over a UNIX socket before closing it, related to net/unix/af_unix.c and net/unix/garbage.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int cond_seq(tvbparse_t* tt, int offset, const tvbparse_wanted_t * wanted, tvbparse_elem_t** tok) { guint i; int len = 0; int start = offset; tvbparse_elem_t* ret_tok = NULL; if ( offset > tt->end_offset ) return -1; #ifdef TVBPARSE_DEBUG if (TVBPARSE_DEBUG & TVBPARSE_DEBUG_SEQ) g_warning(""cond_seq: START""); #endif for(i=0; i < wanted->control.elems->len; i++) { tvbparse_wanted_t* w = (tvbparse_wanted_t *)g_ptr_array_index(wanted->control.elems,i); tvbparse_elem_t* new_elem = NULL; if ( offset + w->len > tt->end_offset ) return -1; len = w->condition(tt, offset, w, &new_elem); if (len >= 0) { if (ret_tok) { if (new_elem->len) ret_tok->len = (new_elem->offset - ret_tok->offset) + new_elem->len; ret_tok->sub->last->next = new_elem; ret_tok->sub->last = new_elem; } else { ret_tok = new_tok(tt, wanted->id, new_elem->offset, new_elem->len, wanted); ret_tok->sub = new_elem; new_elem->last = new_elem; } } else { return -1; } offset += len; offset += ignore_fcn(tt,offset); } *tok = ret_tok; #ifdef TVBPARSE_DEBUG if (TVBPARSE_DEBUG & TVBPARSE_DEBUG_SEQ) g_warning(""cond_seq: GOT len=%i"",offset - start); #endif return offset - start; }
Description: In Wireshark 2.4.0 to 2.4.3 and 2.2.0 to 2.2.11, the JSON, XML, NTP, XMPP, and GDB dissectors could crash. This was addressed in epan/tvbparse.c by limiting the recursion depth.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int do_add_counters(struct net *net, sockptr_t arg, unsigned int len) { unsigned int i; struct xt_counters_info tmp; struct xt_counters *paddc; struct xt_table *t; const struct xt_table_info *private; int ret = 0; struct ipt_entry *iter; unsigned int addend; paddc = xt_copy_counters(arg, len, &tmp); if (IS_ERR(paddc)) return PTR_ERR(paddc); t = xt_find_table_lock(net, AF_INET, tmp.name); if (IS_ERR(t)) { ret = PTR_ERR(t); goto free; } local_bh_disable(); private = t->private; if (private->number != tmp.num_counters) { ret = -EINVAL; goto unlock_up_free; } i = 0; addend = xt_write_recseq_begin(); xt_entry_foreach(iter, private->entries, private->size) { struct xt_counters *tmp; tmp = xt_get_this_cpu_counter(&iter->counters); ADD_COUNTER(*tmp, paddc[i].bcnt, paddc[i].pcnt); ++i; } xt_write_recseq_end(addend); unlock_up_free: local_bh_enable(); xt_table_unlock(t); module_put(t->me); free: vfree(paddc); return ret; }
Description: An issue was discovered in netfilter in the Linux kernel before 5.10. There can be a use-after-free in the packet processing context, because the per-CPU sequence count is mishandled during concurrent iptables rules replacement. This could be exploited with the CAP_NET_ADMIN capability in an unprivileged namespace. NOTE: cc00bca was reverted in 5.12.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int cond_hash(tvbparse_t* tt, const int offset, const tvbparse_wanted_t* wanted, tvbparse_elem_t** tok) { int key_len; gchar* key = NULL; tvbparse_elem_t* key_elem = NULL; tvbparse_wanted_t* value_wanted = NULL; int value_len; tvbparse_elem_t* value_elem = NULL; int tot_len; tvbparse_elem_t* ret_tok; #ifdef TVBPARSE_DEBUG if (TVBPARSE_DEBUG & TVBPARSE_DEBUG_HASH) g_warning(""cond_hash: START""); #endif if ( offset > tt->end_offset ) return -1; key_len = wanted->control.hash.key->condition(tt, offset, wanted->control.hash.key,  &key_elem); if (key_len < 0) return -1; key = tvb_get_string_enc(wmem_packet_scope(),key_elem->tvb,key_elem->offset,key_elem->len, ENC_ASCII); #ifdef TVBPARSE_DEBUG if (TVBPARSE_DEBUG & TVBPARSE_DEBUG_HASH) g_warning(""cond_hash: got key='%s'"",key); #endif if ((value_wanted = (tvbparse_wanted_t *)wmem_map_lookup(wanted->control.hash.table,key))) { value_len = value_wanted->condition(tt, offset + key_len, value_wanted,  &value_elem); } else if (wanted->control.hash.other) { value_len = wanted->control.hash.other->condition(tt, offset+key_len, wanted->control.hash.other,  &value_elem); if (value_len < 0) return -1; } else { return -1; } tot_len = key_len + value_len; ret_tok = new_tok(tt, value_elem->id, offset, tot_len, wanted); ret_tok->sub = key_elem; ret_tok->sub->last->next = value_elem; *tok = ret_tok; #ifdef TVBPARSE_DEBUG if (TVBPARSE_DEBUG & TVBPARSE_DEBUG_HASH) g_warning(""cond_hash: GOT len=%i"",tot_len); #endif return tot_len; }
Description: In Wireshark 2.4.0 to 2.4.3 and 2.2.0 to 2.2.11, the JSON, XML, NTP, XMPP, and GDB dissectors could crash. This was addressed in epan/tvbparse.c by limiting the recursion depth.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static s32 gf_vvc_read_pps_bs_internal(GF_BitStream *bs, VVCState *vvc) { u32 i; s32 pps_id; VVC_PPS *pps; pps_id = gf_bs_read_int_log(bs, 6, ""pps_id""); if ((pps_id < 0) || (pps_id >= 64)) { GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] wrong PPS ID %d in PPS\n"", pps_id)); return -1; } pps = &vvc->pps[pps_id]; if (!pps->state) { pps->id = pps_id; pps->state = 1; } pps->sps_id = gf_bs_read_int_log(bs, 4, ""sps_id""); if (((s32)pps->sps_id<0) || (pps->sps_id >= 16)) { GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] wrong SPS ID %d in PPS\n"", pps->sps_id)); pps->sps_id=0; return -1; } vvc->sps_active_idx = pps->sps_id;  pps->mixed_nal_types = gf_bs_read_int_log(bs, 1, ""mixed_nal_types""); pps->width = gf_bs_read_ue_log(bs, ""width""); pps->height = gf_bs_read_ue_log(bs, ""height""); pps->conf_window = gf_bs_read_int_log(bs, 1, ""conformance_window_flag""); if (pps->conf_window) { pps->cw_left = gf_bs_read_ue_log(bs, ""conf_win_left_offset""); pps->cw_right = gf_bs_read_ue_log(bs, ""conf_win_right_offset""); pps->cw_top = gf_bs_read_ue_log(bs, ""conf_win_top_offset""); pps->cw_bottom = gf_bs_read_ue_log(bs, ""conf_win_bottom_offset""); } if (gf_bs_read_int_log(bs, 1, ""scaling_window_explicit_signaling_flag"")) { gf_bs_read_se_log(bs, ""scaling_win_left_offset""); gf_bs_read_se_log(bs, ""scaling_win_right_offset""); gf_bs_read_se_log(bs, ""scaling_win_top_offset""); gf_bs_read_se_log(bs, ""scaling_win_bottom_offset""); } pps->output_flag_present_flag = gf_bs_read_int_log(bs, 1, ""output_flag_present_flag""); pps->no_pic_partition_flag = gf_bs_read_int_log(bs, 1, ""no_pic_partition_flag""); pps->subpic_id_mapping_present_flag = gf_bs_read_int_log(bs, 1, ""subpic_id_mapping_present_flag""); u32 pps_num_subpics = 1; if (pps->subpic_id_mapping_present_flag) { u32 pps_subpic_id_len; if (!pps->no_pic_partition_flag) { pps_num_subpics = 1+gf_bs_read_ue_log(bs, ""pps_num_subpics_minus1""); } pps_subpic_id_len = 1 + gf_bs_read_ue(bs); for (i=0; i<pps_num_subpics; i++) { gf_bs_read_int_log_idx(bs, pps_subpic_id_len, ""subpic_id"", i); } } pps->single_slice_per_subpic_flag = 1; pps->num_slices_in_pic = 1; pps->num_tiles_in_pic = 0; if (!pps->no_pic_partition_flag) { u32 ctu_size = 5 + gf_bs_read_int_log(bs, 2, ""pps_log2_ctu_size_minus5""); u32 num_exp_tile_columns = 1 + gf_bs_read_ue_log(bs, ""num_exp_tile_columns_minus1""); u32 num_exp_tile_rows = 1 + gf_bs_read_ue_log(bs, ""num_exp_tile_rows_minus1""); if (num_exp_tile_columns > VVC_MAX_TILE_COLS) { GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] wrong num tile columns %d in PPS\n"", num_exp_tile_columns)); pps->sps_id=0; return -1; } if (num_exp_tile_rows > VVC_MAX_TILE_ROWS) { GF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (""[VVC] wrong num tile rows %d in PPS\n"", num_exp_tile_rows)); pps->sps_id=0; return -1; } ctu_size = 1<<ctu_size; pps->pic_width_in_ctbsY = pps->width / ctu_size; if (pps->pic_width_in_ctbsY * ctu_size < pps->width) pps->pic_width_in_ctbsY++; pps->pic_height_in_ctbsY = pps->height / ctu_size; if (pps->pic_height_in_ctbsY * ctu_size < pps->height) pps->pic_height_in_ctbsY++; u32 nb_ctb_left = pps->pic_width_in_ctbsY; pps->num_tile_cols=0; u32 nb_ctb_last=0; for (i=0; i<num_exp_tile_columns; i++) { u32 nb_ctb_width = 1 + gf_bs_read_ue_log_idx(bs, ""tile_column_width_minus1"", i); if (nb_ctb_left < nb_ctb_width) { pps->sps_id=0; return -1; } nb_ctb_left -= nb_ctb_width; pps->tile_cols_width_ctb[i] = nb_ctb_width; nb_ctb_last = nb_ctb_width; pps->num_tile_cols++; if (pps->num_tile_cols > VVC_MAX_TILE_COLS) { pps->sps_id=0; return -1; } } u32 uni_size_ctb = nb_ctb_last; while (nb_ctb_left >= uni_size_ctb) { nb_ctb_left -= uni_size_ctb; if (pps->num_tile_cols >= VVC_MAX_TILE_COLS) { pps->sps_id=0; return -1; } pps->tile_cols_width_ctb[pps->num_tile_cols] = uni_size_ctb; pps->num_tile_cols++; } if (nb_ctb_left>0) { if (pps->num_tile_cols >= VVC_MAX_TILE_COLS) { pps->sps_id=0; return -1; } pps->tile_cols_width_ctb[pps->num_tile_cols] = nb_ctb_left; pps->num_tile_cols++; } nb_ctb_left = pps->pic_height_in_ctbsY; nb_ctb_last=0; pps->num_tile_rows=0; for (i=0; i<num_exp_tile_rows; i++) { u32 nb_ctb_height = 1 + gf_bs_read_ue_log_idx(bs, ""tile_row_height_minus1"", i); if (nb_ctb_left < nb_ctb_height) { pps->sps_id=0; return -1; } nb_ctb_left -= nb_ctb_height; pps->tile_rows_height_ctb[i] = nb_ctb_height; pps->num_tile_rows++; nb_ctb_last = nb_ctb_height; if (pps->num_tile_rows > VVC_MAX_TILE_ROWS) { pps->sps_id=0; return -1; } } uni_size_ctb = nb_ctb_last; while (nb_ctb_left >= uni_size_ctb) { nb_ctb_left -= uni_size_ctb; if (pps->num_tile_rows >= VVC_MAX_TILE_ROWS) { pps->sps_id=0; return -1; } pps->tile_rows_height_ctb[pps->num_tile_rows] = uni_size_ctb; pps->num_tile_rows++; } if (nb_ctb_left>0) { if (pps->num_tile_rows >= VVC_MAX_TILE_ROWS) { pps->sps_id=0; return -1; } pps->tile_rows_height_ctb[pps->num_tile_rows] = nb_ctb_left; pps->num_tile_rows++; } pps->num_tiles_in_pic = pps->num_tile_cols * pps->num_tile_rows; pps->slice_address_len = gf_get_bit_size(pps->num_tiles_in_pic); if (pps->num_tiles_in_pic > 1) { gf_bs_read_int_log(bs, 1, ""pps_loop_filter_across_tiles_enabled_flag""); pps->rect_slice_flag = gf_bs_read_int_log(bs, 1, ""pps_rect_slice_flag""); } if (pps->rect_slice_flag) { pps->single_slice_per_subpic_flag = gf_bs_read_int_log(bs, 1, ""pps_single_slice_per_subpic_flag""); pps->num_slices_in_pic = pps_num_subpics; } if (pps->rect_slice_flag && !pps->single_slice_per_subpic_flag) { pps->num_slices_in_pic = 1 + gf_bs_read_ue_log(bs, ""pps_num_slices_in_pic_minus1""); u8 tile_idx_delta_present_flag = 0; if (pps->num_slices_in_pic > 1) { tile_idx_delta_present_flag = gf_bs_read_int_log(bs, 1, ""pps_tile_idx_delta_present_flag""); } for (i=0; i<pps->num_slices_in_pic-1; i++) { u32 SliceTopLeftTileIdx=0; u32 RowHeightVal=0; u32 slice_width_in_tiles_minus1=0; u32 slice_height_in_tiles_minus1=0; if (SliceTopLeftTileIdx % pps->num_tile_cols != pps->num_tile_cols - 1) { slice_width_in_tiles_minus1 = gf_bs_read_ue_log_idx(bs, ""pps_slice_width_in_tiles_minus1"", i); } if ( (SliceTopLeftTileIdx / pps->num_tile_cols != pps->num_tile_rows - 1) && (tile_idx_delta_present_flag || (SliceTopLeftTileIdx % pps->num_tile_cols == 0) ) ) { slice_height_in_tiles_minus1 = gf_bs_read_ue_log_idx(bs, ""pps_slice_height_in_tiles_minus1"", i); } if (!slice_width_in_tiles_minus1 && !slice_height_in_tiles_minus1 && (RowHeightVal > 1 ) ) { u32 j, num_exp_slices_in_tile = gf_bs_read_ue_log_idx(bs, ""pps_num_exp_slices_in_tile"", i); for (j=0; j<num_exp_slices_in_tile; j++) { gf_bs_read_ue_log_idx2 (bs, ""pps_exp_slice_height_in_ctus_minus1"", i, j); } } if (tile_idx_delta_present_flag && (i < pps->num_slices_in_pic)) { gf_bs_read_se_log_idx(bs, ""pps_tile_idx_delta_val"", i); } } } if (!pps->rect_slice_flag || pps->single_slice_per_subpic_flag || (pps->num_slices_in_pic > 1)) { gf_bs_read_int_log(bs, 1, ""pps_loop_filter_across_slices_enabled_flag""); } } pps->cabac_init_present_flag = gf_bs_read_int_log(bs, 1, ""pps_cabac_init_present_flag""); for (i=0; i<2; i++) { pps->num_ref_idx_default_active[i] = 1 + gf_bs_read_ue_log_idx(bs, ""pps_num_ref_idx_default_active_minus1"", i); } pps->rpl1_idx_present_flag = gf_bs_read_int_log(bs, 1, ""pps_rpl1_idx_present_flag""); pps->weighted_pred_flag = gf_bs_read_int_log(bs, 1, ""pps_weighted_pred_flag""); pps->weighted_bipred_flag = gf_bs_read_int_log(bs, 1, ""pps_weighted_bipred_flag""); if (gf_bs_read_int_log(bs, 1, ""pps_ref_wraparound_enabled_flag"")) { gf_bs_read_ue_log(bs, ""pps_pic_width_minus_wraparound_offset""); } gf_bs_read_se_log(bs, ""pps_init_qp_minus26""); pps->cu_qp_delta_enabled_flag = gf_bs_read_int_log(bs, 1, ""pps_cu_qp_delta_enabled_flag""); pps->slice_chroma_qp_offsets_present_flag = 0; pps->chroma_tool_offsets_present_flag = gf_bs_read_int_log(bs, 1, ""pps_chroma_tool_offsets_present_flag""); if (pps->chroma_tool_offsets_present_flag) { gf_bs_read_se_log(bs, ""pps_cb_qp_offset""); gf_bs_read_se_log(bs, ""pps_cr_qp_offset""); u8 joint_cbcr_qp_offset_present_flag = gf_bs_read_int_log(bs, 1, ""pps_joint_cbcr_qp_offset_present_flag""); if (joint_cbcr_qp_offset_present_flag) { gf_bs_read_se_log(bs, ""pps_joint_cbcr_qp_offset_value""); } pps->slice_chroma_qp_offsets_present_flag = gf_bs_read_int_log(bs, 1, ""pps_slice_chroma_qp_offsets_present_flag""); pps->cu_chroma_qp_offset_list_enabled_flag = gf_bs_read_int_log(bs, 1, ""pps_cu_chroma_qp_offset_list_enabled_flag""); if (pps->cu_chroma_qp_offset_list_enabled_flag) { u32 pps_chroma_qp_offset_list_len = 1 + gf_bs_read_ue_log(bs, ""pps_chroma_qp_offset_list_len_minus1""); for (i=0; i<pps_chroma_qp_offset_list_len; i++) { gf_bs_read_se_log_idx(bs, ""pps_cb_qp_offset_list"", i); gf_bs_read_se_log_idx(bs, ""pps_cr_qp_offset_list"", i); if (joint_cbcr_qp_offset_present_flag) { gf_bs_read_se_log_idx(bs, ""pps_joint_cbcr_qp_offset_list"", i); } } } } pps->dbf_info_in_ph_flag = 0; pps->deblocking_filter_disabled_flag = 0; pps->deblocking_filter_override_enabled_flag = 0; if (gf_bs_read_int_log(bs, 1, ""pps_deblocking_filter_control_present_flag"")) { pps->deblocking_filter_override_enabled_flag = gf_bs_read_int_log(bs, 1, ""pps_deblocking_filter_override_enabled_flag""); pps->deblocking_filter_disabled_flag = gf_bs_read_int_log(bs, 1, ""pps_deblocking_filter_disabled_flag""); if (!pps->no_pic_partition_flag && pps->deblocking_filter_override_enabled_flag) { pps->dbf_info_in_ph_flag = gf_bs_read_int_log(bs, 1, ""pps_dbf_info_in_ph_flag""); } if (!pps->deblocking_filter_disabled_flag) { gf_bs_read_se_log(bs, ""pps_luma_beta_offset_div2""); gf_bs_read_se_log(bs, ""pps_luma_tc_offset_div2""); if (pps->chroma_tool_offsets_present_flag) { gf_bs_read_se_log(bs, ""pps_cb_beta_offset_div2""); gf_bs_read_se_log(bs, ""pps_cb_tc_offset_div2""); gf_bs_read_se_log(bs, ""pps_cr_beta_offset_div2""); gf_bs_read_se_log(bs, ""pps_cr_tc_offset_div2""); } } } pps->wp_info_in_ph_flag = 0; pps->qp_delta_info_in_ph_flag = 0; pps->sao_info_in_ph_flag = 0; if (!pps->no_pic_partition_flag) { pps->rpl_info_in_ph_flag = gf_bs_read_int_log(bs, 1, ""pps_rpl_info_in_ph_flag""); pps->sao_info_in_ph_flag = gf_bs_read_int_log(bs, 1, ""pps_sao_info_in_ph_flag""); pps->alf_info_in_ph_flag = gf_bs_read_int_log(bs, 1, ""pps_alf_info_in_ph_flag""); if ( (pps->weighted_pred_flag || pps->weighted_bipred_flag) && pps->rpl_info_in_ph_flag) { pps->wp_info_in_ph_flag = gf_bs_read_int_log(bs, 1, ""pps_wp_info_in_ph_flag""); } pps->qp_delta_info_in_ph_flag = gf_bs_read_int_log(bs, 1, ""pps_qp_delta_info_in_ph_flag""); } pps->picture_header_extension_present_flag = gf_bs_read_int_log(bs, 1, ""pps_picture_header_extension_present_flag""); pps->slice_header_extension_present_flag = gf_bs_read_int_log(bs, 1, ""pps_slice_header_extension_present_flag""); if (gf_bs_read_int_log(bs, 1, ""pps_extension_flag"")) { } return pps_id; }
Description: GPAC MP4box 2.1-DEV-rev593-g007bf61a0 is vulnerable to Buffer Overflow in gf_hevc_read_sps_bs_internal function of media_tools/av_parsers.c:8261
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void ahci_uninit(AHCIState *s) { g_free(s->dev); }
Description: Memory leak in QEMU (aka Quick Emulator), when built with IDE AHCI Emulation support, allows local guest OS privileged users to cause a denial of service (memory consumption) by repeatedly hot-unplugging the AHCI device.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void ConnectionManagerImpl::ActiveStream::decodeTrailers(RequestTrailerMapPtr&& trailers) { ENVOY_STREAM_LOG(debug, ""request trailers complete:\n{}"", *this, *trailers); ScopeTrackerScopeState scope(this, connection_manager_.read_callbacks_->connection().dispatcher()); resetIdleTimer(); ASSERT(!request_trailers_); request_trailers_ = std::move(trailers); if (!validateTrailers()) { ENVOY_STREAM_LOG(debug, ""request trailers validation failed:\n{}"", *this, *request_trailers_); return; } maybeEndDecode(true); filter_manager_.decodeTrailers(*request_trailers_); }
Description: The HTTP/2 protocol allows a denial of service (server resource consumption) because request cancellation can reset many streams quickly, as exploited in the wild in August through October 2023.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int nghttp2_session_on_rst_stream_received(nghttp2_session *session, nghttp2_frame *frame) { int rv; nghttp2_stream *stream; if (frame->hd.stream_id == 0) { return session_handle_invalid_connection(session, frame, NGHTTP2_ERR_PROTO, ""RST_STREAM: stream_id == 0""); } if (session_detect_idle_stream(session, frame->hd.stream_id)) { return session_handle_invalid_connection(session, frame, NGHTTP2_ERR_PROTO, ""RST_STREAM: stream in idle""); } stream = nghttp2_session_get_stream(session, frame->hd.stream_id); if (stream) { nghttp2_stream_shutdown(stream, NGHTTP2_SHUT_RD); } rv = session_call_on_frame_received(session, frame); if (rv != 0) { return rv; } rv = nghttp2_session_close_stream(session, frame->hd.stream_id, frame->rst_stream.error_code); if (nghttp2_is_fatal(rv)) { return rv; } return 0; }
Description: The HTTP/2 protocol allows a denial of service (server resource consumption) because request cancellation can reset many streams quickly, as exploited in the wild in August through October 2023.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int x_catch_free_colors(Display * dpy, XErrorEvent * err) { if (err->request_code == X_FreeColors) return 0; return x_error_handler.orighandler(dpy, err); }
Description: In Artifex Ghostscript before 9.24, attackers able to supply crafted PostScript files to the builtin PDF14 converter could use a use-after-free in copydevice handling to crash the interpreter or possibly have unspecified other impact.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void ImageDocumentParser::appendBytes(const char* data, size_t length) { if (!length) return; LocalFrame* frame = document()->frame(); Settings* settings = frame->settings(); if (!frame->loader().client()->allowImage(!settings || settings->imagesEnabled(), document()->url())) return; if (document()->cachedImage()) { RELEASE_ASSERT(length <= std::numeric_limits<unsigned>::max()); document()->cachedImage()->appendData(data, length); } if (document()) document()->imageUpdated(); }
Description: Google Chrome before 50.0.2661.75 does not properly consider that frame removal may occur during callback execution, which allows remote attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted extension.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int oidc_request_post_preserved_restore(request_rec *r, const char *original_url) { oidc_debug(r, ""enter: original_url=%s"", original_url); const char *method = ""postOnLoad""; const char *script = apr_psprintf(r->pool, ""    <script type=\""text/javascript\"">\n"" ""      function str_decode(string) {\n"" ""        try {\n"" ""          result = decodeURIComponent(string);\n"" ""        } catch (e) {\n"" ""          result =  unescape(string);\n"" ""        }\n"" ""        return result;\n"" ""      }\n"" ""      function %s() {\n"" ""        var mod_auth_openidc_preserve_post_params = JSON.parse(sessionStorage.getItem('mod_auth_openidc_preserve_post_params'));\n"" "" sessionStorage.removeItem('mod_auth_openidc_preserve_post_params');\n"" ""        for (var key in mod_auth_openidc_preserve_post_params) {\n"" ""          var input = document.createElement(\""input\"");\n"" ""          input.name = str_decode(key);\n"" ""          input.value = str_decode(mod_auth_openidc_preserve_post_params[key]);\n"" ""          input.type = \""hidden\"";\n"" ""          document.forms[0].appendChild(input);\n"" ""        }\n"" ""        document.forms[0].action = '%s';\n"" ""        document.forms[0].submit();\n"" ""      }\n"" ""    </script>\n"", method, original_url); const char *body = ""    <p>Restoring...</p>\n"" ""    <form method=\""post\""></form>\n""; return oidc_util_html_send(r, ""Restoring..."", script, method, body, OK); }
Description: mod_auth_openidc is an authentication/authorization module for the Apache 2.x HTTP server that functions as an OpenID Connect Relying Party, authenticating users against an OpenID Connect Provider. In mod_auth_openidc before version 2.4.9, there is an XSS vulnerability in when using `OIDCPreservePost On`.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int gs_main_finit(gs_main_instance * minst, int exit_status, int code) { i_ctx_t *i_ctx_p = minst->i_ctx_p; gs_dual_memory_t dmem = {0}; int exit_code; ref error_object; char *tempnames; tempnames = gs_main_tempnames(minst); gs_finit_push_systemdict(i_ctx_p); if (minst->init_done >= 2) { gs_main_run_string(minst, ""/BGPrint /GetDeviceParam .special_op \ {{ <</BeginPage {pop} /EndPage {pop pop               /BGPrint false /NumRenderingThreads 0>> setpagedevice} if} if \ serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse \ .systemvar exec"", 0 , &exit_code, &error_object); } if (minst->init_done >= 2) { int code = 0; if (idmemory->reclaim != 0) { code = interp_reclaim(&minst->i_ctx_p, avm_global); if (code < 0) { ref error_name; if (tempnames) free(tempnames); if (gs_errorname(i_ctx_p, code, &error_name) >= 0) { char err_str[32] = {0}; name_string_ref(imemory, &error_name, &error_name); memcpy(err_str, error_name.value.const_bytes, r_size(&error_name)); emprintf2(imemory, ""ERROR: %s (%d) reclaiming the memory while the interpreter finalization.\n"", err_str, code); } else { emprintf1(imemory, ""UNKNOWN ERROR %d reclaiming the memory while the interpreter finalization.\n"", code); } #ifdef MEMENTO_SQUEEZE_BUILD if (code != gs_error_VMerror ) return gs_error_Fatal; #else return gs_error_Fatal; #endif } i_ctx_p = minst->i_ctx_p;  } if (i_ctx_p->pgs != NULL && i_ctx_p->pgs->device != NULL) { gx_device *pdev = i_ctx_p->pgs->device; const char * dname = pdev->dname; rc_adjust(pdev, 1, ""gs_main_finit""); gs_main_run_string(minst, "".uninstallpagedevice serverdict \ /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemvar exec"", 0 , &exit_code, &error_object); code = gs_closedevice(pdev); if (code < 0) { ref error_name; if (gs_errorname(i_ctx_p, code, &error_name) >= 0) { char err_str[32] = {0}; name_string_ref(imemory, &error_name, &error_name); memcpy(err_str, error_name.value.const_bytes, r_size(&error_name)); emprintf3(imemory, ""ERROR: %s (%d) on closing %s device.\n"", err_str, code, dname); } else { emprintf2(imemory, ""UNKNOWN ERROR %d closing %s device.\n"", code, dname); } } rc_decrement(pdev, ""gs_main_finit"");                 if (exit_status == 0 || exit_status == gs_error_Quit) exit_status = code; } gs_main_run_string(minst, ""(%stdout) (w) file closefile (%stderr) (w) file closefile \ serverdict /.jobsavelevel get 0 eq {/quit} {/stop} ifelse .systemexec \ systemdict /savedinitialgstate .forceundef"", 0 , &exit_code, &error_object); } gp_readline_finit(minst->readline_data); i_ctx_p = minst->i_ctx_p; if (gs_debug_c(':')) { print_resource_usage(minst, &gs_imemory, ""Final""); dmprintf1(minst->heap, ""%% Exiting instance 0x%p\n"", minst); } if (minst->init_done >= 1) { gs_memory_t *mem_raw = i_ctx_p->memory.current->non_gc_memory; i_plugin_holder *h = i_ctx_p->plugin_list; dmem = *idmemory; code = alloc_restore_all(i_ctx_p); if (code < 0) emprintf1(mem_raw, ""ERROR %d while the final restore. See gs/psi/ierrors.h for code explanation.\n"", code); i_iodev_finit(&dmem); i_plugin_finit(mem_raw, h); } if (minst->heap->gs_lib_ctx->fstdout2 && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstdout) && (minst->heap->gs_lib_ctx->fstdout2 != minst->heap->gs_lib_ctx->fstderr)) { fclose(minst->heap->gs_lib_ctx->fstdout2); minst->heap->gs_lib_ctx->fstdout2 = (FILE *)NULL; } minst->heap->gs_lib_ctx->stdout_is_redirected = 0; minst->heap->gs_lib_ctx->stdout_to_stderr = 0; if (tempnames) { char *p = tempnames; while (*p) { unlink(p); p += strlen(p) + 1; } free(tempnames); } gs_lib_finit(exit_status, code, minst->heap); gs_free_object(minst->heap, minst->lib_path.container.value.refs, ""lib_path array""); ialloc_finit(&dmem); return exit_status; }
Description: In Artifex Ghostscript before 9.24, attackers able to supply crafted PostScript files could use incorrect free logic in pagedevice replacement to crash the interpreter.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: char * IceGenerateMagicCookie ( int len ) { char    *auth; #ifndef HAVE_ARC4RANDOM_BUF long    ldata[2]; int    seed; int    value; int    i; #endif if ((auth = malloc (len + 1)) == NULL) return (NULL); #ifdef HAVE_ARC4RANDOM_BUF arc4random_buf(auth, len); #else #ifdef ITIMER_REAL { struct timeval  now; X_GETTIMEOFDAY (&now); ldata[0] = now.tv_sec; ldata[1] = now.tv_usec; } #else { long    time (); ldata[0] = time ((long *) 0); ldata[1] = getpid (); } #endif seed = (ldata[0]) + (ldata[1] << 16); srand (seed); for (i = 0; i < len; i++) { value = rand (); auth[i] = value & 0xff; } #endif auth[len] = '\0'; return (auth); }
Description: It was discovered that libICE before 1.0.9-8 used a weak entropy to generate keys. A local attacker could potentially use this flaw for session hijacking using the information available from the process list.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void retreat (octet_iterator& it, distance_type n, octet_iterator start) { for (distance_type i = 0; i < n; ++i) utf8::prior(it, start); }
Description: In LibSass prior to 3.5.5, the function handle_error in sass_context.cpp allows attackers to cause a denial-of-service resulting from a heap-based buffer over-read via a crafted sass file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int proc_show_options(struct seq_file *seq, struct dentry *root) { return 0; }
Description: fs/proc/base.c in the Linux kernel through 3.1 allows local users to obtain sensitive keystroke information via access to /proc/interrupts.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception) { FILE *file; Image *image, *next_image, *pwp_image; ImageInfo *read_info; int c, unique_file; MagickBooleanType status; register Image *p; register ssize_t i; size_t filesize, length; ssize_t count; unsigned char magick[MagickPathExtent]; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); pwp_image=AcquireImage(image_info,exception); image=pwp_image; status=OpenBlob(image_info,pwp_image,ReadBinaryBlobMode,exception); if (status == MagickFalse) return((Image *) NULL); count=ReadBlob(pwp_image,5,magick); if ((count != 5) || (LocaleNCompare((char *) magick,""SFW95"",5) != 0)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); read_info=CloneImageInfo(image_info); (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL, (void *) NULL); SetImageInfoBlob(read_info,(void *) NULL,0); unique_file=AcquireUniqueFileResource(read_info->filename); for ( ; ; ) { for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image)) { for (i=0; i < 17; i++) magick[i]=magick[i+1]; magick[17]=(unsigned char) c; if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) == 0) break; } if (c == EOF) break; if (LocaleNCompare((char *) (magick+12),""SFW94A"",6) != 0) { (void) RelinquishUniqueFileResource(read_info->filename); ThrowReaderException(CorruptImageError,""ImproperImageHeader""); } file=(FILE *) NULL; if (unique_file != -1) file=fdopen(unique_file,""wb""); if ((unique_file == -1) || (file == (FILE *) NULL)) { (void) RelinquishUniqueFileResource(read_info->filename); ThrowFileException(exception,FileOpenError,""UnableToWriteFile"", image->filename); image=DestroyImageList(image); return((Image *) NULL); } length=fwrite(""SFW94A"",1,6,file); (void) length; filesize=65535UL*magick[2]+256L*magick[1]+magick[0]; for (i=0; i < (ssize_t) filesize; i++) { c=ReadBlobByte(pwp_image); (void) fputc(c,file); } (void) fclose(file); next_image=ReadImage(read_info,exception); if (next_image == (Image *) NULL) break; (void) FormatLocaleString(next_image->filename,MagickPathExtent, ""slide_%02ld.sfw"",(long) next_image->scene); if (image == (Image *) NULL) image=next_image; else { for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ; next_image->previous=p; next_image->scene=p->scene+1; p->next=next_image; } if (image_info->number_scenes != 0) if (next_image->scene >= (image_info->scene+image_info->number_scenes-1)) break; status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image), GetBlobSize(pwp_image)); if (status == MagickFalse) break; } if (unique_file != -1) (void) close(unique_file); (void) RelinquishUniqueFileResource(read_info->filename); read_info=DestroyImageInfo(read_info); (void) CloseBlob(pwp_image); pwp_image=DestroyImage(pwp_image); if (EOFBlob(image) != MagickFalse) { char *message; message=GetExceptionMessage(errno); (void) ThrowMagickException(exception,GetMagickModule(),CorruptImageError, ""UnexpectedEndOfFile"",""`%s': %s"",image->filename,message); message=DestroyString(message); } (void) CloseBlob(image); return(GetFirstImageInList(image)); }
Description: Use-after-free vulnerability in the ReadPWPImage function in coders/pwp.c in ImageMagick 6.9.5-5 allows remote attackers to cause a denial of service (application crash) or have other unspecified impact via a crafted file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void gdCtxPrintf(gdIOCtx * out, const char *format, ...) { char buf[4096]; int len; va_list args; va_start(args, format); len = vsnprintf(buf, sizeof(buf)-1, format, args); va_end(args); out->putBuf(out, buf, len); }
Description: gd_xbm.c in the GD Graphics Library (aka libgd) before 2.2.0, as used in certain custom PHP 5.5.x configurations, allows context-dependent attackers to obtain sensitive information from process memory or cause a denial of service (stack-based buffer under-read and application crash) via a long name.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int aiptek_probe(struct usb_interface *intf, const struct usb_device_id *id) { struct usb_device *usbdev = interface_to_usbdev(intf); struct usb_endpoint_descriptor *endpoint; struct aiptek *aiptek; struct input_dev *inputdev; int i; int speeds[] = { 0, AIPTEK_PROGRAMMABLE_DELAY_50, AIPTEK_PROGRAMMABLE_DELAY_400, AIPTEK_PROGRAMMABLE_DELAY_25, AIPTEK_PROGRAMMABLE_DELAY_100, AIPTEK_PROGRAMMABLE_DELAY_200, AIPTEK_PROGRAMMABLE_DELAY_300 }; int err = -ENOMEM; speeds[0] = programmableDelay; aiptek = kzalloc(sizeof(struct aiptek), GFP_KERNEL); inputdev = input_allocate_device(); if (!aiptek || !inputdev) { dev_warn(&intf->dev, ""cannot allocate memory or input device\n""); goto fail1; } aiptek->data = usb_alloc_coherent(usbdev, AIPTEK_PACKET_LENGTH, GFP_ATOMIC, &aiptek->data_dma); if (!aiptek->data) { dev_warn(&intf->dev, ""cannot allocate usb buffer\n""); goto fail1; } aiptek->urb = usb_alloc_urb(0, GFP_KERNEL); if (!aiptek->urb) { dev_warn(&intf->dev, ""cannot allocate urb\n""); goto fail2; } aiptek->inputdev = inputdev; aiptek->usbdev = usbdev; aiptek->intf = intf; aiptek->ifnum = intf->altsetting[0].desc.bInterfaceNumber; aiptek->inDelay = 0; aiptek->endDelay = 0; aiptek->previousJitterable = 0; aiptek->lastMacro = -1; aiptek->curSetting.pointerMode = AIPTEK_POINTER_EITHER_MODE; aiptek->curSetting.coordinateMode = AIPTEK_COORDINATE_ABSOLUTE_MODE; aiptek->curSetting.toolMode = AIPTEK_TOOL_BUTTON_PEN_MODE; aiptek->curSetting.xTilt = AIPTEK_TILT_DISABLE; aiptek->curSetting.yTilt = AIPTEK_TILT_DISABLE; aiptek->curSetting.mouseButtonLeft = AIPTEK_MOUSE_LEFT_BUTTON; aiptek->curSetting.mouseButtonMiddle = AIPTEK_MOUSE_MIDDLE_BUTTON; aiptek->curSetting.mouseButtonRight = AIPTEK_MOUSE_RIGHT_BUTTON; aiptek->curSetting.stylusButtonUpper = AIPTEK_STYLUS_UPPER_BUTTON; aiptek->curSetting.stylusButtonLower = AIPTEK_STYLUS_LOWER_BUTTON; aiptek->curSetting.jitterDelay = jitterDelay; aiptek->curSetting.programmableDelay = programmableDelay; aiptek->newSetting = aiptek->curSetting; usb_make_path(usbdev, aiptek->features.usbPath, sizeof(aiptek->features.usbPath)); strlcat(aiptek->features.usbPath, ""/input0"", sizeof(aiptek->features.usbPath)); inputdev->name = ""Aiptek""; inputdev->phys = aiptek->features.usbPath; usb_to_input_id(usbdev, &inputdev->id); inputdev->dev.parent = &intf->dev; input_set_drvdata(inputdev, aiptek); inputdev->open = aiptek_open; inputdev->close = aiptek_close; for (i = 0; i < ARRAY_SIZE(eventTypes); ++i) __set_bit(eventTypes[i], inputdev->evbit); for (i = 0; i < ARRAY_SIZE(absEvents); ++i) __set_bit(absEvents[i], inputdev->absbit); for (i = 0; i < ARRAY_SIZE(relEvents); ++i) __set_bit(relEvents[i], inputdev->relbit); __set_bit(MSC_SERIAL, inputdev->mscbit); for (i = 0; i < ARRAY_SIZE(buttonEvents); ++i) __set_bit(buttonEvents[i], inputdev->keybit); for (i = 0; i < ARRAY_SIZE(macroKeyEvents); ++i) __set_bit(macroKeyEvents[i], inputdev->keybit); input_set_abs_params(inputdev, ABS_X, 0, 2999, 0, 0); input_set_abs_params(inputdev, ABS_Y, 0, 2249, 0, 0); input_set_abs_params(inputdev, ABS_PRESSURE, 0, 511, 0, 0); input_set_abs_params(inputdev, ABS_TILT_X, AIPTEK_TILT_MIN, AIPTEK_TILT_MAX, 0, 0); input_set_abs_params(inputdev, ABS_TILT_Y, AIPTEK_TILT_MIN, AIPTEK_TILT_MAX, 0, 0); input_set_abs_params(inputdev, ABS_WHEEL, AIPTEK_WHEEL_MIN, AIPTEK_WHEEL_MAX - 1, 0, 0); endpoint = &intf->altsetting[0].endpoint[0].desc; usb_fill_int_urb(aiptek->urb, aiptek->usbdev, usb_rcvintpipe(aiptek->usbdev, endpoint->bEndpointAddress), aiptek->data, 8, aiptek_irq, aiptek, endpoint->bInterval); aiptek->urb->transfer_dma = aiptek->data_dma; aiptek->urb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP; for (i = 0; i < ARRAY_SIZE(speeds); ++i) { aiptek->curSetting.programmableDelay = speeds[i]; (void)aiptek_program_tablet(aiptek); if (input_abs_get_max(aiptek->inputdev, ABS_X) > 0) { dev_info(&intf->dev, ""Aiptek using %d ms programming speed\n"", aiptek->curSetting.programmableDelay); break; } } if (i == ARRAY_SIZE(speeds)) { dev_info(&intf->dev, ""Aiptek tried all speeds, no sane response\n""); goto fail3; } usb_set_intfdata(intf, aiptek); err = sysfs_create_group(&intf->dev.kobj, &aiptek_attribute_group); if (err) { dev_warn(&intf->dev, ""cannot create sysfs group err: %d\n"", err); goto fail3; } err = input_register_device(aiptek->inputdev); if (err) { dev_warn(&intf->dev, ""input_register_device returned err: %d\n"", err); goto fail4; } return 0; fail4:sysfs_remove_group(&intf->dev.kobj, &aiptek_attribute_group); fail3: usb_free_urb(aiptek->urb); fail2:usb_free_coherent(usbdev, AIPTEK_PACKET_LENGTH, aiptek->data, aiptek->data_dma); fail1: usb_set_intfdata(intf, NULL); input_free_device(inputdev); kfree(aiptek); return err; }
Description: The aiptek_probe function in drivers/input/tablet/aiptek.c in the Linux kernel before 4.4 allows physically proximate attackers to cause a denial of service (NULL pointer dereference and system crash) via a crafted USB device that lacks endpoints.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool WideToCharMap(const wchar *Src,char *Dest,size_t DestSize,bool &Success) { if (wcschr(Src,(wchar)MappedStringMark)==NULL) return false; Success=true; uint SrcPos=0,DestPos=0; while (Src[SrcPos]!=0 && DestPos<DestSize-MB_CUR_MAX) { if (uint(Src[SrcPos])==MappedStringMark) { SrcPos++; continue; } if (uint(Src[SrcPos])>=MapAreaStart+0x80 && uint(Src[SrcPos])<MapAreaStart+0x100) Dest[DestPos++]=char(uint(Src[SrcPos++])-MapAreaStart); else { mbstate_t ps; memset(&ps,0,sizeof(ps)); if (wcrtomb(Dest+DestPos,Src[SrcPos],&ps)==-1) { Dest[DestPos]='_'; Success=false; } SrcPos++; memset(&ps,0,sizeof(ps)); int Length=mbrlen(Dest+DestPos,MB_CUR_MAX,&ps); DestPos+=Max(Length,1); } } Dest[Min(DestPos,DestSize-1)]=0; return true; }
Description: UnRAR 5.6.1.2 and 5.6.1.3 has a heap-based buffer overflow in Unpack::CopyString (called from Unpack::Unpack5 and CmdExtract::ExtractCurrentFile).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void llc_conn_handler(struct llc_sap *sap, struct sk_buff *skb) { struct llc_addr saddr, daddr; struct sock *sk; llc_pdu_decode_sa(skb, saddr.mac); llc_pdu_decode_ssap(skb, &saddr.lsap); llc_pdu_decode_da(skb, daddr.mac); llc_pdu_decode_dsap(skb, &daddr.lsap); sk = __llc_lookup(sap, &saddr, &daddr); if (!sk) goto drop; bh_lock_sock(sk); if (unlikely(sk->sk_state == TCP_LISTEN)) { struct sock *newsk = llc_create_incoming_sock(sk, skb->dev, &saddr, &daddr); if (!newsk) goto drop_unlock; skb_set_owner_r(skb, newsk); } else { skb->sk = sk; } if (!sock_owned_by_user(sk)) llc_conn_rcv(sk, skb); else { dprintk(""%s: adding to backlog...\n"", __func__); llc_set_backlog_type(skb, LLC_PACKET); if (sk_add_backlog(sk, skb, sk->sk_rcvbuf)) goto drop_unlock; } out: bh_unlock_sock(sk); sock_put(sk); return; drop: kfree_skb(skb); return; drop_unlock: kfree_skb(skb); goto out; }
Description: The LLC subsystem in the Linux kernel before 4.9.13 does not ensure that a certain destructor exists in required circumstances, which allows local users to cause a denial of service (BUG_ON) or possibly have unspecified other impact via crafted system calls.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void CleanNode( TidyDocImpl* doc, Node *node ) { Node *child, *next; if (node->content) { for (child = node->content; child != NULL; child = next) { next = child->next; if (TY_(nodeIsElement)(child)) { if (nodeIsSTYLE(child)) TY_(DiscardElement)(doc, child); if (nodeIsP(child) && !child->content) TY_(DiscardElement)(doc, child); else if (nodeIsSPAN(child)) DiscardContainer( doc, child, &next); else if (nodeIsA(child) && !child->content) { AttVal *id = TY_(GetAttrByName)( child, ""name"" ); if (!id) id = TY_(GetAttrByName)( child, ""id"" ); if (id) TY_(RepairAttrValue)( doc, child->parent, ""id"", id->value ); TY_(DiscardElement)(doc, child); } else { if (child->attributes) TY_(DropAttrByName)( doc, child, ""class"" ); CleanNode(doc, child); } } } } }
Description: An issue in HTACG HTML Tidy v5.7.28 allows attacker to execute arbitrary code via the -g option of the CleanNode() function in gdoc.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static struct property *dlpar_parse_cc_property(struct cc_workarea *ccwa) { struct property *prop; char *name; char *value; prop = kzalloc(sizeof(*prop), GFP_KERNEL); if (!prop) return NULL; name = (char *)ccwa + be32_to_cpu(ccwa->name_offset); prop->name = kstrdup(name, GFP_KERNEL); prop->length = be32_to_cpu(ccwa->prop_length); value = (char *)ccwa + be32_to_cpu(ccwa->prop_offset); prop->value = kmemdup(value, prop->length, GFP_KERNEL); if (!prop->value) { dlpar_free_cc_property(prop); return NULL; } return prop; }
Description: An issue was discovered in dlpar_parse_cc_property in arch/powerpc/platforms/pseries/dlpar.c in the Linux kernel through 5.1.6. There is an unchecked kstrdup of prop->name, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: inline bool ResolveAxis(const int num_dims, const int* axis, const int64_t num_axis, int* out_axis, int* out_num_axis) { *out_num_axis = 0;      if (num_dims == 0) { return true; } for (int64_t idx = 0; idx < num_axis; ++idx) { int current = axis[idx] < 0 ? (axis[idx] + num_dims) : axis[idx]; TFLITE_DCHECK(current >= 0 && current < num_dims); bool is_dup = false; for (int j = 0; j < *out_num_axis; ++j) { if (out_axis[j] == current) { is_dup = true; break; } } if (!is_dup) { out_axis[*out_num_axis] = current; *out_num_axis += 1; } } return true; }
Description: In tensorflow-lite before versions 1.15.4, 2.0.3, 2.1.2, 2.2.1 and 2.3.1, to mimic Python's indexing with negative values, TFLite uses `ResolveAxis` to convert negative values to positive indices. However, the only check that the converted index is now valid is only present in debug builds. If the `DCHECK` does not trigger, then code execution moves ahead with a negative index. This, in turn, results in accessing data out of bounds which results in segfaults and/or data corruption. The issue is patched in commit 2d88f470dea2671b430884260f3626b1fe99830a, and is released in TensorFlow versions 1.15.4, 2.0.3, 2.1.2, 2.2.1, or 2.3.1.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int WebObjects_translate(request_rec *r) { WebObjects_config *wc; WOURLComponents url; WOURLError urlerr; wc = (WebObjects_config *)ap_get_module_config(r->server->module_config, &WebObjects_module); if (strncmp(wc->WebObjects_alias, r->uri, strlen(wc->WebObjects_alias)) == 0) { url = WOURLComponents_Initializer; urlerr = WOParseApplicationName(&url, r->uri); if (urlerr != WOURLOK && !((urlerr == WOURLInvalidApplicationName) && ac_authorizeAppListing(&url))) { return DECLINED; } if (!adaptorEnabled) { WOLog(WO_ERR, ""WebObjects_translate(): declining request due to initialization failure""); return DECLINED; } r->handler = (char *)ap_pstrdup(r->pool, WEBOBJECTS); return OK; } return DECLINED; }
Description: Project Wonder WebObjects 1.0 through 5.4.3 is vulnerable to Arbitrary HTTP Header injection and URL- or Header-based XSS reflection in all web-server adaptor interfaces.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int cmndlist_matches(const struct sudoers_parse_tree *parse_tree, const struct member_list *list, const char *runchroot, struct cmnd_info *info) { struct member *m; int matched = UNSPEC; debug_decl(cmndlist_matches, SUDOERS_DEBUG_MATCH); TAILQ_FOREACH_REVERSE(m, list, member_list, entries) { matched = cmnd_matches(parse_tree, m, runchroot, info); if (matched != UNSPEC) break; } debug_return_int(matched); }
Description: Sudo before 1.9.15 might allow row hammer attacks (for authentication bypass or privilege escalation) because application logic sometimes is based on not equaling an error value (instead of equaling a success value), and because the values do not resist flips of a single bit.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static ssize_t do_rbd_add(struct bus_type *bus, const char *buf, size_t count) { struct rbd_device *rbd_dev = NULL; struct ceph_options *ceph_opts = NULL; struct rbd_options *rbd_opts = NULL; struct rbd_spec *spec = NULL; struct rbd_client *rbdc; int rc; if (!try_module_get(THIS_MODULE)) return -ENODEV; rc = rbd_add_parse_args(buf, &ceph_opts, &rbd_opts, &spec); if (rc < 0) goto out; rbdc = rbd_get_client(ceph_opts); if (IS_ERR(rbdc)) { rc = PTR_ERR(rbdc); goto err_out_args; } rc = ceph_pg_poolid_by_name(rbdc->client->osdc.osdmap, spec->pool_name); if (rc < 0) { if (rc == -ENOENT) pr_info(""pool %s does not exist\n"", spec->pool_name); goto err_out_client; } spec->pool_id = (u64)rc; rbd_dev = rbd_dev_create(rbdc, spec, rbd_opts); if (!rbd_dev) { rc = -ENOMEM; goto err_out_client; } rbdc = NULL; spec = NULL; rbd_opts = NULL; if (rbd_dev->opts->read_only || strcmp(rbd_dev->spec->snap_name, RBD_SNAP_HEAD_NAME)) __set_bit(RBD_DEV_FLAG_READONLY, &rbd_dev->flags); rbd_dev->config_info = kstrdup(buf, GFP_KERNEL); if (!rbd_dev->config_info) { rc = -ENOMEM; goto err_out_rbd_dev; } rc = rbd_dev_image_probe(rbd_dev, 0); if (rc < 0) goto err_out_rbd_dev; if (rbd_dev->opts->alloc_size > rbd_dev->layout.object_size) { rbd_warn(rbd_dev, ""alloc_size adjusted to %u"", rbd_dev->layout.object_size); rbd_dev->opts->alloc_size = rbd_dev->layout.object_size; } rc = rbd_dev_device_setup(rbd_dev); if (rc) goto err_out_image_probe; rc = rbd_add_acquire_lock(rbd_dev); if (rc) goto err_out_image_lock; rc = device_add(&rbd_dev->dev); if (rc) goto err_out_image_lock; device_add_disk(&rbd_dev->dev, rbd_dev->disk, NULL); blk_put_queue(rbd_dev->disk->queue); spin_lock(&rbd_dev_list_lock); list_add_tail(&rbd_dev->node, &rbd_dev_list); spin_unlock(&rbd_dev_list_lock); pr_info(""%s: capacity %llu features 0x%llx\n"", rbd_dev->disk->disk_name, (unsigned long long)get_capacity(rbd_dev->disk) << SECTOR_SHIFT, rbd_dev->header.features); rc = count; out: module_put(THIS_MODULE); return rc; err_out_image_lock: rbd_dev_image_unlock(rbd_dev); rbd_dev_device_release(rbd_dev); err_out_image_probe: rbd_dev_image_release(rbd_dev); err_out_rbd_dev: rbd_dev_destroy(rbd_dev); err_out_client: rbd_put_client(rbdc); err_out_args: rbd_spec_put(spec); kfree(rbd_opts); goto out; }
Description: The rbd block device driver in drivers/block/rbd.c in the Linux kernel through 5.8.9 used incomplete permission checking for access to rbd devices, which could be leveraged by local attackers to map or unmap rbd block devices, aka CID-f44d04e696fe.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void cb_metrics_prometheus(mk_request_t *request, void *data) { int i; int j; int m; int len; int time_len; int start_time_len; size_t index; size_t num_metrics = 0; long now; flb_sds_t sds; flb_sds_t sds_metric; flb_sds_t tmp_sds; struct flb_sds *metric_helptxt_head; flb_sds_t metric_helptxt; size_t off = 0; struct flb_hs_buf *buf; msgpack_unpacked result; msgpack_object map; char tmp[32]; char time_str[64]; char start_time_str[64]; char* *metrics_arr; struct timeval tp; struct flb_hs *hs = data; struct flb_config *config = hs->config; buf = metrics_get_latest(); if (!buf) { mk_http_status(request, 404); mk_http_done(request); return; } buf->users++; sds = flb_sds_create_size(1024); if (!sds) { mk_http_status(request, 500); mk_http_done(request); buf->users--; return; } metric_helptxt = flb_sds_create_size(128); if (!metric_helptxt) { flb_sds_destroy(sds); mk_http_status(request, 500); mk_http_done(request); buf->users--; return; } metric_helptxt_head = FLB_SDS_HEADER(metric_helptxt); gettimeofday(&tp, NULL); now = tp.tv_sec * 1000 + tp.tv_usec / 1000; time_len = snprintf(time_str, sizeof(time_str) - 1, ""%lu"", now); start_time_len = snprintf(start_time_str, sizeof(start_time_str) - 1, ""%lu"", config->init_time); index = 0; msgpack_unpacked_init(&result); msgpack_unpack_next(&result, buf->raw_data, buf->raw_size, &off); map = result.data; for (i = 0; i < map.via.map.size; i++) { msgpack_object v = map.via.map.ptr[i].val; for (j = 0; j < v.via.map.size; j++) { msgpack_object sv = v.via.map.ptr[j].val; for (m = 0; m < sv.via.map.size; m++) { num_metrics++; } } } metrics_arr = flb_malloc(num_metrics * sizeof(char*)); for (i = 0; i < map.via.map.size; i++) { msgpack_object k; msgpack_object v; k = map.via.map.ptr[i].key; v = map.via.map.ptr[i].val; for (j = 0; j < v.via.map.size; j++) { msgpack_object sk; msgpack_object sv; sk = v.via.map.ptr[j].key; sv = v.via.map.ptr[j].val; for (m = 0; m < sv.via.map.size; m++) { msgpack_object mk; msgpack_object mv; mk = sv.via.map.ptr[m].key; mv = sv.via.map.ptr[m].val; len = snprintf(tmp, sizeof(tmp) - 1, ""%"" PRIu64 "" "", mv.via.u64); if (len < 0) { goto error; } sds_metric = flb_sds_create_size(k.via.str.size + mk.via.str.size + sk.via.str.size + len + time_len + 28); if (sds_metric == NULL) { goto error; } sds_metric = flb_sds_cat(sds_metric, ""fluentbit_"", 10); sds_metric = flb_sds_cat(sds_metric, k.via.str.ptr, k.via.str.size); sds_metric = flb_sds_cat(sds_metric, ""_"", 1); sds_metric = flb_sds_cat(sds_metric, mk.via.str.ptr, mk.via.str.size); sds_metric = flb_sds_cat(sds_metric, ""_total{name=\"""", 13); sds_metric = flb_sds_cat(sds_metric, sk.via.str.ptr, sk.via.str.size); sds_metric = flb_sds_cat(sds_metric, ""\""} "", 3); sds_metric = flb_sds_cat(sds_metric, tmp, len); sds_metric = flb_sds_cat(sds_metric, time_str, time_len); sds_metric = flb_sds_cat(sds_metric, ""\n"", 1); metrics_arr[index] = sds_metric; index++; } } } qsort(metrics_arr, num_metrics, sizeof(char *), string_cmp); tmp_sds = flb_sds_cat(sds, ""# HELP "", 7); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, metrics_arr[0], extract_metric_name_end_position(metrics_arr[0])); null_check(tmp_sds); if (!metrics_help_txt(metrics_arr[0], &metric_helptxt)) { goto error; } tmp_sds = flb_sds_cat(sds, metric_helptxt, metric_helptxt_head->len); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""# TYPE "", 7); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, metrics_arr[0], extract_metric_name_end_position(metrics_arr[0])); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, "" counter\n"", 9); null_check(tmp_sds); for (i = 0; i < num_metrics; i++) { tmp_sds = flb_sds_cat(sds, metrics_arr[i], strlen(metrics_arr[i])); null_check(tmp_sds); if ((i != num_metrics - 1) && (is_same_metric(metrics_arr[i], metrics_arr[i+1]) == 0)) { tmp_sds = flb_sds_cat(sds, ""# HELP "", 7); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, metrics_arr[i+1], extract_metric_name_end_position(metrics_arr[i+1])); null_check(tmp_sds); metric_helptxt_head->len = 0; if (!metrics_help_txt(metrics_arr[i+1], &metric_helptxt)) { goto error; } tmp_sds = flb_sds_cat(sds, metric_helptxt, metric_helptxt_head->len); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""# TYPE "", 7); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, metrics_arr[i+1], extract_metric_name_end_position(metrics_arr[i+1])); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, "" counter\n"", 9); null_check(tmp_sds); } } tmp_sds = flb_sds_cat(sds, ""# HELP process_start_time_seconds Start time of the process since unix epoch in seconds.\n"", 89); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""# TYPE process_start_time_seconds gauge\n"", 40); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""process_start_time_seconds "", 27); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, start_time_str, start_time_len); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""\n"", 1); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""# HELP fluentbit_build_info Build version information.\n"", 55); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""# TYPE fluentbit_build_info gauge\n"", 34); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""fluentbit_build_info{version=\"""", 30); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, FLB_VERSION_STR, sizeof(FLB_VERSION_STR) - 1); null_check(tmp_sds); tmp_sds = flb_sds_cat(sds, ""\"",edition=\"""", 11); null_check(tmp_sds); #ifdef FLB_ENTERPRISE tmp_sds = flb_sds_cat(sds, ""Enterprise\""} 1\n"", 15); null_check(tmp_sds); #else tmp_sds = flb_sds_cat(sds, ""Community\""} 1\n"", 14); null_check(tmp_sds); #endif msgpack_unpacked_destroy(&result); buf->users--; mk_http_status(request, 200); mk_http_header(request, ""Content-Type"", 12, PROMETHEUS_HEADER, sizeof(PROMETHEUS_HEADER) - 1); mk_http_send(request, sds, flb_sds_len(sds), NULL); for (i = 0; i < num_metrics; i++) { flb_sds_destroy(metrics_arr[i]); } flb_free(metrics_arr); flb_sds_destroy(sds); flb_sds_destroy(metric_helptxt); mk_http_done(request); return; error: mk_http_status(request, 500); mk_http_done(request); buf->users--; for (i = 0; i < index; i++) { flb_sds_destroy(metrics_arr[i]); } flb_free(metrics_arr); flb_sds_destroy(sds); flb_sds_destroy(metric_helptxt); msgpack_unpacked_destroy(&result); }
Description: Fluent Bit 1.6.10 has a NULL pointer dereference when an flb_malloc return value is not validated by flb_avro.c or http_server/api/v1/metrics.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static long evtchn_alloc_unbound(evtchn_alloc_unbound_t *alloc) { struct evtchn *chn; struct domain *d; int            port; domid_t        dom = alloc->dom; long           rc; d = rcu_lock_domain_by_any_id(dom); if ( d == NULL ) return -ESRCH; spin_lock(&d->event_lock); if ( (port = get_free_port(d)) < 0 ) ERROR_EXIT_DOM(port, d); chn = evtchn_from_port(d, port); rc = xsm_evtchn_unbound(XSM_TARGET, d, chn, alloc->remote_dom); if ( rc ) goto out; spin_lock(&chn->lock); chn->state = ECS_UNBOUND; if ( (chn->u.unbound.remote_domid = alloc->remote_dom) == DOMID_SELF ) chn->u.unbound.remote_domid = current->domain->domain_id; evtchn_port_init(d, chn); spin_unlock(&chn->lock); alloc->port = port; out: spin_unlock(&d->event_lock); rcu_unlock_domain(d); return rc; }
Description: An issue was discovered in Xen through 4.14.x. There are evtchn_reset() race conditions. Uses of EVTCHNOP_reset (potentially by a guest on itself) or XEN_DOMCTL_soft_reset (by itself covered by XSA-77) can lead to the violation of various internal assumptions. This may lead to out of bounds memory accesses or triggering of bug checks. In particular, x86 PV guests may be able to elevate their privilege to that of the host. Host and guest crashes are also possible, leading to a Denial of Service (DoS). Information leaks cannot be ruled out. All Xen versions from 4.5 onwards are vulnerable. Xen versions 4.4 and earlier are not vulnerable.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void SFS_ArrayDeref(ScriptParser *parser) { if (parser->codec->LastError) return; SFS_Expression(parser); SFS_AddString(parser, ""[""); SFS_CompoundExpression(parser); SFS_AddString(parser, ""]""); }
Description: Uncontrolled Recursion in GitHub repository gpac/gpac prior to 2.1.0-DEV.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void rxrpc_destroy_s(struct key *key) { const struct rxrpc_security *sec = key->payload.data[1]; if (sec) sec->destroy_server_key(key); }
Description: A NULL pointer dereference flaw was found in rxrpc_preparse_s in net/rxrpc/server_key.c in the Linux kernel. This flaw allows a local attacker to crash the system or leak internal kernel information.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int venc_dev::venc_output_log_buffers(const char *buffer_addr, int buffer_len) { if (!m_debug.outfile) { int size = 0; if(m_sVenc_cfg.codectype == V4L2_PIX_FMT_MPEG4) { size = snprintf(m_debug.outfile_name, PROPERTY_VALUE_MAX, ""%s/output_enc_%lu_%lu_%p.m4v"", m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this); } else if(m_sVenc_cfg.codectype == V4L2_PIX_FMT_H264) { size = snprintf(m_debug.outfile_name, PROPERTY_VALUE_MAX, ""%s/output_enc_%lu_%lu_%p.264"", m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this); } else if(m_sVenc_cfg.codectype == V4L2_PIX_FMT_HEVC) { size = snprintf(m_debug.outfile_name, PROPERTY_VALUE_MAX, ""%s/output_enc_%ld_%ld_%p.265"", m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this); } else if(m_sVenc_cfg.codectype == V4L2_PIX_FMT_H263) { size = snprintf(m_debug.outfile_name, PROPERTY_VALUE_MAX, ""%s/output_enc_%lu_%lu_%p.263"", m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this); } else if(m_sVenc_cfg.codectype == V4L2_PIX_FMT_VP8) { size = snprintf(m_debug.outfile_name, PROPERTY_VALUE_MAX, ""%s/output_enc_%lu_%lu_%p.ivf"", m_debug.log_loc, m_sVenc_cfg.input_width, m_sVenc_cfg.input_height, this); } if ((size > PROPERTY_VALUE_MAX) && (size < 0)) { DEBUG_PRINT_ERROR(""Failed to open output file: %s for logging size:%d"", m_debug.outfile_name, size); } m_debug.outfile = fopen(m_debug.outfile_name, ""ab""); if (!m_debug.outfile) { DEBUG_PRINT_ERROR(""Failed to open output file: %s for logging errno:%d"", m_debug.outfile_name, errno); m_debug.outfile_name[0] = '\0'; return -1; } } if (m_debug.outfile && buffer_len) { DEBUG_PRINT_LOW(""%s buffer_len:%d"", __func__, buffer_len); fwrite(buffer_addr, buffer_len, 1, m_debug.outfile); } return 0; }
Description: The secure-session feature in the mm-video-v4l2 venc component in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-08-01 mishandles heap pointers, which allows attackers to gain privileges via a crafted application, aka internal bug 28815329.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int io_poll_update(struct io_kiocb *req, unsigned int issue_flags) { struct io_ring_ctx *ctx = req->ctx; struct io_kiocb *preq; int ret2, ret = 0; spin_lock(&ctx->completion_lock); preq = io_poll_find(ctx, req->poll_update.old_user_data, true); if (!preq || !io_poll_disarm(preq)) { spin_unlock(&ctx->completion_lock); ret = preq ? -EALREADY : -ENOENT; goto out; } spin_unlock(&ctx->completion_lock); if (req->poll_update.update_events || req->poll_update.update_user_data) { if (req->poll_update.update_events) { preq->poll.events &= ~0xffff; preq->poll.events |= req->poll_update.events & 0xffff; preq->poll.events |= IO_POLL_UNMASK; } if (req->poll_update.update_user_data) preq->user_data = req->poll_update.new_user_data; ret2 = io_poll_add(preq, issue_flags); if (!ret2) goto out; } req_set_fail(preq); io_req_complete(preq, -ECANCELED); out: if (ret < 0) req_set_fail(req); io_req_complete(req, ret); return 0; }
Description: A use-after-free vulnerability in the Linux Kernel io_uring subsystem can be exploited to achieve local privilege escalation.

Racing a io_uring cancel poll request with a linked timeout can cause a UAF in a hrtimer.

We recommend upgrading past commit ef7dfac51d8ed961b742218f526bd589f3900a59 (4716c73b188566865bdd79c3a6709696a224ac04 for 5.10 stable and 0e388fce7aec40992eadee654193cad345d62663 for 5.15 stable).


 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int main(int argc, char *argv[]) { struct libmnt_table *tb = NULL; char **tabfiles = NULL; int direction = MNT_ITER_FORWARD; int verify = 0; int c, rc = -1, timeout = -1; int ntabfiles = 0, tabtype = 0; char *outarg = NULL; size_t i; int force_tree = 0, istree = 0; struct libscols_table *table = NULL; enum { FINDMNT_OPT_VERBOSE = CHAR_MAX + 1, FINDMNT_OPT_TREE, FINDMNT_OPT_OUTPUT_ALL, FINDMNT_OPT_PSEUDO, FINDMNT_OPT_REAL, FINDMNT_OPT_VFS_ALL, FINDMNT_OPT_SHADOWED, FINDMNT_OPT_DELETED, }; static const struct option longopts[] = { { ""all"",    no_argument,       NULL, 'A' }, { ""ascii"",    no_argument,       NULL, 'a' }, { ""bytes"",    no_argument,       NULL, 'b' }, { ""canonicalize"",   no_argument,       NULL, 'c' }, { ""deleted"",        no_argument,       NULL, FINDMNT_OPT_DELETED }, { ""direction"",    required_argument, NULL, 'd' }, { ""df"",    no_argument,       NULL, 'D' }, { ""evaluate"",    no_argument,       NULL, 'e' }, { ""first-only"",    no_argument,       NULL, 'f' }, { ""fstab"",    no_argument,       NULL, 's' }, { ""help"",    no_argument,       NULL, 'h' }, { ""invert"",    no_argument,       NULL, 'i' }, { ""json"",    no_argument,       NULL, 'J' }, { ""kernel"",    no_argument,       NULL, 'k' }, { ""list"",    no_argument,       NULL, 'l' }, { ""mountpoint"",    required_argument, NULL, 'M' }, { ""mtab"",    no_argument,       NULL, 'm' }, { ""noheadings"",    no_argument,       NULL, 'n' }, { ""notruncate"",    no_argument,       NULL, 'u' }, { ""options"",    required_argument, NULL, 'O' }, { ""output"",    required_argument, NULL, 'o' }, { ""output-all"",    no_argument,       NULL, FINDMNT_OPT_OUTPUT_ALL }, { ""poll"",    optional_argument, NULL, 'p' }, { ""pairs"",    no_argument,       NULL, 'P' }, { ""raw"",    no_argument,       NULL, 'r' }, { ""types"",    required_argument, NULL, 't' }, { ""nocanonicalize"", no_argument,       NULL, 'C' }, { ""nofsroot"",    no_argument,       NULL, 'v' }, { ""submounts"",    no_argument,       NULL, 'R' }, { ""source"",    required_argument, NULL, 'S' }, { ""tab-file"",    required_argument, NULL, 'F' }, { ""task"",    required_argument, NULL, 'N' }, { ""target"",    required_argument, NULL, 'T' }, { ""timeout"",    required_argument, NULL, 'w' }, { ""uniq"",    no_argument,       NULL, 'U' }, { ""verify"",    no_argument,       NULL, 'x' }, { ""version"",    no_argument,       NULL, 'V' }, { ""verbose"",    no_argument,       NULL, FINDMNT_OPT_VERBOSE }, { ""tree"",    no_argument,       NULL, FINDMNT_OPT_TREE }, { ""real"",    no_argument,       NULL, FINDMNT_OPT_REAL }, { ""pseudo"",    no_argument,       NULL, FINDMNT_OPT_PSEUDO }, { ""vfs-all"",    no_argument,       NULL, FINDMNT_OPT_VFS_ALL }, { ""shadowed"",       no_argument,       NULL, FINDMNT_OPT_SHADOWED }, { NULL, 0, NULL, 0 } }; static const ul_excl_t excl[] = { { 'C', 'c'}, { 'C', 'e' }, { 'J', 'P', 'r','x' }, { 'M', 'T' }, { 'N','k','m','s' }, { 'P','l','r','x' }, { 'p','x' }, { 'm','p','s' }, { FINDMNT_OPT_PSEUDO, FINDMNT_OPT_REAL }, { 0 } }; int excl_st[ARRAY_SIZE(excl)] = UL_EXCL_STATUS_INIT; setlocale(LC_ALL, """"); bindtextdomain(PACKAGE, LOCALEDIR); textdomain(PACKAGE); close_stdout_atexit(); flags |= FL_TREE; while ((c = getopt_long(argc, argv, ""AabCcDd:ehiJfF:o:O:p::PklmM:nN:rst:uvRS:T:Uw:Vx"", longopts, NULL)) != -1) { err_exclusive_options(c, longopts, excl, excl_st); switch(c) { case 'A': flags |= FL_ALL; break; case 'a': flags |= FL_ASCII; break; case 'b': flags |= FL_BYTES; break; case 'C': flags |= FL_NOCACHE; break; case 'c': flags |= FL_CANONICALIZE; break; case 'D': flags &= ~FL_TREE; flags |= FL_DF; break; case 'd': if (!strcmp(optarg, ""forward"")) direction = MNT_ITER_FORWARD; else if (!strcmp(optarg, ""backward"")) direction = MNT_ITER_BACKWARD; else errx(EXIT_FAILURE, _(""unknown direction '%s'""), optarg); break; case 'e': flags |= FL_EVALUATE; break; case 'i': flags |= FL_INVERT; break; case 'J': flags |= FL_JSON; break; case 'f': flags |= FL_FIRSTONLY; break; case 'F': tabfiles = append_tabfile(tabfiles, &ntabfiles, optarg); break; case 'u': disable_columns_truncate(); break; case 'o': outarg = optarg; break; case FINDMNT_OPT_OUTPUT_ALL: for (ncolumns = 0; ncolumns < ARRAY_SIZE(infos); ncolumns++) { if (is_tabdiff_column(ncolumns)) continue; columns[ncolumns] = ncolumns; } break; case 'O': set_match(COL_OPTIONS, optarg); break; case 'p': if (optarg) { nactions = string_to_idarray(optarg, actions, ARRAY_SIZE(actions), poll_action_name_to_id); if (nactions < 0) exit(EXIT_FAILURE); } flags |= FL_POLL; flags &= ~FL_TREE; break; case 'P': flags |= FL_EXPORT; flags &= ~FL_TREE; break; case 'm': tabtype = TABTYPE_MTAB; flags &= ~FL_TREE; break; case 's': tabtype = TABTYPE_FSTAB; flags &= ~FL_TREE; break; case 'k': tabtype = TABTYPE_KERNEL; break; case 't': set_match(COL_FSTYPE, optarg); break; case 'r': flags &= ~FL_TREE; flags |= FL_RAW; break; case 'l': flags &= ~FL_TREE; break; case 'n': flags |= FL_NOHEADINGS; break; case 'N': tabtype = TABTYPE_KERNEL; tabfiles = append_pid_tabfile(tabfiles, &ntabfiles, strtou32_or_err(optarg, _(""invalid TID argument""))); break; case 'v': flags |= FL_NOFSROOT; break; case 'R': flags |= FL_SUBMOUNTS; break; case 'S': set_source_match(optarg); flags |= FL_NOSWAPMATCH; break; case 'M': flags |= FL_STRICTTARGET; case 'T': set_match(COL_TARGET, optarg); flags |= FL_NOSWAPMATCH; break; case 'U': flags |= FL_UNIQ; break; case 'w': timeout = strtos32_or_err(optarg, _(""invalid timeout argument"")); break; case 'x': verify = 1; break; case FINDMNT_OPT_VERBOSE: flags |= FL_VERBOSE; break; case FINDMNT_OPT_TREE: force_tree = 1; break; case FINDMNT_OPT_PSEUDO: flags |= FL_PSEUDO; break; case FINDMNT_OPT_REAL: flags |= FL_REAL; break; case FINDMNT_OPT_VFS_ALL: flags |= FL_VFS_ALL; break; case FINDMNT_OPT_SHADOWED: flags |= FL_SHADOWED; break; case FINDMNT_OPT_DELETED: flags |= FL_DELETED; break; case 'h': usage(); case 'V': print_version(EXIT_SUCCESS); default: errtryhelp(EXIT_FAILURE); } } if (!ncolumns && (flags & FL_DF)) { add_column(columns, ncolumns++, COL_SOURCE); add_column(columns, ncolumns++, COL_FSTYPE); add_column(columns, ncolumns++, COL_SIZE); add_column(columns, ncolumns++, COL_USED); add_column(columns, ncolumns++, COL_AVAIL); add_column(columns, ncolumns++, COL_USEPERC); add_column(columns, ncolumns++, COL_TARGET); } if (!ncolumns) { if (flags & FL_POLL) add_column(columns, ncolumns++, COL_ACTION); add_column(columns, ncolumns++, COL_TARGET); add_column(columns, ncolumns++, COL_SOURCE); add_column(columns, ncolumns++, COL_FSTYPE); add_column(columns, ncolumns++, COL_OPTIONS); } if (outarg && string_add_to_idarray(outarg, columns, ARRAY_SIZE(columns), &ncolumns, column_name_to_id) < 0) return EXIT_FAILURE; if (!tabtype) tabtype = verify ? TABTYPE_FSTAB : TABTYPE_KERNEL; if ((flags & FL_POLL) && ntabfiles > 1) errx(EXIT_FAILURE, _(""--poll accepts only one file, but more specified by --tab-file"")); if (optind < argc && (get_match(COL_SOURCE) || get_match(COL_TARGET))) errx(EXIT_FAILURE, _( ""options --target and --source can't be used together "" ""with command line element that is not an option"")); if (optind < argc) set_source_match(argv[optind++]); if (optind < argc) set_match(COL_TARGET, argv[optind++]); if ((flags & FL_SUBMOUNTS) && is_listall_mode()) flags &= ~FL_SUBMOUNTS; if (!(flags & FL_SUBMOUNTS) && ((flags & FL_FIRSTONLY) || get_match(COL_TARGET) || get_match(COL_SOURCE) || get_match(COL_MAJMIN))) flags &= ~FL_TREE; if (!(flags & FL_NOSWAPMATCH) && !get_match(COL_TARGET) && get_match(COL_SOURCE)) { const char *x = get_match(COL_SOURCE); if (!strncmp(x, ""LABEL="", 6) || !strncmp(x, ""UUID="", 5) || !strncmp(x, ""PARTLABEL="", 10) || !strncmp(x, ""PARTUUID="", 9)) flags |= FL_NOSWAPMATCH; } mnt_init_debug(0); tb = parse_tabfiles(tabfiles, ntabfiles, tabtype); if (!tb) goto leave; if (tabtype == TABTYPE_MTAB && tab_is_kernel(tb)) tabtype = TABTYPE_KERNEL; istree = tab_is_tree(tb); if (istree && force_tree) flags |= FL_TREE; if ((flags & FL_TREE) && (ntabfiles > 1 || !istree)) flags &= ~FL_TREE; if (!(flags & FL_NOCACHE)) { cache = mnt_new_cache(); if (!cache) { warn(_(""failed to initialize libmount cache"")); goto leave; } mnt_table_set_cache(tb, cache); if (tabtype != TABTYPE_KERNEL) cache_set_targets(cache); } if (flags & FL_UNIQ) mnt_table_uniq_fs(tb, MNT_UNIQ_KEEPTREE, uniq_fs_target_cmp); if (verify) { rc = verify_table(tb); goto leave; } scols_init_debug(0); table = scols_new_table(); if (!table) { warn(_(""failed to allocate output table"")); goto leave; } scols_table_enable_raw(table,        !!(flags & FL_RAW)); scols_table_enable_export(table,     !!(flags & FL_EXPORT)); scols_table_enable_json(table,       !!(flags & FL_JSON)); scols_table_enable_ascii(table,      !!(flags & FL_ASCII)); scols_table_enable_noheadings(table, !!(flags & FL_NOHEADINGS)); if (flags & FL_JSON) scols_table_set_name(table, ""filesystems""); for (i = 0; i < ncolumns; i++) { struct libscols_column *cl; int fl = get_column_flags(i); int id = get_column_id(i); if (!(flags & FL_TREE)) fl &= ~SCOLS_FL_TREE; if (!(flags & FL_POLL) && is_tabdiff_column(id)) { warnx(_(""%s column is requested, but --poll "" ""is not enabled""), get_column_name(i)); goto leave; } cl = scols_table_new_column(table, get_column_name(i), get_column_whint(i), fl); if (!cl){ warn(_(""failed to allocate output column"")); goto leave; } if (fl & SCOLS_FL_WRAP) { scols_column_set_wrapfunc(cl, scols_wrapnl_chunksize, scols_wrapnl_nextchunk, NULL); scols_column_set_safechars(cl, ""\n""); } if (flags & FL_JSON) { switch (id) { case COL_SIZE: case COL_AVAIL: case COL_USED: if (!(flags & FL_BYTES)) break; case COL_ID: case COL_PARENT: case COL_FREQ: case COL_PASSNO: case COL_TID: scols_column_set_json_type(cl, SCOLS_JSON_NUMBER); break; case COL_DELETED: scols_column_set_json_type(cl, SCOLS_JSON_BOOLEAN); break; default: if (fl & SCOLS_FL_WRAP) scols_column_set_json_type(cl, SCOLS_JSON_ARRAY_STRING); else scols_column_set_json_type(cl, SCOLS_JSON_STRING); break; } } } if (flags & FL_POLL) { rc = poll_table(tb, tabfiles ? *tabfiles : _PATH_PROC_MOUNTINFO, timeout, table, direction); } else if ((flags & FL_TREE) && !(flags & FL_SUBMOUNTS)) { rc = create_treenode(table, tb, NULL, NULL); } else { rc = add_matching_lines(tb, table, direction); if (rc != 0 && tabtype == TABTYPE_KERNEL && (flags & FL_NOSWAPMATCH) && !(flags & FL_STRICTTARGET) && get_match(COL_TARGET)) { enable_extra_target_match(tb); rc = add_matching_lines(tb, table, direction); } } if (!rc && !(flags & FL_POLL)) scols_print_table(table); leave: scols_unref_table(table); mnt_unref_table(tb); mnt_unref_cache(cache); free(tabfiles); #ifdef HAVE_LIBUDEV udev_unref(udev); #endif return rc ? EXIT_FAILURE : EXIT_SUCCESS; }
Description: A logic error was found in the libmount library of util-linux in the function that allows an unprivileged user to unmount a FUSE filesystem. This flaw allows a local user on a vulnerable system to unmount other users' filesystems that are either world-writable themselves (like /tmp) or mounted in a world-writable directory. An attacker may use this flaw to cause a denial of service to applications that use the affected filesystems.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: SEL  * selReadStream(FILE  *fp) { char    *selname; char     linebuf[256]; l_int32  sy, sx, cy, cx, i, j, version, ignore; SEL     *sel; PROCNAME(""selReadStream""); if (!fp) return (SEL *)ERROR_PTR(""stream not defined"", procName, NULL); if (fscanf(fp, ""  Sel Version %d\n"", &version) != 1) return (SEL *)ERROR_PTR(""not a sel file"", procName, NULL); if (version != SEL_VERSION_NUMBER) return (SEL *)ERROR_PTR(""invalid sel version"", procName, NULL); if (fgets(linebuf, sizeof(linebuf), fp) == NULL) return (SEL *)ERROR_PTR(""error reading into linebuf"", procName, NULL); selname = stringNew(linebuf); sscanf(linebuf, ""  ------  %200s  ------"", selname); if (fscanf(fp, ""  sy = %d, sx = %d, cy = %d, cx = %d\n"", &sy, &sx, &cy, &cx) != 4) { LEPT_FREE(selname); return (SEL *)ERROR_PTR(""dimensions not read"", procName, NULL); } if ((sel = selCreate(sy, sx, selname)) == NULL) { LEPT_FREE(selname); return (SEL *)ERROR_PTR(""sel not made"", procName, NULL); } selSetOrigin(sel, cy, cx); for (i = 0; i < sy; i++) { ignore = fscanf(fp, ""    ""); for (j = 0; j < sx; j++) ignore = fscanf(fp, ""%1d"", &sel->data[i][j]); ignore = fscanf(fp, ""\n""); } ignore = fscanf(fp, ""\n""); LEPT_FREE(selname); return sel; }
Description: Leptonica before 1.80.0 allows a denial of service (application crash) via an incorrect left shift in pixConvert2To8 in pixconv.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int64_t seek_to_sector(BlockDriverState *bs, int64_t sector_num) { BDRVBochsState *s = bs->opaque; int64_t offset = sector_num * 512; int64_t extent_index, extent_offset, bitmap_offset; char bitmap_entry; extent_index = offset / s->extent_size; extent_offset = (offset % s->extent_size) / 512; if (s->catalog_bitmap[extent_index] == 0xffffffff) { return -1;  } bitmap_offset = s->data_offset + (512 * s->catalog_bitmap[extent_index] * (s->extent_blocks + s->bitmap_blocks)); if (bdrv_pread(bs->file, bitmap_offset + (extent_offset / 8), &bitmap_entry, 1) != 1) { return -1; } if (!((bitmap_entry >> (extent_offset % 8)) & 1)) { return -1;  } return bitmap_offset + (512 * (s->bitmap_blocks + extent_offset)); }
Description: Qemu before 1.6.2 block diver for the various disk image formats used by Bochs and for the QCOW version 2 format, are vulnerable to a possible crash caused by signed data types or a logic error while creating QCOW2 snapshots, which leads to incorrectly calling update_refcount() routine.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static struct nft_expr *nft_expr_init(const struct nft_ctx *ctx, const struct nlattr *nla) { struct nft_expr_info expr_info; struct nft_expr *expr; struct module *owner; int err; err = nf_tables_expr_parse(ctx, nla, &expr_info); if (err < 0) goto err1; err = -ENOMEM; expr = kzalloc(expr_info.ops->size, GFP_KERNEL_ACCOUNT); if (expr == NULL) goto err2; err = nf_tables_newexpr(ctx, &expr_info, expr); if (err < 0) goto err3; return expr; err3: kfree(expr); err2: owner = expr_info.ops->type->owner; if (expr_info.ops->type->release_ops) expr_info.ops->type->release_ops(expr_info.ops); module_put(owner); err1: return ERR_PTR(err); }
Description: net/netfilter/nf_tables_api.c in the Linux kernel through 5.18.1 allows a local user (able to create user/net namespaces) to escalate privileges to root because an incorrect NFT_STATEFUL_EXPR check leads to a use-after-free.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int xfrm_dump_policy_done(struct netlink_callback *cb) { struct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1]; struct net *net = sock_net(cb->skb->sk); xfrm_policy_walk_done(walk, net); return 0; }
Description: The XFRM dump policy implementation in net/xfrm/xfrm_user.c in the Linux kernel before 4.13.11 allows local users to gain privileges or cause a denial of service (use-after-free) via a crafted SO_RCVBUF setsockopt system call in conjunction with XFRM_MSG_GETPOLICY Netlink messages.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int fuse_unlink(struct inode *dir, struct dentry *entry) { int err; struct fuse_mount *fm = get_fuse_mount(dir); FUSE_ARGS(args); args.opcode = FUSE_UNLINK; args.nodeid = get_node_id(dir); args.in_numargs = 1; args.in_args[0].size = entry->d_name.len + 1; args.in_args[0].value = entry->d_name.name; err = fuse_simple_request(fm, &args); if (!err) { struct inode *inode = d_inode(entry); struct fuse_inode *fi = get_fuse_inode(inode); spin_lock(&fi->lock); fi->attr_version = atomic64_inc_return(&fm->fc->attr_version); if (inode->i_nlink > 0) drop_nlink(inode); spin_unlock(&fi->lock); fuse_invalidate_attr(inode); fuse_dir_changed(dir); fuse_invalidate_entry_cache(entry); fuse_update_ctime(inode); } else if (err == -EINTR) fuse_invalidate_entry(entry); return err; }
Description: An issue was discovered in the FUSE filesystem implementation in the Linux kernel before 5.10.6, aka CID-5d069dbe8aaf. fuse_do_getattr() calls make_bad_inode() in inappropriate situations, causing a system crash. NOTE: the original fix for this vulnerability was incomplete, and its incompleteness is tracked as CVE-2021-28950.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void DoCompute(const ComputeOptions& options, OpKernelContext* const context) { ModelWeights model_weights; OP_REQUIRES_OK(context, model_weights.Initialize(context)); Examples examples; OP_REQUIRES_OK( context, examples.Initialize(context, model_weights, options.num_sparse_features, options.num_sparse_features_with_values, options.num_dense_features)); const Tensor* example_state_data_t; OP_REQUIRES_OK(context, context->input(""example_state_data"", &example_state_data_t)); TensorShape expected_example_state_shape({examples.num_examples(), 4}); OP_REQUIRES(context, example_state_data_t->shape() == expected_example_state_shape, errors::InvalidArgument( ""Expected shape "", expected_example_state_shape.DebugString(), "" for example_state_data, got "", example_state_data_t->shape().DebugString())); Tensor mutable_example_state_data_t(*example_state_data_t); auto example_state_data = mutable_example_state_data_t.matrix<float>(); OP_REQUIRES_OK(context, context->set_output(""out_example_state_data"", mutable_example_state_data_t)); if (options.adaptive) { OP_REQUIRES_OK(context, examples.SampleAdaptiveProbabilities( options.num_loss_partitions, options.regularizations, model_weights, example_state_data, options.loss_updater, 1)); } else { examples.RandomShuffle(); } struct { mutex mu; Status value TF_GUARDED_BY(mu); } train_step_status; std::atomic<std::int64_t> atomic_index(-1); auto train_step = [&](const int64_t begin, const int64_t end) { for (int id = static_cast<int>(begin); id < end; ++id) { const int64_t example_index = examples.sampled_index(++atomic_index); const Example& example = examples.example(example_index); const float dual = example_state_data(example_index, 0); const float example_weight = example.example_weight(); float example_label = example.example_label(); const Status conversion_status = options.loss_updater->ConvertLabel(&example_label); if (!conversion_status.ok()) { mutex_lock l(train_step_status.mu); train_step_status.value = conversion_status; return; } const ExampleStatistics example_statistics = example.ComputeWxAndWeightedExampleNorm( options.num_loss_partitions, model_weights, options.regularizations, 1 ); const double new_dual = options.loss_updater->ComputeUpdatedDual( options.num_loss_partitions, example_label, example_weight, dual, example_statistics.wx[0], example_statistics.normalized_squared_norm); const double normalized_bounded_dual_delta = (new_dual - dual) * example_weight / options.regularizations.symmetric_l2(); model_weights.UpdateDeltaWeights( context->eigen_cpu_device(), example, std::vector<double>{normalized_bounded_dual_delta}); example_state_data(example_index, 0) = new_dual; example_state_data(example_index, 1) = options.loss_updater->ComputePrimalLoss( example_statistics.prev_wx[0], example_label, example_weight); example_state_data(example_index, 2) = options.loss_updater->ComputeDualLoss(dual, example_label, example_weight); example_state_data(example_index, 3) = example_weight; } }; const int64_t kCostPerUnit = examples.num_features(); const DeviceBase::CpuWorkerThreads& worker_threads = *context->device()->tensorflow_cpu_worker_threads(); Shard(worker_threads.num_threads, worker_threads.workers, examples.num_examples(), kCostPerUnit, train_step); mutex_lock l(train_step_status.mu); OP_REQUIRES_OK(context, train_step_status.value); }
Description: TensorFlow is an open source platform for machine learning. Inputs `dense_features` or `example_state_data` not of rank 2 will trigger a `CHECK` fail in `SdcaOptimizer`. We have patched the issue in GitHub commit 80ff197d03db2a70c6a111f97dcdacad1b0babfa. The fix will be included in TensorFlow 2.11. We will also cherrypick this commit on TensorFlow 2.10.1, 2.9.3, and TensorFlow 2.8.4, as these are also affected and still in supported range.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length,  uint32 width, uint16 spp, struct dump_opts *dump) { int i, j, bytes_per_sample, bytes_per_pixel, shift_width, result = 1; int32  bytes_read = 0; uint16 bps, nstrips, planar, strips_per_sample; uint32 src_rowsize, dst_rowsize, rows_processed, rps; uint32 rows_this_strip = 0; tsample_t s; tstrip_t  strip; tsize_t scanlinesize = TIFFScanlineSize(in); tsize_t stripsize    = TIFFStripSize(in); unsigned char *srcbuffs[MAX_SAMPLES]; unsigned char *buff = NULL; unsigned char *dst = NULL; if (obuf == NULL) { TIFFError(""readSeparateStripsIntoBuffer"",""Invalid buffer argument""); return (0); } memset (srcbuffs, '\0', sizeof(srcbuffs)); TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps); TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar); TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps); if (rps > length) rps = length; bytes_per_sample = (bps + 7) / 8;  bytes_per_pixel  = ((bps * spp) + 7) / 8; if (bytes_per_pixel < (bytes_per_sample + 1)) shift_width = bytes_per_pixel; else shift_width = bytes_per_sample + 1; src_rowsize = ((bps * width) + 7) / 8; dst_rowsize = ((bps * width * spp) + 7) / 8; dst = obuf; if ((dump->infile != NULL) && (dump->level == 3)) { dump_info  (dump->infile, dump->format, """",  ""Image width %d, length %d, Scanline size, %4d bytes"", width, length,  scanlinesize); dump_info  (dump->infile, dump->format, """",  ""Bits per sample %d, Samples per pixel %d, Shift width %d"", bps, spp, shift_width); } nstrips = TIFFNumberOfStrips(in); strips_per_sample = nstrips /spp; for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++) { srcbuffs[s] = NULL; buff = _TIFFmalloc(stripsize); if (!buff) { TIFFError (""readSeparateStripsIntoBuffer"",  ""Unable to allocate strip read buffer for sample %d"", s); for (i = 0; i < s; i++) _TIFFfree (srcbuffs[i]); return 0; } srcbuffs[s] = buff; } rows_processed = 0; for (j = 0; (j < strips_per_sample) && (result == 1); j++) { for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++) { buff = srcbuffs[s]; strip = (s * strips_per_sample) + j;  bytes_read = TIFFReadEncodedStrip (in, strip, buff, stripsize); rows_this_strip = bytes_read / src_rowsize; if (bytes_read < 0 && !ignore) { TIFFError(TIFFFileName(in), ""Error, can't read strip %lu for sample %d"", (unsigned long) strip, s + 1); result = 0; break; } #ifdef DEVELMODE TIFFError("""", ""Strip %2d, read %5d bytes for %4d scanlines, shift width %d"",  strip, bytes_read, rows_this_strip, shift_width); #endif } if (rps > rows_this_strip) rps = rows_this_strip; dst = obuf + (dst_rowsize * rows_processed); if ((bps % 8) == 0) { if (combineSeparateSamplesBytes (srcbuffs, dst, width, rps, spp, bps, dump->infile,  dump->format, dump->level)) { result = 0; break; } } else { switch (shift_width) { case 1: if (combineSeparateSamples8bits (srcbuffs, dst, width, rps, spp, bps, dump->infile, dump->format, dump->level)) { result = 0; break; } break; case 2: if (combineSeparateSamples16bits (srcbuffs, dst, width, rps, spp, bps, dump->infile, dump->format, dump->level)) { result = 0; break; } break; case 3: if (combineSeparateSamples24bits (srcbuffs, dst, width, rps, spp, bps, dump->infile, dump->format, dump->level)) { result = 0; break; } break; case 4:  case 5: case 6: case 7: case 8: if (combineSeparateSamples32bits (srcbuffs, dst, width, rps, spp, bps, dump->infile, dump->format, dump->level)) { result = 0; break; } break; default: TIFFError (""readSeparateStripsIntoBuffer"", ""Unsupported bit depth: %d"", bps); result = 0; break; } } if ((rows_processed + rps) > length) { rows_processed = length; rps = length - rows_processed; } else rows_processed += rps; } for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++) { buff = srcbuffs[s]; if (buff != NULL) _TIFFfree(buff); } return (result); }
Description: tools/tiffcrop.c in libtiff 4.0.6 reads an undefined buffer in readContigStripsIntoBuffer() because of a uint16 integer overflow. Reported as MSVR 35100.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: BIGNUM *BN_mod_sqrt(BIGNUM *in, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx) { BIGNUM *ret = in; int err = 1; int r; BIGNUM *A, *b, *q, *t, *x, *y; int e, i, j; if (!BN_is_odd(p) || BN_abs_is_word(p, 1)) { if (BN_abs_is_word(p, 2)) { if (ret == NULL) ret = BN_new(); if (ret == NULL) goto end; if (!BN_set_word(ret, BN_is_bit_set(a, 0))) { if (ret != in) BN_free(ret); return NULL; } bn_check_top(ret); return ret; } BNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); return NULL; } if (BN_is_zero(a) || BN_is_one(a)) { if (ret == NULL) ret = BN_new(); if (ret == NULL) goto end; if (!BN_set_word(ret, BN_is_one(a))) { if (ret != in) BN_free(ret); return NULL; } bn_check_top(ret); return ret; } BN_CTX_start(ctx); A = BN_CTX_get(ctx); b = BN_CTX_get(ctx); q = BN_CTX_get(ctx); t = BN_CTX_get(ctx); x = BN_CTX_get(ctx); y = BN_CTX_get(ctx); if (y == NULL) goto end; if (ret == NULL) ret = BN_new(); if (ret == NULL) goto end; if (!BN_nnmod(A, a, p, ctx)) goto end; e = 1; while (!BN_is_bit_set(p, e)) e++; if (e == 1) { if (!BN_rshift(q, p, 2)) goto end; q->neg = 0; if (!BN_add_word(q, 1)) goto end; if (!BN_mod_exp(ret, A, q, p, ctx)) goto end; err = 0; goto vrfy; } if (e == 2) { if (!BN_mod_lshift1_quick(t, A, p)) goto end; if (!BN_rshift(q, p, 3)) goto end; q->neg = 0; if (!BN_mod_exp(b, t, q, p, ctx)) goto end; if (!BN_mod_sqr(y, b, p, ctx)) goto end; if (!BN_mod_mul(t, t, y, p, ctx)) goto end; if (!BN_sub_word(t, 1)) goto end; if (!BN_mod_mul(x, A, b, p, ctx)) goto end; if (!BN_mod_mul(x, x, t, p, ctx)) goto end; if (!BN_copy(ret, x)) goto end; err = 0; goto vrfy; } if (!BN_copy(q, p)) goto end;                q->neg = 0; i = 2; do { if (i < 22) { if (!BN_set_word(y, i)) goto end; } else { if (!BN_priv_rand(y, BN_num_bits(p), 0, 0)) goto end; if (BN_ucmp(y, p) >= 0) { if (!(p->neg ? BN_add : BN_sub) (y, y, p)) goto end; } if (BN_is_zero(y)) if (!BN_set_word(y, i)) goto end; } r = BN_kronecker(y, q, ctx);  if (r < -1) goto end; if (r == 0) { BNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); goto end; } } while (r == 1 && ++i < 82); if (r != -1) { BNerr(BN_F_BN_MOD_SQRT, BN_R_TOO_MANY_ITERATIONS); goto end; } if (!BN_rshift(q, q, e)) goto end; if (!BN_mod_exp(y, y, q, p, ctx)) goto end; if (BN_is_one(y)) { BNerr(BN_F_BN_MOD_SQRT, BN_R_P_IS_NOT_PRIME); goto end; } if (!BN_rshift1(t, q)) goto end; if (BN_is_zero(t)) {         if (!BN_nnmod(t, A, p, ctx)) goto end; if (BN_is_zero(t)) { BN_zero(ret); err = 0; goto end; } else if (!BN_one(x)) goto end; } else { if (!BN_mod_exp(x, A, t, p, ctx)) goto end; if (BN_is_zero(x)) { BN_zero(ret); err = 0; goto end; } } if (!BN_mod_sqr(b, x, p, ctx)) goto end; if (!BN_mod_mul(b, b, A, p, ctx)) goto end; if (!BN_mod_mul(x, x, A, p, ctx)) goto end; while (1) { if (BN_is_one(b)) { if (!BN_copy(ret, x)) goto end; err = 0; goto vrfy; } i = 1; if (!BN_mod_sqr(t, b, p, ctx)) goto end; while (!BN_is_one(t)) { i++; if (i == e) { BNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); goto end; } if (!BN_mod_mul(t, t, t, p, ctx)) goto end; } if (!BN_copy(t, y)) goto end; for (j = e - i - 1; j > 0; j--) { if (!BN_mod_sqr(t, t, p, ctx)) goto end; } if (!BN_mod_mul(y, t, t, p, ctx)) goto end; if (!BN_mod_mul(x, x, t, p, ctx)) goto end; if (!BN_mod_mul(b, b, y, p, ctx)) goto end; e = i; } vrfy: if (!err) { if (!BN_mod_sqr(x, ret, p, ctx)) err = 1; if (!err && 0 != BN_cmp(x, A)) { BNerr(BN_F_BN_MOD_SQRT, BN_R_NOT_A_SQUARE); err = 1; } } end: if (err) { if (ret != in) BN_clear_free(ret); ret = NULL; } BN_CTX_end(ctx); bn_check_top(ret); return ret; }
Description: The BN_mod_sqrt() function, which computes a modular square root, contains a bug that can cause it to loop forever for non-prime moduli. Internally this function is used when parsing certificates that contain elliptic curve public keys in compressed form or explicit elliptic curve parameters with a base point encoded in compressed form. It is possible to trigger the infinite loop by crafting a certificate that has invalid explicit curve parameters. Since certificate parsing happens prior to verification of the certificate signature, any process that parses an externally supplied certificate may thus be subject to a denial of service attack. The infinite loop can also be reached when parsing crafted private keys as they can contain explicit elliptic curve parameters. Thus vulnerable situations include: - TLS clients consuming server certificates - TLS servers consuming client certificates - Hosting providers taking certificates or private keys from customers - Certificate authorities parsing certification requests from subscribers - Anything else which parses ASN.1 elliptic curve parameters Also any other applications that use the BN_mod_sqrt() where the attacker can control the parameter values are vulnerable to this DoS issue. In the OpenSSL 1.0.2 version the public key is not parsed during initial parsing of the certificate which makes it slightly harder to trigger the infinite loop. However any operation which requires the public key from the certificate will trigger the infinite loop. In particular the attacker can use a self-signed certificate to trigger the loop during verification of the certificate signature. This issue affects OpenSSL versions 1.0.2, 1.1.1 and 3.0. It was addressed in the releases of 1.1.1n and 3.0.2 on the 15th March 2022. Fixed in OpenSSL 3.0.2 (Affected 3.0.0,3.0.1). Fixed in OpenSSL 1.1.1n (Affected 1.1.1-1.1.1m). Fixed in OpenSSL 1.0.2zd (Affected 1.0.2-1.0.2zc).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: struct group *hyper_getgrnam(const char *name) { gid_t gid = (gid_t)id_or_max(name); FILE *file = fopen(""/etc/group"", ""r""); if (!file) { perror(""faile to open /etc/group""); return NULL; } for (;;) { struct group *gr = fgetgrent(file); if (!gr) break; if (!strcmp(gr->gr_name, name) || gr->gr_gid == gid) { fclose(file); return gr; } } fclose(file); return NULL; }
Description: util.c in runV 1.0.0 for Docker mishandles a numeric username, which allows attackers to obtain root access by leveraging the presence of an initial numeric value on an /etc/passwd line, and then issuing a ""docker exec"" command with that value in the -u argument, a similar issue to CVE-2016-3697.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int nbd_negotiate_options(NBDClient *client) { uint32_t flags; bool fixedNewstyle = false; if (nbd_negotiate_read(client->ioc, &flags, sizeof(flags)) < 0) { LOG(""read failed""); return -EIO; } TRACE(""Checking client flags""); be32_to_cpus(&flags); if (flags & NBD_FLAG_C_FIXED_NEWSTYLE) { TRACE(""Client supports fixed newstyle handshake""); fixedNewstyle = true; flags &= ~NBD_FLAG_C_FIXED_NEWSTYLE; } if (flags & NBD_FLAG_C_NO_ZEROES) { TRACE(""Client supports no zeroes at handshake end""); client->no_zeroes = true; flags &= ~NBD_FLAG_C_NO_ZEROES; } if (flags != 0) { TRACE(""Unknown client flags 0x%"" PRIx32 "" received"", flags); return -EIO; } while (1) { int ret; uint32_t clientflags, length; uint64_t magic; if (nbd_negotiate_read(client->ioc, &magic, sizeof(magic)) < 0) { LOG(""read failed""); return -EINVAL; } TRACE(""Checking opts magic""); if (magic != be64_to_cpu(NBD_OPTS_MAGIC)) { LOG(""Bad magic received""); return -EINVAL; } if (nbd_negotiate_read(client->ioc, &clientflags, sizeof(clientflags)) < 0) { LOG(""read failed""); return -EINVAL; } clientflags = be32_to_cpu(clientflags); if (nbd_negotiate_read(client->ioc, &length, sizeof(length)) < 0) { LOG(""read failed""); return -EINVAL; } length = be32_to_cpu(length); TRACE(""Checking option 0x%"" PRIx32, clientflags); if (client->tlscreds && client->ioc == (QIOChannel *)client->sioc) { QIOChannel *tioc; if (!fixedNewstyle) { TRACE(""Unsupported option 0x%"" PRIx32, clientflags); return -EINVAL; } switch (clientflags) { case NBD_OPT_STARTTLS: tioc = nbd_negotiate_handle_starttls(client, length); if (!tioc) { return -EIO; } object_unref(OBJECT(client->ioc)); client->ioc = QIO_CHANNEL(tioc); break; case NBD_OPT_EXPORT_NAME: TRACE(""Option 0x%x not permitted before TLS"", clientflags); return -EINVAL; default: if (nbd_negotiate_drop_sync(client->ioc, length) < 0) { return -EIO; } ret = nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_TLS_REQD, clientflags, ""Option 0x%"" PRIx32 ""not permitted before TLS"", clientflags); if (ret < 0) { return ret; } if (clientflags == NBD_OPT_ABORT) { return -EINVAL; } break; } } else if (fixedNewstyle) { switch (clientflags) { case NBD_OPT_LIST: ret = nbd_negotiate_handle_list(client, length); if (ret < 0) { return ret; } break; case NBD_OPT_ABORT: nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, clientflags); return -EINVAL; case NBD_OPT_EXPORT_NAME: return nbd_negotiate_handle_export_name(client, length); case NBD_OPT_STARTTLS: if (nbd_negotiate_drop_sync(client->ioc, length) < 0) { return -EIO; } if (client->tlscreds) { ret = nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_INVALID, clientflags, ""TLS already enabled""); } else { ret = nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_POLICY, clientflags, ""TLS not configured""); } if (ret < 0) { return ret; } break; default: if (nbd_negotiate_drop_sync(client->ioc, length) < 0) { return -EIO; } ret = nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_UNSUP, clientflags, ""Unsupported option 0x%"" PRIx32, clientflags); if (ret < 0) { return ret; } break; } } else { switch (clientflags) { case NBD_OPT_EXPORT_NAME: return nbd_negotiate_handle_export_name(client, length); default: TRACE(""Unsupported option 0x%"" PRIx32, clientflags); return -EINVAL; } } } }
Description: An assertion-failure flaw was found in Qemu before 2.10.1, in the Network Block Device (NBD) server's initial connection negotiation, where the I/O coroutine was undefined. This could crash the qemu-nbd server if a client sent unexpected data during connection negotiation. A remote user or process could use this flaw to crash the qemu-nbd server resulting in denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset, struct inode **i) { squashfs_dir_header_2 dirh; char buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1] __attribute__((aligned)); squashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer; long long start; int bytes = 0; int dir_count, size, res; struct dir_ent *ent, *cur_ent = NULL; struct dir *dir; TRACE(""squashfs_opendir: inode start block %d, offset %d\n"", block_start, offset); *i = read_inode(block_start, offset); dir = malloc(sizeof(struct dir)); if(dir == NULL) MEM_ERROR(); dir->dir_count = 0; dir->cur_entry = NULL; dir->mode = (*i)->mode; dir->uid = (*i)->uid; dir->guid = (*i)->gid; dir->mtime = (*i)->time; dir->xattr = (*i)->xattr; dir->dirs = NULL; if ((*i)->data == 0) return dir; start = sBlk.s.directory_table_start + (*i)->start; offset = (*i)->offset; size = (*i)->data + bytes; while(bytes < size) { if(swap) { squashfs_dir_header_2 sdirh; res = read_directory_data(&sdirh, &start, &offset, sizeof(sdirh)); if(res) SQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh); } else res = read_directory_data(&dirh, &start, &offset, sizeof(dirh)); if(res == FALSE) goto corrupted; dir_count = dirh.count + 1; TRACE(""squashfs_opendir: Read directory header @ byte position "" ""%d, %d directory entries\n"", bytes, dir_count); bytes += sizeof(dirh); if(dir_count > SQUASHFS_DIR_COUNT) { ERROR(""File system corrupted: too many entries in directory\n""); goto corrupted; } while(dir_count--) { if(swap) { squashfs_dir_entry_2 sdire; res = read_directory_data(&sdire, &start, &offset, sizeof(sdire)); if(res) SQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire); } else res = read_directory_data(dire, &start, &offset, sizeof(*dire)); if(res == FALSE) goto corrupted; bytes += sizeof(*dire); if(dire->size >= SQUASHFS_NAME_LEN) { ERROR(""File system corrupted: filename too long\n""); goto corrupted; } res = read_directory_data(dire->name, &start, &offset, dire->size + 1); if(res == FALSE) goto corrupted; dire->name[dire->size + 1] = '\0'; if(check_name(dire->name, dire->size + 1) == FALSE) { ERROR(""File system corrupted: invalid characters in name\n""); goto corrupted; } TRACE(""squashfs_opendir: directory entry %s, inode "" ""%d:%d, type %d\n"", dire->name, dirh.start_block, dire->offset, dire->type); ent = malloc(sizeof(struct dir_ent)); if(ent == NULL) MEM_ERROR(); ent->name = strdup(dire->name); ent->start_block = dirh.start_block; ent->offset = dire->offset; ent->type = dire->type; ent->next = NULL; if(cur_ent == NULL) dir->dirs = ent; else cur_ent->next = ent; cur_ent = ent; dir->dir_count ++; bytes += dire->size + 1; } } return dir; corrupted: squashfs_closedir(dir); return NULL; }
Description: squashfs_opendir in unsquash-2.c in Squashfs-Tools 4.5 allows Directory Traversal, a different vulnerability than CVE-2021-40153. A squashfs filesystem that has been crafted to include a symbolic link and then contents under the same filename in a filesystem can cause unsquashfs to first create the symbolic link pointing outside the expected directory, and then the subsequent write operation will cause the unsquashfs process to write through the symbolic link elsewhere in the filesystem.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void trunc_string( char_u*s, char_u*buf, introom_in, intbuflen) { size_troom = room_in - 3;     size_thalf; size_tlen = 0; inte; inti; intn; if (*s == NUL) { if (buflen > 0) *buf = NUL; return; } if (room_in < 3) room = 0; half = room / 2; for (e = 0; len < half && e < buflen; ++e) { if (s[e] == NUL) { buf[e] = NUL; return; } n = ptr2cells(s + e); if (len + n > half) break; len += n; buf[e] = s[e]; if (has_mbyte) for (n = (*mb_ptr2len)(s + e); --n > 0; ) { if (++e == buflen) break; buf[e] = s[e]; } } i = e; if (enc_dbcs != 0) { n = vim_strsize(s + i); while (len + n > room) { n -= ptr2cells(s + i); i += (*mb_ptr2len)(s + i); } } else if (enc_utf8) { half = i = (int)STRLEN(s); for (;;) { do half = half - utf_head_off(s, s + half - 1) - 1; while (half > 0 && utf_iscomposing(utf_ptr2char(s + half))); n = ptr2cells(s + half); if (len + n > room || half == 0) break; len += n; i = (int)half; } } else { for (i = (int)STRLEN(s); i - 1 >= 0 && len + (n = ptr2cells(s + i - 1)) <= room; --i) len += n; } if (i <= e + 3) { if (s != buf) { len = STRLEN(s); if (len >= (size_t)buflen) len = buflen - 1; len = len - e + 1; if (len < 1) buf[e - 1] = NUL; else mch_memmove(buf + e, s + e, len); } } else if (e + 3 < buflen) { mch_memmove(buf + e, ""..."", (size_t)3); len = STRLEN(s + i) + 1; if (len >= (size_t)buflen - e - 3) len = buflen - e - 3 - 1; mch_memmove(buf + e + 3, s + i, len); buf[e + 3 + len - 1] = NUL; } else { buf[e - 1] = NUL; } }
Description: Heap-based Buffer Overflow in GitHub repository vim/vim prior to 9.0.1969.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void parse_atomic_type(const RAnal *anal, const RBinDwarfDie *all_dies,  const ut64 count, ut64 idx) { r_return_if_fail (all_dies); const RBinDwarfDie *die = &all_dies[idx]; char *name = NULL; ut64 size = 0; size_t i; for (i = 0; i < die->count; i++) { RBinDwarfAttrValue *value = &die->attr_values[i]; switch (die->attr_values[i].attr_name) { case DW_AT_name: name = strdup (value->string.content); if (!name) { return; } break; case DW_AT_byte_size: size = value->data * CHAR_BIT; break; case DW_AT_bit_size: size = value->data; break; case DW_AT_encoding: default: break; } } if (!name) { return; } RAnalBaseType *base_type = r_anal_new_base_type (R_ANAL_BASE_TYPE_KIND_ATOMIC); if (!base_type) { return; } base_type->name = name; base_type->size = size; r_anal_save_base_type (anal, base_type); r_anal_free_base_type (base_type); }
Description: radare2 4.5.0 misparses DWARF information in executable files, causing a segmentation fault in parse_typedef in type_dwarf.c via a malformed DW_AT_name in the .debug_info section.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: CURLcode Curl_smtp_escape_eob(struct connectdata *conn, const ssize_t nread) { ssize_t i; ssize_t si; struct Curl_easy *data = conn->data; struct SMTP *smtp = data->req.protop; char *scratch = data->state.scratch; char *newscratch = NULL; char *oldscratch = NULL; size_t eob_sent; if(!scratch || data->set.crlf) { oldscratch = scratch; scratch = newscratch = malloc(2 * data->set.buffer_size); if(!newscratch) { failf(data, ""Failed to alloc scratch buffer!""); return CURLE_OUT_OF_MEMORY; } } eob_sent = smtp->eob; for(i = 0, si = 0; i < nread; i++) { if(SMTP_EOB[smtp->eob] == data->req.upload_fromhere[i]) { smtp->eob++; if(2 == smtp->eob || SMTP_EOB_LEN == smtp->eob) smtp->trailing_crlf = TRUE; else smtp->trailing_crlf = FALSE; } else if(smtp->eob) { memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent); si += smtp->eob - eob_sent; if(SMTP_EOB[0] == data->req.upload_fromhere[i]) smtp->eob = 1; else smtp->eob = 0; eob_sent = 0; smtp->trailing_crlf = FALSE; } if(SMTP_EOB_FIND_LEN == smtp->eob) { memcpy(&scratch[si], &SMTP_EOB_REPL[eob_sent], SMTP_EOB_REPL_LEN - eob_sent); si += SMTP_EOB_REPL_LEN - eob_sent; smtp->eob = 0; eob_sent = 0; } else if(!smtp->eob) scratch[si++] = data->req.upload_fromhere[i]; } if(smtp->eob - eob_sent) { memcpy(&scratch[si], &SMTP_EOB[eob_sent], smtp->eob - eob_sent); si += smtp->eob - eob_sent; } if(si != nread) { data->req.upload_fromhere = scratch; data->state.scratch = scratch; free(oldscratch); data->req.upload_present = si; } else free(newscratch); return CURLE_OK; }
Description: Curl_smtp_escape_eob in lib/smtp.c in curl 7.54.1 to and including curl 7.60.0 has a heap-based buffer overflow that might be exploitable by an attacker who can control the data that curl transmits over SMTP with certain settings (i.e., use of a nonstandard --limit-rate argument or CURLOPT_BUFFERSIZE value).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static guint get_chancount(tvbuff_t *tvb) { guint         offset; guint8        tlv_type; guint16       tlv_len; tlv_len_len_e tlv_len_len; guint         chancount = THREAD_MC_INVALID_CHAN_COUNT; offset = 0; while (tvb_offset_exists(tvb, offset)) { tlv_type = tvb_get_guint8(tvb, offset); tlv_len = (guint16)tvb_get_guint8(tvb, offset + 1); if (THREAD_TLV_LENGTH_ESC == tlv_len) { tlv_len = tvb_get_ntohs(tvb, offset + 2); tlv_len_len = TLV_LEN_LEN16; } else { tlv_len_len = TLV_LEN_LEN8; } offset += 1 + tlv_len_len; switch(tlv_type) { case THREAD_MC_TLV_CHANNEL_MASK: { int i, j; guint8 entries = 0; gint32 check_len = tlv_len; guint8 check_offset = offset + 1;  guint8 masklen; while (check_len > 0) { masklen = tvb_get_guint8(tvb, check_offset); if (masklen == 0) { break;  } masklen += 2;  check_offset += masklen; check_len -= masklen; entries++; } if (check_len != 0) { return chancount; } else { chancount = 0; for (i = 0; i < entries; i++) { offset++; masklen = tvb_get_guint8(tvb, offset); offset++; for (j = 0; j < masklen; j++) { chancount += count_bits_in_byte(tvb_get_guint8(tvb, offset)); offset++; } } } } break; default: offset += tlv_len; } } return chancount; }
Description: In Wireshark 2.4.0 to 2.4.4 and 2.2.0 to 2.2.12, epan/dissectors/packet-thread.c had an infinite loop that was addressed by using a correct integer data type.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int digest_generic_verify(struct digest *d, const unsigned char *md) { int ret; int len = digest_length(d); unsigned char *tmp; tmp = xmalloc(len); ret = digest_final(d, tmp); if (ret) goto end; ret = memcmp(md, tmp, len); ret = ret ? -EINVAL : 0; end: free(tmp); return ret; }
Description: crypto/digest.c in Pengutronix barebox through 2021.07.0 leaks timing information because memcmp is used during digest verification.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int jas_stream_write(jas_stream_t *stream, const void *buf, int cnt) { int n; const char *bufptr; bufptr = buf; n = 0; while (n < cnt) { if (jas_stream_putc(stream, *bufptr) == EOF) { return n; } ++bufptr; ++n; } return n; }
Description: Multiple integer overflows in the (1) jas_realloc function in base/jas_malloc.c and (2) mem_resize function in base/jas_stream.c in JasPer before 1.900.22 allow remote attackers to cause a denial of service via a crafted image, which triggers use after free vulnerabilities.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool Decoder::canSplitFunctionOn( utils::Address addr, llvm::BasicBlock* splitBb, std::set<llvm::BasicBlock*>& newFncStarts) { newFncStarts.insert(splitBb); auto* f = splitBb->getParent(); auto fAddr = getFunctionAddress(f); auto fSzIt = _fnc2sz.find(f); if (fSzIt != _fnc2sz.end()) { if (fAddr <= addr && addr < (fAddr+fSzIt->second)) { LOG << ""\t\t\t\t\t"" << ""!CAN S: addr cond @ "" << addr << std::endl; return false; } } std::set<Address> fncStarts; fncStarts.insert(fAddr); fncStarts.insert(addr); LOG << ""\t\t\t\t\t"" << ""CAN S: split @ "" << fAddr << std::endl; LOG << ""\t\t\t\t\t"" << ""CAN S: split @ "" << addr << std::endl; bool changed = true; while (changed) { changed = false; for (BasicBlock& b : *f) { Address bAddr; BasicBlock* bPrev = &b; while (bAddr.isUndefined() && bPrev) { bAddr = getBasicBlockAddress(bPrev); bPrev = bPrev->getPrevNode(); } if (bAddr.isUndefined()) { continue; } auto up = fncStarts.upper_bound(bAddr); --up; Address bFnc = *up; for (auto* p : predecessors(&b)) { Address pAddr; BasicBlock* pPrev = p; while (pAddr.isUndefined() && pPrev) { pAddr = getBasicBlockAddress(pPrev); pPrev = pPrev->getPrevNode(); } if (pAddr.isUndefined()) { continue; } auto up = fncStarts.upper_bound(pAddr); --up; Address pFnc = *up; if (bFnc != pFnc) { if (!canSplitFunctionOn(&b)) { return false; } changed |= newFncStarts.insert(&b).second; changed |= fncStarts.insert(bAddr).second; LOG << ""\t\t\t\t\t"" << ""CAN S: split @ "" << bAddr << std::endl; } } } } return true; }
Description: An issue was discovered in retdec v3.3. In function canSplitFunctionOn() of ir_modifications.cpp, there is a possible out of bounds read due to a heap buffer overflow. The impact is: Deny of Service, Memory Disclosure, and Possible Code Execution.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static RList *oneshotall_buffer(RBin *bin, RBuffer *b) { RList *list = r_list_newf (free); RBinXtrData *meta = get_the_meta (bin, b); r_list_append (list, meta); return list; }
Description: Radare2 v5.7.2 was discovered to contain a NULL pointer dereference via the function r_bin_file_xtr_load_buffer at bin/bfile.c. This vulnerability allows attackers to cause a Denial of Service (DOS) via a crafted binary file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int xwd_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { AVFrame *p = data; const uint8_t *buf = avpkt->data; int i, ret, buf_size = avpkt->size; uint32_t version, header_size, vclass, ncolors; uint32_t xoffset, be, bpp, lsize, rsize; uint32_t pixformat, pixdepth, bunit, bitorder, bpad; uint32_t rgb[3]; uint8_t *ptr; GetByteContext gb; if (buf_size < XWD_HEADER_SIZE) return AVERROR_INVALIDDATA; bytestream2_init(&gb, buf, buf_size); header_size = bytestream2_get_be32u(&gb); version = bytestream2_get_be32u(&gb); if (version != XWD_VERSION) { av_log(avctx, AV_LOG_ERROR, ""unsupported version\n""); return AVERROR_INVALIDDATA; } if (buf_size < header_size || header_size < XWD_HEADER_SIZE) { av_log(avctx, AV_LOG_ERROR, ""invalid header size\n""); return AVERROR_INVALIDDATA; } pixformat     = bytestream2_get_be32u(&gb); pixdepth      = bytestream2_get_be32u(&gb); avctx->width  = bytestream2_get_be32u(&gb); avctx->height = bytestream2_get_be32u(&gb); xoffset       = bytestream2_get_be32u(&gb); be            = bytestream2_get_be32u(&gb); bunit         = bytestream2_get_be32u(&gb); bitorder      = bytestream2_get_be32u(&gb); bpad          = bytestream2_get_be32u(&gb); bpp           = bytestream2_get_be32u(&gb); lsize         = bytestream2_get_be32u(&gb); vclass        = bytestream2_get_be32u(&gb); rgb[0]        = bytestream2_get_be32u(&gb); rgb[1]        = bytestream2_get_be32u(&gb); rgb[2]        = bytestream2_get_be32u(&gb); bytestream2_skipu(&gb, 8); ncolors       = bytestream2_get_be32u(&gb); bytestream2_skipu(&gb, header_size - (XWD_HEADER_SIZE - 20)); av_log(avctx, AV_LOG_DEBUG, ""pixformat %""PRIu32"", pixdepth %""PRIu32"", bunit %""PRIu32"", bitorder %""PRIu32"", bpad %""PRIu32""\n"", pixformat, pixdepth, bunit, bitorder, bpad); av_log(avctx, AV_LOG_DEBUG, ""vclass %""PRIu32"", ncolors %""PRIu32"", bpp %""PRIu32"", be %""PRIu32"", lsize %""PRIu32"", xoffset %""PRIu32""\n"", vclass, ncolors, bpp, be, lsize, xoffset); av_log(avctx, AV_LOG_DEBUG, ""red %0""PRIx32"", green %0""PRIx32"", blue %0""PRIx32""\n"", rgb[0], rgb[1], rgb[2]); if (pixformat > XWD_Z_PIXMAP) { av_log(avctx, AV_LOG_ERROR, ""invalid pixmap format\n""); return AVERROR_INVALIDDATA; } if (pixdepth == 0 || pixdepth > 32) { av_log(avctx, AV_LOG_ERROR, ""invalid pixmap depth\n""); return AVERROR_INVALIDDATA; } if (xoffset) { avpriv_request_sample(avctx, ""xoffset %""PRIu32"""", xoffset); return AVERROR_PATCHWELCOME; } if (be > 1) { av_log(avctx, AV_LOG_ERROR, ""invalid byte order\n""); return AVERROR_INVALIDDATA; } if (bitorder > 1) { av_log(avctx, AV_LOG_ERROR, ""invalid bitmap bit order\n""); return AVERROR_INVALIDDATA; } if (bunit != 8 && bunit != 16 && bunit != 32) { av_log(avctx, AV_LOG_ERROR, ""invalid bitmap unit\n""); return AVERROR_INVALIDDATA; } if (bpad != 8 && bpad != 16 && bpad != 32) { av_log(avctx, AV_LOG_ERROR, ""invalid bitmap scan-line pad\n""); return AVERROR_INVALIDDATA; } if (bpp == 0 || bpp > 32) { av_log(avctx, AV_LOG_ERROR, ""invalid bits per pixel\n""); return AVERROR_INVALIDDATA; } if (ncolors > 256) { av_log(avctx, AV_LOG_ERROR, ""invalid number of entries in colormap\n""); return AVERROR_INVALIDDATA; } if ((ret = av_image_check_size(avctx->width, avctx->height, 0, NULL)) < 0) return ret; rsize = FFALIGN(avctx->width * bpp, bpad) / 8; if (lsize < rsize) { av_log(avctx, AV_LOG_ERROR, ""invalid bytes per scan-line\n""); return AVERROR_INVALIDDATA; } if (bytestream2_get_bytes_left(&gb) < ncolors * XWD_CMAP_SIZE + (uint64_t)avctx->height * lsize) { av_log(avctx, AV_LOG_ERROR, ""input buffer too small\n""); return AVERROR_INVALIDDATA; } if (pixformat != XWD_Z_PIXMAP) { avpriv_report_missing_feature(avctx, ""Pixmap format %""PRIu32, pixformat); return AVERROR_PATCHWELCOME; } avctx->pix_fmt = AV_PIX_FMT_NONE; switch (vclass) { case XWD_STATIC_GRAY: case XWD_GRAY_SCALE: if (bpp != 1 && bpp != 8) return AVERROR_INVALIDDATA; if (pixdepth == 1) { avctx->pix_fmt = AV_PIX_FMT_MONOWHITE; } else if (pixdepth == 8) { avctx->pix_fmt = AV_PIX_FMT_GRAY8; } break; case XWD_STATIC_COLOR: case XWD_PSEUDO_COLOR: if (bpp == 8) avctx->pix_fmt = AV_PIX_FMT_PAL8; break; case XWD_TRUE_COLOR: case XWD_DIRECT_COLOR: if (bpp != 16 && bpp != 24 && bpp != 32) return AVERROR_INVALIDDATA; if (bpp == 16 && pixdepth == 15) { if (rgb[0] == 0x7C00 && rgb[1] == 0x3E0 && rgb[2] == 0x1F) avctx->pix_fmt = be ? AV_PIX_FMT_RGB555BE : AV_PIX_FMT_RGB555LE; else if (rgb[0] == 0x1F && rgb[1] == 0x3E0 && rgb[2] == 0x7C00) avctx->pix_fmt = be ? AV_PIX_FMT_BGR555BE : AV_PIX_FMT_BGR555LE; } else if (bpp == 16 && pixdepth == 16) { if (rgb[0] == 0xF800 && rgb[1] == 0x7E0 && rgb[2] == 0x1F) avctx->pix_fmt = be ? AV_PIX_FMT_RGB565BE : AV_PIX_FMT_RGB565LE; else if (rgb[0] == 0x1F && rgb[1] == 0x7E0 && rgb[2] == 0xF800) avctx->pix_fmt = be ? AV_PIX_FMT_BGR565BE : AV_PIX_FMT_BGR565LE; } else if (bpp == 24) { if (rgb[0] == 0xFF0000 && rgb[1] == 0xFF00 && rgb[2] == 0xFF) avctx->pix_fmt = be ? AV_PIX_FMT_RGB24 : AV_PIX_FMT_BGR24; else if (rgb[0] == 0xFF && rgb[1] == 0xFF00 && rgb[2] == 0xFF0000) avctx->pix_fmt = be ? AV_PIX_FMT_BGR24 : AV_PIX_FMT_RGB24; } else if (bpp == 32) { if (rgb[0] == 0xFF0000 && rgb[1] == 0xFF00 && rgb[2] == 0xFF) avctx->pix_fmt = be ? AV_PIX_FMT_ARGB : AV_PIX_FMT_BGRA; else if (rgb[0] == 0xFF && rgb[1] == 0xFF00 && rgb[2] == 0xFF0000) avctx->pix_fmt = be ? AV_PIX_FMT_ABGR : AV_PIX_FMT_RGBA; } bytestream2_skipu(&gb, ncolors * XWD_CMAP_SIZE); break; default: av_log(avctx, AV_LOG_ERROR, ""invalid visual class\n""); return AVERROR_INVALIDDATA; } if (avctx->pix_fmt == AV_PIX_FMT_NONE) { avpriv_request_sample(avctx, ""Unknown file: bpp %""PRIu32"", pixdepth %""PRIu32"", vclass %""PRIu32"""", bpp, pixdepth, vclass); return AVERROR_PATCHWELCOME; } if ((ret = ff_get_buffer(avctx, p, 0)) < 0) return ret; p->key_frame = 1; p->pict_type = AV_PICTURE_TYPE_I; if (avctx->pix_fmt == AV_PIX_FMT_PAL8) { uint32_t *dst = (uint32_t *)p->data[1]; uint8_t red, green, blue; for (i = 0; i < ncolors; i++) { bytestream2_skipu(&gb, 4);             red    = bytestream2_get_byteu(&gb); bytestream2_skipu(&gb, 1); green  = bytestream2_get_byteu(&gb); bytestream2_skipu(&gb, 1); blue   = bytestream2_get_byteu(&gb); bytestream2_skipu(&gb, 3);  dst[i] = red << 16 | green << 8 | blue; } } ptr = p->data[0]; for (i = 0; i < avctx->height; i++) { bytestream2_get_bufferu(&gb, ptr, rsize); bytestream2_skipu(&gb, lsize - rsize); ptr += p->linesize[0]; } *got_frame       = 1; return buf_size; }
Description: Heap-based buffer overflow in the xwd_decode_frame function in libavcodec/xwddec.c in FFmpeg before 2.8.12, 3.0.x before 3.0.8, 3.1.x before 3.1.8, 3.2.x before 3.2.5, and 3.3.x before 3.3.1 allows remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: GVariant * g_variant_get_normal_form (GVariant *value) { GVariant *trusted; if (g_variant_is_normal_form (value)) return g_variant_ref (value); trusted = g_variant_deep_copy (value); g_assert (g_variant_is_trusted (trusted)); return g_variant_ref_sink (trusted); }
Description: A flaw was found in GLib. GVariant deserialization is vulnerable to a slowdown issue where a crafted GVariant can cause excessive processing, leading to denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: Elf64_Sym const *PackLinuxElf64::elf_lookup(char const *name) const { if (hashtab && dynsym && dynstr) { unsigned const nbucket = get_te32(&hashtab[0]); unsigned const *const buckets = &hashtab[2]; unsigned const *const chains = &buckets[nbucket]; unsigned const m = elf_hash(name) % nbucket; if (!nbucket ||  (unsigned)(file_size - ((char const *)buckets - (char const *)(void const *)file_image)) <= sizeof(unsigned)*nbucket ) { char msg[80]; snprintf(msg, sizeof(msg), ""bad nbucket %#x\n"", nbucket); throwCantPack(msg); } unsigned si; for (si= get_te32(&buckets[m]); 0!=si; si= get_te32(&chains[si])) { char const *const p= get_dynsym_name(si, (unsigned)-1); if (0==strcmp(name, p)) { return &dynsym[si]; } } } if (gashtab && dynsym && dynstr) { unsigned const n_bucket = get_te32(&gashtab[0]); unsigned const symbias  = get_te32(&gashtab[1]); unsigned const n_bitmask = get_te32(&gashtab[2]); unsigned const gnu_shift = get_te32(&gashtab[3]); upx_uint64_t const *const bitmask = (upx_uint64_t const *)(void const *)&gashtab[4]; unsigned     const *const buckets = (unsigned const *)&bitmask[n_bitmask]; unsigned     const *const hasharr = &buckets[n_bucket]; if (!n_bucket || (void const *)&file_image[file_size] <= (void const *)hasharr) { char msg[80]; snprintf(msg, sizeof(msg), ""bad n_bucket %#x\n"", n_bucket); throwCantPack(msg); } if (!n_bitmask || (unsigned)(file_size - ((char const *)bitmask - (char const *)(void const *)file_image)) <= sizeof(unsigned)*n_bitmask ) { char msg[80]; snprintf(msg, sizeof(msg), ""bad n_bitmask %#x\n"", n_bitmask); throwCantPack(msg); } unsigned const h = gnu_hash(name); unsigned const hbit1 = 077& h; unsigned const hbit2 = 077& (h>>gnu_shift); upx_uint64_t const w = get_te64(&bitmask[(n_bitmask -1) & (h>>6)]); if (1& (w>>hbit1) & (w>>hbit2)) { unsigned bucket = get_te32(&buckets[h % n_bucket]); if (n_bucket <= bucket) { char msg[80]; snprintf(msg, sizeof(msg), ""bad DT_GNU_HASH n_bucket{%#x} <= buckets[%d]{%#x}\n"", n_bucket, h % n_bucket, bucket); throwCantPack(msg); } if (0!=bucket) { Elf64_Sym const *dsp = &dynsym[bucket]; unsigned const *hp = &hasharr[bucket - symbias]; do if (0==((h ^ get_te32(hp))>>1)) { unsigned st_name = get_te32(&dsp->st_name); char const *const p = get_str_name(st_name, (unsigned)-1); if (0==strcmp(name, p)) { return dsp; } } while (++dsp, (char const *)hp < (char const *)&file_image[file_size] &&  0==(1u& get_te32(hp++))); } } } return 0; }
Description: An floating point exception was discovered in the elf_lookup function in p_lx_elf.cpp in UPX 4.0.0 via a crafted Mach-O file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void CClient::EchoMessage(const CMessage& Message) { CMessage EchoedMessage = Message; for (CClient* pClient : GetClients()) { if (pClient->HasEchoMessage() || (pClient != this && (m_pNetwork->IsChan(Message.GetParam(0)) || pClient->HasSelfMessage()))) { EchoedMessage.SetNick(GetNickMask()); pClient->PutClient(EchoedMessage); } } }
Description: ZNC 1.8.0 up to 1.8.1-rc1 allows authenticated users to trigger an application crash (with a NULL pointer dereference) if echo-message is not enabled and there is no network.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: unsigned int add_ch(unsigned char ch, unsigned char* buf, unsigned int idx) { if (idx >= MAX_ALN) { verbprintf(3, ""FLEX: idx %u >= MAX_ALN %u\n"", idx, MAX_ALN); return 0; } if (ch == 0x09 && idx < (MAX_ALN - 2)) {          buf[idx] = '\\'; buf[idx + 1] = 't'; return 2; } if (ch == 0x0a && idx < (MAX_ALN - 2)) {          buf[idx] = '\\'; buf[idx + 1] = 'n'; return 2; } if (ch == 0x0d && idx < (MAX_ALN - 2)) {          buf[idx] = '\\'; buf[idx + 1] = 'r'; return 2; } if (ch >= 32 && ch <= 126) { buf[idx] = ch; return 1; } return 0; }
Description: A vulnerability was found in multimon-ng. It has been rated as critical. This issue affects the function add_ch of the file demod_flex.c. The manipulation of the argument ch leads to format string. Upgrading to version 1.2.0 is able to address this issue. The name of the patch is e5a51c508ef952e81a6da25b43034dd1ed023c07. It is recommended to upgrade the affected component. The identifier VDB-216269 was assigned to this vulnerability.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int mem_write(jas_stream_obj_t *obj, char *buf, int cnt) { int n; int ret; jas_stream_memobj_t *m = (jas_stream_memobj_t *)obj; long newbufsize; long newpos; assert(buf); assert(cnt >= 0); JAS_DBGLOG(100, (""mem_write(%p, %p, %d)\n"", obj, buf, cnt)); newpos = m->pos_ + cnt; if (newpos > m->bufsize_ && m->growable_) { newbufsize = m->bufsize_; while (newbufsize < newpos) { newbufsize <<= 1; assert(newbufsize >= 0); } JAS_DBGLOG(100, (""mem_write resizing from %d to %z\n"", m->bufsize_, newbufsize)); JAS_DBGLOG(100, (""mem_write resizing from %d to %ul\n"", m->bufsize_, JAS_CAST(unsigned long, newbufsize))); if (mem_resize(m, newbufsize)) { return -1; } } if (m->pos_ > m->len_) { n = JAS_MIN(m->pos_, m->bufsize_) - m->len_; if (n > 0) { memset(&m->buf_[m->len_], 0, n); m->len_ += n; } if (m->pos_ != m->len_) { return 0; } } n = m->bufsize_ - m->pos_; ret = JAS_MIN(n, cnt); if (ret > 0) { memcpy(&m->buf_[m->pos_], buf, ret); m->pos_ += ret; } if (m->pos_ > m->len_) { m->len_ = m->pos_; } assert(ret == cnt); return ret; }
Description: Multiple integer overflows in the (1) jas_realloc function in base/jas_malloc.c and (2) mem_resize function in base/jas_stream.c in JasPer before 1.900.22 allow remote attackers to cause a denial of service via a crafted image, which triggers use after free vulnerabilities.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int nfqnl_mangle(void *data, int data_len, struct nf_queue_entry *e, int diff) { struct sk_buff *nskb; if (diff < 0) { if (pskb_trim(e->skb, data_len)) return -ENOMEM; } else if (diff > 0) { if (data_len > 0xFFFF) return -EINVAL; if (diff > skb_tailroom(e->skb)) { nskb = skb_copy_expand(e->skb, skb_headroom(e->skb), diff, GFP_ATOMIC); if (!nskb) return -ENOMEM; kfree_skb(e->skb); e->skb = nskb; } skb_put(e->skb, diff); } if (skb_ensure_writable(e->skb, data_len)) return -ENOMEM; skb_copy_to_linear_data(e->skb, data, data_len); e->skb->ip_summed = CHECKSUM_NONE; return 0; }
Description: nfqnl_mangle in net/netfilter/nfnetlink_queue.c in the Linux kernel through 5.18.14 allows remote attackers to cause a denial of service (panic) because, in the case of an nf_queue verdict with a one-byte nfta_payload attribute, an skb_pull can encounter a negative skb->len.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: GSWindow * gs_window_new (GdkDisplay *display, GdkMonitor *monitor, gboolean   lock_enabled) { GObject   *result; GdkScreen *screen = gdk_display_get_default_screen (display); result = g_object_new (GS_TYPE_WINDOW, ""type"", GTK_WINDOW_POPUP, ""screen"", screen, ""monitor"", monitor, ""lock-enabled"", lock_enabled, ""app-paintable"", TRUE, NULL); return GS_WINDOW (result); }
Description: mate-screensaver before 1.20.2 in MATE Desktop Environment allows physically proximate attackers to view screen content and possibly control applications. By unplugging and re-plugging or power-cycling external output devices (such as additionally attached graphical outputs via HDMI, VGA, DVI, etc.) the content of a screensaver-locked session can be revealed. In some scenarios, the attacker can execute applications, such as by clicking with a mouse.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: V8ContextNativeHandler::V8ContextNativeHandler(ScriptContext* context) : ObjectBackedNativeHandler(context), context_(context) { RouteFunction(""GetAvailability"", base::Bind(&V8ContextNativeHandler::GetAvailability, base::Unretained(this))); RouteFunction(""GetModuleSystem"", base::Bind(&V8ContextNativeHandler::GetModuleSystem, base::Unretained(this))); RouteFunction( ""RunWithNativesEnabled"", base::Bind(&V8ContextNativeHandler::RunWithNativesEnabled, base::Unretained(this))); }
Description: The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void nbd_trip(void *opaque) { NBDClient *client = opaque; NBDExport *exp = client->exp; NBDRequestData *req; NBDRequest request; NBDReply reply; ssize_t ret; int flags; TRACE(""Reading request.""); if (client->closing) { return; } req = nbd_request_get(client); ret = nbd_co_receive_request(req, &request); if (ret == -EAGAIN) { goto done; } if (ret == -EIO) { goto out; } reply.handle = request.handle; reply.error = 0; if (ret < 0) { reply.error = -ret; goto error_reply; } if (client->closing) { goto done; } switch (request.type) { case NBD_CMD_READ: TRACE(""Request type is READ""); if (request.flags & NBD_CMD_FLAG_FUA) { ret = blk_co_flush(exp->blk); if (ret < 0) { LOG(""flush failed""); reply.error = -ret; goto error_reply; } } ret = blk_pread(exp->blk, request.from + exp->dev_offset, req->data, request.len); if (ret < 0) { LOG(""reading from file failed""); reply.error = -ret; goto error_reply; } TRACE(""Read %"" PRIu32"" byte(s)"", request.len); if (nbd_co_send_reply(req, &reply, request.len) < 0) goto out; break; case NBD_CMD_WRITE: TRACE(""Request type is WRITE""); if (exp->nbdflags & NBD_FLAG_READ_ONLY) { TRACE(""Server is read-only, return error""); reply.error = EROFS; goto error_reply; } TRACE(""Writing to device""); flags = 0; if (request.flags & NBD_CMD_FLAG_FUA) { flags |= BDRV_REQ_FUA; } ret = blk_pwrite(exp->blk, request.from + exp->dev_offset, req->data, request.len, flags); if (ret < 0) { LOG(""writing to file failed""); reply.error = -ret; goto error_reply; } if (nbd_co_send_reply(req, &reply, 0) < 0) { goto out; } break; case NBD_CMD_WRITE_ZEROES: TRACE(""Request type is WRITE_ZEROES""); if (exp->nbdflags & NBD_FLAG_READ_ONLY) { TRACE(""Server is read-only, return error""); reply.error = EROFS; goto error_reply; } TRACE(""Writing to device""); flags = 0; if (request.flags & NBD_CMD_FLAG_FUA) { flags |= BDRV_REQ_FUA; } if (!(request.flags & NBD_CMD_FLAG_NO_HOLE)) { flags |= BDRV_REQ_MAY_UNMAP; } ret = blk_pwrite_zeroes(exp->blk, request.from + exp->dev_offset, request.len, flags); if (ret < 0) { LOG(""writing to file failed""); reply.error = -ret; goto error_reply; } if (nbd_co_send_reply(req, &reply, 0) < 0) { goto out; } break; case NBD_CMD_DISC: abort(); case NBD_CMD_FLUSH: TRACE(""Request type is FLUSH""); ret = blk_co_flush(exp->blk); if (ret < 0) { LOG(""flush failed""); reply.error = -ret; } if (nbd_co_send_reply(req, &reply, 0) < 0) { goto out; } break; case NBD_CMD_TRIM: TRACE(""Request type is TRIM""); ret = blk_co_pdiscard(exp->blk, request.from + exp->dev_offset, request.len); if (ret < 0) { LOG(""discard failed""); reply.error = -ret; } if (nbd_co_send_reply(req, &reply, 0) < 0) { goto out; } break; default: LOG(""invalid request type (%"" PRIu32 "") received"", request.type); reply.error = EINVAL; error_reply: if (nbd_co_send_reply(req, &reply, 0) < 0 || !req->complete) { goto out; } break; } TRACE(""Request/Reply complete""); done: nbd_request_put(req); return; out: nbd_request_put(req); client_close(client); }
Description: An assertion-failure flaw was found in Qemu before 2.10.1, in the Network Block Device (NBD) server's initial connection negotiation, where the I/O coroutine was undefined. This could crash the qemu-nbd server if a client sent unexpected data during connection negotiation. A remote user or process could use this flaw to crash the qemu-nbd server resulting in denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void _pci_cleanup_msix(struct arch_msix *msix) { if ( !--msix->used_entries ) { if ( rangeset_remove_range(mmio_ro_ranges, msix->table.first, msix->table.last) ) WARN(); if ( rangeset_remove_range(mmio_ro_ranges, msix->pba.first, msix->pba.last) ) WARN(); } }
Description: An issue was discovered in Xen through 4.14.x. The PCI passthrough code improperly uses register data. Code paths in Xen's MSI handling have been identified that act on unsanitized values read back from device hardware registers. While devices strictly compliant with PCI specifications shouldn't be able to affect these registers, experience shows that it's very common for devices to have out-of-spec ""backdoor"" operations that can affect the result of these reads. A not fully trusted guest may be able to crash Xen, leading to a Denial of Service (DoS) for the entire system. Privilege escalation and information leaks cannot be excluded. All versions of Xen supporting PCI passthrough are affected. Only x86 systems are vulnerable. Arm systems are not vulnerable. Only guests with passed through PCI devices may be able to leverage the vulnerability. Only systems passing through devices with out-of-spec (""backdoor"") functionality can cause issues. Experience shows that such out-of-spec functionality is common; unless you have reason to believe that your device does not have such functionality, it's better to assume that it does.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: AP4_AvccAtom::AP4_AvccAtom(AP4_UI32 size, const AP4_UI08* payload) : AP4_Atom(AP4_ATOM_TYPE_AVCC, size) { unsigned int payload_size = size-AP4_ATOM_HEADER_SIZE; m_RawBytes.SetData(payload, payload_size); m_ConfigurationVersion = payload[0]; m_Profile              = payload[1]; m_ProfileCompatibility = payload[2]; m_Level                = payload[3]; m_NaluLengthSize       = 1+(payload[4]&3); AP4_UI08 num_seq_params = payload[5]&31; m_SequenceParameters.EnsureCapacity(num_seq_params); unsigned int cursor = 6; for (unsigned int i=0; i<num_seq_params; i++) { m_SequenceParameters.Append(AP4_DataBuffer()); AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]); m_SequenceParameters[i].SetData(&payload[cursor]+2, param_length); cursor += 2+param_length; } AP4_UI08 num_pic_params = payload[cursor++]; m_PictureParameters.EnsureCapacity(num_pic_params); for (unsigned int i=0; i<num_pic_params; i++) { m_PictureParameters.Append(AP4_DataBuffer()); AP4_UI16 param_length = AP4_BytesToInt16BE(&payload[cursor]); m_PictureParameters[i].SetData(&payload[cursor]+2, param_length); cursor += 2+param_length; } }
Description: The AP4_AvccAtom and AP4_HvccAtom classes in Bento4 version 1.5.0-617 do not properly validate data sizes, leading to a heap-based buffer over-read and application crash in AP4_DataBuffer::SetData in Core/Ap4DataBuffer.cpp.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int kvm_read_guest_virt(struct kvm_vcpu *vcpu, gva_t addr, void *val, unsigned int bytes, struct x86_exception *exception) { u32 access = (kvm_x86_ops->get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0; return kvm_read_guest_virt_helper(addr, val, bytes, vcpu, access, exception); }
Description: The KVM implementation in the Linux kernel through 4.20.5 has an Information Leak.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: omx_vdec::omx_vdec(): m_error_propogated(false), m_state(OMX_StateInvalid), m_app_data(NULL), m_inp_mem_ptr(NULL), m_out_mem_ptr(NULL), input_flush_progress (false), output_flush_progress (false), input_use_buffer (false), output_use_buffer (false), ouput_egl_buffers(false), m_use_output_pmem(OMX_FALSE), m_out_mem_region_smi(OMX_FALSE), m_out_pvt_entry_pmem(OMX_FALSE), pending_input_buffers(0), pending_output_buffers(0), m_out_bm_count(0), m_inp_bm_count(0), m_inp_bPopulated(OMX_FALSE), m_out_bPopulated(OMX_FALSE), m_flags(0), #ifdef _ANDROID_ m_heap_ptr(NULL), #endif m_inp_bEnabled(OMX_TRUE), m_out_bEnabled(OMX_TRUE), m_in_alloc_cnt(0), m_platform_list(NULL), m_platform_entry(NULL), m_pmem_info(NULL), h264_parser(NULL), arbitrary_bytes (true), psource_frame (NULL), pdest_frame (NULL), m_inp_heap_ptr (NULL), m_phdr_pmem_ptr(NULL), m_heap_inp_bm_count (0), codec_type_parse ((codec_type)0), first_frame_meta (true), frame_count (0), nal_count (0), nal_length(0), look_ahead_nal (false), first_frame(0), first_buffer(NULL), first_frame_size (0), m_device_file_ptr(NULL), m_vc1_profile((vc1_profile_type)0), h264_last_au_ts(LLONG_MAX), h264_last_au_flags(0), m_disp_hor_size(0), m_disp_vert_size(0), prev_ts(LLONG_MAX), rst_prev_ts(true), frm_int(0), in_reconfig(false), m_display_id(NULL), client_extradata(0), m_reject_avc_1080p_mp (0), #ifdef _ANDROID_ m_enable_android_native_buffers(OMX_FALSE), m_use_android_native_buffers(OMX_FALSE), iDivXDrmDecrypt(NULL), #endif m_desc_buffer_ptr(NULL), secure_mode(false), m_other_extradata(NULL), m_profile(0), client_set_fps(false), m_last_rendered_TS(-1), m_queued_codec_config_count(0), secure_scaling_to_non_secure_opb(false) { DEBUG_PRINT_HIGH(""In %u bit OMX vdec Constructor"", (unsigned int)sizeof(long) * 8); memset(&m_debug,0,sizeof(m_debug)); #ifdef _ANDROID_ char property_value[PROPERTY_VALUE_MAX] = {0}; property_get(""vidc.debug.level"", property_value, ""1""); debug_level = atoi(property_value); property_value[0] = '\0'; DEBUG_PRINT_HIGH(""In OMX vdec Constructor""); property_get(""vidc.dec.debug.perf"", property_value, ""0""); perf_flag = atoi(property_value); if (perf_flag) { DEBUG_PRINT_HIGH(""vidc.dec.debug.perf is %d"", perf_flag); dec_time.start(); proc_frms = latency = 0; } prev_n_filled_len = 0; property_value[0] = '\0'; property_get(""vidc.dec.debug.ts"", property_value, ""0""); m_debug_timestamp = atoi(property_value); DEBUG_PRINT_HIGH(""vidc.dec.debug.ts value is %d"",m_debug_timestamp); if (m_debug_timestamp) { time_stamp_dts.set_timestamp_reorder_mode(true); time_stamp_dts.enable_debug_print(true); } property_value[0] = '\0'; property_get(""vidc.dec.debug.concealedmb"", property_value, ""0""); m_debug_concealedmb = atoi(property_value); DEBUG_PRINT_HIGH(""vidc.dec.debug.concealedmb value is %d"",m_debug_concealedmb); property_value[0] = '\0'; property_get(""vidc.dec.profile.check"", property_value, ""0""); m_reject_avc_1080p_mp = atoi(property_value); DEBUG_PRINT_HIGH(""vidc.dec.profile.check value is %d"",m_reject_avc_1080p_mp); property_value[0] = '\0'; property_get(""vidc.dec.log.in"", property_value, ""0""); m_debug.in_buffer_log = atoi(property_value); property_value[0] = '\0'; property_get(""vidc.dec.log.out"", property_value, ""0""); m_debug.out_buffer_log = atoi(property_value); sprintf(m_debug.log_loc, ""%s"", BUFFER_LOG_LOC); property_value[0] = '\0'; property_get(""vidc.log.loc"", property_value, """"); if (*property_value) strlcpy(m_debug.log_loc, property_value, PROPERTY_VALUE_MAX); property_value[0] = '\0'; property_get(""vidc.dec.120fps.enabled"", property_value, ""0""); if(atoi(property_value)) { DEBUG_PRINT_LOW(""feature 120 FPS decode enabled""); m_last_rendered_TS = 0; } property_value[0] = '\0'; property_get(""vidc.dec.debug.dyn.disabled"", property_value, ""0""); m_disable_dynamic_buf_mode = atoi(property_value); DEBUG_PRINT_HIGH(""vidc.dec.debug.dyn.disabled value is %d"",m_disable_dynamic_buf_mode); #endif memset(&m_cmp,0,sizeof(m_cmp)); memset(&m_cb,0,sizeof(m_cb)); memset (&drv_ctx,0,sizeof(drv_ctx)); memset (&h264_scratch,0,sizeof (OMX_BUFFERHEADERTYPE)); memset (m_hwdevice_name,0,sizeof(m_hwdevice_name)); memset(m_demux_offsets, 0, ( sizeof(OMX_U32) * 8192) ); memset(&m_custom_buffersize, 0, sizeof(m_custom_buffersize)); m_demux_entries = 0; msg_thread_id = 0; async_thread_id = 0; msg_thread_created = false; async_thread_created = false; #ifdef _ANDROID_ICS_ memset(&native_buffer, 0 ,(sizeof(struct nativebuffer) * MAX_NUM_INPUT_OUTPUT_BUFFERS)); #endif memset(&drv_ctx.extradata_info, 0, sizeof(drv_ctx.extradata_info)); memset(&m_frame_pack_arrangement, 0, sizeof(OMX_QCOM_FRAME_PACK_ARRANGEMENT)); m_frame_pack_arrangement.cancel_flag = 1; drv_ctx.timestamp_adjust = false; drv_ctx.video_driver_fd = -1; m_vendor_config.pData = NULL; pthread_mutex_init(&m_lock, NULL); pthread_mutex_init(&c_lock, NULL); sem_init(&m_cmd_lock,0,0); sem_init(&m_safe_flush, 0, 0); streaming[CAPTURE_PORT] = streaming[OUTPUT_PORT] = false; #ifdef _ANDROID_ char extradata_value[PROPERTY_VALUE_MAX] = {0}; property_get(""vidc.dec.debug.extradata"", extradata_value, ""0""); m_debug_extradata = atoi(extradata_value); DEBUG_PRINT_HIGH(""vidc.dec.debug.extradata value is %d"",m_debug_extradata); #endif m_fill_output_msg = OMX_COMPONENT_GENERATE_FTB; client_buffers.set_vdec_client(this); dynamic_buf_mode = false; out_dynamic_list = NULL; is_down_scalar_enabled = false; m_smoothstreaming_mode = false; m_smoothstreaming_width = 0; m_smoothstreaming_height = 0; is_q6_platform = false; }
Description: Use-after-free vulnerability in the mm-video-v4l2 vdec component in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-07-01 allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 27890802.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static MagickBooleanType WriteJP2Image(const ImageInfo *image_info,Image *image, ExceptionInfo *exception) { const char *option, *property; int jp2_status; MagickBooleanType status; opj_codec_t *jp2_codec; OPJ_COLOR_SPACE jp2_colorspace; opj_cparameters_t *parameters; opj_image_cmptparm_t jp2_info[5]; opj_image_t *jp2_image; opj_stream_t *jp2_stream; ssize_t i; ssize_t y; unsigned int channels; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); assert(image != (Image *) NULL); assert(image->signature == MagickCoreSignature); if (image->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); status=OpenBlob(image_info,image,WriteBinaryBlobMode,exception); if (status == MagickFalse) return(status); parameters=(opj_cparameters_t *) AcquireMagickMemory(sizeof(*parameters)); if (parameters == (opj_cparameters_t *) NULL) ThrowWriterException(ResourceLimitError,""MemoryAllocationFailed""); opj_set_default_encoder_parameters(parameters); option=GetImageOption(image_info,""jp2:number-resolutions""); if (option != (const char *) NULL) parameters->numresolution=StringToInteger(option); else parameters->numresolution=CalculateNumResolutions(image->columns, image->rows); parameters->tcp_numlayers=1; parameters->tcp_rates[0]=0;   parameters->cp_disto_alloc=1; if ((image_info->quality != 0) && (image_info->quality != 100)) { parameters->tcp_distoratio[0]=(double) image_info->quality; parameters->cp_fixed_quality=OPJ_TRUE; parameters->cp_disto_alloc=0; } if (image_info->extract != (char *) NULL) { RectangleInfo geometry; int flags; (void) memset(&geometry,0,sizeof(geometry)); flags=ParseAbsoluteGeometry(image_info->extract,&geometry); parameters->cp_tdx=(int) geometry.width; parameters->cp_tdy=(int) geometry.width; if ((flags & HeightValue) != 0) parameters->cp_tdy=(int) geometry.height; if ((flags & XValue) != 0) parameters->cp_tx0=geometry.x; if ((flags & YValue) != 0) parameters->cp_ty0=geometry.y; parameters->tile_size_on=OPJ_TRUE; parameters->numresolution=CalculateNumResolutions(parameters->cp_tdx, parameters->cp_tdy); } option=GetImageOption(image_info,""jp2:quality""); if (option != (const char *) NULL) { const char *p; p=option; for (i=0; sscanf(p,""%f"",&parameters->tcp_distoratio[i]) == 1; i++) { if (i > 100) break; while ((*p != '\0') && (*p != ',')) p++; if (*p == '\0') break; p++; } parameters->tcp_numlayers=i+1; parameters->cp_fixed_quality=OPJ_TRUE; parameters->cp_disto_alloc=0; } option=GetImageOption(image_info,""jp2:progression-order""); if (option != (const char *) NULL) { if (LocaleCompare(option,""LRCP"") == 0) parameters->prog_order=OPJ_LRCP; if (LocaleCompare(option,""RLCP"") == 0) parameters->prog_order=OPJ_RLCP; if (LocaleCompare(option,""RPCL"") == 0) parameters->prog_order=OPJ_RPCL; if (LocaleCompare(option,""PCRL"") == 0) parameters->prog_order=OPJ_PCRL; if (LocaleCompare(option,""CPRL"") == 0) parameters->prog_order=OPJ_CPRL; } option=GetImageOption(image_info,""jp2:rate""); if (option != (const char *) NULL) { const char *p; p=option; for (i=0; sscanf(p,""%f"",&parameters->tcp_rates[i]) == 1; i++) { if (i >= 100) break; while ((*p != '\0') && (*p != ',')) p++; if (*p == '\0') break; p++; } parameters->tcp_numlayers=i+1; parameters->cp_disto_alloc=OPJ_TRUE; } if (image_info->sampling_factor != (const char *) NULL) (void) sscanf(image_info->sampling_factor,""%d,%d"", &parameters->subsampling_dx,&parameters->subsampling_dy); property=GetImageProperty(image,""comment"",exception); if (property != (const char *) NULL) parameters->cp_comment=(char *) property; channels=3; jp2_colorspace=OPJ_CLRSPC_SRGB; if (image->colorspace == YUVColorspace) { jp2_colorspace=OPJ_CLRSPC_SYCC; parameters->subsampling_dx=2; } else { if (IsGrayColorspace(image->colorspace) != MagickFalse) { channels=1; jp2_colorspace=OPJ_CLRSPC_GRAY; } else (void) TransformImageColorspace(image,sRGBColorspace,exception); if (image->alpha_trait != UndefinedPixelTrait) channels++; } parameters->tcp_mct=channels == 3 ? 1 : 0; memset(jp2_info,0,sizeof(jp2_info)); for (i=0; i < (ssize_t) channels; i++) { jp2_info[i].prec=(OPJ_UINT32) image->depth; jp2_info[i].bpp=(OPJ_UINT32) image->depth; if ((image->depth == 1) && ((LocaleCompare(image_info->magick,""JPT"") == 0) || (LocaleCompare(image_info->magick,""JP2"") == 0))) { jp2_info[i].prec++;   jp2_info[i].bpp++; } jp2_info[i].sgnd=0; jp2_info[i].dx=parameters->subsampling_dx; jp2_info[i].dy=parameters->subsampling_dy; jp2_info[i].w=(OPJ_UINT32) image->columns; jp2_info[i].h=(OPJ_UINT32) image->rows; } jp2_image=opj_image_create((OPJ_UINT32) channels,jp2_info,jp2_colorspace); if (jp2_image == (opj_image_t *) NULL) { parameters=(opj_cparameters_t *) RelinquishMagickMemory(parameters); ThrowWriterException(DelegateError,""UnableToEncodeImageFile""); } jp2_image->x0=parameters->image_offset_x0; jp2_image->y0=parameters->image_offset_y0; jp2_image->x1=(unsigned int) (2*parameters->image_offset_x0+ (image->columns-1)*parameters->subsampling_dx+1); jp2_image->y1=(unsigned int) (2*parameters->image_offset_y0+ (image->rows-1)*parameters->subsampling_dx+1); if ((image->depth == 12) && ((image->columns == 2048) || (image->rows == 1080) || (image->columns == 4096) || (image->rows == 2160))) CinemaProfileCompliance(jp2_image,parameters); if (channels == 4) jp2_image->comps[3].alpha=1; else if ((channels == 2) && (jp2_colorspace == OPJ_CLRSPC_GRAY)) jp2_image->comps[1].alpha=1; for (y=0; y < (ssize_t) image->rows; y++) { const Quantum *p; ssize_t x; p=GetVirtualPixels(image,0,y,image->columns,1,exception); if (p == (const Quantum *) NULL) break; for (x=0; x < (ssize_t) image->columns; x++) { for (i=0; i < (ssize_t) channels; i++) { double scale; int *q; scale=(double) (((size_t) 1UL << jp2_image->comps[i].prec)-1)/ QuantumRange; q=jp2_image->comps[i].data+(y/jp2_image->comps[i].dy* image->columns/jp2_image->comps[i].dx+x/jp2_image->comps[i].dx); switch (i) { case 0: { if (jp2_colorspace == OPJ_CLRSPC_GRAY) { *q=(int) (scale*GetPixelGray(image,p)); break; } *q=(int) (scale*GetPixelRed(image,p)); break; } case 1: { if (jp2_colorspace == OPJ_CLRSPC_GRAY) { *q=(int) (scale*GetPixelAlpha(image,p)); break; } *q=(int) (scale*GetPixelGreen(image,p)); break; } case 2: { *q=(int) (scale*GetPixelBlue(image,p)); break; } case 3: { *q=(int) (scale*GetPixelAlpha(image,p)); break; } } } p+=GetPixelChannels(image); } status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y, image->rows); if (status == MagickFalse) break; } if (LocaleCompare(image_info->magick,""JPT"") == 0) jp2_codec=opj_create_compress(OPJ_CODEC_JPT); else if (LocaleCompare(image_info->magick,""J2K"") == 0) jp2_codec=opj_create_compress(OPJ_CODEC_J2K); else jp2_codec=opj_create_compress(OPJ_CODEC_JP2); opj_set_warning_handler(jp2_codec,JP2WarningHandler,exception); opj_set_error_handler(jp2_codec,JP2ErrorHandler,exception); opj_setup_encoder(jp2_codec,parameters,jp2_image); jp2_stream=opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,OPJ_FALSE); if (jp2_stream == (opj_stream_t *) NULL) { opj_destroy_codec(jp2_codec); opj_image_destroy(jp2_image); parameters=(opj_cparameters_t *) RelinquishMagickMemory(parameters); ThrowWriterException(DelegateError,""UnableToEncodeImageFile""); } opj_stream_set_read_function(jp2_stream,JP2ReadHandler); opj_stream_set_write_function(jp2_stream,JP2WriteHandler); opj_stream_set_seek_function(jp2_stream,JP2SeekHandler); opj_stream_set_skip_function(jp2_stream,JP2SkipHandler); opj_stream_set_user_data(jp2_stream,image,NULL); jp2_status=opj_start_compress(jp2_codec,jp2_image,jp2_stream); if ((jp2_status == 0) || (opj_encode(jp2_codec,jp2_stream) == 0) || (opj_end_compress(jp2_codec,jp2_stream) == 0)) { opj_stream_destroy(jp2_stream); opj_destroy_codec(jp2_codec); opj_image_destroy(jp2_image); parameters=(opj_cparameters_t *) RelinquishMagickMemory(parameters); ThrowWriterException(DelegateError,""UnableToEncodeImageFile""); } opj_stream_destroy(jp2_stream); opj_destroy_codec(jp2_codec); opj_image_destroy(jp2_image); parameters=(opj_cparameters_t *) RelinquishMagickMemory(parameters); (void) CloseBlob(image); return(MagickTrue); }
Description: A flaw was found in ImageMagick in coders/jp2.c. An attacker who submits a crafted file that is processed by ImageMagick could trigger undefined behavior in the form of math division by zero. The highest threat from this vulnerability is to system availability.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: enum ImapAuthRes imap_auth_cram_md5(struct ImapData *idata, const char *method) { char ibuf[LONG_STRING * 2], obuf[LONG_STRING]; unsigned char hmac_response[MD5_DIGEST_LEN]; int len; int rc; if (!mutt_bit_isset(idata->capabilities, ACRAM_MD5)) return IMAP_AUTH_UNAVAIL; mutt_message(_(""Authenticating (CRAM-MD5)..."")); if (mutt_account_getlogin(&idata->conn->account) < 0) return IMAP_AUTH_FAILURE; if (mutt_account_getpass(&idata->conn->account) < 0) return IMAP_AUTH_FAILURE; imap_cmd_start(idata, ""AUTHENTICATE CRAM-MD5""); do rc = imap_cmd_step(idata); while (rc == IMAP_CMD_CONTINUE); if (rc != IMAP_CMD_RESPOND) { mutt_debug(1, ""Invalid response from server: %s\n"", ibuf); goto bail; } len = mutt_b64_decode(obuf, idata->buf + 2); if (len == -1) { mutt_debug(1, ""Error decoding base64 response.\n""); goto bail; } obuf[len] = '\0'; mutt_debug(2, ""CRAM challenge: %s\n"", obuf); hmac_md5(idata->conn->account.pass, obuf, hmac_response); int off = snprintf(obuf, sizeof(obuf), ""%s "", idata->conn->account.user); mutt_md5_toascii(hmac_response, obuf + off); mutt_debug(2, ""CRAM response: %s\n"", obuf); mutt_b64_encode(ibuf, obuf, strlen(obuf), sizeof(ibuf) - 2); mutt_str_strcat(ibuf, sizeof(ibuf), ""\r\n""); mutt_socket_send(idata->conn, ibuf); do rc = imap_cmd_step(idata); while (rc == IMAP_CMD_CONTINUE); if (rc != IMAP_CMD_OK) { mutt_debug(1, ""Error receiving server response.\n""); goto bail; } if (imap_code(idata->buf)) return IMAP_AUTH_SUCCESS; bail: mutt_error(_(""CRAM-MD5 authentication failed."")); return IMAP_AUTH_FAILURE; }
Description: An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They have a buffer overflow via base64 data.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void StreamTcpPacketSetState(Packet *p, TcpSession *ssn, uint8_t state) { if (state == ssn->state || PKT_IS_PSEUDOPKT(p)) return; ssn->state = state; switch(ssn->state) { case TCP_ESTABLISHED: case TCP_FIN_WAIT1: case TCP_FIN_WAIT2: case TCP_CLOSING: case TCP_CLOSE_WAIT: FlowUpdateState(p->flow, FLOW_STATE_ESTABLISHED); break; case TCP_LAST_ACK: case TCP_TIME_WAIT: case TCP_CLOSED: FlowUpdateState(p->flow, FLOW_STATE_CLOSED); break; } }
Description: Suricata before 4.0.5 stops TCP stream inspection upon a TCP RST from a server. This allows detection bypass because Windows TCP clients proceed with normal processing of TCP data that arrives shortly after an RST (i.e., they act as if the RST had not yet been received).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static Image *ReadPESImage(const ImageInfo *image_info,ExceptionInfo *exception) { char filename[MagickPathExtent]; FILE *file; Image *image; ImageInfo *read_info; int delta_x, delta_y, j, unique_file, x, y; MagickBooleanType status; PESBlockInfo blocks[256]; PointInfo *stitches; SegmentInfo bounds; register ssize_t i; size_t number_blocks, number_colors, number_stitches; ssize_t count, offset; unsigned char magick[4], version[4]; assert(image_info != (const ImageInfo *) NULL); assert(image_info->signature == MagickCoreSignature); if (image_info->debug != MagickFalse) (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"", image_info->filename); assert(exception != (ExceptionInfo *) NULL); assert(exception->signature == MagickCoreSignature); image=AcquireImage(image_info,exception); status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception); if (status == MagickFalse) { image=DestroyImageList(image); return((Image *) NULL); } count=ReadBlob(image,4,magick); if ((count != 4) || (LocaleNCompare((char *) magick,""#PES"",4) != 0)) ThrowReaderException(CorruptImageError,""ImproperImageHeader""); count=ReadBlob(image,4,version); offset=ReadBlobLSBSignedLong(image); if (DiscardBlobBytes(image,offset+36) == MagickFalse) ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"", image->filename); if (EOFBlob(image) != MagickFalse) ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile""); number_colors=(size_t) ReadBlobByte(image)+1; for (i=0; i < (ssize_t) number_colors; i++) { j=ReadBlobByte(image); blocks[i].color=PESColor+(j < 0 ? 0 : j); blocks[i].offset=0; } for ( ; i < 256L; i++) { blocks[i].offset=0; blocks[i].color=PESColor; } if (DiscardBlobBytes(image,532L-number_colors-21) == MagickFalse) ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"", image->filename); if (EOFBlob(image) != MagickFalse) ThrowReaderException(CorruptImageError,""UnexpectedEndOfFile""); number_stitches=64; stitches=(PointInfo *) AcquireQuantumMemory(number_stitches, sizeof(*stitches)); if (stitches == (PointInfo *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); bounds.x1=65535.0; bounds.y1=65535.0; bounds.x2=(-65535.0); bounds.y2=(-65535.0); i=0; j=0; delta_x=0; delta_y=0; while (EOFBlob(image) == MagickFalse) { x=ReadBlobByte(image); y=ReadBlobByte(image); if ((x == 0xff) && (y == 0)) break; if ((x == 254) && (y == 176)) { j++; blocks[j].offset=(ssize_t) i; if (j >= 256) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); (void) ReadBlobByte(image); continue; } if ((x & 0x80) == 0) { if ((x & 0x40) != 0) x-=0x80; } else { x=((x & 0x0f) << 8)+y; if ((x & 0x800) != 0) x-=0x1000; y=ReadBlobByte(image); } if ((y & 0x80) == 0) { if ((y & 0x40) != 0) y-=0x80; } else { y=((y & 0x0f) << 8)+ReadBlobByte(image); if ((y & 0x800) != 0) y-=0x1000; } x+=delta_x; y+=delta_y; delta_x=x; delta_y=y; stitches[i].x=(double) x; stitches[i].y=(double) y; if ((double) x < bounds.x1) bounds.x1=(double) x; if ((double) x > bounds.x2) bounds.x2=(double) x; if ((double) y < bounds.y1) bounds.y1=(double) y; if ((double) y > bounds.y2) bounds.y2=(double) y; i++; if (i >= (ssize_t) number_stitches) { number_stitches<<=1; stitches=(PointInfo *)  ResizeQuantumMemory(stitches,(size_t) number_stitches,sizeof(*stitches)); if (stitches == (PointInfo *) NULL) ThrowReaderException(ResourceLimitError,""MemoryAllocationFailed""); } } j++; blocks[j].offset=(ssize_t) i; number_blocks=(size_t) j; image->columns=bounds.x2-bounds.x1; image->rows=bounds.y2-bounds.y1; status=SetImageExtent(image,image->columns,image->rows,exception); if (status == MagickFalse) return(DestroyImageList(image)); file=(FILE *) NULL; unique_file=AcquireUniqueFileResource(filename); if (unique_file != -1) file=fdopen(unique_file,""wb""); if ((unique_file == -1) || (file == (FILE *) NULL)) ThrowImageException(FileOpenError,""UnableToCreateTemporaryFile""); (void) FormatLocaleFile(file,""<?xml version=\""1.0\""?>\n""); (void) FormatLocaleFile(file,""<svg xmlns=\""http:    ""xlink=\""http:    ""ev=\""http:    ""baseProfile=\""full\"" width=\""%g\"" height=\""%g\"">\n"",(double) image->columns,(double) image->rows); for (i=0; i < (ssize_t) number_blocks; i++) { offset=blocks[i].offset; (void) FormatLocaleFile(file,""  <path stroke=\""#%02x%02x%02x\"" "" ""fill=\""none\"" d=\""M %g %g"",blocks[i].color->red,blocks[i].color->green, blocks[i].color->blue,stitches[offset].x-bounds.x1, stitches[offset].y-bounds.y1); for (j=1; j < (ssize_t) (blocks[i+1].offset-offset); j++) (void) FormatLocaleFile(file,"" L %g %g"",stitches[offset+j].x-bounds.x1, stitches[offset+j].y-bounds.y1); (void) FormatLocaleFile(file,""\""/>\n""); } (void) FormatLocaleFile(file,""</svg>\n""); (void) fclose(file); (void) CloseBlob(image); image=DestroyImage(image); read_info=CloneImageInfo(image_info); SetImageInfoBlob(read_info,(void *) NULL,0); (void) FormatLocaleString(read_info->filename,MagickPathExtent,""svg:%s"", filename); image=ReadImage(read_info,exception); if (image != (Image *) NULL) { (void) CopyMagickString(image->filename,image_info->filename, MagickPathExtent); (void) CopyMagickString(image->magick_filename,image_info->filename, MagickPathExtent); (void) CopyMagickString(image->magick,""PES"",MagickPathExtent); } read_info=DestroyImageInfo(read_info); (void) RelinquishUniqueFileResource(filename); return(GetFirstImageInList(image)); }
Description: In ImageMagick 7.0.6-1, a memory leak vulnerability was found in the function ReadPESImage in coders/pes.c, which allows attackers to cause a denial of service, related to ResizeMagickMemory in memory.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int init_device (u2fh_devs * devs, struct u2fdevice *dev) { unsigned char resp[1024]; unsigned char nonce[8]; if (obtain_nonce(nonce) != 0) { return U2FH_TRANSPORT_ERROR; } size_t resplen = sizeof (resp); dev->cid = CID_BROADCAST; if (u2fh_sendrecv (devs, dev->id, U2FHID_INIT, nonce, sizeof (nonce), resp, &resplen) == U2FH_OK) { U2FHID_INIT_RESP initresp; if (resplen > sizeof (initresp)) { return U2FH_MEMORY_ERROR; } memcpy (&initresp, resp, resplen); dev->cid = initresp.cid; dev->versionInterface = initresp.versionInterface; dev->versionMajor = initresp.versionMajor; dev->versionMinor = initresp.versionMinor; dev->capFlags = initresp.capFlags; } else { return U2FH_TRANSPORT_ERROR; } return U2FH_OK; }
Description: In devs.c in Yubico libu2f-host before 1.1.8, the response to init is misparsed, leaking uninitialized stack memory back to the device.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static long evtchn_bind_interdomain(evtchn_bind_interdomain_t *bind) { struct evtchn *lchn, *rchn; struct domain *ld = current->domain, *rd; int            lport, rport = bind->remote_port; domid_t        rdom = bind->remote_dom; long           rc; if ( rdom == DOMID_SELF ) rdom = current->domain->domain_id; if ( (rd = rcu_lock_domain_by_id(rdom)) == NULL ) return -ESRCH; if ( ld < rd ) { spin_lock(&ld->event_lock); spin_lock(&rd->event_lock); } else { if ( ld != rd ) spin_lock(&rd->event_lock); spin_lock(&ld->event_lock); } if ( (lport = get_free_port(ld)) < 0 ) ERROR_EXIT(lport); lchn = evtchn_from_port(ld, lport); if ( !port_is_valid(rd, rport) ) ERROR_EXIT_DOM(-EINVAL, rd); rchn = evtchn_from_port(rd, rport); if ( (rchn->state != ECS_UNBOUND) || (rchn->u.unbound.remote_domid != ld->domain_id) ) ERROR_EXIT_DOM(-EINVAL, rd); rc = xsm_evtchn_interdomain(XSM_HOOK, ld, lchn, rd, rchn); if ( rc ) goto out; double_evtchn_lock(lchn, rchn); lchn->u.interdomain.remote_dom  = rd; lchn->u.interdomain.remote_port = rport; lchn->state                     = ECS_INTERDOMAIN; evtchn_port_init(ld, lchn); rchn->u.interdomain.remote_dom  = ld; rchn->u.interdomain.remote_port = lport; rchn->state                     = ECS_INTERDOMAIN; evtchn_port_set_pending(ld, lchn->notify_vcpu_id, lchn); double_evtchn_unlock(lchn, rchn); bind->local_port = lport; out: check_free_port(ld, lport); spin_unlock(&ld->event_lock); if ( ld != rd ) spin_unlock(&rd->event_lock); rcu_unlock_domain(rd); return rc; }
Description: An issue was discovered in Xen through 4.14.x. There are evtchn_reset() race conditions. Uses of EVTCHNOP_reset (potentially by a guest on itself) or XEN_DOMCTL_soft_reset (by itself covered by XSA-77) can lead to the violation of various internal assumptions. This may lead to out of bounds memory accesses or triggering of bug checks. In particular, x86 PV guests may be able to elevate their privilege to that of the host. Host and guest crashes are also possible, leading to a Denial of Service (DoS). Information leaks cannot be ruled out. All Xen versions from 4.5 onwards are vulnerable. Xen versions 4.4 and earlier are not vulnerable.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: ResponsePtr Server::ServeStatic(RequestPtr request) { assert(request->method() == methods::kGet); if (doc_root_.empty()) { LOG_INFO(""The doc root was not specified""); return {}; } fs::path path = doc_root_ / request->url().path(); try { auto body = std::make_shared<FileBody>(path, file_chunk_size_); auto response = std::make_shared<Response>(Status::kOK); std::string extension = path.extension().string(); response->SetContentType(media_types::FromExtension(extension), """"); response->SetBody(body, true); return response; } catch (const Error& error) { LOG_ERRO(""File error: %s"", error.message().c_str()); return {}; } }
Description: This affects the package sprinfall/webcc before 0.3.0. It is possible to traverse directories to fetch arbitrary files from the server.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int bgp_attr_check(struct peer *peer, struct attr *attr, bgp_size_t length) { uint8_t type = 0; if (CHECK_FLAG(peer->cap, PEER_CAP_RESTART_RCV) && !attr->flag && !length) return BGP_ATTR_PARSE_PROCEED; if ((!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI)) && CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_UNREACH_NLRI)))) return BGP_ATTR_PARSE_PROCEED; if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_ORIGIN))) type = BGP_ATTR_ORIGIN; if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_AS_PATH))) type = BGP_ATTR_AS_PATH; if (!CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_NEXT_HOP)) && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_MP_REACH_NLRI))) type = BGP_ATTR_NEXT_HOP; if (peer->sort == BGP_PEER_IBGP && !CHECK_FLAG(attr->flag, ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF))) type = BGP_ATTR_LOCAL_PREF; if (type) { flog_warn(EC_BGP_MISSING_ATTRIBUTE, ""%s Missing well-known attribute %s."", peer->host, lookup_msg(attr_str, type, NULL)); return BGP_ATTR_PARSE_WITHDRAW; } return BGP_ATTR_PARSE_PROCEED; }
Description: An issue was discovered in FRRouting FRR through 9.0.1. A crash can occur when a malformed BGP UPDATE message with an EOR is processed, because the presence of EOR does not lead to a treat-as-withdraw outcome.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void g_socket_client_async_connect_data_free (GSocketClientAsyncConnectData *data) { g_clear_object (&data->connectable); g_clear_object (&data->enumerator); g_clear_object (&data->proxy_addr); g_clear_object (&data->socket); g_clear_object (&data->connection); g_slist_free_full (data->connection_attempts, connection_attempt_unref); g_clear_error (&data->last_error); g_slice_free (GSocketClientAsyncConnectData, data); }
Description: gio/gsocketclient.c in GNOME GLib 2.59.2 does not ensure that a parent GTask remains alive during the execution of a connection-attempting enumeration, which allows remote attackers to cause a denial of service (g_socket_client_connected_callback mishandling and application crash) via a crafted web site, as demonstrated by GNOME Web (aka Epiphany).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void DISOpticalFlowImpl::calc(InputArray I0, InputArray I1, InputOutputArray flow) { CV_Assert(!I0.empty() && I0.depth() == CV_8U && I0.channels() == 1); CV_Assert(!I1.empty() && I1.depth() == CV_8U && I1.channels() == 1); CV_Assert(I0.sameSize(I1)); CV_Assert(I0.isContinuous()); CV_Assert(I1.isContinuous()); CV_OCL_RUN(flow.isUMat() && (patch_size == 8) && (use_spatial_propagation == true), ocl_calc(I0, I1, flow)); Mat I0Mat = I0.getMat(); Mat I1Mat = I1.getMat(); bool use_input_flow = false; if (flow.sameSize(I0) && flow.depth() == CV_32F && flow.channels() == 2) use_input_flow = true; else flow.create(I1Mat.size(), CV_32FC2); Mat flowMat = flow.getMat(); coarsest_scale = min((int)(log(max(I0Mat.cols, I0Mat.rows) / (4.0 * patch_size)) / log(2.0) + 0.5),  (int)(log(min(I0Mat.cols, I0Mat.rows) / patch_size) / log(2.0)));               int num_stripes = getNumThreads(); prepareBuffers(I0Mat, I1Mat, flowMat, use_input_flow); Ux[coarsest_scale].setTo(0.0f); Uy[coarsest_scale].setTo(0.0f); for (int i = coarsest_scale; i >= finest_scale; i--) { w = I0s[i].cols; h = I0s[i].rows; ws = 1 + (w - patch_size) / patch_stride; hs = 1 + (h - patch_size) / patch_stride; precomputeStructureTensor(I0xx_buf, I0yy_buf, I0xy_buf, I0x_buf, I0y_buf, I0xs[i], I0ys[i]); if (use_spatial_propagation) { parallel_for_(Range(0, 8), PatchInverseSearch_ParBody(*this, 8, hs, Sx, Sy, Ux[i], Uy[i], I0s[i], I1s_ext[i], I0xs[i], I0ys[i], 2, i)); } else { parallel_for_(Range(0, num_stripes), PatchInverseSearch_ParBody(*this, num_stripes, hs, Sx, Sy, Ux[i], Uy[i], I0s[i], I1s_ext[i], I0xs[i], I0ys[i], 1, i)); } parallel_for_(Range(0, num_stripes), Densification_ParBody(*this, num_stripes, I0s[i].rows, Ux[i], Uy[i], Sx, Sy, I0s[i], I1s[i])); if (variational_refinement_iter > 0) variational_refinement_processors[i]->calcUV(I0s[i], I1s[i], Ux[i], Uy[i]); if (i > finest_scale) { resize(Ux[i], Ux[i - 1], Ux[i - 1].size()); resize(Uy[i], Uy[i - 1], Uy[i - 1].size()); Ux[i - 1] *= 2; Uy[i - 1] *= 2; } } Mat uxy[] = {Ux[finest_scale], Uy[finest_scale]}; merge(uxy, 2, U); resize(U, flowMat, flowMat.size()); flowMat *= 1 << finest_scale; }
Description: An out-of-bounds read was discovered in OpenCV before 4.1.1. Specifically, variable coarsest_scale is assumed to be greater than or equal to finest_scale within the calc()/ocl_calc() functions in dis_flow.cpp. However, this is not true when dealing with small images, leading to an out-of-bounds read of the heap-allocated arrays Ux and Uy.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static long elf_x86_64_get_synthetic_symtab (bfd *abfd, long symcount ATTRIBUTE_UNUSED, asymbol **syms ATTRIBUTE_UNUSED, long dynsymcount, asymbol **dynsyms, asymbol **ret) { long size, count, i, n; int j; unsigned int plt_got_offset, plt_entry_size, plt_got_insn_size; asymbol *s; bfd_byte *plt_contents; long dynrelcount, relsize; arelent **dynrelbuf; const struct elf_x86_64_lazy_plt_layout *lazy_plt; const struct elf_x86_64_non_lazy_plt_layout *non_lazy_plt; const struct elf_x86_64_lazy_plt_layout *lazy_bnd_plt; const struct elf_x86_64_non_lazy_plt_layout *non_lazy_bnd_plt; const struct elf_x86_64_lazy_plt_layout *lazy_ibt_plt; const struct elf_x86_64_non_lazy_plt_layout *non_lazy_ibt_plt; asection *plt; char *names; enum elf_x86_64_plt_type plt_type; struct elf_x86_64_plt plts[] = { { "".plt"", NULL, NULL, plt_unknown, 0, 0, 0, 0 }, { "".plt.got"", NULL, NULL, plt_non_lazy, 0, 0, 0, 0 }, { "".plt.sec"", NULL, NULL, plt_second, 0, 0, 0, 0 }, { "".plt.bnd"", NULL, NULL, plt_second, 0, 0, 0, 0 }, { NULL, NULL, NULL, plt_non_lazy, 0, 0, 0, 0 } }; *ret = NULL; if ((abfd->flags & (DYNAMIC | EXEC_P)) == 0) return 0; if (dynsymcount <= 0) return 0; relsize = bfd_get_dynamic_reloc_upper_bound (abfd); if (relsize <= 0) return -1; dynrelbuf = (arelent **) bfd_malloc (relsize); if (dynrelbuf == NULL) return -1; dynrelcount = bfd_canonicalize_dynamic_reloc (abfd, dynrelbuf, dynsyms); if (dynrelcount <= 0) return -1; qsort (dynrelbuf, dynrelcount, sizeof (arelent *), compare_relocs); if (get_elf_x86_64_backend_data (abfd)->os == is_normal) { lazy_plt = &elf_x86_64_lazy_plt; non_lazy_plt = &elf_x86_64_non_lazy_plt; lazy_bnd_plt = &elf_x86_64_lazy_bnd_plt; non_lazy_bnd_plt = &elf_x86_64_non_lazy_bnd_plt; if (ABI_64_P (abfd)) { lazy_ibt_plt = &elf_x86_64_lazy_ibt_plt; non_lazy_ibt_plt = &elf_x86_64_non_lazy_ibt_plt; } else { lazy_ibt_plt = &elf_x32_lazy_ibt_plt; non_lazy_ibt_plt = &elf_x32_non_lazy_ibt_plt; } } else { lazy_plt = &elf_x86_64_nacl_plt; non_lazy_plt = NULL; lazy_bnd_plt = NULL; non_lazy_bnd_plt = NULL; lazy_ibt_plt = NULL; non_lazy_ibt_plt = NULL; } count = 0; for (j = 0; plts[j].name != NULL; j++) { plt = bfd_get_section_by_name (abfd, plts[j].name); if (plt == NULL || plt->size == 0) continue; plt_contents = (bfd_byte *) bfd_malloc (plt->size); if (plt_contents == NULL) break; if (!bfd_get_section_contents (abfd, (asection *) plt, plt_contents, 0, plt->size)) { free (plt_contents); break; } plt_type = plt_unknown; if (plts[j].type == plt_unknown && (plt->size >= (lazy_plt->plt_entry_size + lazy_plt->plt_entry_size))) { if ((memcmp (plt_contents, lazy_plt->plt0_entry, lazy_plt->plt0_got1_offset) == 0) && (memcmp (plt_contents + 6, lazy_plt->plt0_entry + 6, 2) == 0)) plt_type = plt_lazy; else if (lazy_bnd_plt != NULL && (memcmp (plt_contents, lazy_bnd_plt->plt0_entry, lazy_bnd_plt->plt0_got1_offset) == 0) && (memcmp (plt_contents + 6, lazy_bnd_plt->plt0_entry + 6, 3) == 0)) { plt_type = plt_lazy | plt_second; if ((memcmp (plt_contents + lazy_ibt_plt->plt_entry_size, lazy_ibt_plt->plt_entry, lazy_ibt_plt->plt_got_offset) == 0)) lazy_plt = lazy_ibt_plt; else lazy_plt = lazy_bnd_plt; } } if (non_lazy_plt != NULL && (plt_type == plt_unknown || plt_type == plt_non_lazy) && plt->size >= non_lazy_plt->plt_entry_size) { if (memcmp (plt_contents, non_lazy_plt->plt_entry, non_lazy_plt->plt_got_offset) == 0) plt_type = plt_non_lazy; } if (plt_type == plt_unknown || plt_type == plt_second) { if (non_lazy_bnd_plt != NULL && plt->size >= non_lazy_bnd_plt->plt_entry_size && (memcmp (plt_contents, non_lazy_bnd_plt->plt_entry, non_lazy_bnd_plt->plt_got_offset) == 0)) { plt_type = plt_second; non_lazy_plt = non_lazy_bnd_plt; } else if (non_lazy_ibt_plt != NULL && plt->size >= non_lazy_ibt_plt->plt_entry_size && (memcmp (plt_contents, non_lazy_ibt_plt->plt_entry, non_lazy_ibt_plt->plt_got_offset) == 0)) { plt_type = plt_second; non_lazy_plt = non_lazy_ibt_plt; } } if (plt_type == plt_unknown) continue; plts[j].sec = plt; plts[j].type = plt_type; if ((plt_type & plt_lazy)) { plts[j].plt_got_offset = lazy_plt->plt_got_offset; plts[j].plt_got_insn_size = lazy_plt->plt_got_insn_size; plts[j].plt_entry_size = lazy_plt->plt_entry_size; i = 1; } else { plts[j].plt_got_offset = non_lazy_plt->plt_got_offset; plts[j].plt_got_insn_size = non_lazy_plt->plt_got_insn_size; plts[j].plt_entry_size = non_lazy_plt->plt_entry_size; i = 0; } if (plt_type == (plt_lazy | plt_second)) plts[j].count = 0; else { n = plt->size / plts[j].plt_entry_size; plts[j].count = n; count += n - i; } plts[j].contents = plt_contents; } if (count == 0) return -1; size = count * sizeof (asymbol); s = *ret = (asymbol *) bfd_zmalloc (size); if (s == NULL) { bad_return: for (j = 0; plts[j].name != NULL; j++) if (plts[j].contents != NULL) free (plts[j].contents); free (dynrelbuf); return -1; } size = 0; n = 0; for (j = 0; plts[j].name != NULL; j++) if ((plt_contents = plts[j].contents) != NULL) { long k; bfd_vma offset; plt_got_offset = plts[j].plt_got_offset; plt_got_insn_size = plts[j].plt_got_insn_size; plt_entry_size = plts[j].plt_entry_size; plt = plts[j].sec; if ((plts[j].type & plt_lazy)) { k = 1; offset = plt_entry_size; } else { k = 0; offset = 0; } for (; k < plts[j].count; k++) { int off; bfd_vma got_vma; long min, max, mid; arelent *p; off = H_GET_32 (abfd, (plt_contents + offset + plt_got_offset)); got_vma = plt->vma + offset + off + plt_got_insn_size; p = dynrelbuf[0]; min = 0; max = dynrelcount; while ((min + 1) < max) { arelent *r; mid = (min + max) / 2; r = dynrelbuf[mid]; if (got_vma > r->address) min = mid; else if (got_vma < r->address) max = mid; else { p = r; break; } } if (got_vma == p->address && p->howto != NULL && (p->howto->type == R_X86_64_JUMP_SLOT || p->howto->type == R_X86_64_GLOB_DAT || p->howto->type == R_X86_64_IRELATIVE)) { *s = **p->sym_ptr_ptr; if ((s->flags & BSF_LOCAL) == 0) s->flags |= BSF_GLOBAL; s->flags |= BSF_SYNTHETIC; s->flags &= ~BSF_SECTION_SYM; s->section = plt; s->the_bfd = plt->owner; s->value = offset; s->udata.p = p; size += strlen (s->name) + sizeof (""@plt""); if (p->addend != 0) size += sizeof (""+0x"") - 1 + 8 + 8 * ABI_64_P (abfd); n++; s++; } offset += plt_entry_size; } } if (n == 0) goto bad_return; count = n; names = (char *) bfd_malloc (size); if (s == NULL) goto bad_return; s = *ret; for (i = 0; i < count; i++) { arelent *p = (arelent *) s->udata.p; s->udata.p = NULL; size = strlen (s->name); memcpy (names, s->name, size); s->name = names; names += size; if (p->addend != 0) { char buf[30], *a; memcpy (names, ""+0x"", sizeof (""+0x"") - 1); names += sizeof (""+0x"") - 1; bfd_sprintf_vma (abfd, buf, p->addend); for (a = buf; *a == '0'; ++a) ; size = strlen (a); memcpy (names, a, size); names += size; } memcpy (names, ""@plt"", sizeof (""@plt"")); names += sizeof (""@plt""); s++; } for (j = 0; plts[j].name != NULL; j++) if (plts[j].contents != NULL) free (plts[j].contents); free (dynrelbuf); return count; }
Description: The *_get_synthetic_symtab functions in the Binary File Descriptor (BFD) library (aka libbfd), as distributed in GNU Binutils 2.29, do not ensure a unique PLT entry for a symbol, which allows remote attackers to cause a denial of service (heap-based buffer overflow and application crash) or possibly have unspecified other impact via a crafted ELF file, related to elf32-i386.c and elf64-x86-64.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: long jpc_bitstream_getbits(jpc_bitstream_t *bitstream, int n) { long v; int u; assert(n >= 0 && n < 32); v = 0; while (--n >= 0) { if ((u = jpc_bitstream_getbit(bitstream)) < 0) { return -1; } v = (v << 1) | u; } return v; }
Description: The jpc_bitstream_getbits function in jpc_bs.c in JasPer before 2.0.10 allows remote attackers to cause a denial of service (assertion failure) via a very large integer.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: const char *janus_rtp_header_extension_get_from_id(const char *sdp, int id) { if(!sdp || id < 0) return NULL; char extmap[100]; g_snprintf(extmap, 100, ""a=extmap:%d "", id); const char *line = strstr(sdp, ""m=""); while(line) { char *next = strchr(line, '\n'); if(next) { *next = '\0'; if(strstr(line, extmap)) { char extension[100]; if(sscanf(line, ""a=extmap:%d %s"", &id, extension) == 2) { *next = '\n'; if(strstr(extension, JANUS_RTP_EXTMAP_AUDIO_LEVEL)) return JANUS_RTP_EXTMAP_AUDIO_LEVEL; if(strstr(extension, JANUS_RTP_EXTMAP_VIDEO_ORIENTATION)) return JANUS_RTP_EXTMAP_VIDEO_ORIENTATION; if(strstr(extension, JANUS_RTP_EXTMAP_PLAYOUT_DELAY)) return JANUS_RTP_EXTMAP_PLAYOUT_DELAY; if(strstr(extension, JANUS_RTP_EXTMAP_TOFFSET)) return JANUS_RTP_EXTMAP_TOFFSET; if(strstr(extension, JANUS_RTP_EXTMAP_ABS_SEND_TIME)) return JANUS_RTP_EXTMAP_ABS_SEND_TIME; if(strstr(extension, JANUS_RTP_EXTMAP_TRANSPORT_WIDE_CC)) return JANUS_RTP_EXTMAP_TRANSPORT_WIDE_CC; if(strstr(extension, JANUS_RTP_EXTMAP_MID)) return JANUS_RTP_EXTMAP_MID; if(strstr(extension, JANUS_RTP_EXTMAP_RID)) return JANUS_RTP_EXTMAP_RID; if(strstr(extension, JANUS_RTP_EXTMAP_REPAIRED_RID)) return JANUS_RTP_EXTMAP_REPAIRED_RID; JANUS_LOG(LOG_ERR, ""Unsupported extension '%s'\n"", extension); return NULL; } } *next = '\n'; } line = next ? (next+1) : NULL; } return NULL; }
Description: An issue was discovered in janus-gateway (aka Janus WebRTC Server) through 0.10.0. janus_streaming_rtsp_parse_sdp in plugins/janus_streaming.c has a Buffer Overflow via a crafted RTSP server.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void virtio_input_teardown(void *param) { struct virtio_input *vi; vi = (struct virtio_input *)param; if (vi) { pthread_mutex_destroy(&vi->mtx); if (vi->event_queue) free(vi->event_queue); if (vi->fd > 0) close(vi->fd); if (vi->evdev) free(vi->evdev); if (vi->serial) free(vi->serial); free(vi); vi = NULL; } }
Description: The polling timer handler in ACRN before 2.5 has a use-after-free for a freed virtio device, related to devicemodel/hw/pci/virtio/*.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int dissect_openflow_match_v5(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree, int offset, guint16 length _U_) { proto_item *ti; proto_tree *match_tree; guint16 match_type; guint16 match_length; gint32 fields_end; guint16 pad_length; match_tree = proto_tree_add_subtree(tree, tvb, offset, -1, ett_openflow_v5_match, &ti, ""Match""); match_type = tvb_get_ntohs(tvb, offset); proto_tree_add_item(match_tree, hf_openflow_v5_match_type, tvb, offset, 2, ENC_BIG_ENDIAN); offset+=2; match_length = tvb_get_ntohs(tvb, offset); pad_length = (match_length + 7)/8*8 - match_length; proto_item_set_len(ti, match_length + pad_length); proto_tree_add_item(match_tree, hf_openflow_v5_match_length, tvb, offset, 2, ENC_BIG_ENDIAN); offset+=2; switch (match_type) { case OFPMT_STANDARD: proto_tree_add_expert_format(match_tree, pinfo, &ei_openflow_v5_match_undecoded, tvb, offset, match_length - 4, ""Standard match body (deprecated).""); offset+=match_length-4; break; case OFPMT_OXM: fields_end = offset + match_length - 4; while(offset < fields_end) { offset = dissect_openflow_oxm_v5(tvb, pinfo, match_tree, offset, length); } break; default: proto_tree_add_expert_format(match_tree, pinfo, &ei_openflow_v5_match_undecoded, tvb, offset, match_length - 4, ""Unknown match body.""); offset+=match_length-4; break; } if (pad_length > 0) { proto_tree_add_item(match_tree, hf_openflow_v5_match_pad, tvb, offset, pad_length, ENC_NA); offset+=pad_length; } return offset; }
Description: In Wireshark 2.2.0 to 2.2.1 and 2.0.0 to 2.0.7, the OpenFlow dissector could crash with memory exhaustion, triggered by network traffic or a capture file. This was addressed in epan/dissectors/packet-openflow_v5.c by ensuring that certain length values were sufficiently large.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void n_start_visual_mode(int c) { #ifdef FEAT_CONCEAL int cursor_line_was_concealed = curwin->w_p_cole > 0 && conceal_cursor_line(curwin); #endif VIsual_mode = c; VIsual_active = TRUE; VIsual_reselect = TRUE; trigger_modechanged(); if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB) { validate_virtcol(); coladvance(curwin->w_virtcol); } VIsual = curwin->w_cursor; #ifdef FEAT_FOLDING foldAdjustVisual(); #endif setmouse(); #ifdef FEAT_CONCEAL conceal_check_cursor_line(cursor_line_was_concealed); #endif if (p_smd && msg_silent == 0) redraw_cmdline = TRUE;#ifdef FEAT_CLIPBOARD clip_star.vmode = NUL; #endif if (curwin->w_redr_type < INVERTED) { curwin->w_old_cursor_lnum = curwin->w_cursor.lnum; curwin->w_old_visual_lnum = curwin->w_cursor.lnum; } }
Description: vim is vulnerable to Heap-based Buffer Overflow
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static gint64 ascend_seek(wtap *wth, int *err, gchar **err_info) { int byte; gint64 date_off = -1, cur_off, packet_off; size_t string_level[ASCEND_MAGIC_STRINGS]; guint string_i = 0, type = 0; guint excessive_read_count = 262144; memset(&string_level, 0, sizeof(string_level)); while (((byte = file_getc(wth->fh)) != EOF)) { excessive_read_count--; if (!excessive_read_count) { *err = 0; return -1; } for (string_i = 0; string_i < ASCEND_MAGIC_STRINGS; string_i++) { const gchar *strptr = ascend_magic[string_i].strptr; size_t len          = strlen(strptr); if (byte == *(strptr + string_level[string_i])) { string_level[string_i]++; if (string_level[string_i] >= len) { cur_off = file_tell(wth->fh); if (cur_off == -1) { *err = file_error(wth->fh, err_info); return -1; } if (strcmp(strptr, ASCEND_DATE) == 0) { date_off = cur_off - len; } else { if (date_off == -1) { packet_off = cur_off - len; } else { packet_off = date_off; } type = ascend_magic[string_i].type; goto found; } } } else { string_level[string_i] = 0; } } } *err = file_error(wth->fh, err_info); return -1; found: if (file_seek(wth->fh, packet_off, SEEK_SET, err) == -1) return -1; wth->phdr.pseudo_header.ascend.type = type; return packet_off; }
Description: The ascend_seek function in wiretap/ascendtext.c in the Ascend file parser in Wireshark 1.12.x before 1.12.9 and 2.0.x before 2.0.1 does not ensure the presence of a '\0' character at the end of a date string, which allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void gprinter_free(struct usb_function *f) { struct printer_dev *dev = func_to_printer(f); struct f_printer_opts *opts; opts = container_of(f->fi, struct f_printer_opts, func_inst); kfree(dev); mutex_lock(&opts->lock); --opts->refcnt; mutex_unlock(&opts->lock); }
Description: A vulnerability was found in the Linux kernel, where accessing a deallocated instance in printer_ioctl() printer_ioctl() tries to access of a printer_dev instance. However, use-after-free arises because it had been freed by gprinter_free().
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void CommunicatorClass::suck(const string &domain,const string &remote) { L<<Logger::Error<<""Initiating transfer of '""<<domain<<""' from remote '""<<remote<<""'""<<endl; UeberBackend B;  DomainInfo di; di.backend=0; bool transaction=false; try { DNSSECKeeper dk (&B);  if(!B.getDomainInfo(domain, di) || !di.backend) {       L<<Logger::Error<<""Can't determine backend for domain '""<<domain<<""'""<<endl; return; } uint32_t domain_id=di.id; string tsigkeyname, tsigalgorithm, tsigsecret; if(dk.getTSIGForAccess(domain, remote, &tsigkeyname)) { string tsigsecret64; if(B.getTSIGKey(tsigkeyname, &tsigalgorithm, &tsigsecret64)) { B64Decode(tsigsecret64, tsigsecret); } else { L<<Logger::Error<<""TSIG key '""<<tsigkeyname<<""' for domain '""<<domain<<""' not found""<<endl; return; } } scoped_ptr<AuthLua> pdl; vector<string> scripts; if(B.getDomainMetadata(domain, ""LUA-AXFR-SCRIPT"", scripts) && !scripts.empty()) { try { pdl.reset(new AuthLua(scripts[0])); L<<Logger::Info<<""Loaded Lua script '""<<scripts[0]<<""' to edit the incoming AXFR of '""<<domain<<""'""<<endl; } catch(std::exception& e) { L<<Logger::Error<<""Failed to load Lua editing script '""<<scripts[0]<<""' for incoming AXFR of '""<<domain<<""': ""<<e.what()<<endl; return; } } vector<string> localaddr; ComboAddress laddr; if(B.getDomainMetadata(domain, ""AXFR-SOURCE"", localaddr) && !localaddr.empty()) { try { laddr = ComboAddress(localaddr[0]); L<<Logger::Info<<""AXFR source for domain '""<<domain<<""' set to ""<<localaddr[0]<<endl; } catch(std::exception& e) { L<<Logger::Error<<""Failed to load AXFR source '""<<localaddr[0]<<""' for incoming AXFR of '""<<domain<<""': ""<<e.what()<<endl; return; } } else { laddr.sin4.sin_family = 0; } bool hadDnssecZone = false; bool hadPresigned = false; bool hadNSEC3 = false; NSEC3PARAMRecordContent ns3pr, hadNs3pr; bool isNarrow, hadNarrow=false; if(dk.isSecuredZone(domain)) { hadDnssecZone=true; hadPresigned=dk.isPresigned(domain); if (dk.getNSEC3PARAM(domain, &ns3pr, &isNarrow)) { hadNSEC3 = true; hadNs3pr = ns3pr; hadNarrow = isNarrow; } } bool isDnssecZone = false; bool isPresigned = false; bool isNSEC3 = false; bool optOutFlag = false; bool first=true; bool firstNSEC3=true; unsigned int soa_serial = 0; set<string> nsset, qnames, secured; vector<DNSResourceRecord> rrs; ComboAddress raddr(remote, 53); AXFRRetriever retriever(raddr, domain.c_str(), tsigkeyname, tsigalgorithm, tsigsecret, (laddr.sin4.sin_family == 0) ? NULL : &laddr); Resolver::res_t recs; while(retriever.getChunk(recs)) { if(first) { L<<Logger::Error<<""AXFR started for '""<<domain<<""'""<<endl; first=false; } for(Resolver::res_t::iterator i=recs.begin();i!=recs.end();++i) { if(i->qtype.getCode() == QType::OPT || i->qtype.getCode() == QType::TSIG)           continue; if(!endsOn(i->qname, domain)) { L<<Logger::Error<<""Remote ""<<remote<<"" tried to sneak in out-of-zone data '""<<i->qname<<""'|""<<i->qtype.getName()<<"" during AXFR of zone '""<<domain<<""', ignoring""<<endl; continue; } vector<DNSResourceRecord> out; if(!pdl || !pdl->axfrfilter(raddr, domain, *i, out)) { out.push_back(*i); } BOOST_FOREACH(DNSResourceRecord& rr, out) { switch(rr.qtype.getCode()) { case QType::NSEC3PARAM: { ns3pr = NSEC3PARAMRecordContent(rr.content); isDnssecZone = isNSEC3 = true; isNarrow = false; continue; } case QType::NSEC3: { NSEC3RecordContent ns3rc(rr.content); if (firstNSEC3) { isDnssecZone = isPresigned = true; firstNSEC3 = false; } else if (optOutFlag != (ns3rc.d_flags & 1)) throw PDNSException(""Zones with a mixture of Opt-Out NSEC3 RRs and non-Opt-Out NSEC3 RRs are not supported.""); optOutFlag = ns3rc.d_flags & 1; if (ns3rc.d_set.count(QType::NS) && !pdns_iequals(rr.qname, domain)) secured.insert(toLower(makeRelative(rr.qname, domain))); continue; } case QType::NSEC: { isDnssecZone = isPresigned = true; continue; } case QType::SOA: { if(soa_serial != 0) continue;               SOAData sd; fillSOAData(rr.content,sd); soa_serial = sd.serial; break; } case QType::NS: { if(!pdns_iequals(rr.qname, domain)) nsset.insert(rr.qname); break; } default: break; } qnames.insert(rr.qname); rr.domain_id=domain_id; rrs.push_back(rr); } } } if(isNSEC3) { ns3pr.d_flags = optOutFlag ? 1 : 0; } if(!isPresigned) { DNSSECKeeper::keyset_t keys = dk.getKeys(domain); if(!keys.empty()) { isDnssecZone = true; isNSEC3 = hadNSEC3; ns3pr = hadNs3pr; optOutFlag = (hadNs3pr.d_flags & 1); isNarrow = hadNarrow; } } if(isDnssecZone) { if(!isNSEC3) L<<Logger::Info<<""Adding NSEC ordering information""<<endl; else if(!isNarrow) L<<Logger::Info<<""Adding NSEC3 hashed ordering information for '""<<domain<<""'""<<endl; else L<<Logger::Info<<""Erasing NSEC3 ordering since we are narrow, only setting 'auth' fields""<<endl; } transaction=di.backend->startTransaction(domain, domain_id); L<<Logger::Error<<""Transaction started for '""<<domain<<""'""<<endl; if (isDnssecZone) { if (isPresigned && !hadPresigned) { dk.setPresigned(domain); } else if (hadPresigned && !isPresigned) { dk.unsetPresigned(domain); } if (isNSEC3) { if (!hadNSEC3 || (hadNarrow  != isNarrow) || (ns3pr.d_algorithm != hadNs3pr.d_algorithm) || (ns3pr.d_flags != hadNs3pr.d_flags) || (ns3pr.d_iterations != hadNs3pr.d_iterations) || (ns3pr.d_salt != hadNs3pr.d_salt)) { dk.setNSEC3PARAM(domain, ns3pr, isNarrow); } } else if (hadNSEC3 ) { dk.unsetNSEC3PARAM(domain); } } else if (hadDnssecZone) { if (hadPresigned) { dk.unsetPresigned(domain); } if (hadNSEC3) { dk.unsetNSEC3PARAM(domain); } } bool doent=true; uint32_t maxent = ::arg().asNum(""max-ent-entries""); string ordername, shorter; set<string> rrterm; map<string,bool> nonterm; BOOST_FOREACH(DNSResourceRecord& rr, rrs) { if(!isPresigned) { if (rr.qtype.getCode() == QType::RRSIG) continue; if(isDnssecZone && rr.qtype.getCode() == QType::DNSKEY && !::arg().mustDo(""direct-dnskey"")) continue; } rr.auth=true; shorter=rr.qname; rrterm.clear(); do { if(doent) { if (!qnames.count(shorter)) rrterm.insert(shorter); } if(nsset.count(shorter) && rr.qtype.getCode() != QType::DS) rr.auth=false; if (pdns_iequals(shorter, domain))           break; }while(chopOff(shorter)); if(doent && !rrterm.empty()) { bool auth; if (!rr.auth && rr.qtype.getCode() == QType::NS) { if (isNSEC3) ordername=toBase32Hex(hashQNameWithSalt(ns3pr.d_iterations, ns3pr.d_salt, rr.qname)); auth=(!isNSEC3 || !optOutFlag || secured.count(ordername)); } else auth=rr.auth; BOOST_FOREACH(const string nt, rrterm){ if (!nonterm.count(nt)) nonterm.insert(pair<string, bool>(nt, auth)); else if (auth) nonterm[nt]=true; } if(nonterm.size() > maxent) { L<<Logger::Error<<""AXFR zone ""<<domain<<"" has too many empty non terminals.""<<endl; nonterm.clear(); doent=false; } } if (rr.qtype.getCode() == QType::RRSIG) rr.auth=true; if (isDnssecZone && rr.qtype.getCode() != QType::RRSIG) { if (isNSEC3) { ordername=toBase32Hex(hashQNameWithSalt(ns3pr.d_iterations, ns3pr.d_salt, rr.qname)); if(!isNarrow && (rr.auth || (rr.qtype.getCode() == QType::NS && (!optOutFlag || secured.count(ordername))))) { di.backend->feedRecord(rr, &ordername); } else di.backend->feedRecord(rr); } else { if (rr.auth || rr.qtype.getCode() == QType::NS) { ordername=toLower(labelReverse(makeRelative(rr.qname, domain))); di.backend->feedRecord(rr, &ordername); } else di.backend->feedRecord(rr); } } else di.backend->feedRecord(rr); } if(doent && !nonterm.empty()) { if (isNSEC3) { di.backend->feedEnts3(domain_id, domain, nonterm, ns3pr.d_iterations, ns3pr.d_salt, isNarrow); } else di.backend->feedEnts(domain_id, nonterm); } di.backend->commitTransaction(); transaction = false; di.backend->setFresh(domain_id); PC.purge(domain+""$""); L<<Logger::Error<<""AXFR done for '""<<domain<<""', zone committed with serial number ""<<soa_serial<<endl; if(::arg().mustDo(""slave-renotify"")) notifyDomain(domain); } catch(DBException &re) { L<<Logger::Error<<""Unable to feed record during incoming AXFR of '""+domain+""': ""<<re.reason<<endl; if(di.backend && transaction) { L<<Logger::Error<<""Aborting possible open transaction for domain '""<<domain<<""' AXFR""<<endl; di.backend->abortTransaction(); } } catch(MOADNSException &re) { L<<Logger::Error<<""Unable to parse record during incoming AXFR of '""+domain+""' (MOADNSException): ""<<re.what()<<endl; if(di.backend && transaction) { L<<Logger::Error<<""Aborting possible open transaction for domain '""<<domain<<""' AXFR""<<endl; di.backend->abortTransaction(); } } catch(std::exception &re) { L<<Logger::Error<<""Unable to parse record during incoming AXFR of '""+domain+""' (std::exception): ""<<re.what()<<endl; if(di.backend && transaction) { L<<Logger::Error<<""Aborting possible open transaction for domain '""<<domain<<""' AXFR""<<endl; di.backend->abortTransaction(); } } catch(ResolverException &re) { L<<Logger::Error<<""Unable to AXFR zone '""+domain+""' from remote '""<<remote<<""' (resolver): ""<<re.reason<<endl; if(di.backend && transaction) { L<<Logger::Error<<""Aborting possible open transaction for domain '""<<domain<<""' AXFR""<<endl; di.backend->abortTransaction(); } } catch(PDNSException &ae) { L<<Logger::Error<<""Unable to AXFR zone '""+domain+""' from remote '""<<remote<<""' (PDNSException): ""<<ae.reason<<endl; if(di.backend && transaction) { L<<Logger::Error<<""Aborting possible open transaction for domain '""<<domain<<""' AXFR""<<endl; di.backend->abortTransaction(); } } }
Description: PowerDNS (aka pdns) Authoritative Server before 4.0.1 allows remote primary DNS servers to cause a denial of service (memory exhaustion and secondary DNS server crash) via a large (1) AXFR or (2) IXFR response.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void nfc_llcp_mac_is_up(struct nfc_dev *dev, u32 target_idx, u8 comm_mode, u8 rf_mode) { struct nfc_llcp_local *local; pr_debug(""rf mode %d\n"", rf_mode); local = nfc_llcp_find_local(dev); if (local == NULL) return; local->target_idx = target_idx; local->comm_mode = comm_mode; local->rf_mode = rf_mode; if (rf_mode == NFC_RF_INITIATOR) { pr_debug(""Queueing Tx work\n""); schedule_work(&local->tx_work); } else { mod_timer(&local->link_timer, jiffies + msecs_to_jiffies(local->remote_lto)); } }
Description: A use-after-free flaw was found in nfc_llcp_find_local in net/nfc/llcp_core.c in NFC in the Linux kernel. This flaw allows a local user with special privileges to impact a kernel information leak issue.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int romfs_dev_read(struct super_block *sb, unsigned long pos, void *buf, size_t buflen) { size_t limit; limit = romfs_maxsize(sb); if (pos >= limit) return -EIO; if (buflen > limit - pos) buflen = limit - pos; #ifdef CONFIG_ROMFS_ON_MTD if (sb->s_mtd) return romfs_mtd_read(sb, pos, buf, buflen); #endif #ifdef CONFIG_ROMFS_ON_BLOCK if (sb->s_bdev) return romfs_blk_read(sb, pos, buf, buflen); #endif return -EIO; }
Description: An issue was discovered in romfs_dev_read in fs/romfs/storage.c in the Linux kernel before 5.8.4. Uninitialized memory leaks to userspace, aka CID-bcf85fcedfdd.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: util::Status OAuth2Credential::UpdateFromString(const string& json) { OAuth2AuthorizationFlow::SimpleJsonData data; googleapis::util::Status status = data.Init(json); if (!status.ok()) return status; string str_value; int int_value; if (data.GetString(""refresh_token"", &str_value)) { VLOG(1) << ""Updating refresh token""; refresh_token_.set(str_value); } if (data.GetString(""access_token"", &str_value)) { access_token_.set(str_value); VLOG(1) << ""Updating access token""; } if (data.GetString(""expires_at"", &str_value) || data.GetString(""exp"", &str_value)) { int64 timestamp; if (!safe_strto64(str_value.c_str(), &timestamp)) { LOG(ERROR) << ""Invalid timestamp=["" << str_value << ""]""; } else { expiration_timestamp_secs_.set(timestamp); VLOG(1) << ""Updating access token expiration""; } } else if (data.GetScalar(""expires_in"", &int_value)) { int64 now = DateTime().ToEpochTime(); int64 expiration = now + int_value; expiration_timestamp_secs_.set(expiration); VLOG(1) << ""Updating access token expiration""; } if (data.GetString(""email"", &str_value)) { string bool_str; data.GetString(""email_verified"", &bool_str); email_ = str_value; email_verified_ = bool_str == ""true""; } if (data.GetString(""id_token"", &str_value)) { int dot_positions[3]; int n_dots = 0; for (size_t i = 0; i < str_value.size(); ++i) { if (str_value[i] == '.') { dot_positions[n_dots] = i; ++n_dots; if (n_dots == 3) break; } } if (n_dots != 2) { return StatusUnknown(""Invalid id_token attribute - not a JWT""); } string claims; const char *claims_start = str_value.data() + dot_positions[0] + 1; size_t claims_len = dot_positions[1] - dot_positions[0] - 1; if (!googleapis_util::Base64Unescape(claims_start, claims_len, &claims)) { return StatusUnknown(""id_token claims not base-64 encoded""); } return UpdateFromString(claims); } return StatusOk(); }
Description: An unhandled exception vulnerability exists during Google Sign-In with Google API C++ Client before 2019-04-10. It potentially causes an outage of third-party services that were not designed to recover from exceptions. On the client, ID token handling can cause an unhandled exception because of misinterpretation of an integer as a string, resulting in denial-of-service and then other users can no longer login/sign-in to the affected third-party service. Once this third-party service uses Google Sign-In with google-api-cpp-client, a malicious user can trigger this client/auth/oauth2_authorization.cc vulnerability by requesting the client to receive the ID token from a Google authentication server.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int do_addsub( intop_type, pos_T*pos, intlength, linenr_TPrenum1) { intcol; char_u*buf1; char_ubuf2[NUMBUFLEN]; intpre;    static inthexupper = FALSE;    uvarnumber_Tn; uvarnumber_Toldn; char_u*ptr; intc; inttodel; intdo_hex; intdo_oct; intdo_bin; intdo_alpha; intdo_unsigned; intfirstdigit; intsubtract; intnegative = FALSE; intwas_positive = TRUE; intvisual = VIsual_active; intdid_change = FALSE; pos_Tsave_cursor = curwin->w_cursor; intmaxlen = 0; pos_Tstartpos; pos_Tendpos; colnr_Tsave_coladd = 0; do_hex = (vim_strchr(curbuf->b_p_nf, 'x') != NULL);    do_oct = (vim_strchr(curbuf->b_p_nf, 'o') != NULL);    do_bin = (vim_strchr(curbuf->b_p_nf, 'b') != NULL);    do_alpha = (vim_strchr(curbuf->b_p_nf, 'p') != NULL);    do_unsigned = (vim_strchr(curbuf->b_p_nf, 'u') != NULL); if (virtual_active()) { save_coladd = pos->coladd; pos->coladd = 0; } curwin->w_cursor = *pos; ptr = ml_get(pos->lnum); col = pos->col; if (*ptr == NUL || col + !!save_coladd >= (int)STRLEN(ptr)) goto theend; if (!VIsual_active) { if (do_bin) while (col > 0 && vim_isbdigit(ptr[col])) { --col; if (has_mbyte) col -= (*mb_head_off)(ptr, ptr + col); } if (do_hex) while (col > 0 && vim_isxdigit(ptr[col])) { --col; if (has_mbyte) col -= (*mb_head_off)(ptr, ptr + col); } if (       do_bin && do_hex && ! ((col > 0 && (ptr[col] == 'X' || ptr[col] == 'x') && ptr[col - 1] == '0' && (!has_mbyte || !(*mb_head_off)(ptr, ptr + col - 1)) && vim_isxdigit(ptr[col + 1])))) { col = pos->col; while (col > 0 && vim_isdigit(ptr[col])) { col--; if (has_mbyte) col -= (*mb_head_off)(ptr, ptr + col); } } if ((       do_hex && col > 0 && (ptr[col] == 'X' || ptr[col] == 'x') && ptr[col - 1] == '0' && (!has_mbyte || !(*mb_head_off)(ptr, ptr + col - 1)) && vim_isxdigit(ptr[col + 1])) || (       do_bin && col > 0 && (ptr[col] == 'B' || ptr[col] == 'b') && ptr[col - 1] == '0' && (!has_mbyte || !(*mb_head_off)(ptr, ptr + col - 1)) && vim_isbdigit(ptr[col + 1]))) { --col; if (has_mbyte) col -= (*mb_head_off)(ptr, ptr + col); } else { col = pos->col; while (ptr[col] != NUL && !vim_isdigit(ptr[col]) && !(do_alpha && ASCII_ISALPHA(ptr[col]))) col += mb_ptr2len(ptr + col); while (col > 0 && vim_isdigit(ptr[col - 1]) && !(do_alpha && ASCII_ISALPHA(ptr[col]))) { --col; if (has_mbyte) col -= (*mb_head_off)(ptr, ptr + col); } } } if (visual) { while (ptr[col] != NUL && length > 0 && !vim_isdigit(ptr[col]) && !(do_alpha && ASCII_ISALPHA(ptr[col]))) { int mb_len = mb_ptr2len(ptr + col); col += mb_len; length -= mb_len; } if (length == 0) goto theend; if (col > pos->col && ptr[col - 1] == '-' && (!has_mbyte || !(*mb_head_off)(ptr, ptr + col - 1)) && !do_unsigned) { negative = TRUE; was_positive = FALSE; } } firstdigit = ptr[col]; if (!VIM_ISDIGIT(firstdigit) && !(do_alpha && ASCII_ISALPHA(firstdigit))) { beep_flush(); goto theend; } if (do_alpha && ASCII_ISALPHA(firstdigit)) { if (op_type == OP_NR_SUB) { if (CharOrd(firstdigit) < Prenum1) { if (isupper(firstdigit)) firstdigit = 'A'; else firstdigit = 'a'; } else firstdigit -= Prenum1; } else { if (26 - CharOrd(firstdigit) - 1 < Prenum1) { if (isupper(firstdigit)) firstdigit = 'Z'; else firstdigit = 'z'; } else firstdigit += Prenum1; } curwin->w_cursor.col = col; if (!did_change) startpos = curwin->w_cursor; did_change = TRUE; (void)del_char(FALSE); ins_char(firstdigit); endpos = curwin->w_cursor; curwin->w_cursor.col = col; } else { pos_Tsave_pos; inti; if (col > 0 && ptr[col - 1] == '-' && (!has_mbyte || !(*mb_head_off)(ptr, ptr + col - 1)) && !visual && !do_unsigned) { --col; negative = TRUE; } if (visual && VIsual_mode != 'V') maxlen = (curbuf->b_visual.vi_curswant == MAXCOL ? (int)STRLEN(ptr) - col : length); int overflow = FALSE; vim_str2nr(ptr + col, &pre, &length, 0 + (do_bin ? STR2NR_BIN : 0) + (do_oct ? STR2NR_OCT : 0) + (do_hex ? STR2NR_HEX : 0), NULL, &n, maxlen, FALSE, &overflow); if (pre && negative) { ++col; --length; negative = FALSE; } subtract = FALSE; if (op_type == OP_NR_SUB) subtract ^= TRUE; if (negative) subtract ^= TRUE; oldn = n; if (!overflow)  { if (subtract) n -= (uvarnumber_T)Prenum1; else n += (uvarnumber_T)Prenum1; } if (!pre) { if (subtract) { if (n > oldn) { n = 1 + (n ^ (uvarnumber_T)-1); negative ^= TRUE; } } else { if (n < oldn) { n = (n ^ (uvarnumber_T)-1); negative ^= TRUE; } } if (n == 0) negative = FALSE; } if (do_unsigned && negative) { if (subtract) n = (uvarnumber_T)0; else n = (uvarnumber_T)(-1); negative = FALSE; } if (visual && !was_positive && !negative && col > 0) { col--; length++; } curwin->w_cursor.col = col; if (!did_change) startpos = curwin->w_cursor; did_change = TRUE; todel = length; c = gchar_cursor(); if (c == '-') --length; save_pos = curwin->w_cursor; for (i = 0; i < todel; ++i) { if (c < 0x100 && isalpha(c)) { if (isupper(c)) hexupper = TRUE; else hexupper = FALSE; } inc_cursor(); c = gchar_cursor(); } curwin->w_cursor = save_pos; buf1 = alloc(length + NUMBUFLEN); if (buf1 == NULL) goto theend; ptr = buf1; if (negative && (!visual || was_positive)) *ptr++ = '-'; if (pre) { *ptr++ = '0'; --length; } if (pre == 'b' || pre == 'B' || pre == 'x' || pre == 'X') { *ptr++ = pre; --length; } if (pre == 'b' || pre == 'B') { int bit = 0; int bits = sizeof(uvarnumber_T) * 8; for (bit = bits; bit > 0; bit--) if ((n >> (bit - 1)) & 0x1) break; for (i = 0; bit > 0; bit--) buf2[i++] = ((n >> (bit - 1)) & 0x1) ? '1' : '0'; buf2[i] = '\0'; } else if (pre == 0) vim_snprintf((char *)buf2, NUMBUFLEN, ""%llu"", n); else if (pre == '0') vim_snprintf((char *)buf2, NUMBUFLEN, ""%llo"", n); else if (pre && hexupper) vim_snprintf((char *)buf2, NUMBUFLEN, ""%llX"", n); else vim_snprintf((char *)buf2, NUMBUFLEN, ""%llx"", n); length -= (int)STRLEN(buf2); if (firstdigit == '0' && !(do_oct && pre == 0)) while (length-- > 0) *ptr++ = '0'; *ptr = NUL; STRCAT(buf1, buf2); save_pos = curwin->w_cursor; if (todel > 0) inc_cursor(); ins_str(buf1);vim_free(buf1); if (todel > 0) { int bytes_after = (int)STRLEN(ml_get_curline()) - curwin->w_cursor.col; curwin->w_cursor = save_pos; (void)del_char(FALSE); curwin->w_cursor.col = (colnr_T)(STRLEN(ml_get_curline()) - bytes_after); --todel; } while (todel-- > 0) (void)del_char(FALSE); endpos = curwin->w_cursor; if (did_change && curwin->w_cursor.col) --curwin->w_cursor.col; } if (did_change && (cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0) { curbuf->b_op_start = startpos; curbuf->b_op_end = endpos; if (curbuf->b_op_end.col > 0) --curbuf->b_op_end.col; } theend: if (visual) curwin->w_cursor = save_cursor; else if (did_change) curwin->w_set_curswant = TRUE; else if (virtual_active()) curwin->w_cursor.coladd = save_coladd; return did_change; }
Description: Out-of-bounds Write in GitHub repository vim/vim prior to 9.0.1847.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: sds genRedisInfoString(void) { sds info; time_t uptime = time(NULL)-server.stat_starttime; int j; char hmem[64]; struct rusage self_ru, c_ru; getrusage(RUSAGE_SELF, &self_ru); getrusage(RUSAGE_CHILDREN, &c_ru); bytesToHuman(hmem,zmalloc_used_memory()); info = sdscatprintf(sdsempty(), ""redis_version:%s\r\n"" ""redis_git_sha1:%s\r\n"" ""redis_git_dirty:%d\r\n"" ""arch_bits:%s\r\n"" ""multiplexing_api:%s\r\n"" ""process_id:%ld\r\n"" ""uptime_in_seconds:%ld\r\n"" ""uptime_in_days:%ld\r\n"" ""lru_clock:%ld\r\n"" ""used_cpu_sys:%.2f\r\n"" ""used_cpu_user:%.2f\r\n"" ""used_cpu_sys_childrens:%.2f\r\n"" ""used_cpu_user_childrens:%.2f\r\n"" ""connected_clients:%d\r\n"" ""connected_slaves:%d\r\n"" ""blocked_clients:%d\r\n"" ""used_memory:%zu\r\n"" ""used_memory_human:%s\r\n"" ""used_memory_rss:%zu\r\n"" ""mem_fragmentation_ratio:%.2f\r\n"" ""use_tcmalloc:%d\r\n"" ""loading:%d\r\n"" ""aof_enabled:%d\r\n"" ""changes_since_last_save:%lld\r\n"" ""bgsave_in_progress:%d\r\n"" ""last_save_time:%ld\r\n"" ""bgrewriteaof_in_progress:%d\r\n"" ""total_connections_received:%lld\r\n"" ""total_commands_processed:%lld\r\n"" ""expired_keys:%lld\r\n"" ""evicted_keys:%lld\r\n"" ""keyspace_hits:%lld\r\n"" ""keyspace_misses:%lld\r\n"" ""hash_max_zipmap_entries:%zu\r\n"" ""hash_max_zipmap_value:%zu\r\n"" ""pubsub_channels:%ld\r\n"" ""pubsub_patterns:%u\r\n"" ""vm_enabled:%d\r\n"" ""role:%s\r\n"" ,REDIS_VERSION, redisGitSHA1(), strtol(redisGitDirty(),NULL,10) > 0, (sizeof(long) == 8) ? ""64"" : ""32"", aeGetApiName(), (long) getpid(), uptime, uptime/(3600*24), (unsigned long) server.lruclock, (float)self_ru.ru_utime.tv_sec+(float)self_ru.ru_utime.tv_usec/1000000, (float)self_ru.ru_stime.tv_sec+(float)self_ru.ru_stime.tv_usec/1000000, (float)c_ru.ru_utime.tv_sec+(float)c_ru.ru_utime.tv_usec/1000000, (float)c_ru.ru_stime.tv_sec+(float)c_ru.ru_stime.tv_usec/1000000, listLength(server.clients)-listLength(server.slaves), listLength(server.slaves), server.bpop_blocked_clients, zmalloc_used_memory(), hmem, zmalloc_get_rss(), zmalloc_get_fragmentation_ratio(), #ifdef USE_TCMALLOC 1, #else 0, #endif server.loading, server.appendonly, server.dirty, server.bgsavechildpid != -1, server.lastsave, server.bgrewritechildpid != -1, server.stat_numconnections, server.stat_numcommands, server.stat_expiredkeys, server.stat_evictedkeys, server.stat_keyspace_hits, server.stat_keyspace_misses, server.hash_max_zipmap_entries, server.hash_max_zipmap_value, dictSize(server.pubsub_channels), listLength(server.pubsub_patterns), server.vm_enabled != 0, server.masterhost == NULL ? ""master"" : ""slave"" ); if (server.masterhost) { info = sdscatprintf(info, ""master_host:%s\r\n"" ""master_port:%d\r\n"" ""master_link_status:%s\r\n"" ""master_last_io_seconds_ago:%d\r\n"" ""master_sync_in_progress:%d\r\n"" ,server.masterhost, server.masterport, (server.replstate == REDIS_REPL_CONNECTED) ? ""up"" : ""down"", server.master ? ((int)(time(NULL)-server.master->lastinteraction)) : -1, server.replstate == REDIS_REPL_TRANSFER ); if (server.replstate == REDIS_REPL_TRANSFER) { info = sdscatprintf(info, ""master_sync_left_bytes:%ld\r\n"" ""master_sync_last_io_seconds_ago:%d\r\n"" ,(long)server.repl_transfer_left, (int)(time(NULL)-server.repl_transfer_lastio) ); } } if (server.vm_enabled) { lockThreadedIO(); info = sdscatprintf(info, ""vm_conf_max_memory:%llu\r\n"" ""vm_conf_page_size:%llu\r\n"" ""vm_conf_pages:%llu\r\n"" ""vm_stats_used_pages:%llu\r\n"" ""vm_stats_swapped_objects:%llu\r\n"" ""vm_stats_swappin_count:%llu\r\n"" ""vm_stats_swappout_count:%llu\r\n"" ""vm_stats_io_newjobs_len:%lu\r\n"" ""vm_stats_io_processing_len:%lu\r\n"" ""vm_stats_io_processed_len:%lu\r\n"" ""vm_stats_io_active_threads:%lu\r\n"" ""vm_stats_blocked_clients:%lu\r\n"" ,(unsigned long long) server.vm_max_memory, (unsigned long long) server.vm_page_size, (unsigned long long) server.vm_pages, (unsigned long long) server.vm_stats_used_pages, (unsigned long long) server.vm_stats_swapped_objects, (unsigned long long) server.vm_stats_swapins, (unsigned long long) server.vm_stats_swapouts, (unsigned long) listLength(server.io_newjobs), (unsigned long) listLength(server.io_processing), (unsigned long) listLength(server.io_processed), (unsigned long) server.io_active_threads, (unsigned long) server.vm_blocked_clients ); unlockThreadedIO(); } if (server.loading) { double perc; time_t eta, elapsed; off_t remaining_bytes = server.loading_total_bytes- server.loading_loaded_bytes; perc = ((double)server.loading_loaded_bytes / server.loading_total_bytes) * 100; elapsed = time(NULL)-server.loading_start_time; if (elapsed == 0) { eta = 1;  } else { eta = (elapsed*remaining_bytes)/server.loading_loaded_bytes; } info = sdscatprintf(info, ""loading_start_time:%ld\r\n"" ""loading_total_bytes:%llu\r\n"" ""loading_loaded_bytes:%llu\r\n"" ""loading_loaded_perc:%.2f\r\n"" ""loading_eta_seconds:%ld\r\n"" ,(unsigned long) server.loading_start_time, (unsigned long long) server.loading_total_bytes, (unsigned long long) server.loading_loaded_bytes, perc, eta ); } for (j = 0; j < server.dbnum; j++) { long long keys, vkeys; keys = dictSize(server.db[j].dict); vkeys = dictSize(server.db[j].expires); if (keys || vkeys) { info = sdscatprintf(info, ""db%d:keys=%lld,expires=%lld\r\n"", j, keys, vkeys); } } return info; }
Description: Insecure temporary file vulnerability in Redis before 2.6 related to /tmp/redis-%p.vm.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int mp_pack(lua_State *L) { int nargs = lua_gettop(L); int i; mp_buf *buf; if (nargs == 0) return luaL_argerror(L, 0, ""MessagePack pack needs input.""); buf = mp_buf_new(L); for(i = 1; i <= nargs; i++) { lua_pushvalue(L, i); mp_encode_lua_type(L,buf,0); lua_pushlstring(L,(char*)buf->b,buf->len); buf->free += buf->len; buf->len = 0; } mp_buf_free(L, buf); lua_concat(L, nargs); return 1; }
Description: Memory Corruption was discovered in the cmsgpack library in the Lua subsystem in Redis before 3.2.12, 4.x before 4.0.10, and 5.x before 5.0 RC2 because of stack-based buffer overflows.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: u_int atm_if_print(netdissect_options *ndo, const struct pcap_pkthdr *h, const u_char *p) { u_int caplen = h->caplen; u_int length = h->len; uint32_t llchdr; u_int hdrlen = 0; if (caplen < 1 || length < 1) { ND_PRINT((ndo, ""%s"", tstr)); return (caplen); } if (*p == LLC_UI) { if (ndo->ndo_eflag) ND_PRINT((ndo, ""CNLPID "")); isoclns_print(ndo, p + 1, length - 1, caplen - 1); return hdrlen; } if (caplen < 3 || length < 3) { ND_PRINT((ndo, ""%s"", tstr)); return (caplen); } llchdr = EXTRACT_24BITS(p); if (llchdr != LLC_UI_HDR(LLCSAP_SNAP) && llchdr != LLC_UI_HDR(LLCSAP_ISONS) && llchdr != LLC_UI_HDR(LLCSAP_IP)) { if (caplen < 20 || length < 20) { ND_PRINT((ndo, ""%s"", tstr)); return (caplen); } if (ndo->ndo_eflag) ND_PRINT((ndo, ""%08x%08x %08x%08x "", EXTRACT_32BITS(p), EXTRACT_32BITS(p+4), EXTRACT_32BITS(p+8), EXTRACT_32BITS(p+12))); p += 20; length -= 20; caplen -= 20; hdrlen += 20; } hdrlen += atm_llc_print(ndo, p, length, caplen); return (hdrlen); }
Description: The ISO CLNS parser in tcpdump before 4.9.2 has a buffer over-read in print-isoclns.c:isoclns_print().
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void kill_TCP_connection(TCP_Client_Connection *tcp_connection) { if (tcp_connection == nullptr) { return; } wipe_priority_list(tcp_connection); kill_sock(tcp_connection->sock); crypto_memzero(tcp_connection, sizeof(TCP_Client_Connection)); free(tcp_connection); }
Description: The TCP Server module in toxcore before 0.2.8 doesn't free the TCP priority queue under certain conditions, which allows a remote attacker to exhaust the system's memory, causing a denial of service (DoS).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: explicit ElementsAccessorBase(const char* name) : ElementsAccessor(name) { }
Description: In CollectValuesOrEntriesImpl of elements.cc, there is possible remote code execution due to type confusion. This could lead to remote escalation of privilege with no additional execution privileges needed. User interaction is needed for exploitation. Product: Android. Versions: Android-7.0 Android-7.1.1 Android-7.1.2 Android-8.0 Android-8.1 Android-9.0 Android ID: A-111274046
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void dump_boot(DOS_FS * fs, struct boot_sector *b, unsigned lss) { unsigned short sectors; printf(""Boot sector contents:\n""); if (!atari_format) { char id[9]; strncpy(id, (const char *)b->system_id, 8); id[8] = 0; printf(""System ID \""%s\""\n"", id); } else { printf(""Serial number 0x%x\n"", b->system_id[5] | (b->system_id[6] << 8) | (b-> system_id[7] << 16)); } printf(""Media byte 0x%02x (%s)\n"", b->media, get_media_descr(b->media)); printf(""%10d bytes per logical sector\n"", GET_UNALIGNED_W(b->sector_size)); printf(""%10d bytes per cluster\n"", fs->cluster_size); printf(""%10d reserved sector%s\n"", le16toh(b->reserved), le16toh(b->reserved) == 1 ? """" : ""s""); printf(""First FAT starts at byte %llu (sector %llu)\n"", (unsigned long long)fs->fat_start, (unsigned long long)fs->fat_start / lss); printf(""%10d FATs, %d bit entries\n"", b->fats, fs->fat_bits); printf(""%10d bytes per FAT (= %u sectors)\n"", fs->fat_size, fs->fat_size / lss); if (!fs->root_cluster) { printf(""Root directory starts at byte %llu (sector %llu)\n"", (unsigned long long)fs->root_start, (unsigned long long)fs->root_start / lss); printf(""%10d root directory entries\n"", fs->root_entries); } else { printf(""Root directory start at cluster %lu (arbitrary size)\n"", (unsigned long)fs->root_cluster); } printf(""Data area starts at byte %llu (sector %llu)\n"", (unsigned long long)fs->data_start, (unsigned long long)fs->data_start / lss); printf(""%10lu data clusters (%llu bytes)\n"", (unsigned long)fs->data_clusters, (unsigned long long)fs->data_clusters * fs->cluster_size); printf(""%u sectors/track, %u heads\n"", le16toh(b->secs_track), le16toh(b->heads)); printf(""%10u hidden sectors\n"", atari_format ? (((unsigned char *)&b->hidden)[0] | ((unsigned char *)&b->hidden)[1] << 8) : le32toh(b->hidden)); sectors = GET_UNALIGNED_W(b->sectors); printf(""%10u sectors total\n"", sectors ? sectors : le32toh(b->total_sect)); }
Description: The read_boot function in boot.c in dosfstools before 4.0 allows attackers to cause a denial of service (crash) via a crafted filesystem, which triggers a heap-based buffer overflow in the (1) read_fat function or an out-of-bounds heap read in (2) get_fat function.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void PropagateUploadEncrypted::slotFolderEncryptedMetadataReceived(const QJsonDocument &json, int statusCode) { qCDebug(lcPropagateUploadEncrypted) << ""Metadata Received, Preparing it for the new file."" << json.toVariant(); _metadata.reset(new FolderMetadata(_propagator->account(), json.toJson(QJsonDocument::Compact), statusCode)); if (!_metadata->isMetadataSetup()) { if (_isFolderLocked) { connect(this, &PropagateUploadEncrypted::folderUnlocked, this, &PropagateUploadEncrypted::error); unlockFolder(); } else { emit error(); } return; } QFileInfo info(_propagator->fullLocalPath(_item->_file)); const QString fileName = info.fileName(); bool found = false; EncryptedFile encryptedFile; const QVector<EncryptedFile> files = _metadata->files(); for(const EncryptedFile &file : files) { if (file.originalFilename == fileName) { encryptedFile = file; found = true; } } if (!found) { encryptedFile.encryptionKey = EncryptionHelper::generateRandom(16); encryptedFile.encryptedFilename = EncryptionHelper::generateRandomFilename(); encryptedFile.initializationVector = EncryptionHelper::generateRandom(16); encryptedFile.fileVersion = 1; encryptedFile.metadataKey = 1; encryptedFile.originalFilename = fileName; QMimeDatabase mdb; encryptedFile.mimetype = mdb.mimeTypeForFile(info).name().toLocal8Bit(); if (encryptedFile.mimetype == QByteArrayLiteral(""inode/directory"")) { encryptedFile.mimetype = QByteArrayLiteral(""httpd/unix-directory""); } } _item->_encryptedFileName = _remoteParentPath + QLatin1Char('/') + encryptedFile.encryptedFilename; _item->_isEncrypted = true; qCDebug(lcPropagateUploadEncrypted) << ""Creating the encrypted file.""; if (info.isDir()) { _completeFileName = encryptedFile.encryptedFilename; } else { QFile input(info.absoluteFilePath()); QFile output(QDir::tempPath() + QDir::separator() + encryptedFile.encryptedFilename); QByteArray tag; bool encryptionResult = EncryptionHelper::fileEncryption( encryptedFile.encryptionKey, encryptedFile.initializationVector, &input, &output, tag); if (!encryptionResult) { qCDebug(lcPropagateUploadEncrypted()) << ""There was an error encrypting the file, aborting upload.""; connect(this, &PropagateUploadEncrypted::folderUnlocked, this, &PropagateUploadEncrypted::error); unlockFolder(); return; } encryptedFile.authenticationTag = tag; _completeFileName = output.fileName(); } qCDebug(lcPropagateUploadEncrypted) << ""Creating the metadata for the encrypted file.""; _metadata->addEncryptedFile(encryptedFile); _encryptedFile = encryptedFile; qCDebug(lcPropagateUploadEncrypted) << ""Metadata created, sending to the server.""; if (statusCode == 404) { auto job = new StoreMetaDataApiJob(_propagator->account(), _folderId, _metadata->encryptedMetadata()); connect(job, &StoreMetaDataApiJob::success, this, &PropagateUploadEncrypted::slotUpdateMetadataSuccess); connect(job, &StoreMetaDataApiJob::error, this, &PropagateUploadEncrypted::slotUpdateMetadataError); job->start(); } else { auto job = new UpdateMetadataApiJob(_propagator->account(), _folderId, _metadata->encryptedMetadata(), _folderToken); connect(job, &UpdateMetadataApiJob::success, this, &PropagateUploadEncrypted::slotUpdateMetadataSuccess); connect(job, &UpdateMetadataApiJob::error, this, &PropagateUploadEncrypted::slotUpdateMetadataError); job->start(); } }
Description: The Nextcloud Desktop Client is a tool to synchronize files from Nextcloud Server. Starting with version 3.0.0 and prior to version 3.6.5, a malicious server administrator can recover and modify the contents of end-to-end encrypted files. Users should upgrade the Nextcloud Desktop client to 3.6.5 to receive a patch. No known workarounds are available.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int ndlz4_decompress(const uint8_t *input, int32_t input_len, uint8_t *output, int32_t output_len, uint8_t meta, blosc2_dparams *dparams) { BLOSC_UNUSED_PARAM(meta); BLOSC_UNUSED_PARAM(dparams); uint8_t *ip = (uint8_t *) input; uint8_t *ip_limit = ip + input_len; uint8_t *op = (uint8_t *) output; uint8_t ndim; uint32_t blockshape[2]; uint32_t eshape[2]; uint8_t *buffercpy; uint8_t local_buffer[16]; uint8_t token; if (NDLZ_UNEXPECT_CONDITIONAL(input_len < 8)) { return 0; } ndim = *ip; ip++; if (ndim != 2) { BLOSC_TRACE_ERROR(""This codec only works for ndim = 2""); return BLOSC2_ERROR_FAILURE; } memcpy(&blockshape[0], ip, 4); ip += 4; memcpy(&blockshape[1], ip, 4); ip += 4; eshape[0] = ((blockshape[0] + 3) / 4) * 4; eshape[1] = ((blockshape[1] + 3) / 4) * 4; if (NDLZ_UNEXPECT_CONDITIONAL(output_len < (int32_t) (blockshape[0] * blockshape[1]))) { return 0; } memset(op, 0, blockshape[0] * blockshape[1]); uint32_t i_stop[2]; for (int i = 0; i < 2; ++i) { i_stop[i] = eshape[i] / 4; } uint32_t ii[2]; uint32_t padding[2] = {0}; uint32_t ind = 0; uint8_t cell_aux[16]; for (ii[0] = 0; ii[0] < i_stop[0]; ++ii[0]) { for (ii[1] = 0; ii[1] < i_stop[1]; ++ii[1]) {            if (NDLZ_UNEXPECT_CONDITIONAL(ip > ip_limit)) { BLOSC_TRACE_ERROR(""Exceeding input length""); return BLOSC2_ERROR_FAILURE; } if (ii[0] == i_stop[0] - 1) { padding[0] = (blockshape[0] % 4 == 0) ? 4 : blockshape[0] % 4; } else { padding[0] = 4; } if (ii[1] == i_stop[1] - 1) { padding[1] = (blockshape[1] % 4 == 0) ? 4 : blockshape[1] % 4; } else { padding[1] = 4; } token = *ip++; if (token == 0) {            buffercpy = ip; ip += padding[0] * padding[1]; } else if (token == (uint8_t) ((1U << 7U) | (1U << 6U))) {          uint16_t offset = *((uint16_t *) ip); buffercpy = ip - offset - 1; ip += 2; } else if (token == (uint8_t) (1U << 6U)) {         buffercpy = cell_aux; memset(buffercpy, *ip, 16); ip++; } else if (token >= 224) {         buffercpy = local_buffer; uint16_t offset = *((uint16_t *) ip); offset += 3; ip += 2; int i, j, k; if ((token >> 3U) == 28) { i = 1; j = 2; k = 3; } else { i = 0; if ((token >> 3U) < 30) { j = 1; k = 2; } else { k = 3; if ((token >> 3U) == 30) { j = 1; } else { j = 2; } } } memcpy(&buffercpy[i * 4], ip - offset, 4); memcpy(&buffercpy[j * 4], ip - offset + 4, 4); memcpy(&buffercpy[k * 4], ip - offset + 8, 4); for (int l = 0; l < 4; l++) { if ((l != i) && (l != j) && (l != k)) { memcpy(&buffercpy[l * 4], ip, 4); ip += 4; break; } } } else if ((token >= 128) && (token <= 191)) {         buffercpy = local_buffer; uint16_t offset = *((uint16_t *) ip); offset += 3; ip += 2; int i, j; if (token == 128) { i = 2; j = 3; } else { i = (token - 128) >> 5U; j = ((token - 128) >> 3U) - (i << 2U); } memcpy(&buffercpy[i * 4], ip - offset, 4); memcpy(&buffercpy[j * 4], ip - offset + 4, 4); for (int k = 0; k < 4; k++) { if ((k != i) && (k != j)) { memcpy(&buffercpy[k * 4], ip, 4); ip += 4; } } } else if ((token >= 40) && (token <= 63)) {          buffercpy = local_buffer; uint16_t offset_1 = *((uint16_t *) ip); offset_1 += 5; ip += 2; uint16_t offset_2 = *((uint16_t *) ip); offset_2 += 5; ip += 2; int i, j, k, l, m; i = 0; j = ((token - 32) >> 3U); l = -1; for (k = 1; k < 4; k++) { if ((k != i) && (k != j)) { if (l == -1) { l = k; } else { m = k; } } } memcpy(&buffercpy[i * 4], ip - offset_1, 4); memcpy(&buffercpy[j * 4], ip - offset_1 + 4, 4); memcpy(&buffercpy[l * 4], ip - offset_2, 4); memcpy(&buffercpy[m * 4], ip - offset_2 + 4, 4); } else { BLOSC_TRACE_ERROR(""Invalid token: %u at cell [%d, %d]\n"", token, ii[0], ii[1]); return BLOSC2_ERROR_FAILURE; } uint32_t orig = ii[0] * 4 * blockshape[1] + ii[1] * 4; for (uint32_t i = 0; i < 4; i++) { if (i < padding[0]) { ind = orig + i * blockshape[1]; memcpy(&op[ind], buffercpy, padding[1]); } buffercpy += padding[1]; } if (ind > (uint32_t) output_len) { BLOSC_TRACE_ERROR(""Exceeding output size""); return BLOSC2_ERROR_FAILURE; } } } ind += padding[1]; if (ind != (blockshape[0] * blockshape[1])) { BLOSC_TRACE_ERROR(""Output size is not compatible with embedded blockshape""); return BLOSC2_ERROR_FAILURE; } if (ind > (uint32_t) output_len) { BLOSC_TRACE_ERROR(""Exceeding output size""); return BLOSC2_ERROR_FAILURE; } return (int) ind; }
Description: C-blosc2 before 2.9.3 was discovered to contain a NULL pointer dereference in ndlz/ndlz8x8.c via a NULL pointer to memset.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void wc_push_to_iso2022(Str os, wc_wchar_t cc, wc_status *st) { wc_uchar g = 0; wc_bool is_wide = WC_FALSE, retry = WC_FALSE; wc_wchar_t cc2; while (1) { switch (WC_CCS_TYPE(cc.ccs)) { case WC_CCS_A_CS94: if (cc.ccs == WC_CCS_US_ASCII) cc.ccs = st->g0_ccs; g = cs94_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE]; break; case WC_CCS_A_CS94W: is_wide = 1; switch (cc.ccs) { #ifdef USE_UNICODE case WC_CCS_JIS_X_0212: if (!WcOption.use_jisx0212 && WcOption.use_jisx0213 && WcOption.ucs_conv) { cc2 = wc_jisx0212_to_jisx0213(cc); if (cc2.ccs == WC_CCS_JIS_X_0213_1 || cc2.ccs == WC_CCS_JIS_X_0213_2) { cc = cc2; continue; } } break; case WC_CCS_JIS_X_0213_1: case WC_CCS_JIS_X_0213_2: if (!WcOption.use_jisx0213 && WcOption.use_jisx0212 && WcOption.ucs_conv) { cc2 = wc_jisx0213_to_jisx0212(cc); if (cc2.ccs == WC_CCS_JIS_X_0212) { cc = cc2; continue; } } break; #endif } g = cs94w_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE]; break; case WC_CCS_A_CS96: g = cs96_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE]; break; case WC_CCS_A_CS96W: is_wide = 1; g = cs96w_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE]; break; case WC_CCS_A_CS942: g = cs942_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE]; break; case WC_CCS_A_UNKNOWN_W: if (WcOption.no_replace) return; is_wide = 1; cc.ccs = WC_CCS_US_ASCII; g = cs94_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE]; cc.code = ((wc_uint32)WC_REPLACE_W[0] << 8) | WC_REPLACE_W[1]; break; case WC_CCS_A_UNKNOWN: if (WcOption.no_replace) return; cc.ccs = WC_CCS_US_ASCII; g = cs94_gmap[WC_CCS_INDEX(cc.ccs) - WC_F_ISO_BASE]; cc.code = (wc_uint32)WC_REPLACE[0]; break; default: if ((cc.ccs == WC_CCS_JOHAB || cc.ccs == WC_CCS_JOHAB_1 || cc.ccs == WC_CCS_JOHAB_2 || cc.ccs == WC_CCS_JOHAB_3) && cs94w_gmap[WC_F_KS_X_1001 - WC_F_ISO_BASE]) { wc_wchar_t cc2 = wc_johab_to_ksx1001(cc); if (cc2.ccs == WC_CCS_KS_X_1001) { cc = cc2; continue; } } #ifdef USE_UNICODE if (WcOption.ucs_conv) cc = wc_any_to_iso2022(cc, st); else #endif cc.ccs = WC_CCS_IS_WIDE(cc.ccs) ? WC_CCS_UNKNOWN_W : WC_CCS_UNKNOWN; continue; } if (! g) { #ifdef USE_UNICODE if (WcOption.ucs_conv && ! retry) cc = wc_any_to_any_ces(cc, st); else #endif cc.ccs = WC_CCS_IS_WIDE(cc.ccs) ? WC_CCS_UNKNOWN_W : WC_CCS_UNKNOWN; retry = WC_TRUE; continue; } wc_push_iso2022_esc(os, cc.ccs, g, 1, st); if (is_wide) Strcat_char(os, (char)((cc.code >> 8) & 0x7f)); Strcat_char(os, (char)(cc.code & 0x7f)); return; } }
Description: An issue was discovered in the Tatsuya Kinoshita w3m fork before 0.5.3-31. w3m allows remote attackers to cause a denial of service (out-of-bounds array access) via a crafted HTML page.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: property * decode_buf_properties(uint8_t *packet, uint32_t packet_len, uint32_t *pos, uint32_t *len, bool copy_value) { int       rv; uint8_t * msg_body    = packet; size_t    msg_len     = packet_len; uint32_t  prop_len    = 0; uint8_t   bytes       = 0; uint32_t  current_pos = *pos; property *list        = NULL; if (current_pos >= msg_len) { return NULL; } if ((rv = read_variable_int(msg_body + current_pos, msg_len - current_pos, &prop_len, &bytes)) != 0) { return NULL; } current_pos += bytes; struct pos_buf buf = { .curpos = &msg_body[current_pos], .endpos                = &msg_body[current_pos + prop_len] }; if (prop_len == 0) { goto out; } uint8_t prop_id = 0; list            = property_alloc(); while (buf.curpos < buf.endpos) { read_byte(&buf, &prop_id); property *         cur_prop = NULL; property_type_enum type     = property_get_value_type(prop_id); cur_prop = property_parse(&buf, cur_prop, prop_id, type, copy_value); property_append(list, cur_prop); } out: current_pos += (prop_len); *pos = current_pos; *len = prop_len; return list; }
Description: In NanoMQ v0.15.0-0, Heap overflow occurs in read_byte function of mqtt_code.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int fmt_mtm_load_song(song_t *song, slurp_t *fp, unsigned int lflags) { uint8_t b[192]; int16_t ntrk, nchan, nord, npat, nsmp; uint16_t comment_len; int n, pat, chan, smp, rows, todo = 0; song_note_t *note; uint16_t tmp; uint32_t tmplong; song_note_t **trackdata, *tracknote; song_sample_t *sample; slurp_read(fp, b, 3); if (memcmp(b, ""MTM"", 3) != 0) return LOAD_UNSUPPORTED; n = slurp_getc(fp); sprintf(song->tracker_id, ""MultiTracker %d.%d"", n >> 4, n & 0xf); slurp_read(fp, song->title, 20); song->title[20] = 0; slurp_read(fp, &ntrk, 2); ntrk = bswapLE16(ntrk); npat = slurp_getc(fp); nord = slurp_getc(fp) + 1; slurp_read(fp, &comment_len, 2); comment_len = bswapLE16(comment_len); nsmp = slurp_getc(fp); slurp_getc(fp);  rows = slurp_getc(fp);  if (rows != 64) todo |= 64; rows = MIN(rows, 64); nchan = slurp_getc(fp); for (n = 0; n < 32; n++) { int pan = slurp_getc(fp) & 0xf; pan = SHORT_PANNING(pan); pan *= 4; song->channels[n].panning = pan; } for (n = nchan; n < MAX_CHANNELS; n++) song->channels[n].flags = CHN_MUTE; if (nsmp > MAX_SAMPLES) { log_appendf(4, "" Warning: Too many samples""); } for (n = 1, sample = song->samples + 1; n <= nsmp; n++, sample++) { if (n > MAX_SAMPLES) { slurp_seek(fp, 37, SEEK_CUR); continue; } char name[23]; slurp_read(fp, name, 22); name[22] = '\0'; strcpy(sample->name, name); slurp_read(fp, &tmplong, 4); sample->length = bswapLE32(tmplong); slurp_read(fp, &tmplong, 4); sample->loop_start = bswapLE32(tmplong); slurp_read(fp, &tmplong, 4); sample->loop_end = bswapLE32(tmplong); if ((sample->loop_end - sample->loop_start) > 2) { sample->flags |= CHN_LOOP; } else { sample->loop_start = 0; sample->loop_end = 0; } song->samples[n].c5speed = MOD_FINETUNE(slurp_getc(fp)); sample->volume = slurp_getc(fp); sample->volume *= 4; sample->global_volume = 64; if (slurp_getc(fp) & 1) { todo |= 16; sample->flags |= CHN_16BIT; sample->length >>= 1; sample->loop_start >>= 1; sample->loop_end >>= 1; } song->samples[n].vib_type = 0; song->samples[n].vib_rate = 0; song->samples[n].vib_depth = 0; song->samples[n].vib_speed = 0; } slurp_read(fp, song->orderlist, 128); memset(song->orderlist + nord, ORDER_LAST, MAX_ORDERS - nord); trackdata = mem_calloc(ntrk, sizeof(song_note_t *)); for (n = 0; n < ntrk; n++) { slurp_read(fp, b, 3 * rows); trackdata[n] = mem_calloc(rows, sizeof(song_note_t)); mtm_unpack_track(b, trackdata[n], rows); } if (npat >= MAX_PATTERNS) { log_appendf(4, "" Warning: Too many patterns""); } for (pat = 0; pat <= npat; pat++) { if (pat >= MAX_PATTERNS) { slurp_seek(fp, 64, SEEK_CUR); continue; } song->patterns[pat] = csf_allocate_pattern(MAX(rows, 32)); song->pattern_size[pat] = song->pattern_alloc_size[pat] = 64; tracknote = trackdata[n]; for (chan = 0; chan < 32; chan++) { slurp_read(fp, &tmp, 2); tmp = bswapLE16(tmp); if (tmp == 0) { continue; } else if (tmp > ntrk) { for (n = 0; n < ntrk; n++) free(trackdata[n]); free(trackdata); return LOAD_FORMAT_ERROR; } note = song->patterns[pat] + chan; tracknote = trackdata[tmp - 1]; for (n = 0; n < rows; n++, tracknote++, note += MAX_CHANNELS) *note = *tracknote; } if (rows < 32) { note = song->patterns[pat] + 64 * (rows - 1); while (note->effect || note->param) note++; note->effect = FX_PATTERNBREAK; } } for (n = 0; n < ntrk; n++) free(trackdata[n]); free(trackdata); read_lined_message(song->message, fp, comment_len, 40); if (!(lflags & LOAD_NOSAMPLES)) { for (smp = 1; smp <= nsmp && smp <= MAX_SAMPLES; smp++) { uint32_t ssize; if (song->samples[smp].length == 0) continue; ssize = csf_read_sample(song->samples + smp, (SF_LE | SF_PCMU | SF_M | ((song->samples[smp].flags & CHN_16BIT) ? SF_16 : SF_8)), fp->data + fp->pos, fp->length - fp->pos); slurp_seek(fp, ssize, SEEK_CUR); } } song->flags = SONG_ITOLDEFFECTS | SONG_COMPATGXX; if (todo & 64) log_appendf(2, "" TODO: test this file with other players (beats per track != 64)""); if (todo & 16) log_appendf(2, "" TODO: double check 16 bit sample loading""); return LOAD_SUCCESS; }
Description: An issue was discovered in Schism Tracker through 20190722. There is an integer underflow via a large plen in fmt_okt_load_song in the Amiga Oktalyzer parser in fmt/okt.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int execstack2_continue(i_ctx_t *i_ctx_p) { os_ptr op = osp; return do_execstack(i_ctx_p, op->value.boolval, op - 1); }
Description: Artifex Ghostscript allows attackers to bypass a sandbox protection mechanism by leveraging exposure of system operators in the saved execution stack in an error object.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static GVariant * g_variant_deep_copy (GVariant *value) { switch (g_variant_classify (value)) { case G_VARIANT_CLASS_MAYBE: case G_VARIANT_CLASS_TUPLE: case G_VARIANT_CLASS_DICT_ENTRY: case G_VARIANT_CLASS_VARIANT: { GVariantBuilder builder; gsize i, n_children; g_variant_builder_init (&builder, g_variant_get_type (value)); for (i = 0, n_children = g_variant_n_children (value); i < n_children; i++) { GVariant *child = g_variant_get_child_value (value, i); g_variant_builder_add_value (&builder, g_variant_deep_copy (child)); g_variant_unref (child); } return g_variant_builder_end (&builder); } case G_VARIANT_CLASS_ARRAY: { GVariantBuilder builder; gsize i, n_children; GVariant *first_invalid_child_deep_copy = NULL; GVariant *child = g_variant_maybe_get_child_value (value, i); if (child != NULL) { g_variant_builder_add_value (&builder, g_variant_deep_copy (child)); } else if (child == NULL && first_invalid_child_deep_copy != NULL) { g_variant_builder_add_value (&builder, first_invalid_child_deep_copy); } else if (child == NULL) { child = g_variant_get_child_value (value, i); first_invalid_child_deep_copy = g_variant_ref_sink (g_variant_deep_copy (child)); g_variant_builder_add_value (&builder, first_invalid_child_deep_copy); } g_clear_pointer (&child, g_variant_unref); } g_clear_pointer (&first_invalid_child_deep_copy, g_variant_unref); return g_variant_builder_end (&builder); } case G_VARIANT_CLASS_BOOLEAN: return g_variant_new_boolean (g_variant_get_boolean (value)); case G_VARIANT_CLASS_BYTE: return g_variant_new_byte (g_variant_get_byte (value)); case G_VARIANT_CLASS_INT16: return g_variant_new_int16 (g_variant_get_int16 (value)); case G_VARIANT_CLASS_UINT16: return g_variant_new_uint16 (g_variant_get_uint16 (value)); case G_VARIANT_CLASS_INT32: return g_variant_new_int32 (g_variant_get_int32 (value)); case G_VARIANT_CLASS_UINT32: return g_variant_new_uint32 (g_variant_get_uint32 (value)); case G_VARIANT_CLASS_INT64: return g_variant_new_int64 (g_variant_get_int64 (value)); case G_VARIANT_CLASS_UINT64: return g_variant_new_uint64 (g_variant_get_uint64 (value)); case G_VARIANT_CLASS_HANDLE: return g_variant_new_handle (g_variant_get_handle (value)); case G_VARIANT_CLASS_DOUBLE: return g_variant_new_double (g_variant_get_double (value)); case G_VARIANT_CLASS_STRING: return g_variant_new_string (g_variant_get_string (value, NULL)); case G_VARIANT_CLASS_OBJECT_PATH: return g_variant_new_object_path (g_variant_get_string (value, NULL)); case G_VARIANT_CLASS_SIGNATURE: return g_variant_new_signature (g_variant_get_string (value, NULL)); } g_assert_not_reached (); }
Description: A flaw was found in GLib. GVariant deserialization is vulnerable to a slowdown issue where a crafted GVariant can cause excessive processing, leading to denial of service.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int ebt_size_mwt(struct compat_ebt_entry_mwt *match32, unsigned int size_left, enum compat_mwt type, struct ebt_entries_buf_state *state, const void *base) { int growth = 0; char *buf; if (size_left == 0) return 0; buf = (char *) match32; while (size_left >= sizeof(*match32)) { struct ebt_entry_match *match_kern; int ret; match_kern = (struct ebt_entry_match *) state->buf_kern_start; if (match_kern) { char *tmp; tmp = state->buf_kern_start + state->buf_kern_offset; match_kern = (struct ebt_entry_match *) tmp; } ret = ebt_buf_add(state, buf, sizeof(*match32)); if (ret < 0) return ret; size_left -= sizeof(*match32); ret = ebt_buf_add_pad(state, ebt_compat_entry_padsize()); if (ret < 0) return ret; if (match32->match_size > size_left) return -EINVAL; size_left -= match32->match_size; ret = compat_mtw_from_user(match32, type, state, base); if (ret < 0) return ret; if (WARN_ON(ret < match32->match_size)) return -EINVAL; growth += ret - match32->match_size; growth += ebt_compat_entry_padsize(); buf += sizeof(*match32); buf += match32->match_size; if (match_kern) match_kern->match_size = ret; WARN_ON(type == EBT_COMPAT_TARGET && size_left); match32 = (struct compat_ebt_entry_mwt *) buf; } return growth; }
Description: A flaw was found in the Linux 4.x kernel's implementation of 32-bit syscall interface for bridging. This allowed a privileged user to arbitrarily write to a limited range of kernel memory.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int vmx_update_pi_irte(struct kvm *kvm, unsigned int host_irq, uint32_t guest_irq, bool set) { struct kvm_kernel_irq_routing_entry *e; struct kvm_irq_routing_table *irq_rt; struct kvm_lapic_irq irq; struct kvm_vcpu *vcpu; struct vcpu_data vcpu_info; int idx, ret = -EINVAL; if (!kvm_arch_has_assigned_device(kvm) || !irq_remapping_cap(IRQ_POSTING_CAP) || !kvm_vcpu_apicv_active(kvm->vcpus[0])) return 0; idx = srcu_read_lock(&kvm->irq_srcu); irq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu); BUG_ON(guest_irq >= irq_rt->nr_rt_entries); hlist_for_each_entry(e, &irq_rt->map[guest_irq], link) { if (e->type != KVM_IRQ_ROUTING_MSI) continue; kvm_set_msi_irq(kvm, e, &irq); if (!kvm_intr_is_single_vcpu(kvm, &irq, &vcpu)) { ret = irq_set_vcpu_affinity(host_irq, NULL); if (ret < 0) { printk(KERN_INFO ""failed to back to remapped mode, irq: %u\n"", host_irq); goto out; } continue; } vcpu_info.pi_desc_addr = __pa(vcpu_to_pi_desc(vcpu)); vcpu_info.vector = irq.vector; trace_kvm_pi_irte_update(vcpu->vcpu_id, host_irq, e->gsi, vcpu_info.vector, vcpu_info.pi_desc_addr, set); if (set) ret = irq_set_vcpu_affinity(host_irq, &vcpu_info); else { pi_set_sn(vcpu_to_pi_desc(vcpu)); ret = irq_set_vcpu_affinity(host_irq, NULL); pi_clear_sn(vcpu_to_pi_desc(vcpu)); } if (ret < 0) { printk(KERN_INFO ""%s: failed to update PI IRTE\n"", __func__); goto out; } } ret = 0; out: srcu_read_unlock(&kvm->irq_srcu, idx); return ret; }
Description: The KVM subsystem in the Linux kernel through 4.13.3 allows guest OS users to cause a denial of service (assertion failure, and hypervisor hang or crash) via an out-of bounds guest_irq value, related to arch/x86/kvm/vmx.c and virt/kvm/eventfd.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void g_keyfile_settings_backend_set_property (GObject      *object, guint         prop_id, const GValue *value, GParamSpec   *pspec) { GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object); switch (prop_id) { case PROP_FILENAME: g_assert (kfsb->file == NULL); kfsb->file = g_file_new_for_path (g_value_get_string (value)); break; case PROP_ROOT_PATH: g_assert (kfsb->prefix == NULL); kfsb->prefix = g_value_dup_string (value); if (kfsb->prefix) kfsb->prefix_len = strlen (kfsb->prefix); break; case PROP_ROOT_GROUP: g_assert (kfsb->root_group == NULL); kfsb->root_group = g_value_dup_string (value); if (kfsb->root_group) kfsb->root_group_len = strlen (kfsb->root_group); break; default: G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec); break; } }
Description: The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: coap_status_t coap_parse_message(void *packet, uint8_t *data, uint16_t data_len) { coap_packet_t *const coap_pkt = (coap_packet_t *) packet; uint8_t *current_option; unsigned int option_number = 0; unsigned int option_delta = 0; size_t option_length = 0; unsigned int *x; memset(coap_pkt, 0, sizeof(coap_packet_t)); coap_pkt->buffer = data; coap_pkt->version = (COAP_HEADER_VERSION_MASK & coap_pkt->buffer[0])>>COAP_HEADER_VERSION_POSITION; coap_pkt->type = (COAP_HEADER_TYPE_MASK & coap_pkt->buffer[0])>>COAP_HEADER_TYPE_POSITION; coap_pkt->token_len = MIN(COAP_TOKEN_LEN, (COAP_HEADER_TOKEN_LEN_MASK & coap_pkt->buffer[0])>>COAP_HEADER_TOKEN_LEN_POSITION); coap_pkt->code = coap_pkt->buffer[1]; coap_pkt->mid = coap_pkt->buffer[2]<<8 | coap_pkt->buffer[3]; if (coap_pkt->version != 1) { coap_error_message = ""CoAP version must be 1""; return BAD_REQUEST_4_00; } current_option = data + COAP_HEADER_LEN; if (coap_pkt->token_len != 0) { memcpy(coap_pkt->token, current_option, coap_pkt->token_len); SET_OPTION(coap_pkt, COAP_OPTION_TOKEN); PRINTF(""Token (len %u) [0x%02X%02X%02X%02X%02X%02X%02X%02X]\n"", coap_pkt->token_len, coap_pkt->token[0], coap_pkt->token[1], coap_pkt->token[2], coap_pkt->token[3], coap_pkt->token[4], coap_pkt->token[5], coap_pkt->token[6], coap_pkt->token[7] );  } current_option += coap_pkt->token_len; while (current_option < data+data_len) { if ((current_option[0] & 0xF0)==0xF0) { coap_pkt->payload = ++current_option; coap_pkt->payload_len = data_len - (coap_pkt->payload - data); break; } option_delta = current_option[0]>>4; option_length = current_option[0] & 0x0F; ++current_option; x = &option_delta; do { if (*x==13) { *x += current_option[0]; ++current_option; } else if (*x==14) { *x += 255; *x += current_option[0]<<8; ++current_option; *x += current_option[0]; ++current_option; } } while (x!=(unsigned int *)&option_length && (x=(unsigned int *)&option_length)); option_number += option_delta; if (current_option + option_length > data + data_len) { PRINTF(""OPTION %u (delta %u, len %u) has invalid length.\n"", option_number, option_delta, option_length); return BAD_REQUEST_4_00; } else { PRINTF(""OPTION %u (delta %u, len %u): "", option_number, option_delta, option_length); } SET_OPTION(coap_pkt, option_number); switch (option_number) { case COAP_OPTION_CONTENT_TYPE: coap_pkt->content_type = coap_parse_int_option(current_option, option_length); PRINTF(""Content-Format [%u]\n"", coap_pkt->content_type); break; case COAP_OPTION_MAX_AGE: coap_pkt->max_age = coap_parse_int_option(current_option, option_length); PRINTF(""Max-Age [%lu]\n"", coap_pkt->max_age); break; case COAP_OPTION_ETAG: coap_pkt->etag_len = (uint8_t)(MIN(COAP_ETAG_LEN, option_length)); memcpy(coap_pkt->etag, current_option, coap_pkt->etag_len); PRINTF(""ETag %u [0x%02X%02X%02X%02X%02X%02X%02X%02X]\n"", coap_pkt->etag_len, coap_pkt->etag[0], coap_pkt->etag[1], coap_pkt->etag[2], coap_pkt->etag[3], coap_pkt->etag[4], coap_pkt->etag[5], coap_pkt->etag[6], coap_pkt->etag[7] );  break; case COAP_OPTION_ACCEPT: if (coap_pkt->accept_num < COAP_MAX_ACCEPT_NUM) { coap_pkt->accept[coap_pkt->accept_num] = coap_parse_int_option(current_option, option_length); coap_pkt->accept_num += 1; PRINTF(""Accept [%u]\n"", coap_pkt->content_type); } break; case COAP_OPTION_IF_MATCH: coap_pkt->if_match_len = (uint8_t)(MIN(COAP_ETAG_LEN, option_length)); memcpy(coap_pkt->if_match, current_option, coap_pkt->if_match_len); PRINTF(""If-Match %u [0x%02X%02X%02X%02X%02X%02X%02X%02X]\n"", coap_pkt->if_match_len, coap_pkt->if_match[0], coap_pkt->if_match[1], coap_pkt->if_match[2], coap_pkt->if_match[3], coap_pkt->if_match[4], coap_pkt->if_match[5], coap_pkt->if_match[6], coap_pkt->if_match[7] );  break; case COAP_OPTION_IF_NONE_MATCH: coap_pkt->if_none_match = 1; PRINTF(""If-None-Match\n""); break; case COAP_OPTION_URI_HOST: coap_pkt->uri_host = current_option; coap_pkt->uri_host_len = option_length; PRINTF(""Uri-Host [%.*s]\n"", coap_pkt->uri_host_len, coap_pkt->uri_host); break; case COAP_OPTION_URI_PORT: coap_pkt->uri_port = coap_parse_int_option(current_option, option_length); PRINTF(""Uri-Port [%u]\n"", coap_pkt->uri_port); break; case COAP_OPTION_URI_PATH: coap_add_multi_option( &(coap_pkt->uri_path), current_option, option_length, 1); PRINTF(""Uri-Path [%.*s]\n"", option_length, current_option); break; case COAP_OPTION_URI_QUERY: coap_add_multi_option( &(coap_pkt->uri_query), current_option, option_length, 1); PRINTF(""Uri-Query [%.*s]\n"", option_length, current_option); break; case COAP_OPTION_LOCATION_PATH: coap_add_multi_option( &(coap_pkt->location_path), current_option, option_length, 1); break; case COAP_OPTION_LOCATION_QUERY: coap_merge_multi_option( &(coap_pkt->location_query), &(coap_pkt->location_query_len), current_option, option_length, '&'); PRINTF(""Location-Query [%.*s]\n"", option_length, current_option); break; case COAP_OPTION_PROXY_URI: coap_pkt->proxy_uri = current_option; coap_pkt->proxy_uri_len = option_length; PRINTF(""Proxy-Uri NOT IMPLEMENTED [%.*s]\n"", coap_pkt->proxy_uri_len, coap_pkt->proxy_uri); coap_error_message = ""This is a constrained server (Contiki)""; return PROXYING_NOT_SUPPORTED_5_05; break; case COAP_OPTION_OBSERVE: coap_pkt->observe = coap_parse_int_option(current_option, option_length); PRINTF(""Observe [%lu]\n"", coap_pkt->observe); break; case COAP_OPTION_BLOCK2: coap_pkt->block2_num = coap_parse_int_option(current_option, option_length); coap_pkt->block2_more = (coap_pkt->block2_num & 0x08)>>3; coap_pkt->block2_size = 16 << (coap_pkt->block2_num & 0x07); coap_pkt->block2_offset = (coap_pkt->block2_num & ~0x0000000F)<<(coap_pkt->block2_num & 0x07); coap_pkt->block2_num >>= 4; PRINTF(""Block2 [%lu%s (%u B/blk)]\n"", coap_pkt->block2_num, coap_pkt->block2_more ? ""+"" : """", coap_pkt->block2_size); break; case COAP_OPTION_BLOCK1: coap_pkt->block1_num = coap_parse_int_option(current_option, option_length); coap_pkt->block1_more = (coap_pkt->block1_num & 0x08)>>3; coap_pkt->block1_size = 16 << (coap_pkt->block1_num & 0x07); coap_pkt->block1_offset = (coap_pkt->block1_num & ~0x0000000F)<<(coap_pkt->block1_num & 0x07); coap_pkt->block1_num >>= 4; PRINTF(""Block1 [%lu%s (%u B/blk)]\n"", coap_pkt->block1_num, coap_pkt->block1_more ? ""+"" : """", coap_pkt->block1_size); break; case COAP_OPTION_SIZE: coap_pkt->size = coap_parse_int_option(current_option, option_length); PRINTF(""Size [%lu]\n"", coap_pkt->size); break; default: PRINTF(""unknown (%u)\n"", option_number); if (option_number & 1) { coap_error_message = ""Unsupported critical option""; return BAD_OPTION_4_02; } } current_option += option_length; }  PRINTF(""-Done parsing-------\n""); return NO_ERROR; }
Description: In Eclipse Wakaama (formerly liblwm2m) 1.0, core/er-coap-13/er-coap-13.c in lwm2mserver in the LWM2M server mishandles invalid options, leading to a memory leak. Processing of a single crafted packet leads to leaking (wasting) 24 bytes of memory. This can lead to termination of the LWM2M server after exhausting all available memory.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void initialise_write_state(fz_context *ctx, pdf_document *doc, const pdf_write_options *in_opts, pdf_write_state *opts) { int num; int xref_len = pdf_xref_len(ctx, doc); opts->do_incremental = in_opts->do_incremental; opts->do_ascii = in_opts->do_ascii; opts->do_tight = !in_opts->do_pretty; opts->do_expand = in_opts->do_decompress; opts->do_compress = in_opts->do_compress; opts->do_compress_images = in_opts->do_compress_images; opts->do_compress_fonts = in_opts->do_compress_fonts; opts->do_garbage = in_opts->do_garbage; opts->do_linear = in_opts->do_linear; opts->do_clean = in_opts->do_clean; opts->start = 0; opts->main_xref_offset = INT_MIN; opts->use_list = fz_malloc_array(ctx, xref_len + 3, sizeof(int)); opts->ofs_list = fz_malloc_array(ctx, xref_len + 3, sizeof(int64_t)); opts->gen_list = fz_calloc(ctx, xref_len + 3, sizeof(int)); opts->renumber_map = fz_malloc_array(ctx, xref_len + 3, sizeof(int)); opts->rev_renumber_map = fz_malloc_array(ctx, xref_len + 3, sizeof(int)); opts->continue_on_error = in_opts->continue_on_error; opts->errors = in_opts->errors; for (num = 0; num < xref_len; num++) { opts->use_list[num] = 0; opts->ofs_list[num] = 0; opts->renumber_map[num] = num; opts->rev_renumber_map[num] = num; } }
Description: pdf/pdf-write.c in Artifex MuPDF before 1.12.0 mishandles certain length changes when a repair operation occurs during a clean operation, which allows remote attackers to cause a denial of service (buffer overflow and application crash) or possibly have unspecified other impact via a crafted PDF document.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void io_req_task_queue(struct io_kiocb *req) { int ret; init_task_work(&req->task_work, io_req_task_submit); ret = io_req_task_work_add(req, &req->task_work); if (unlikely(ret)) { struct task_struct *tsk; init_task_work(&req->task_work, io_req_task_cancel); tsk = io_wq_get_task(req->ctx->io_wq); task_work_add(tsk, &req->task_work, 0); wake_up_process(tsk); } }
Description: An issue was discovered in the Linux kernel before 5.8.2. fs/io_uring.c has a use-after-free related to io_async_task_func and ctx reference holding, aka CID-6d816e088c35.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: std::pair<std::unique_ptr<BCProviderFromSrc>, std::string> BCProviderFromSrc::createBCProviderFromSrcImpl( std::unique_ptr<Buffer> buffer, llvh::StringRef sourceURL, std::unique_ptr<SourceMap> sourceMap, const CompileFlags &compileFlags, const ScopeChain &scopeChain, SourceErrorManager::DiagHandlerTy diagHandler, void *diagContext, const std::function<void(Module &)> &runOptimizationPasses) { assert( buffer->data()[buffer->size()] == 0 && ""The input buffer must be null terminated""); CodeGenerationSettings codeGenOpts{}; codeGenOpts.unlimitedRegisters = false; codeGenOpts.instrumentIR = compileFlags.instrumentIR; OptimizationSettings optSettings; optSettings.staticBuiltins = compileFlags.staticBuiltins.hasValue() ? compileFlags.staticBuiltins.getValue() : false; auto context = std::make_shared<Context>(codeGenOpts, optSettings); std::unique_ptr<SimpleDiagHandlerRAII> outputManager; if (diagHandler) { context->getSourceErrorManager().setDiagHandler(diagHandler, diagContext); } else { outputManager.reset( new SimpleDiagHandlerRAII(context->getSourceErrorManager())); } auto getErrorString = [&outputManager]() { return outputManager ? outputManager->getErrorString() : std::string(""error""); }; context->getSourceErrorManager().setWarningStatus( Warning::UndefinedVariable, false); context->setStrictMode(compileFlags.strict); context->setEnableEval(true); context->setPreemptiveFunctionCompilationThreshold( compileFlags.preemptiveFunctionCompilationThreshold); context->setPreemptiveFileCompilationThreshold( compileFlags.preemptiveFileCompilationThreshold); if (compileFlags.lazy && !runOptimizationPasses) { context->setLazyCompilation(true); } context->setGeneratorEnabled(compileFlags.enableGenerator); context->setDebugInfoSetting( compileFlags.debug ? DebugInfoSetting::ALL : DebugInfoSetting::THROWING); context->setEmitAsyncBreakCheck(compileFlags.emitAsyncBreakCheck); DeclarationFileListTy declFileList; if (compileFlags.includeLibHermes) { auto libBuffer = llvh::MemoryBuffer::getMemBuffer(libhermes); parser::JSParser libParser(*context, std::move(libBuffer)); auto libParsed = libParser.parse(); assert(libParsed && ""Libhermes failed to parse""); declFileList.push_back(libParsed.getValue()); } bool isLargeFile = buffer->size() >= context->getPreemptiveFileCompilationThreshold(); int fileBufId = context->getSourceErrorManager().addNewSourceBuffer( std::make_unique<HermesLLVMMemoryBuffer>(std::move(buffer), sourceURL)); if (sourceMap != nullptr) { auto sourceMapTranslator = std::make_shared<SourceMapTranslator>(context->getSourceErrorManager()); context->getSourceErrorManager().setTranslator(sourceMapTranslator); sourceMapTranslator->addSourceMap(fileBufId, std::move(sourceMap)); } auto parserMode = parser::FullParse; bool useStaticBuiltinDetected = false; if (context->isLazyCompilation() && isLargeFile) { if (!parser::JSParser::preParseBuffer( *context, fileBufId, useStaticBuiltinDetected)) { return {nullptr, getErrorString()}; } parserMode = parser::LazyParse; } sem::SemContext semCtx{}; parser::JSParser parser(*context, fileBufId, parserMode); auto parsed = parser.parse(); if (!parsed || !hermes::sem::validateAST(*context, semCtx, *parsed)) { return {nullptr, getErrorString()}; } if (parserMode != parser::LazyParse) { useStaticBuiltinDetected = parser.getUseStaticBuiltin(); } if (!compileFlags.staticBuiltins) { context->setStaticBuiltinOptimization(useStaticBuiltinDetected); } Module M(context); hermes::generateIRFromESTree(parsed.getValue(), &M, declFileList, scopeChain); if (context->getSourceErrorManager().getErrorCount() > 0) { return {nullptr, getErrorString()}; } if (runOptimizationPasses) runOptimizationPasses(M); BytecodeGenerationOptions opts{compileFlags.format}; opts.optimizationEnabled = !!runOptimizationPasses; opts.staticBuiltinsEnabled = context->getOptimizationSettings().staticBuiltins; opts.verifyIR = compileFlags.verifyIR; auto bytecode = createBCProviderFromSrc( hbc::generateBytecodeModule(&M, M.getTopLevelFunction(), opts)); bytecode->singleFunction_ = isSingleFunctionExpression(parsed.getValue()); return {std::move(bytecode), std::string{}}; }
Description: An integer conversion error in Hermes bytecode generation, prior to commit 6aa825e480d48127b480b08d13adf70033237097, could have been used to perform Out-Of-Bounds operations and subsequently execute arbitrary code. Note that this is only exploitable in cases where Hermes is used to execute untrusted JavaScript. Hence, most React Native applications are not affected.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: PyObject *addaceex(addaceexfunc addfunc, CHAR *funcname, PyACL *This, DWORD revision, DWORD aceflags, DWORD access, PyObject *obSID) { if (addfunc == NULL) return PyErr_Format(PyExc_NotImplementedError, ""%s not supported by this version of Windows"", funcname); PSID psid; BOOL bsuccess; PACL pacl = This->GetACL(); PACL pacl_padded = NULL; if (!PyWinObject_AsSID(obSID, &psid, FALSE)) return NULL; bsuccess = (*addfunc)(pacl, revision, aceflags, access, psid); if (bsuccess) bsuccess = _ReorderACL(pacl); else { DWORD err = GetLastError(); if (err != ERROR_ALLOTTED_SPACE_EXCEEDED) return PyWin_SetAPIError(funcname, err); unsigned short required_size = pacl->AclSize + sizeof(ACCESS_ALLOWED_ACE) + (unsigned short)GetLengthSid(psid); pacl_padded = (ACL *)malloc(required_size); if (pacl_padded == NULL) return PyErr_Format(PyExc_MemoryError, ""%s: unable to allocated %d bytes"", funcname, required_size); ZeroMemory(pacl_padded, required_size); memcpy(pacl_padded, pacl, pacl->AclSize); pacl_padded->AclSize = required_size; bsuccess = (*addfunc)(pacl_padded, revision, aceflags, access, psid); if (bsuccess) { bsuccess = _ReorderACL(pacl_padded); if (bsuccess) bsuccess = This->SetACL(pacl_padded); } else PyWin_SetAPIError(funcname); } if (pacl_padded) free(pacl_padded); if (bsuccess) { Py_INCREF(Py_None); return Py_None; } return NULL; }
Description: An integer overflow exists in pywin32 prior to version b301 when adding an access control entry (ACE) to an access control list (ACL) that would cause the size to be greater than 65535 bytes. An attacker who successfully exploited this vulnerability could crash the vulnerable process.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: PJ_DEF(pj_status_t) pjmedia_rtcp_fb_parse_sli( const void *buf, pj_size_t length, unsigned *sli_cnt, pjmedia_rtcp_fb_sli sli[]) { pjmedia_rtcp_common *hdr = (pjmedia_rtcp_common*) buf; pj_uint8_t *p; unsigned cnt, i; PJ_ASSERT_RETURN(buf && sli_cnt && sli, PJ_EINVAL); PJ_ASSERT_RETURN(length >= sizeof(pjmedia_rtcp_common), PJ_ETOOSMALL); if (hdr->pt != RTCP_PSFB || hdr->count != 2) return PJ_ENOTFOUND; cnt = pj_ntohs((pj_uint16_t)hdr->length) - 2; if (length < (cnt+3)*4) return PJ_ETOOSMALL; *sli_cnt = PJ_MIN(*sli_cnt, cnt); p = (pj_uint8_t*)hdr + sizeof(*hdr); for (i = 0; i < *sli_cnt; ++i) { sli[i].first = (p[0] << 5) + ((p[1] & 0xF8) >> 3); sli[i].number = ((p[1] & 0x07) << 10) + (p[2] << 2) + ((p[3] & 0xC0) >> 6); sli[i].pict_id = (p[3] & 0x3F); p += 4; } return PJ_SUCCESS; }
Description: PJSIP is a free and open source multimedia communication library written in C. PJSIP versions 2.12 and prior do not parse incoming RTCP feedback RPSI (Reference Picture Selection Indication) packet, but any app that directly uses pjmedia_rtcp_fb_parse_rpsi() will be affected. A patch is available in the `master` branch of the `pjsip/pjproject` GitHub repository. There are currently no known workarounds.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int main(int argc, char *argv[]) { struct fuse_args args = FUSE_ARGS_INIT(argc, argv); struct fuse_session *se; struct fuse_cmdline_opts opts; struct lo_data lo = { .sandbox = SANDBOX_NAMESPACE, .debug = 0, .writeback = 0, .posix_lock = 0, .allow_direct_io = 0, .proc_self_fd = -1, .user_killpriv_v2 = -1, .user_posix_acl = -1, }; struct lo_map_elem *root_elem; struct lo_map_elem *reserve_elem; int ret = -1; tzset(); umask(0); qemu_init_exec_dir(argv[0]); pthread_mutex_init(&lo.mutex, NULL); lo.inodes = g_hash_table_new(lo_key_hash, lo_key_equal); lo.root.fd = -1; lo.root.fuse_ino = FUSE_ROOT_ID; lo.cache = CACHE_AUTO; lo_map_init(&lo.ino_map); reserve_elem = lo_map_reserve(&lo.ino_map, 0); if (!reserve_elem) { fuse_log(FUSE_LOG_ERR, ""failed to alloc reserve_elem.\n""); goto err_out1; } reserve_elem->in_use = false; root_elem = lo_map_reserve(&lo.ino_map, lo.root.fuse_ino); if (!root_elem) { fuse_log(FUSE_LOG_ERR, ""failed to alloc root_elem.\n""); goto err_out1; } root_elem->inode = &lo.root; lo_map_init(&lo.dirp_map); lo_map_init(&lo.fd_map); if (fuse_parse_cmdline(&args, &opts) != 0) { goto err_out1; } fuse_set_log_func(log_func); use_syslog = opts.syslog; if (use_syslog) { openlog(""virtiofsd"", LOG_PID, LOG_DAEMON); } if (opts.show_help) { printf(""usage: %s [options]\n\n"", argv[0]); fuse_cmdline_help(); printf(""    -o source=PATH             shared directory tree\n""); fuse_lowlevel_help(); ret = 0; goto err_out1; } else if (opts.show_version) { qemu_version(); fuse_lowlevel_version(); ret = 0; goto err_out1; } else if (opts.print_capabilities) { print_capabilities(); ret = 0; goto err_out1; } if (fuse_opt_parse(&args, &lo, lo_opts, NULL) == -1) { goto err_out1; } if (opts.log_level != 0) { current_log_level = opts.log_level; } else { current_log_level = FUSE_LOG_INFO; } lo.debug = opts.debug; if (lo.debug) { current_log_level = FUSE_LOG_DEBUG; } if (lo.source) { struct stat stat; int res; res = lstat(lo.source, &stat); if (res == -1) { fuse_log(FUSE_LOG_ERR, ""failed to stat source (\""%s\""): %m\n"", lo.source); exit(1); } if (!S_ISDIR(stat.st_mode)) { fuse_log(FUSE_LOG_ERR, ""source is not a directory\n""); exit(1); } } else { lo.source = strdup(""/""); if (!lo.source) { fuse_log(FUSE_LOG_ERR, ""failed to strdup source\n""); goto err_out1; } } if (lo.xattrmap) { lo.xattr = 1; parse_xattrmap(&lo); } if (!lo.timeout_set) { switch (lo.cache) { case CACHE_NONE: lo.timeout = 0.0; break; case CACHE_AUTO: lo.timeout = 1.0; break; case CACHE_ALWAYS: lo.timeout = 86400.0; break; } } else if (lo.timeout < 0) { fuse_log(FUSE_LOG_ERR, ""timeout is negative (%lf)\n"", lo.timeout); exit(1); } if (lo.user_posix_acl == 1 && !lo.xattr) { fuse_log(FUSE_LOG_ERR, ""Can't enable posix ACLs. xattrs are disabled."" ""\n""); exit(1); } lo.use_statx = true; se = fuse_session_new(&args, &lo_oper, sizeof(lo_oper), &lo); if (se == NULL) { goto err_out1; } if (fuse_set_signal_handlers(se) != 0) { goto err_out2; } if (fuse_session_mount(se) != 0) { goto err_out3; } fuse_daemonize(opts.foreground); setup_nofile_rlimit(opts.rlimit_nofile); setup_capng(); setup_sandbox(&lo, se, opts.syslog); setup_root(&lo, &lo.root); ret = virtio_loop(se); fuse_session_unmount(se); cleanup_capng(); err_out3: fuse_remove_signal_handlers(se); err_out2: fuse_session_destroy(se); err_out1: fuse_opt_free_args(&args); fuse_lo_data_cleanup(&lo); return ret ? 1 : 0; }
Description: A flaw was found in the QEMU virtio-fs shared file system daemon (virtiofsd) implementation. This flaw is strictly related to CVE-2018-13405. A local guest user can create files in the directories shared by virtio-fs with unintended group ownership in a scenario where a directory is SGID to a certain group and is writable by a user who is not a member of the group. This could allow a malicious unprivileged user inside the guest to gain access to resources accessible to the root group, potentially escalating their privileges within the guest. A malicious local user in the host might also leverage this unexpected executable file created by the guest to escalate their privileges on the host system.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static inline int get_chainname_rulenum(const struct ipt_entry *s, const struct ipt_entry *e, const char *hookname, const char **chainname, const char **comment, unsigned int *rulenum) { const struct xt_standard_target *t = (void *)ipt_get_target_c(s); if (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) { *chainname = t->target.data; (*rulenum) = 0; } else if (s == e) { (*rulenum)++; if (s->target_offset == sizeof(struct ipt_entry) && strcmp(t->target.u.kernel.target->name, XT_STANDARD_TARGET) == 0 && t->verdict < 0 && unconditional(&s->ip)) { *comment = *chainname == hookname ? comments[NF_IP_TRACE_COMMENT_POLICY] : comments[NF_IP_TRACE_COMMENT_RETURN]; } return 1; } else (*rulenum)++; return 0; }
Description: The netfilter subsystem in the Linux kernel through 4.5.2 does not validate certain offset fields, which allows local users to gain privileges or cause a denial of service (heap memory corruption) via an IPT_SO_SET_REPLACE setsockopt call.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int iccompareproc(i_ctx_t *i_ctx_p, ref *space, ref *testspace) { int code1, code2; ref ICCdict1, ICCdict2, *tempref1, *tempref2; int buff_size; code1 = array_get(imemory, space, 1, &ICCdict1); if (code1 < 0) return 0; code2 = array_get(imemory, testspace, 1, &ICCdict2); if (code2 < 0) return 0; if (ICCdict1.value.bytes == ICCdict2.value.bytes)  return 1; code1 = dict_find_string(&ICCdict1, ""N"", &tempref1); code2 = dict_find_string(&ICCdict2, ""N"", &tempref2); if (code1 != code2) return 0; if (tempref1->value.intval != tempref2->value.intval) return 0; if (!comparedictkey(i_ctx_p, &ICCdict1, &ICCdict2, (char *)""Range"")) return 0; code1 = dict_find_string(&ICCdict1, ""DataSource"", &tempref1); if (code1 <= 0) return 0; code2 = dict_find_string(&ICCdict2, ""DataSource"", &tempref2); if (code2 <= 0) return 0; if (r_size(tempref1) != r_size(tempref2))  return 0; buff_size = r_size(tempref1); if (memcmp(tempref1->value.const_bytes, tempref2->value.const_bytes, buff_size) == 0) return 1; else return 0; }
Description: In Artifex Ghostscript through 9.25, the setpattern operator did not properly validate certain types. A specially crafted PostScript document could exploit this to crash Ghostscript or, possibly, execute arbitrary code in the context of the Ghostscript process. This is a type confusion issue because of failure to check whether the Implementation of a pattern dictionary was a structure type.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int GENERAL_NAME_cmp(GENERAL_NAME *a, GENERAL_NAME *b) { int result = -1; if (!a || !b || a->type != b->type) return -1; switch (a->type) { case GEN_X400: case GEN_EDIPARTY: result = ASN1_TYPE_cmp(a->d.other, b->d.other); break; case GEN_OTHERNAME: result = OTHERNAME_cmp(a->d.otherName, b->d.otherName); break; case GEN_EMAIL: case GEN_DNS: case GEN_URI: result = ASN1_STRING_cmp(a->d.ia5, b->d.ia5); break; case GEN_DIRNAME: result = X509_NAME_cmp(a->d.dirn, b->d.dirn); break; case GEN_IPADD: result = ASN1_OCTET_STRING_cmp(a->d.ip, b->d.ip); break; case GEN_RID: result = OBJ_cmp(a->d.rid, b->d.rid); break; } return result; }
Description: The X.509 GeneralName type is a generic type for representing different types of names. One of those name types is known as EDIPartyName. OpenSSL provides a function GENERAL_NAME_cmp which compares different instances of a GENERAL_NAME to see if they are equal or not. This function behaves incorrectly when both GENERAL_NAMEs contain an EDIPARTYNAME. A NULL pointer dereference and a crash may occur leading to a possible denial of service attack. OpenSSL itself uses the GENERAL_NAME_cmp function for two purposes: 1) Comparing CRL distribution point names between an available CRL and a CRL distribution point embedded in an X509 certificate 2) When verifying that a timestamp response token signer matches the timestamp authority name (exposed via the API functions TS_RESP_verify_response and TS_RESP_verify_token) If an attacker can control both items being compared then that attacker could trigger a crash. For example if the attacker can trick a client or server into checking a malicious certificate against a malicious CRL then this may occur. Note that some applications automatically download CRLs based on a URL embedded in a certificate. This checking happens prior to the signatures on the certificate and CRL being verified. OpenSSL's s_server, s_client and verify tools have support for the ""-crl_download"" option which implements automatic CRL downloading and this attack has been demonstrated to work against those tools. Note that an unrelated bug means that affected versions of OpenSSL cannot parse or construct correct encodings of EDIPARTYNAME. However it is possible to construct a malformed EDIPARTYNAME that OpenSSL's parser will accept and hence trigger this attack. All OpenSSL 1.1.1 and 1.0.2 versions are affected by this issue. Other OpenSSL releases are out of support and have not been checked. Fixed in OpenSSL 1.1.1i (Affected 1.1.1-1.1.1h). Fixed in OpenSSL 1.0.2x (Affected 1.0.2-1.0.2w).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void ll_invalidate_aliases(struct inode *inode) { struct dentry *dentry; struct ll_d_hlist_node *p; LASSERT(inode != NULL); CDEBUG(D_INODE, ""marking dentries for ino %lu/%u(%p) invalid\n"", inode->i_ino, inode->i_generation, inode); ll_lock_dcache(inode); ll_d_hlist_for_each_entry(dentry, p, &inode->i_dentry, d_alias) { CDEBUG(D_DENTRY, ""dentry in drop %.*s (%p) parent %p "" ""inode %p flags %d\n"", dentry->d_name.len, dentry->d_name.name, dentry, dentry->d_parent, dentry->d_inode, dentry->d_flags); if (unlikely(dentry == dentry->d_sb->s_root)) { CERROR(""%s: called on root dentry=%p, fid=""DFID""\n"", ll_get_fsname(dentry->d_sb, NULL, 0), dentry, PFID(ll_inode2fid(inode))); lustre_dump_dentry(dentry, 1); dump_stack(); } d_lustre_invalidate(dentry, 0); } ll_unlock_dcache(inode); }
Description: The d_walk function in fs/dcache.c in the Linux kernel through 3.17.2 does not properly maintain the semantics of rename_lock, which allows local users to cause a denial of service (deadlock and system hang) via a crafted application.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int SoundPool::load(int fd, int64_t offset, int64_t length, int priority __unused) { ALOGV(""load: fd=%d, offset=%"" PRId64 "", length=%"" PRId64 "", priority=%d"", fd, offset, length, priority); Mutex::Autolock lock(&mLock); sp<Sample> sample = new Sample(++mNextSampleID, fd, offset, length); mSamples.add(sample->sampleID(), sample); doLoad(sample); return sample->sampleID(); }
Description: media/libmedia/SoundPool.cpp in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49G, and 6.x before 2016-02-01 mishandles locking requirements, which allows attackers to gain privileges via a crafted application, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25781119.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static gboolean iseries_check_file_type (wtap * wth, int *err, gchar **err_info, int format) { guint      line; int        num_items_scanned; char       buf[ISERIES_LINE_LENGTH], protocol[9]; iseries_t *iseries; iseries                = (iseries_t *) g_malloc (sizeof (iseries_t)); wth->priv              = (void *) iseries; iseries->have_date     = FALSE; iseries->format        = format; for (line = 0; line < ISERIES_HDR_LINES_TO_CHECK; line++) { if (file_gets (buf, ISERIES_LINE_LENGTH, wth->fh) == NULL) { *err = file_error (wth->fh, err_info); if (*err == WTAP_ERR_SHORT_READ) *err = 0; return FALSE; } if (iseries->format == ISERIES_FORMAT_UNICODE) { iseries_UNICODE_to_ASCII ((guint8 *)buf, ISERIES_LINE_LENGTH); } ascii_strup_inplace (buf); num_items_scanned = sscanf (buf, ""%*[ \n\t]OBJECT PROTOCOL%*[ .:\n\t]%8s"", protocol); if (num_items_scanned == 1) { if (memcmp (protocol, ""ETHERNET"", 8) != 0) return FALSE; } num_items_scanned = sscanf (buf, ""%*[ \n\t]START DATE/TIME%*[ .:\n\t]%2d/%2d/%2d"", &iseries->month, &iseries->day, &iseries->year); if (num_items_scanned == 3) { iseries->have_date = TRUE; } } *err = 0; return TRUE; }
Description: The iseries_check_file_type function in wiretap/iseries.c in the iSeries file parser in Wireshark 2.0.x before 2.0.2 does not consider that a line may lack the ""OBJECT PROTOCOL"" substring, which allows remote attackers to cause a denial of service (out-of-bounds read and application crash) via a crafted file.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static FT_Error tt_size_select( FT_Size   size, FT_ULong  strike_index ) { TT_Face   ttface = (TT_Face)size->face; TT_Size   ttsize = (TT_Size)size; FT_Error  error  = FT_Err_Ok; ttsize->strike_index = strike_index; if ( FT_IS_SCALABLE( size->face ) ) { FT_Select_Metrics( size->face, strike_index ); tt_size_reset( ttsize, 0 );  } else { SFNT_Service      sfnt         = (SFNT_Service)ttface->sfnt; FT_Size_Metrics*  size_metrics = &size->metrics; error = sfnt->load_strike_metrics( ttface, strike_index, size_metrics ); if ( error ) ttsize->strike_index = 0xFFFFFFFFUL; } return error; }
Description: In multiple locations, there is a possible code execution due to type confusion. This could lead to remote code execution with no additional execution privileges needed. User interaction is not needed for exploitation.


 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void FrameworkListener::init(const char *socketName UNUSED, bool withSeq) { mCommands = new FrameworkCommandCollection(); errorRate = 0; mCommandCount = 0; mWithSeq = withSeq; }
Description: libsysutils/src/FrameworkListener.cpp in Framework Listener in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-10-01, and 7.0 before 2016-10-01 allows attackers to gain privileges via a crafted application, aka internal bug 29831647.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int fsl_lpspi_probe(struct platform_device *pdev) { struct device_node *np = pdev->dev.of_node; struct fsl_lpspi_data *fsl_lpspi; struct spi_controller *controller; struct spi_imx_master *lpspi_platform_info = dev_get_platdata(&pdev->dev); struct resource *res; int i, ret, irq; u32 temp; bool is_slave; is_slave = of_property_read_bool((&pdev->dev)->of_node, ""spi-slave""); if (is_slave) controller = spi_alloc_slave(&pdev->dev, sizeof(struct fsl_lpspi_data)); else controller = spi_alloc_master(&pdev->dev, sizeof(struct fsl_lpspi_data)); if (!controller) return -ENOMEM; platform_set_drvdata(pdev, controller); fsl_lpspi = spi_controller_get_devdata(controller); fsl_lpspi->dev = &pdev->dev; fsl_lpspi->is_slave = is_slave; if (!fsl_lpspi->is_slave) { for (i = 0; i < controller->num_chipselect; i++) { int cs_gpio = of_get_named_gpio(np, ""cs-gpios"", i); if (!gpio_is_valid(cs_gpio) && lpspi_platform_info) cs_gpio = lpspi_platform_info->chipselect[i]; fsl_lpspi->chipselect[i] = cs_gpio; if (!gpio_is_valid(cs_gpio)) continue; ret = devm_gpio_request(&pdev->dev, fsl_lpspi->chipselect[i], DRIVER_NAME); if (ret) { dev_err(&pdev->dev, ""can't get cs gpios\n""); goto out_controller_put; } } controller->cs_gpios = fsl_lpspi->chipselect; controller->prepare_message = fsl_lpspi_prepare_message; } controller->bits_per_word_mask = SPI_BPW_RANGE_MASK(8, 32); controller->transfer_one = fsl_lpspi_transfer_one; controller->prepare_transfer_hardware = lpspi_prepare_xfer_hardware; controller->unprepare_transfer_hardware = lpspi_unprepare_xfer_hardware; controller->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH; controller->flags = SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX; controller->dev.of_node = pdev->dev.of_node; controller->bus_num = pdev->id; controller->slave_abort = fsl_lpspi_slave_abort; init_completion(&fsl_lpspi->xfer_done); res = platform_get_resource(pdev, IORESOURCE_MEM, 0); fsl_lpspi->base = devm_ioremap_resource(&pdev->dev, res); if (IS_ERR(fsl_lpspi->base)) { ret = PTR_ERR(fsl_lpspi->base); goto out_controller_put; } fsl_lpspi->base_phys = res->start; irq = platform_get_irq(pdev, 0); if (irq < 0) { ret = irq; goto out_controller_put; } ret = devm_request_irq(&pdev->dev, irq, fsl_lpspi_isr, 0, dev_name(&pdev->dev), fsl_lpspi); if (ret) { dev_err(&pdev->dev, ""can't get irq%d: %d\n"", irq, ret); goto out_controller_put; } fsl_lpspi->clk_per = devm_clk_get(&pdev->dev, ""per""); if (IS_ERR(fsl_lpspi->clk_per)) { ret = PTR_ERR(fsl_lpspi->clk_per); goto out_controller_put; } fsl_lpspi->clk_ipg = devm_clk_get(&pdev->dev, ""ipg""); if (IS_ERR(fsl_lpspi->clk_ipg)) { ret = PTR_ERR(fsl_lpspi->clk_ipg); goto out_controller_put; } ret = fsl_lpspi_init_rpm(fsl_lpspi); if (ret) goto out_controller_put; ret = pm_runtime_get_sync(fsl_lpspi->dev); if (ret < 0) { dev_err(fsl_lpspi->dev, ""failed to enable clock\n""); return ret; } temp = readl(fsl_lpspi->base + IMX7ULP_PARAM); fsl_lpspi->txfifosize = 1 << (temp & 0x0f); fsl_lpspi->rxfifosize = 1 << ((temp >> 8) & 0x0f); ret = fsl_lpspi_dma_init(&pdev->dev, fsl_lpspi, controller); if (ret == -EPROBE_DEFER) goto out_controller_put; if (ret < 0) dev_err(&pdev->dev, ""dma setup error %d, use pio\n"", ret); ret = devm_spi_register_controller(&pdev->dev, controller); if (ret < 0) { dev_err(&pdev->dev, ""spi_register_controller error.\n""); goto out_controller_put; } return 0; out_controller_put: spi_controller_put(controller); return ret; }
Description: A memory leak in the fsl_lpspi_probe() function in drivers/spi/spi-fsl-lpspi.c in the Linux kernel through 5.3.11 allows attackers to cause a denial of service (memory consumption) by triggering pm_runtime_get_sync() failures, aka CID-057b8945f78f. NOTE: third parties dispute the relevance of this because an attacker cannot realistically control these failures at probe time
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int find_high_bit(unsigned int x) { int i; for(i=31;i>=0;i--) { if(x&(1<<i)) return i; } return 0; }
Description: libimageworsener.a in ImageWorsener before 1.3.1 has ""left shift cannot be represented in type int"" undefined behavior issues, which might allow remote attackers to cause a denial of service (application crash) or possibly have unspecified other impact via a crafted image, related to imagew-bmp.c and imagew-util.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int dvb_demux_open(struct inode *inode, struct file *file) { struct dvb_device *dvbdev = file->private_data; struct dmxdev *dmxdev = dvbdev->priv; int i; struct dmxdev_filter *dmxdevfilter; if (!dmxdev->filter) return -EINVAL; if (mutex_lock_interruptible(&dmxdev->mutex)) return -ERESTARTSYS; for (i = 0; i < dmxdev->filternum; i++) if (dmxdev->filter[i].state == DMXDEV_STATE_FREE) break; if (i == dmxdev->filternum) { mutex_unlock(&dmxdev->mutex); return -EMFILE; } dmxdevfilter = &dmxdev->filter[i]; mutex_init(&dmxdevfilter->mutex); file->private_data = dmxdevfilter; #ifdef CONFIG_DVB_MMAP dmxdev->may_do_mmap = 1; #else dmxdev->may_do_mmap = 0; #endif dvb_ringbuffer_init(&dmxdevfilter->buffer, NULL, 8192); dvb_vb2_init(&dmxdevfilter->vb2_ctx, ""demux_filter"", file->f_flags & O_NONBLOCK); dmxdevfilter->type = DMXDEV_TYPE_NONE; dvb_dmxdev_filter_state_set(dmxdevfilter, DMXDEV_STATE_ALLOCATED); timer_setup(&dmxdevfilter->timer, dvb_dmxdev_filter_timeout, 0); dvbdev->users++; mutex_unlock(&dmxdev->mutex); return 0; }
Description: In drivers/media/dvb-core/dmxdev.c in the Linux kernel through 5.19.10, there is a use-after-free caused by refcount races, affecting dvb_demux_open and dvb_dmxdev_release.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files, rpmpsm psm, char ** failedFile) { FD_t payload = rpmtePayload(te); rpmfi fi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE); rpmfs fs = rpmteGetFileStates(te); rpmPlugins plugins = rpmtsPlugins(ts); struct stat sb; int saveerrno = errno; int rc = 0; int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0; int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0; int firsthardlink = -1; int skip; rpmFileAction action; char *tid = NULL; const char *suffix; char *fpath = NULL; if (fi == NULL) { rc = RPMERR_BAD_MAGIC; goto exit; } rasprintf(&tid, "";%08x"", (unsigned)rpmtsGetTid(ts)); rc = fsmMkdirs(files, fs, plugins); while (!rc) { rc = rpmfiNext(fi); if (rc < 0) { if (rc == RPMERR_ITER_END) rc = 0; break; } action = rpmfsGetAction(fs, rpmfiFX(fi)); skip = XFA_SKIPPING(action); suffix = S_ISDIR(rpmfiFMode(fi)) ? NULL : tid; if (action != FA_TOUCH) { fpath = fsmFsPath(fi, suffix); } else { fpath = fsmFsPath(fi, """"); } rc = rpmfiStat(fi, 1, &sb); fsmDebug(fpath, action, &sb); if (rc) break; rc = rpmpluginsCallFsmFilePre(plugins, fi, fpath, sb.st_mode, action); if (rc) { skip = 1; } else { setFileState(fs, rpmfiFX(fi)); } if (!skip) { int setmeta = 1; if (!suffix) { rc = fsmBackup(fi, action); } if (!suffix) { rc = fsmVerify(fpath, fi); } else { rc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT; } if (S_ISREG(sb.st_mode)) { if (rc == RPMERR_ENOENT) { rc = fsmMkfile(fi, fpath, files, psm, nodigest, &setmeta, &firsthardlink); } } else if (S_ISDIR(sb.st_mode)) { if (rc == RPMERR_ENOENT) { mode_t mode = sb.st_mode; mode &= ~07777; mode |=  00700; rc = fsmMkdir(fpath, mode); } } else if (S_ISLNK(sb.st_mode)) { if (rc == RPMERR_ENOENT) { rc = fsmSymlink(rpmfiFLink(fi), fpath); } } else if (S_ISFIFO(sb.st_mode)) { if (rc == RPMERR_ENOENT) { rc = fsmMkfifo(fpath, 0000); } } else if (S_ISCHR(sb.st_mode) || S_ISBLK(sb.st_mode) || S_ISSOCK(sb.st_mode)) { if (rc == RPMERR_ENOENT) { rc = fsmMknod(fpath, sb.st_mode, sb.st_rdev); } } else { if (!IS_DEV_LOG(fpath)) rc = RPMERR_UNKNOWN_FILETYPE; } if (!rc && setmeta) { rc = fsmSetmeta(fpath, fi, plugins, action, &sb, nofcaps); } } else if (firsthardlink >= 0 && rpmfiArchiveHasContent(fi)) { char *fn = rpmfilesFN(files, firsthardlink); rc = expandRegular(fi, fn, psm, 0, nodigest, 0); firsthardlink = -1; free(fn); } if (rc) { if (!skip) { if (suffix && (action != FA_TOUCH)) { (void) fsmRemove(fpath, sb.st_mode); } errno = saveerrno; } } else { rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi)); if (!skip) { if (suffix) rc = fsmBackup(fi, action); if (!rc) rc = fsmCommit(&fpath, fi, action, suffix); } } if (rc) *failedFile = xstrdup(fpath); rpmpluginsCallFsmFilePost(plugins, fi, fpath, sb.st_mode, action, rc); fpath = _free(fpath); } rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ)); rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST)); exit: rpmfiArchiveClose(fi); rpmfiFree(fi); Fclose(payload); free(tid); free(fpath); return rc; }
Description: It was found that rpm did not properly handle RPM installations when a destination path was a symbolic link to a directory, possibly changing ownership and permissions of an arbitrary directory, and RPM files being placed in an arbitrary destination. An attacker, with write access to a directory in which a subdirectory will be installed, could redirect that directory to an arbitrary location and gain root privilege.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void cliRefreshPrompt(void) { int len; if (config.eval_ldb) return; if (config.hostsocket != NULL) len = snprintf(config.prompt,sizeof(config.prompt),""redis %s"", config.hostsocket); else len = anetFormatAddr(config.prompt, sizeof(config.prompt), config.hostip, config.hostport); if (config.dbnum != 0) len += snprintf(config.prompt+len,sizeof(config.prompt)-len,""[%d]"", config.dbnum); snprintf(config.prompt+len,sizeof(config.prompt)-len,""> ""); }
Description: Buffer overflow in redis-cli of Redis before 4.0.10 and 5.x before 5.0 RC3 allows an attacker to achieve code execution and escalate to higher privileges via a crafted command line. NOTE: It is unclear whether there are any common situations in which redis-cli is used with, for example, a -h (aka hostname) argument from an untrusted source.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: char_u * eval_next_non_blank(char_u *arg, evalarg_T *evalarg, int *getnext) { char_u *p = skipwhite(arg); *getnext = FALSE; if (in_vim9script() && evalarg != NULL && (evalarg->eval_cookie != NULL || evalarg->eval_cctx != NULL || *p == NL) && (*p == NUL || *p == NL || (vim9_comment_start(p) && VIM_ISWHITE(p[-1])))) { char_u *next; if (*p == NL) next = newline_skip_comments(p); else if (evalarg->eval_cookie != NULL) next = getline_peek_skip_comments(evalarg); else next = peek_next_line_from_context(evalarg->eval_cctx); if (next != NULL) { *getnext = TRUE; return skipwhite(next); } } return p; }
Description: NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.0552.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void add_capabilities (proto_tree *tree, packet_info *pinfo, tvbuff_t *tvb, guint8 pdu_type) { proto_tree *wsp_capabilities, *cap_subtree, *cap_subtree2; proto_item *ti, *cap_item, *cap_item2; char       *capaName, *str; guint32     offset       = 0; guint32     len          = 0; guint32     capaStart    = 0;  guint32     capaLen      = 0;  guint32     capaValueLen = 0;  guint32     tvb_len      = tvb_reported_length(tvb); gboolean    ok           = FALSE; guint8      peek; guint32     value; if (tvb_len == 0) { return; } ti = proto_tree_add_item(tree, hf_capabilities_section, tvb, 0, tvb_len, ENC_NA); wsp_capabilities = proto_item_add_subtree(ti, ett_capabilities); while (offset < tvb_len) { capaStart = offset; capaValueLen = tvb_get_guintvar(tvb, offset, &len, pinfo, &ei_wsp_oversized_uintvar); capaLen = capaValueLen + len; cap_subtree = proto_tree_add_subtree(wsp_capabilities, tvb, offset, capaLen, ett_capabilities_entry, &cap_item, ""Capability""); offset += len; peek = tvb_get_guint8(tvb, offset); if (is_token_text(peek)) {  capaName = (gchar *)tvb_get_stringz_enc(wmem_packet_scope(), tvb, capaStart, (gint *)&len, ENC_ASCII); if (g_ascii_strcasecmp(capaName, ""client-sdu-size"") == 0) { peek = WSP_CAPA_CLIENT_SDU_SIZE; } else if (g_ascii_strcasecmp(capaName, ""server-sdu-size"") == 0) { peek = WSP_CAPA_SERVER_SDU_SIZE; } else if (g_ascii_strcasecmp(capaName, ""protocol options"") == 0) { peek = WSP_CAPA_PROTOCOL_OPTIONS; } else if (g_ascii_strcasecmp(capaName, ""method-mor"") == 0) { peek = WSP_CAPA_METHOD_MOR; } else if (g_ascii_strcasecmp(capaName, ""push-mor"") == 0) { peek = WSP_CAPA_PUSH_MOR; } else if (g_ascii_strcasecmp(capaName, ""extended methods"") == 0) { peek = WSP_CAPA_EXTENDED_METHODS; } else if (g_ascii_strcasecmp(capaName, ""header code pages"") == 0) { peek = WSP_CAPA_HEADER_CODE_PAGES; } else if (g_ascii_strcasecmp(capaName, ""aliases"") == 0) { peek = WSP_CAPA_ALIASES; } else if (g_ascii_strcasecmp(capaName, ""client-message-size"") == 0) { peek = WSP_CAPA_CLIENT_MESSAGE_SIZE; } else if (g_ascii_strcasecmp(capaName, ""server-message-size"") == 0) { peek = WSP_CAPA_SERVER_MESSAGE_SIZE; } else { expert_add_info_format(pinfo, cap_item, &ei_wsp_capability_invalid, ""Unknown or invalid textual capability: %s"", capaName); offset = capaStart + capaLen; continue; } offset += len; } else if (peek < 0x80) { expert_add_info_format(pinfo, cap_item, &ei_wsp_capability_invalid, ""Invalid well-known capability: 0x%02X"", peek); return; } if (peek & 0x80) {  peek &= 0x7F; len = 1; offset++; } proto_item_append_text(cap_item, "": %s"", val_to_str_const(peek, wsp_capability_vals, ""Invalid capabiliity"")); switch (peek) { case WSP_CAPA_CLIENT_SDU_SIZE: value = tvb_get_guintvar(tvb, offset, &len, pinfo, &ei_wsp_oversized_uintvar); proto_tree_add_uint(cap_subtree, hf_capa_client_sdu_size, tvb, offset, len, value); break; case WSP_CAPA_SERVER_SDU_SIZE: value = tvb_get_guintvar(tvb, offset, &len, pinfo, &ei_wsp_oversized_uintvar); proto_tree_add_uint(cap_subtree, hf_capa_server_sdu_size, tvb, offset, len, value); break; case WSP_CAPA_PROTOCOL_OPTIONS: if (capaValueLen - len == 1) { static const int * capabilities[] = { &hf_capa_protocol_option_confirmed_push, &hf_capa_protocol_option_push, &hf_capa_protocol_option_session_resume, &hf_capa_protocol_option_ack_headers, &hf_capa_protocol_option_large_data_transfer, NULL }; proto_tree_add_bitmask_with_flags(cap_subtree, tvb, offset, hf_capa_protocol_options, ett_proto_option_capability, capabilities, ENC_NA, BMT_NO_FALSE); } else { proto_item_append_text(cap_item, "" <warning: bit field too large>""); offset = capaStart + capaLen; continue; } break; case WSP_CAPA_METHOD_MOR: proto_tree_add_item(cap_subtree, hf_capa_method_mor, tvb, offset, len, ENC_NA); break; case WSP_CAPA_PUSH_MOR: proto_tree_add_item(cap_subtree, hf_capa_push_mor, tvb, offset, len, ENC_NA); break; case WSP_CAPA_EXTENDED_METHODS: cap_subtree2 = proto_tree_add_subtree(cap_subtree, tvb, capaStart, capaLen, ett_capabilities_extended_methods, &cap_item2, ""Extended Methods""); if (pdu_type == WSP_PDU_CONNECT) { while (offset < capaStart + capaLen) { ti = proto_tree_add_item(cap_subtree2, hf_capa_extended_method, tvb, offset, 1, ENC_NA); offset++; get_text_string(str, tvb, offset, len, ok); if (! ok) { expert_add_info(pinfo, ti, &ei_wsp_capability_encoding_invalid); return; } proto_item_append_text(ti, "" = %s"", str); proto_item_set_len(ti, len+1); offset += len; } } else { while (offset < capaStart + capaLen) { proto_tree_add_item(cap_subtree2, hf_capa_extended_method, tvb, offset, 1, ENC_NA); offset++; } } break; case WSP_CAPA_HEADER_CODE_PAGES: cap_subtree2 = proto_tree_add_subtree(cap_subtree, tvb, capaStart, capaLen, ett_capabilities_header_code_pages, &cap_item2, ""Header Code Pages""); if (pdu_type == WSP_PDU_CONNECT) { while (offset < capaStart + capaLen) { ti = proto_tree_add_item(cap_subtree2, hf_capa_header_code_page, tvb, offset, 1, ENC_NA); offset++; get_text_string(str, tvb, offset, len, ok); if (! ok) { expert_add_info(pinfo, ti, &ei_wsp_capability_encoding_invalid); return; } proto_item_append_text(ti, "" = %s"", str); proto_item_set_len(ti, len+1); offset += len; } } else { while (offset < capaStart + capaLen) { proto_tree_add_item(cap_subtree2, hf_capa_header_code_page, tvb, offset, 1, ENC_NA); offset++; } } break; case WSP_CAPA_ALIASES: proto_tree_add_item(cap_subtree, hf_capa_aliases, tvb, capaStart, capaLen, ENC_NA); break; case WSP_CAPA_CLIENT_MESSAGE_SIZE: value = tvb_get_guintvar(tvb, offset, &len, pinfo, &ei_wsp_oversized_uintvar); proto_tree_add_uint(cap_subtree, hf_capa_client_message_size, tvb, offset, len, value); break; case WSP_CAPA_SERVER_MESSAGE_SIZE: value = tvb_get_guintvar(tvb, offset, &len, pinfo, &ei_wsp_oversized_uintvar); proto_tree_add_uint(cap_subtree, hf_capa_server_message_size, tvb, offset, len, value); break; default: expert_add_info_format(pinfo, cap_item, &ei_wsp_capability_invalid, ""Unknown well-known capability: 0x%02X"", peek); break; } offset = capaStart + capaLen; } }
Description: In Wireshark 2.2.0 to 2.2.5 and 2.0.0 to 2.0.11, the WSP dissector could go into an infinite loop, triggered by packet injection or a malformed capture file. This was addressed in epan/dissectors/packet-wsp.c by adding a length check.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static struct buffer_head *__ext4_read_dirblock(struct inode *inode, ext4_lblk_t block, dirblock_type_t type, const char *func, unsigned int line) { struct buffer_head *bh; struct ext4_dir_entry *dirent; int is_dx_block = 0; if (ext4_simulate_fail(inode->i_sb, EXT4_SIM_DIRBLOCK_EIO)) bh = ERR_PTR(-EIO); else bh = ext4_bread(NULL, inode, block, 0); if (IS_ERR(bh)) { __ext4_warning(inode->i_sb, func, line, ""inode #%lu: lblock %lu: comm %s: "" ""error %ld reading directory block"", inode->i_ino, (unsigned long)block, current->comm, PTR_ERR(bh)); return bh; } if (!bh && (type == INDEX || type == DIRENT_HTREE)) { ext4_error_inode(inode, func, line, block, ""Directory hole found for htree %s block"", (type == INDEX) ? ""index"" : ""leaf""); return ERR_PTR(-EFSCORRUPTED); } if (!bh) return NULL; dirent = (struct ext4_dir_entry *) bh->b_data; if (is_dx(inode)) { if (block == 0) is_dx_block = 1; else if (ext4_rec_len_from_disk(dirent->rec_len, inode->i_sb->s_blocksize) == inode->i_sb->s_blocksize) is_dx_block = 1; } if (!is_dx_block && type == INDEX) { ext4_error_inode(inode, func, line, block, ""directory leaf block found instead of index block""); brelse(bh); return ERR_PTR(-EFSCORRUPTED); } if (!ext4_has_metadata_csum(inode->i_sb) || buffer_verified(bh)) return bh; if (is_dx_block && type == INDEX) { if (ext4_dx_csum_verify(inode, dirent) && !ext4_simulate_fail(inode->i_sb, EXT4_SIM_DIRBLOCK_CRC)) set_buffer_verified(bh); else { ext4_error_inode_err(inode, func, line, block, EFSBADCRC, ""Directory index failed checksum""); brelse(bh); return ERR_PTR(-EFSBADCRC); } } if (!is_dx_block) { if (ext4_dirblock_csum_verify(inode, bh) && !ext4_simulate_fail(inode->i_sb, EXT4_SIM_DIRBLOCK_CRC)) set_buffer_verified(bh); else { ext4_error_inode_err(inode, func, line, block, EFSBADCRC, ""Directory block failed checksum""); brelse(bh); return ERR_PTR(-EFSBADCRC); } } return bh; }
Description: Apptainer is an open source container platform for Linux. There is an ext4 use-after-free flaw that is exploitable through versions of Apptainer < 1.1.0 and installations that include apptainer-suid < 1.1.8 on older operating systems where that CVE has not been patched. That includes Red Hat Enterprise Linux 7, Debian 10 buster (unless the linux-5.10 package is installed), Ubuntu 18.04 bionic and Ubuntu 20.04 focal. Use-after-free flaws in the kernel can be used to attack the kernel for denial of service and potentially for privilege escalation.

Apptainer 1.1.8 includes a patch that by default disables mounting of extfs filesystem types in setuid-root mode, while continuing to allow mounting of extfs filesystems in non-setuid ""rootless"" mode using fuse2fs.

Some workarounds are possible. Either do not install apptainer-suid (for versions 1.1.0 through 1.1.7) or set `allow setuid = no` in apptainer.conf.  This requires having unprivileged user namespaces enabled and except for apptainer 1.1.x versions will disallow mounting of sif files, extfs files, and squashfs files in addition to other, less significant impacts.  (Encrypted sif files are also not supported unprivileged in apptainer 1.1.x.). Alternatively, use the `limit containers` options in apptainer.conf/singularity.conf to limit sif files to trusted users, groups, and/or paths, and set `allow container extfs = no` to disallow mounting of extfs overlay files.  The latter option by itself does not disallow mounting of extfs overlay partitions inside SIF files, so that's why the former options are also needed.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void mqtts_tcptran_pipe_recv_cb(void *arg) { nni_aio *           aio; nni_iov             iov; uint8_t             type, pos, flags; uint32_t            len = 0, rv; size_t              n; nni_msg *           msg, *qmsg; mqtts_tcptran_pipe *p     = arg; nni_aio *           rxaio = p->rxaio; bool                ack   = false; nni_mtx_lock(&p->mtx); aio = nni_list_first(&p->recvq); if ((rv = nni_aio_result(rxaio)) != 0) { rv = SERVER_UNAVAILABLE; goto recv_error; } n = nni_aio_count(rxaio); p->gotrxhead += n; nni_aio_iov_advance(rxaio, n); if (nni_aio_iov_count(rxaio) > 0) { nng_stream_recv(p->conn, rxaio); nni_mtx_unlock(&p->mtx); return; } rv = mqtt_get_remaining_length(p->rxlen, p->gotrxhead, &len, &pos); p->wantrxhead = len + 1 + pos; if (p->gotrxhead <= 5 && p->rxlen[p->gotrxhead - 1] > 0x7f) { if (p->gotrxhead == NNI_NANO_MAX_HEADER_SIZE) { rv = PACKET_TOO_LARGE; goto recv_error; } iov.iov_buf = &p->rxlen[p->gotrxhead]; iov.iov_len = 1; nni_aio_set_iov(rxaio, 1, &iov); nng_stream_recv(p->conn, rxaio); nni_mtx_unlock(&p->mtx); return; } if (NULL == p->rxmsg) { if ((len > p->rcvmax) && (p->rcvmax > 0)) { rv = PACKET_TOO_LARGE; goto recv_error; } if ((rv = nni_msg_alloc(&p->rxmsg, (size_t) len)) != 0) { rv = UNSPECIFIED_ERROR; goto recv_error; } nni_msg_set_remaining_len(p->rxmsg, len); if (len != 0) { iov.iov_buf = nni_msg_body(p->rxmsg); iov.iov_len = (size_t) len; nni_aio_set_iov(rxaio, 1, &iov); nng_stream_recv(p->conn, rxaio); nni_mtx_unlock(&p->mtx); return; } } nni_aio_list_remove(aio); nni_msg_header_append(p->rxmsg, p->rxlen, pos + 1); msg      = p->rxmsg; p->rxmsg = NULL; n        = nni_msg_len(msg); type     = p->rxlen[0] & 0xf0; flags    = p->rxlen[0] & 0x0f; uint8_t   qos_pac; uint16_t  packet_id   = 0; uint8_t   reason_code = 0; property *prop        = NULL; uint8_t   ack_cmd     = 0; switch (type) { case CMD_PUBLISH: qos_pac = nni_msg_get_pub_qos(msg); if (qos_pac > 0) { if (qos_pac == 1) { ack_cmd = CMD_PUBACK; } else if (qos_pac == 2) { ack_cmd = CMD_PUBREC; } packet_id = nni_msg_get_pub_pid(msg); ack = true; } break; case CMD_PUBREC: if (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code, &prop, p->proto) != 0) { rv = PROTOCOL_ERROR; goto recv_error; } ack_cmd = CMD_PUBREL; ack     = true; break; case CMD_PUBREL: if (flags == 0x02) { if (nni_mqtt_pubres_decode(msg, &packet_id, &reason_code, &prop, p->proto) != 0) { rv = PROTOCOL_ERROR; goto recv_error; } ack_cmd = CMD_PUBCOMP; ack     = true; break; } else { rv = PROTOCOL_ERROR; goto recv_error; } case CMD_PUBACK: case CMD_PUBCOMP: if (nni_mqtt_pubres_decode( msg, &packet_id, &reason_code, &prop, p->proto) != 0) { rv = PROTOCOL_ERROR; goto recv_error; } if (p->proto == MQTT_PROTOCOL_VERSION_v5) { p->sndmax++; } break; default: break; } if (ack == true) { if ((rv = nni_msg_alloc(&qmsg, 0)) != 0) { ack = false; rv  = UNSPECIFIED_ERROR; goto recv_error; } nni_mqtt_msgack_encode( qmsg, packet_id, reason_code, prop, p->proto); nni_mqtt_pubres_header_encode(qmsg, ack_cmd); if (p->proto == MQTT_PROTOCOL_VERSION_v5) { property_free(prop); } if (p->busy == false) { nni_msg_insert(qmsg, nni_msg_header(qmsg), nni_msg_header_len(qmsg)); iov.iov_len    = nni_msg_len(qmsg); iov.iov_buf    = nni_msg_body(qmsg); p->busy        = true; nni_aio_set_msg(p->qsaio, qmsg); nni_aio_set_iov(p->qsaio, 1, &iov); nng_stream_send(p->conn, p->qsaio); } else { if (nni_lmq_full(&p->rslmq)) { if (nni_lmq_cap(&p->rslmq) <= NNG_TRAN_MAX_LMQ_SIZE) { if ((rv = nni_lmq_resize(&p->rslmq, nni_lmq_cap(&p->rslmq) * 2)) == 0) { nni_lmq_put(&p->rslmq, qmsg); } else { nni_msg_free(qmsg); } } else { nni_msg *old; (void) nni_lmq_get(&p->rslmq, &old); nni_msg_free(old); nni_lmq_put(&p->rslmq, qmsg); } } else { nni_lmq_put(&p->rslmq, qmsg); } } ack = false; } nni_pipe_bump_rx(p->npipe, n); if (!nni_list_empty(&p->recvq)) { mqtts_tcptran_pipe_recv_start(p); } #ifdef NNG_HAVE_MQTT_BROKER nni_msg_set_conn_param(msg, p->cparam); #endif nni_aio_set_msg(aio, msg); p->pingcnt = 0; nni_mtx_unlock(&p->mtx); nni_aio_finish_sync(aio, 0, n); return; recv_error: nni_aio_list_remove(aio); msg      = p->rxmsg; p->rxmsg = NULL; nni_pipe_bump_error(p->npipe, rv); nni_mtx_unlock(&p->mtx); nni_msg_free(msg); nni_aio_finish_error(aio, rv); }
Description: A heap buffer overflow vulnerability exists in NanoMQ 0.17.2. The vulnerability can be triggered by calling the function nni_msg_get_pub_pid() in the file message.c. An attacker could exploit this vulnerability to cause a denial of service attack.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int decode_update_thread_context(AVCodecContext *dst, const AVCodecContext *src) { H264Context *h = dst->priv_data, *h1 = src->priv_data; int inited = h->context_initialized, err = 0; int context_reinitialized = 0; int i, ret; if (dst == src || !h1->context_initialized) return 0; if (inited && (h->width                 != h1->width                 || h->height                != h1->height                || h->mb_width              != h1->mb_width              || h->mb_height             != h1->mb_height             || h->sps.bit_depth_luma    != h1->sps.bit_depth_luma    || h->sps.chroma_format_idc != h1->sps.chroma_format_idc || h->sps.colorspace        != h1->sps.colorspace)) { h->avctx->bits_per_raw_sample = h->sps.bit_depth_luma; av_freep(&h->bipred_scratchpad); h->width     = h1->width; h->height    = h1->height; h->mb_height = h1->mb_height; h->mb_width  = h1->mb_width; h->mb_num    = h1->mb_num; h->mb_stride = h1->mb_stride; h->b_stride  = h1->b_stride; if ((err = h264_slice_header_init(h, 1)) < 0) { av_log(h->avctx, AV_LOG_ERROR, ""h264_slice_header_init() failed""); return err; } context_reinitialized = 1; h->linesize   = h1->linesize; h->uvlinesize = h1->uvlinesize; memcpy(h->block_offset, h1->block_offset, sizeof(h->block_offset)); } if (!inited) { for (i = 0; i < MAX_SPS_COUNT; i++) av_freep(h->sps_buffers + i); for (i = 0; i < MAX_PPS_COUNT; i++) av_freep(h->pps_buffers + i); memcpy(h, h1, sizeof(*h1)); memset(h->sps_buffers, 0, sizeof(h->sps_buffers)); memset(h->pps_buffers, 0, sizeof(h->pps_buffers)); memset(&h->er, 0, sizeof(h->er)); memset(&h->me, 0, sizeof(h->me)); memset(&h->mb, 0, sizeof(h->mb)); memset(&h->mb_luma_dc, 0, sizeof(h->mb_luma_dc)); memset(&h->mb_padding, 0, sizeof(h->mb_padding)); h->context_initialized = 0; memset(&h->cur_pic, 0, sizeof(h->cur_pic)); av_frame_unref(&h->cur_pic.f); h->cur_pic.tf.f = &h->cur_pic.f; h->avctx             = dst; h->DPB               = NULL; h->qscale_table_pool = NULL; h->mb_type_pool      = NULL; h->ref_index_pool    = NULL; h->motion_val_pool   = NULL; ret = ff_h264_alloc_tables(h); if (ret < 0) { av_log(dst, AV_LOG_ERROR, ""Could not allocate memory for h264\n""); return ret; } ret = context_init(h); if (ret < 0) { av_log(dst, AV_LOG_ERROR, ""context_init() failed.\n""); return ret; } for (i = 0; i < 2; i++) { h->rbsp_buffer[i]      = NULL; h->rbsp_buffer_size[i] = 0; } h->bipred_scratchpad = NULL; h->edge_emu_buffer   = NULL; h->thread_context[0] = h; h->context_initialized = 1; } h->avctx->coded_height  = h1->avctx->coded_height; h->avctx->coded_width   = h1->avctx->coded_width; h->avctx->width         = h1->avctx->width; h->avctx->height        = h1->avctx->height; h->coded_picture_number = h1->coded_picture_number; h->first_field          = h1->first_field; h->picture_structure    = h1->picture_structure; h->qscale               = h1->qscale; h->droppable            = h1->droppable; h->data_partitioning    = h1->data_partitioning; h->low_delay            = h1->low_delay; for (i = 0; i < MAX_PICTURE_COUNT; i++) { unref_picture(h, &h->DPB[i]); if (h1->DPB[i].f.buf[0] && (ret = ref_picture(h, &h->DPB[i], &h1->DPB[i])) < 0) return ret; } h->cur_pic_ptr = REBASE_PICTURE(h1->cur_pic_ptr, h, h1); unref_picture(h, &h->cur_pic); if ((ret = ref_picture(h, &h->cur_pic, &h1->cur_pic)) < 0) return ret; h->workaround_bugs = h1->workaround_bugs; h->low_delay       = h1->low_delay; h->droppable       = h1->droppable; err = alloc_scratch_buffers(h, h1->linesize); if (err < 0) return err; h->is_avc = h1->is_avc; if ((ret = copy_parameter_set((void **)h->sps_buffers, (void **)h1->sps_buffers, MAX_SPS_COUNT, sizeof(SPS))) < 0) return ret; h->sps = h1->sps; if ((ret = copy_parameter_set((void **)h->pps_buffers, (void **)h1->pps_buffers, MAX_PPS_COUNT, sizeof(PPS))) < 0) return ret; h->pps = h1->pps; copy_fields(h, h1, dequant4_buffer, dequant4_coeff); for (i = 0; i < 6; i++) h->dequant4_coeff[i] = h->dequant4_buffer[0] + (h1->dequant4_coeff[i] - h1->dequant4_buffer[0]); for (i = 0; i < 6; i++) h->dequant8_coeff[i] = h->dequant8_buffer[0] + (h1->dequant8_coeff[i] - h1->dequant8_buffer[0]); h->dequant_coeff_pps = h1->dequant_coeff_pps; copy_fields(h, h1, poc_lsb, redundant_pic_count); copy_fields(h, h1, short_ref, cabac_init_idc); copy_picture_range(h->short_ref, h1->short_ref, 32, h, h1); copy_picture_range(h->long_ref, h1->long_ref, 32, h, h1); copy_picture_range(h->delayed_pic, h1->delayed_pic, MAX_DELAYED_PIC_COUNT + 2, h, h1); h->last_slice_type = h1->last_slice_type; if (context_reinitialized) h264_set_parameter_from_sps(h); if (!h->cur_pic_ptr) return 0; if (!h->droppable) { err = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index); h->prev_poc_msb = h->poc_msb; h->prev_poc_lsb = h->poc_lsb; } h->prev_frame_num_offset = h->frame_num_offset; h->prev_frame_num        = h->frame_num; h->outputed_poc          = h->next_outputed_poc; h->recovery_frame        = h1->recovery_frame; h->frame_recovered       = h1->frame_recovered; return err; }
Description: A vulnerability has been found in FFmpeg 2.0 and classified as critical. This vulnerability affects the function decode_update_thread_context. The manipulation leads to memory corruption. The attack can be initiated remotely. It is recommended to apply a patch to fix this issue.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void parse_version(pj_scanner *scanner,  volatile parse_context *ctx) { ctx->last_error = PJMEDIA_SDP_EINVER; if (*(scanner->curptr+1) != '=') { on_scanner_error(scanner); return; } if (*(scanner->curptr+2) != '0') { on_scanner_error(scanner); return; } pj_scan_skip_line(scanner); }
Description: PJSIP is a free and open source multimedia communication library written in C. In versions of PJSIP prior to 2.13 the PJSIP parser, PJMEDIA RTP decoder, and PJMEDIA SDP parser are affeced by a buffer overflow vulnerability. Users connecting to untrusted clients are at risk. This issue has been patched and is available as commit c4d3498 in the master branch and will be included in releases 2.13 and later. Users are advised to upgrade. There are no known workarounds for this issue.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static ssize_t aio_setup_single_vector(struct kiocb *kiocb, int rw, char __user *buf, unsigned long *nr_segs, size_t len, struct iovec *iovec) { if (unlikely(!access_ok(!rw, buf, len))) return -EFAULT; iovec->iov_base = buf; iovec->iov_len = len; *nr_segs = 1; return 0; }
Description: Integer overflow in the aio_setup_single_vector function in fs/aio.c in the Linux kernel 4.0 allows local users to cause a denial of service or possibly have unspecified other impact via a large AIO iovec.  NOTE: this vulnerability exists because of a CVE-2012-6701 regression.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void Gobby::GotoDialog::on_changed() { g_assert(m_current_view != NULL); GtkTextBuffer* buffer = GTK_TEXT_BUFFER( m_current_view->get_text_buffer()); m_entry_line->set_range(1, gtk_text_buffer_get_line_count(buffer)); }
Description: Gobby 0.4.11 allows a NULL pointer dereference in the D-Bus handler for certain set_language calls.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int get_vdev_port_node_info(struct mdesc_handle *md, u64 node, union md_node_info *node_info) { const u64 *parent_cfg_hdlp; const char *name; const u64 *idp; idp = mdesc_get_property(md, node, ""id"", NULL); name = mdesc_get_property(md, node, ""name"", NULL); parent_cfg_hdlp = parent_cfg_handle(md, node); if (!idp || !name || !parent_cfg_hdlp) return -1; node_info->vdev_port.id = *idp; node_info->vdev_port.name = kstrdup_const(name, GFP_KERNEL); node_info->vdev_port.parent_cfg_hdl = *parent_cfg_hdlp; return 0; }
Description: An issue was discovered in get_vdev_port_node_info in arch/sparc/kernel/mdesc.c in the Linux kernel through 5.1.6. There is an unchecked kstrdup_const of node_info->vdev_port.name, which might allow an attacker to cause a denial of service (NULL pointer dereference and system crash).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int st21nfca_connectivity_event_received(struct nfc_hci_dev *hdev, u8 host, u8 event, struct sk_buff *skb) { int r = 0; struct device *dev = &hdev->ndev->dev; struct nfc_evt_transaction *transaction; pr_debug(""connectivity gate event: %x\n"", event); switch (event) { case ST21NFCA_EVT_CONNECTIVITY: r = nfc_se_connectivity(hdev->ndev, host); break; case ST21NFCA_EVT_TRANSACTION: if (skb->len < NFC_MIN_AID_LENGTH + 2 && skb->data[0] != NFC_EVT_TRANSACTION_AID_TAG) return -EPROTO; transaction = devm_kzalloc(dev, skb->len - 2, GFP_KERNEL); if (!transaction) return -ENOMEM; transaction->aid_len = skb->data[1]; memcpy(transaction->aid, &skb->data[2], transaction->aid_len); if (skb->data[transaction->aid_len + 2] != NFC_EVT_TRANSACTION_PARAMS_TAG) return -EPROTO; transaction->params_len = skb->data[transaction->aid_len + 3]; memcpy(transaction->params, skb->data + transaction->aid_len + 4, transaction->params_len); r = nfc_se_transaction(hdev->ndev, host, transaction); break; default: nfc_err(&hdev->ndev->dev, ""Unexpected event on connectivity gate\n""); return 1; } kfree_skb(skb); return r; }
Description: st21nfca_connectivity_event_received in drivers/nfc/st21nfca/se.c in the Linux kernel through 5.16.12 has EVT_TRANSACTION buffer overflows because of untrusted length parameters.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void t1_check_unusual_charstring(void) { char *p = strstr(t1_line_array, charstringname) + strlen(charstringname); int i; if (sscanf(p, ""%i"", &i) != 1) { strcpy(t1_buf_array, t1_line_array); *(strend(t1_buf_array) - 1) = ' '; t1_getline(); strcat(t1_buf_array, t1_line_array); strcpy(t1_line_array, t1_buf_array); t1_line_ptr = eol(t1_line_array); } }
Description: An issue was discovered in t1_check_unusual_charstring functions in writet1.c files in TeX Live before 2018-09-21. A buffer overflow in the handling of Type 1 fonts allows arbitrary code execution when a malicious font is loaded by one of the vulnerable tools: pdflatex, pdftex, dvips, or luatex.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: long keyctl_set_reqkey_keyring(int reqkey_defl) { struct cred *new; int ret, old_setting; old_setting = current_cred_xxx(jit_keyring); if (reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE) return old_setting; new = prepare_creds(); if (!new) return -ENOMEM; switch (reqkey_defl) { case KEY_REQKEY_DEFL_THREAD_KEYRING: ret = install_thread_keyring_to_cred(new); if (ret < 0) goto error; goto set; case KEY_REQKEY_DEFL_PROCESS_KEYRING: ret = install_process_keyring_to_cred(new); if (ret < 0) { if (ret != -EEXIST) goto error; ret = 0; } goto set; case KEY_REQKEY_DEFL_DEFAULT: case KEY_REQKEY_DEFL_SESSION_KEYRING: case KEY_REQKEY_DEFL_USER_KEYRING: case KEY_REQKEY_DEFL_USER_SESSION_KEYRING: case KEY_REQKEY_DEFL_REQUESTOR_KEYRING: goto set; case KEY_REQKEY_DEFL_NO_CHANGE: case KEY_REQKEY_DEFL_GROUP_KEYRING: default: ret = -EINVAL; goto error; } set: new->jit_keyring = reqkey_defl; commit_creds(new); return old_setting; error: abort_creds(new); return ret; }
Description: The KEYS subsystem in the Linux kernel before 4.10.13 allows local users to cause a denial of service (memory consumption) via a series of KEY_REQKEY_DEFL_THREAD_KEYRING keyctl_set_reqkey_keyring calls.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int chmd_read_headers(struct mspack_system *sys, struct mspack_file *fh, struct mschmd_header *chm, int entire) { unsigned int section, name_len, x, errors, num_chunks; unsigned char buf[0x54], *chunk = NULL, *name, *p, *end; struct mschmd_file *fi, *link = NULL; off_t offset, length; int num_entries; chm->files         = NULL; chm->sysfiles      = NULL; chm->chunk_cache   = NULL; chm->sec0.base.chm = chm; chm->sec0.base.id  = 0; chm->sec1.base.chm = chm; chm->sec1.base.id  = 1; chm->sec1.content  = NULL; chm->sec1.control  = NULL; chm->sec1.spaninfo = NULL; chm->sec1.rtable   = NULL; if (sys->read(fh, &buf[0], chmhead_SIZEOF) != chmhead_SIZEOF) { return MSPACK_ERR_READ; } if (EndGetI32(&buf[chmhead_Signature]) != 0x46535449) { return MSPACK_ERR_SIGNATURE; } if (mspack_memcmp(&buf[chmhead_GUID1], &guids[0], 32L) != 0) { D((""incorrect GUIDs"")) return MSPACK_ERR_SIGNATURE; } chm->version   = EndGetI32(&buf[chmhead_Version]); chm->timestamp = EndGetM32(&buf[chmhead_Timestamp]); chm->language  = EndGetI32(&buf[chmhead_LanguageID]); if (chm->version > 3) { sys->message(fh, ""WARNING; CHM version > 3""); } if (sys->read(fh, &buf[0], chmhst3_SIZEOF) != chmhst3_SIZEOF) { return MSPACK_ERR_READ; } if (read_off64(&offset,           &buf[chmhst_OffsetHS0],  sys, fh) || read_off64(&chm->dir_offset,  &buf[chmhst_OffsetHS1],  sys, fh) || read_off64(&chm->sec0.offset, &buf[chmhst3_OffsetCS0], sys, fh)) { return MSPACK_ERR_DATAFORMAT; } if (sys->seek(fh, offset, MSPACK_SYS_SEEK_START)) { return MSPACK_ERR_SEEK; } if (sys->read(fh, &buf[0], chmhs0_SIZEOF) != chmhs0_SIZEOF) { return MSPACK_ERR_READ; } if (read_off64(&chm->length, &buf[chmhs0_FileLen], sys, fh)) { return MSPACK_ERR_DATAFORMAT; } if (sys->seek(fh, chm->dir_offset, MSPACK_SYS_SEEK_START)) { return MSPACK_ERR_SEEK; } if (sys->read(fh, &buf[0], chmhs1_SIZEOF) != chmhs1_SIZEOF) { return MSPACK_ERR_READ; } chm->dir_offset = sys->tell(fh); chm->chunk_size = EndGetI32(&buf[chmhs1_ChunkSize]); chm->density    = EndGetI32(&buf[chmhs1_Density]); chm->depth      = EndGetI32(&buf[chmhs1_Depth]); chm->index_root = EndGetI32(&buf[chmhs1_IndexRoot]); chm->num_chunks = EndGetI32(&buf[chmhs1_NumChunks]); chm->first_pmgl = EndGetI32(&buf[chmhs1_FirstPMGL]); chm->last_pmgl  = EndGetI32(&buf[chmhs1_LastPMGL]); if (chm->version < 3) { chm->sec0.offset = chm->dir_offset + (chm->chunk_size * chm->num_chunks); } if (chm->sec0.offset > chm->length) { D((""content section begins after file has ended"")) return MSPACK_ERR_DATAFORMAT; } if (chm->chunk_size < (pmgl_Entries + 2)) { D((""chunk size not large enough"")) return MSPACK_ERR_DATAFORMAT; } if (chm->num_chunks == 0) { D((""no chunks"")) return MSPACK_ERR_DATAFORMAT; } if (chm->num_chunks > 100000) { D((""more than 100,000 chunks"")) return MSPACK_ERR_DATAFORMAT; }    if ((off_t)chm->chunk_size * (off_t)chm->num_chunks > chm->length) { D((""chunks larger than entire file"")) return MSPACK_ERR_DATAFORMAT; } if ((chm->chunk_size & (chm->chunk_size - 1)) != 0) { sys->message(fh, ""WARNING; chunk size is not a power of two""); } if (chm->first_pmgl != 0) { sys->message(fh, ""WARNING; first PMGL chunk is not zero""); } if (chm->first_pmgl > chm->last_pmgl) { D((""first pmgl chunk is after last pmgl chunk"")) return MSPACK_ERR_DATAFORMAT; } if (chm->index_root != 0xFFFFFFFF && chm->index_root > chm->num_chunks) { D((""index_root outside valid range"")) return MSPACK_ERR_DATAFORMAT; } if (!entire) { return MSPACK_ERR_OK; } if ((x = chm->first_pmgl) != 0) { if (sys->seek(fh,(off_t) (x * chm->chunk_size), MSPACK_SYS_SEEK_CUR)) { return MSPACK_ERR_SEEK; } } num_chunks = chm->last_pmgl - x + 1; if (!(chunk = (unsigned char *) sys->alloc(sys, (size_t)chm->chunk_size))) { return MSPACK_ERR_NOMEMORY; } errors = 0; while (num_chunks--) { if (sys->read(fh, chunk, (int)chm->chunk_size) != (int)chm->chunk_size) { sys->free(chunk); return MSPACK_ERR_READ; } if (EndGetI32(&chunk[pmgl_Signature]) != 0x4C474D50) continue; if (EndGetI32(&chunk[pmgl_QuickRefSize]) < 2) { sys->message(fh, ""WARNING; PMGL quickref area is too small""); } if (EndGetI32(&chunk[pmgl_QuickRefSize]) >  ((int)chm->chunk_size - pmgl_Entries)) { sys->message(fh, ""WARNING; PMGL quickref area is too large""); } p = &chunk[pmgl_Entries]; end = &chunk[chm->chunk_size - 2]; num_entries = EndGetI16(end); while (num_entries--) { READ_ENCINT(name_len); if (name_len > (unsigned int) (end - p)) goto chunk_end; name = p; p += name_len; READ_ENCINT(section); READ_ENCINT(offset); READ_ENCINT(length); if ((offset == 0) && (length == 0)) { if ((name_len > 0) && (name[name_len-1] == '/')) continue; } if (section > 1) { sys->message(fh, ""invalid section number '%u'."", section); continue; } if (!(fi = (struct mschmd_file *) sys->alloc(sys, sizeof(struct mschmd_file) + name_len + 1))) { sys->free(chunk); return MSPACK_ERR_NOMEMORY; } fi->next     = NULL; fi->filename = (char *) &fi[1]; fi->section  = ((section == 0) ? (struct mschmd_section *) (&chm->sec0) : (struct mschmd_section *) (&chm->sec1)); fi->offset   = offset; fi->length   = length; sys->copy(name, fi->filename, (size_t) name_len); fi->filename[name_len] = '\0'; if (name[0] == ':' && name[1] == ':') { if (mspack_memcmp(&name[2], &content_name[2], 31L) == 0) { if (mspack_memcmp(&name[33], &content_name[33], 8L) == 0) { chm->sec1.content = fi; } else if (mspack_memcmp(&name[33], &control_name[33], 11L) == 0) { chm->sec1.control = fi; } else if (mspack_memcmp(&name[33], &spaninfo_name[33], 8L) == 0) { chm->sec1.spaninfo = fi; } else if (mspack_memcmp(&name[33], &rtable_name[33], 72L) == 0) { chm->sec1.rtable = fi; } } fi->next = chm->sysfiles; chm->sysfiles = fi; } else { if (link) link->next = fi; else chm->files = fi; link = fi; } } chunk_end: if (num_entries >= 0) { D((""chunk ended before all entries could be read"")) errors++; } } sys->free(chunk); return (errors > 0) ? MSPACK_ERR_DATAFORMAT : MSPACK_ERR_OK; }
Description: An issue was discovered in mspack/chmd.c in libmspack before 0.7alpha. There is an off-by-one error in the CHM PMGI/PMGL chunk number validity checks, which could lead to denial of service (uninitialized data dereference and application crash).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int main(int argc, char **argv) { krb5_error_code ret; krb5_context context; krb5_pac pac; krb5_data data; krb5_principal p; ret = krb5_init_context(&context); if (ret) err(NULL, 0, ""krb5_init_contex""); test_pac_ticket_signature(context); ret = krb5_set_default_realm(context, ""WIN2K3.THINKER.LOCAL""); if (ret) err(context, ret, ""krb5_set_default_realm""); ret = krb5_parse_name(context, user, &p); if (ret) err(context, ret, ""krb5_parse_name""); check_pac(context, -1, saved_pac, sizeof(saved_pac), authtime, p, type_1_length, 0, &member_keyblock, &kdc_keyblock); { krb5_principal sp; krb5_principal sep; const struct pac_and_info *pi; ret = krb5_parse_name(context, s4u_principal, &sp); if (ret) err(context, ret, ""krb5_parse_name""); ret = krb5_parse_name_flags(context, s4u_enterprise, KRB5_PRINCIPAL_PARSE_ENTERPRISE, &sep); if (ret) err(context, ret, ""krb5_parse_name_flags""); for (pi = s4u_pacs; pi->data != NULL; pi++) { check_pac(context, pi - s4u_pacs, pi->data, pi->length, pi->authtime, pi->is_enterprise ? sep : sp, s4u_logon_info_buffer_len, pi->is_xrealm, pi->is_xrealm ? &s4u_tgt_srv_key : &s4u_srv_key, NULL); } krb5_free_principal(context, sp); krb5_free_principal(context, sep); } ret = krb5_pac_init(context, &pac); if (ret) err(context, ret, ""krb5_pac_init""); krb5_pac_free(context, pac); ret = krb5_pac_init(context, &pac); if (ret) err(context, ret, ""krb5_pac_init""); { const krb5_data cdata = { 0, 2, ""\x00\x01"" } ; ret = krb5_pac_add_buffer(context, pac, 1, &cdata); if (ret) err(context, ret, ""krb5_pac_add_buffer""); } { ret = krb5_pac_get_buffer(context, pac, 1, &data); if (ret) err(context, ret, ""krb5_pac_get_buffer""); if (data.length != 2 || memcmp(data.data, ""\x00\x01"", 2) != 0) err(context, 0, ""krb5_pac_get_buffer data not the same""); krb5_free_data_contents(context, &data); } { const krb5_data cdata = { 0, 2, ""\x02\x00"" } ; ret = krb5_pac_add_buffer(context, pac, 2, &cdata); if (ret) err(context, ret, ""krb5_pac_add_buffer""); } { ret = krb5_pac_get_buffer(context, pac, 1, &data); if (ret) err(context, ret, ""krb5_pac_get_buffer""); if (data.length != 2 || memcmp(data.data, ""\x00\x01"", 2) != 0) err(context, 0, ""krb5_pac_get_buffer data not the same""); krb5_free_data_contents(context, &data); ret = krb5_pac_get_buffer(context, pac, 2, &data); if (ret) err(context, ret, ""krb5_pac_get_buffer""); if (data.length != 2 || memcmp(data.data, ""\x02\x00"", 2) != 0) err(context, 0, ""krb5_pac_get_buffer data not the same""); krb5_free_data_contents(context, &data); } ret = krb5_pac_sign(context, pac, authtime, p, &member_keyblock, &kdc_keyblock, &data); if (ret) err(context, ret, ""krb5_pac_sign""); krb5_pac_free(context, pac); ret = krb5_pac_parse(context, data.data, data.length, &pac); krb5_free_data_contents(context, &data); if (ret) err(context, ret, ""krb5_pac_parse 3""); ret = krb5_pac_verify(context, pac, authtime, p, &member_keyblock, &kdc_keyblock); if (ret) err(context, ret, ""krb5_pac_verify 3""); { uint32_t *list; size_t len; ret = krb5_pac_get_types(context, pac, &len, &list); if (ret) err(context, ret, ""krb5_pac_get_types""); if (len != 5) err(context, 0, ""list wrong length""); free(list); } { krb5_principal ep, np; ret = krb5_parse_name_flags(context, user, KRB5_PRINCIPAL_PARSE_ENTERPRISE, &ep); if (ret) err(context, ret, ""krb5_parse_name_flags""); ret = krb5_copy_principal(context, ep, &np); if (ret) err(context, ret, ""krb5_copy_principal""); np->type = KRB5_NT_MS_PRINCIPAL; ret = krb5_pac_verify(context, pac, authtime, ep, &member_keyblock, &kdc_keyblock); if (!ret) err(context, ret, ""krb5_pac_verify should have failed""); ret = krb5_pac_sign(context, pac, authtime, ep, &member_keyblock, &kdc_keyblock, &data); if (!ret) err(context, ret, ""krb5_pac_sign should have failed""); ret = krb5_pac_verify_ext(context, pac, authtime, p, &member_keyblock, &kdc_keyblock, TRUE); if (!ret) err(context, ret, ""krb5_pac_verify_ext with realm should fail""); ret = krb5_pac_sign_ext(context, pac, authtime, p, &member_keyblock, &kdc_keyblock, TRUE, &data); if (!ret) err(context, ret, ""krb5_pac_sign_ext with realm should fail""); krb5_pac_free(context, pac); ret = krb5_pac_init(context, &pac); if (ret) err(context, ret, ""krb5_pac_init""); ret = krb5_pac_sign(context, pac, authtime, ep, &member_keyblock, &kdc_keyblock, &data); if (ret) err(context, ret, ""krb5_pac_sign enterprise failed""); krb5_pac_free(context, pac); ret = krb5_pac_parse(context, data.data, data.length, &pac); krb5_free_data_contents(context, &data); if (ret) err(context, ret, ""krb5_pac_parse failed""); ret = krb5_pac_verify(context, pac, authtime, ep, &member_keyblock, &kdc_keyblock); if (ret) err(context, ret, ""krb5_pac_verify enterprise failed""); ret = krb5_pac_verify(context, pac, authtime, np, &member_keyblock, &kdc_keyblock); if (ret) err(context, ret, ""krb5_pac_verify enterprise as nt-ms failed""); ret = krb5_pac_verify(context, pac, authtime, p, &member_keyblock, &kdc_keyblock); if (!ret) err(context, ret, ""krb5_pac_verify should have failed""); krb5_pac_free(context, pac); ret = krb5_pac_init(context, &pac); if (ret) err(context, ret, ""krb5_pac_init""); ret = krb5_pac_sign(context, pac, authtime, np, &member_keyblock, &kdc_keyblock, &data); if (ret) err(context, ret, ""krb5_pac_sign enterprise failed""); krb5_pac_free(context, pac); ret = krb5_pac_parse(context, data.data, data.length, &pac); krb5_free_data_contents(context, &data); if (ret) err(context, ret, ""krb5_pac_parse failed""); ret = krb5_pac_verify(context, pac, authtime, np, &member_keyblock, &kdc_keyblock); if (ret) err(context, ret, ""krb5_pac_verify enterprise failed""); ret = krb5_pac_verify(context, pac, authtime, ep, &member_keyblock, &kdc_keyblock); if (ret) err(context, ret, ""krb5_pac_verify nt-ms as enterprise failed""); ret = krb5_pac_verify(context, pac, authtime, p, &member_keyblock, &kdc_keyblock); if (!ret) err(context, ret, ""krb5_pac_verify should have failed""); krb5_pac_free(context, pac); ret = krb5_pac_init(context, &pac); if (ret) err(context, ret, ""krb5_pac_init""); ret = krb5_pac_sign_ext(context, pac, authtime, p, &member_keyblock, &kdc_keyblock, TRUE, &data); if (ret) err(context, ret, ""krb5_pac_sign_ext with realm failed""); krb5_pac_free(context, pac); ret = krb5_pac_parse(context, data.data, data.length, &pac); krb5_free_data_contents(context, &data); if (ret) err(context, ret, ""krb5_pac_parse failed""); ret = krb5_pac_verify_ext(context, pac, authtime, p, &member_keyblock, &kdc_keyblock, TRUE); if (ret) err(context, ret, ""krb5_pac_verify_ext with realm failed""); ret = krb5_pac_verify(context, pac, authtime, p, &member_keyblock, &kdc_keyblock); if (!ret) err(context, ret, ""krb5_pac_verify should have failed""); krb5_pac_free(context, pac); ret = krb5_pac_init(context, &pac); if (ret) err(context, ret, ""krb5_pac_init""); ret = krb5_pac_sign_ext(context, pac, authtime, ep, &member_keyblock, &kdc_keyblock, TRUE, &data); if (ret) err(context, ret, ""krb5_pac_sign_ext ent with realm failed""); krb5_pac_free(context, pac); ret = krb5_pac_parse(context, data.data, data.length, &pac); krb5_free_data_contents(context, &data); if (ret) err(context, ret, ""krb5_pac_parse failed""); ret = krb5_pac_verify_ext(context, pac, authtime, ep, &member_keyblock, &kdc_keyblock, TRUE); if (ret) err(context, ret, ""krb5_pac_verify_ext ent with realm failed""); ret = krb5_pac_verify(context, pac, authtime, p, &member_keyblock, &kdc_keyblock); if (!ret) err(context, ret, ""krb5_pac_verify should have failed""); ret = krb5_pac_verify(context, pac, authtime, ep, &member_keyblock, &kdc_keyblock); if (!ret) err(context, ret, ""krb5_pac_verify should have failed""); ret = krb5_pac_verify_ext(context, pac, authtime, p, &member_keyblock, &kdc_keyblock, TRUE); if (!ret) err(context, ret, ""krb5_pac_verify_ext should have failed""); krb5_free_principal(context, ep); krb5_free_principal(context, np); } krb5_pac_free(context, pac); krb5_free_principal(context, p); krb5_free_context(context); return 0; }
Description: PAC parsing in MIT Kerberos 5 (aka krb5) before 1.19.4 and 1.20.x before 1.20.1 has integer overflows that may lead to remote code execution (in KDC, kadmind, or a GSS or Kerberos application server) on 32-bit platforms (which have a resultant heap-based buffer overflow), and cause a denial of service on other platforms. This occurs in krb5_pac_parse in lib/krb5/krb/pac.c. Heimdal before 7.7.1 has ""a similar bug.""
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int snd_ctl_elem_write_user(struct snd_ctl_file *file, struct snd_ctl_elem_value __user *_control) { struct snd_ctl_elem_value *control; struct snd_card *card; int result; control = memdup_user(_control, sizeof(*control)); if (IS_ERR(control)) return PTR_ERR(control); card = file->card; snd_power_lock(card); result = snd_power_wait(card, SNDRV_CTL_POWER_D0); if (result >= 0) result = snd_ctl_elem_write(card, file, control); snd_power_unlock(card); if (result >= 0) if (copy_to_user(_control, control, sizeof(*control))) result = -EFAULT; kfree(control); return result; }
Description: A use after free vulnerability exists in the ALSA PCM package in the Linux Kernel. SNDRV_CTL_IOCTL_ELEM_{READ|WRITE}32 is missing locks that can be used in a use-after-free that can result in a priviledge escalation to gain ring0 access from the system user. We recommend upgrading past commit 56b88b50565cd8b946a2d00b0c83927b7ebb055e

 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int evp_EncryptDecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl, const unsigned char *in, int inl) { int i, j, bl, cmpl = inl; if (EVP_CIPHER_CTX_test_flags(ctx, EVP_CIPH_FLAG_LENGTH_BITS)) cmpl = (cmpl + 7) / 8; bl = ctx->cipher->block_size; if (inl < 0 || (inl == 0 && EVP_CIPHER_mode(ctx->cipher) != EVP_CIPH_CCM_MODE)) { *outl = 0; return inl == 0; } if (ctx->cipher->flags & EVP_CIPH_FLAG_CUSTOM_CIPHER) { if (bl == 1 && is_partially_overlapping(out, in, cmpl)) { EVPerr(EVP_F_EVP_ENCRYPTDECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING); return 0; } i = ctx->cipher->do_cipher(ctx, out, in, inl); if (i < 0) return 0; else *outl = i; return 1; } if (is_partially_overlapping(out + ctx->buf_len, in, cmpl)) { EVPerr(EVP_F_EVP_ENCRYPTDECRYPTUPDATE, EVP_R_PARTIALLY_OVERLAPPING); return 0; } if (ctx->buf_len == 0 && (inl & (ctx->block_mask)) == 0) { if (ctx->cipher->do_cipher(ctx, out, in, inl)) { *outl = inl; return 1; } else { *outl = 0; return 0; } } i = ctx->buf_len; OPENSSL_assert(bl <= (int)sizeof(ctx->buf)); if (i != 0) { if (bl - i > inl) { memcpy(&(ctx->buf[i]), in, inl); ctx->buf_len += inl; *outl = 0; return 1; } else { j = bl - i; memcpy(&(ctx->buf[i]), in, j); inl -= j; in += j; if (!ctx->cipher->do_cipher(ctx, out, ctx->buf, bl)) return 0; out += bl; *outl = bl; } } else *outl = 0; i = inl & (bl - 1); inl -= i; if (inl > 0) { if (!ctx->cipher->do_cipher(ctx, out, in, inl)) return 0; *outl += inl; } if (i != 0) memcpy(ctx->buf, &(in[inl]), i); ctx->buf_len = i; return 1; }
Description: Calls to EVP_CipherUpdate, EVP_EncryptUpdate and EVP_DecryptUpdate may overflow the output length argument in some cases where the input length is close to the maximum permissable length for an integer on the platform. In such cases the return value from the function call will be 1 (indicating success), but the output length value will be negative. This could cause applications to behave incorrectly or crash. OpenSSL versions 1.1.1i and below are affected by this issue. Users of these versions should upgrade to OpenSSL 1.1.1j. OpenSSL versions 1.0.2x and below are affected by this issue. However OpenSSL 1.0.2 is out of support and no longer receiving public updates. Premium support customers of OpenSSL 1.0.2 should upgrade to 1.0.2y. Other users should upgrade to 1.1.1j. Fixed in OpenSSL 1.1.1j (Affected 1.1.1-1.1.1i). Fixed in OpenSSL 1.0.2y (Affected 1.0.2-1.0.2x).
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void igraph_i_graphml_attribute_data_finish(struct igraph_i_graphml_parser_state *state) { const char *key=fromXmlChar(state->data_key); igraph_attribute_elemtype_t type=state->data_type; igraph_trie_t *trie=0; igraph_vector_ptr_t *ptrvector=0; igraph_i_graphml_attribute_record_t *graphmlrec; igraph_attribute_record_t *rec; long int recid, id=0; int ret; switch (type) { case IGRAPH_ATTRIBUTE_GRAPH: trie=&state->g_names; ptrvector=&state->g_attrs; id=0; break; case IGRAPH_ATTRIBUTE_VERTEX: trie=&state->v_names; ptrvector=&state->v_attrs; id=state->act_node; break; case IGRAPH_ATTRIBUTE_EDGE: trie=&state->e_names; ptrvector=&state->e_attrs; id=igraph_vector_size(&state->edgelist)/2-1;  break; default: break; } igraph_trie_check(trie, key, &recid); if (recid < 0) { igraph_warningf( ""unknown attribute key '%s' in a <data> tag, ignoring attribute"", __FILE__, __LINE__, 0, key ); igraph_Free(state->data_char); return; } graphmlrec=VECTOR(*ptrvector)[recid]; rec=&graphmlrec->record; switch (rec->type) { igraph_vector_bool_t *boolvec; igraph_vector_t *vec; igraph_strvector_t *strvec; long int s, i; const char* strvalue; case IGRAPH_ATTRIBUTE_BOOLEAN: boolvec=(igraph_vector_bool_t *)rec->value; s=igraph_vector_bool_size(boolvec); if (id >= s) { ret=igraph_vector_bool_resize(boolvec, id+1); if (ret) { RETURN_GRAPHML_PARSE_ERROR_WITH_CODE(state, ""Cannot parse GraphML file"", ret); } for (i=s; i<id; i++) { VECTOR(*boolvec)[i] = graphmlrec->default_value.as_boolean; } } VECTOR(*boolvec)[id] = igraph_i_graphml_parse_boolean(state->data_char, graphmlrec->default_value.as_boolean); break; case IGRAPH_ATTRIBUTE_NUMERIC: vec=(igraph_vector_t *)rec->value; s=igraph_vector_size(vec); if (id >= s) { ret=igraph_vector_resize(vec, id+1); if (ret) { RETURN_GRAPHML_PARSE_ERROR_WITH_CODE(state, ""Cannot parse GraphML file"", ret); } for (i=s; i<id; i++) { VECTOR(*vec)[i] = graphmlrec->default_value.as_numeric; } } VECTOR(*vec)[id] = igraph_i_graphml_parse_numeric(state->data_char, graphmlrec->default_value.as_numeric); break; case IGRAPH_ATTRIBUTE_STRING: strvec=(igraph_strvector_t *)rec->value; s=igraph_strvector_size(strvec); if (id >= s) { ret=igraph_strvector_resize(strvec, id+1); if (ret) { RETURN_GRAPHML_PARSE_ERROR_WITH_CODE(state, ""Cannot parse GraphML file"", ret); } strvalue = graphmlrec->default_value.as_string; for (i=s;i<id;i++) { igraph_strvector_set(strvec, i, strvalue); } } if (state->data_char) { strvalue = state->data_char; } else { strvalue = graphmlrec->default_value.as_string; } ret=igraph_strvector_set(strvec, id, strvalue); if (ret) { RETURN_GRAPHML_PARSE_ERROR_WITH_CODE(state, ""Cannot parse GraphML file"", ret); } break; default: break; } if (state->data_char) { igraph_Free(state->data_char); } }
Description: The igraph_i_strdiff function in igraph_trie.c in igraph through 0.7.1 has an NULL pointer dereference that allows attackers to cause a denial of service (application crash) via a crafted object.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int put_page_from_l4e(l4_pgentry_t l4e, unsigned long pfn, int partial, bool defer) { if ( (l4e_get_flags(l4e) & _PAGE_PRESENT) && (l4e_get_pfn(l4e) != pfn) ) { struct page_info *pg = l4e_get_page(l4e); if ( unlikely(partial > 0) ) { ASSERT(!defer); return put_page_type_preemptible(pg); } if ( defer ) { current->arch.old_guest_table = pg; return 0; } return put_page_and_type_preemptible(pg); } return 1; }
Description: An issue was discovered in Xen through 4.9.x allowing x86 PV guest OS users to cause a denial of service (unbounded recursion, stack consumption, and hypervisor crash) or possibly gain privileges via crafted page-table stacking.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static int priv_op_write_msr(unsigned int reg, uint64_t val, struct x86_emulate_ctxt *ctxt) { struct vcpu *curr = current; const struct domain *currd = curr->domain; bool vpmu_msr = false; switch ( reg ) { uint64_t temp; int rc; case MSR_FS_BASE: if ( is_pv_32bit_domain(currd) ) break; wrfsbase(val); curr->arch.pv_vcpu.fs_base = val; return X86EMUL_OKAY; case MSR_GS_BASE: if ( is_pv_32bit_domain(currd) ) break; wrgsbase(val); curr->arch.pv_vcpu.gs_base_kernel = val; return X86EMUL_OKAY; case MSR_SHADOW_GS_BASE: if ( is_pv_32bit_domain(currd) || wrmsr_safe(MSR_SHADOW_GS_BASE, val) ) break; curr->arch.pv_vcpu.gs_base_user = val; return X86EMUL_OKAY; case MSR_K7_FID_VID_STATUS: case MSR_K7_FID_VID_CTL: case MSR_K8_PSTATE_LIMIT: case MSR_K8_PSTATE_CTRL: case MSR_K8_PSTATE_STATUS: case MSR_K8_PSTATE0: case MSR_K8_PSTATE1: case MSR_K8_PSTATE2: case MSR_K8_PSTATE3: case MSR_K8_PSTATE4: case MSR_K8_PSTATE5: case MSR_K8_PSTATE6: case MSR_K8_PSTATE7: case MSR_K8_HWCR: if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD ) break; if ( likely(!is_cpufreq_controller(currd)) || wrmsr_safe(reg, val) == 0 ) return X86EMUL_OKAY; break; case MSR_AMD64_NB_CFG: if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD || boot_cpu_data.x86 < 0x10 || boot_cpu_data.x86 > 0x17 ) break; if ( !is_hardware_domain(currd) || !is_pinned_vcpu(curr) ) return X86EMUL_OKAY; if ( (rdmsr_safe(MSR_AMD64_NB_CFG, temp) != 0) || ((val ^ temp) & ~(1ULL << AMD64_NB_CFG_CF8_EXT_ENABLE_BIT)) ) goto invalid; if ( wrmsr_safe(MSR_AMD64_NB_CFG, val) == 0 ) return X86EMUL_OKAY; break; case MSR_FAM10H_MMIO_CONF_BASE: if ( boot_cpu_data.x86_vendor != X86_VENDOR_AMD || boot_cpu_data.x86 < 0x10 || boot_cpu_data.x86 > 0x17 ) break; if ( !is_hardware_domain(currd) || !is_pinned_vcpu(curr) ) return X86EMUL_OKAY; if ( rdmsr_safe(MSR_FAM10H_MMIO_CONF_BASE, temp) != 0 ) break; if ( (pci_probe & PCI_PROBE_MASK) == PCI_PROBE_MMCONF ? temp != val : ((temp ^ val) & ~(FAM10H_MMIO_CONF_ENABLE | (FAM10H_MMIO_CONF_BUSRANGE_MASK << FAM10H_MMIO_CONF_BUSRANGE_SHIFT) | ((u64)FAM10H_MMIO_CONF_BASE_MASK << FAM10H_MMIO_CONF_BASE_SHIFT))) ) goto invalid; if ( wrmsr_safe(MSR_FAM10H_MMIO_CONF_BASE, val) == 0 ) return X86EMUL_OKAY; break; case MSR_IA32_UCODE_REV: if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL ) break; if ( !is_hardware_domain(currd) || !is_pinned_vcpu(curr) ) return X86EMUL_OKAY; if ( rdmsr_safe(reg, temp) ) break; if ( val ) goto invalid; return X86EMUL_OKAY; case MSR_IA32_MISC_ENABLE: if ( rdmsr_safe(reg, temp) ) break; if ( val != guest_misc_enable(temp) ) goto invalid; return X86EMUL_OKAY; case MSR_IA32_MPERF: case MSR_IA32_APERF: if ( (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL) && (boot_cpu_data.x86_vendor != X86_VENDOR_AMD) ) break; if ( likely(!is_cpufreq_controller(currd)) || wrmsr_safe(reg, val) == 0 ) return X86EMUL_OKAY; break; case MSR_IA32_PERF_CTL: if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL ) break; if ( likely(!is_cpufreq_controller(currd)) || wrmsr_safe(reg, val) == 0 ) return X86EMUL_OKAY; break; case MSR_IA32_THERM_CONTROL: case MSR_IA32_ENERGY_PERF_BIAS: if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL ) break; if ( !is_hardware_domain(currd) || !is_pinned_vcpu(curr) || wrmsr_safe(reg, val) == 0 ) return X86EMUL_OKAY; break; case MSR_AMD64_DR0_ADDRESS_MASK: if ( !boot_cpu_has(X86_FEATURE_DBEXT) || (val >> 32) ) break; curr->arch.pv_vcpu.dr_mask[0] = val; if ( curr->arch.debugreg[7] & DR7_ACTIVE_MASK ) wrmsrl(MSR_AMD64_DR0_ADDRESS_MASK, val); return X86EMUL_OKAY; case MSR_AMD64_DR1_ADDRESS_MASK ... MSR_AMD64_DR3_ADDRESS_MASK: if ( !boot_cpu_has(X86_FEATURE_DBEXT) || (val >> 32) ) break; curr->arch.pv_vcpu.dr_mask[reg - MSR_AMD64_DR1_ADDRESS_MASK + 1] = val; if ( curr->arch.debugreg[7] & DR7_ACTIVE_MASK ) wrmsrl(reg, val); return X86EMUL_OKAY; case MSR_INTEL_PLATFORM_INFO: if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL || val || rdmsr_safe(MSR_INTEL_PLATFORM_INFO, val) ) break; return X86EMUL_OKAY; case MSR_INTEL_MISC_FEATURES_ENABLES: if ( boot_cpu_data.x86_vendor != X86_VENDOR_INTEL || (val & ~MSR_MISC_FEATURES_CPUID_FAULTING) || rdmsr_safe(MSR_INTEL_MISC_FEATURES_ENABLES, temp) ) break; if ( (val & MSR_MISC_FEATURES_CPUID_FAULTING) && !this_cpu(cpuid_faulting_enabled) ) break; curr->arch.cpuid_faulting = !!(val & MSR_MISC_FEATURES_CPUID_FAULTING); return X86EMUL_OKAY; case MSR_P6_PERFCTR(0)...MSR_P6_PERFCTR(7): case MSR_P6_EVNTSEL(0)...MSR_P6_EVNTSEL(3): case MSR_CORE_PERF_FIXED_CTR0...MSR_CORE_PERF_FIXED_CTR2: case MSR_CORE_PERF_FIXED_CTR_CTRL...MSR_CORE_PERF_GLOBAL_OVF_CTRL: if ( boot_cpu_data.x86_vendor == X86_VENDOR_INTEL ) { vpmu_msr = true; case MSR_AMD_FAM15H_EVNTSEL0...MSR_AMD_FAM15H_PERFCTR5: case MSR_K7_EVNTSEL0...MSR_K7_PERFCTR3: if ( vpmu_msr || (boot_cpu_data.x86_vendor == X86_VENDOR_AMD) ) { if ( (vpmu_mode & XENPMU_MODE_ALL) && !is_hardware_domain(currd) ) return X86EMUL_OKAY; if ( vpmu_do_wrmsr(reg, val, 0) ) break; return X86EMUL_OKAY; } } default: if ( wrmsr_hypervisor_regs(reg, val) == 1 ) return X86EMUL_OKAY; rc = vmce_wrmsr(reg, val); if ( rc < 0 ) break; if ( rc ) return X86EMUL_OKAY; if ( (rdmsr_safe(reg, temp) != 0) || (val != temp) ) invalid: gdprintk(XENLOG_WARNING, ""Domain attempted WRMSR %08x from 0x%016""PRIx64"" to 0x%016""PRIx64""\n"", reg, temp, val); return X86EMUL_OKAY; } return X86EMUL_UNHANDLEABLE; }
Description: The x86 segment base write emulation functionality in Xen 4.4.x through 4.7.x allows local x86 PV guest OS administrators to cause a denial of service (host crash) by leveraging lack of canonical address checks.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: bool CClient::OnTextMessage(CTextMessage& Message) { CString sTargets = Message.GetTarget(); VCString vTargets; sTargets.Split("","", vTargets, false); for (CString& sTarget : vTargets) { Message.SetTarget(sTarget); if (m_pNetwork) { Message.SetChan(m_pNetwork->FindChan(sTarget)); } if (sTarget.TrimPrefix(m_pUser->GetStatusPrefix())) { if (sTarget.Equals(""status"")) { CString sMsg = Message.GetText(); UserCommand(sMsg); } else { CALLMOD(sTarget, this, m_pUser, m_pNetwork, OnModCommand(Message.GetText())); } continue; } bool bContinue = false; NETWORKMODULECALL(OnUserTextMessage(Message), m_pUser, m_pNetwork, this, &bContinue); if (bContinue) continue; if (!GetIRCSock()) { if (!sTarget.Equals(m_sNick)) PutStatus( t_f(""Your message to {1} got lost, you are not connected "" ""to IRC!"")(Message.GetTarget())); continue; } if (m_pNetwork) { AddBuffer(Message); EchoMessage(Message); PutIRC(Message.ToString(CMessage::ExcludePrefix | CMessage::ExcludeTags)); } } return true; }
Description: ZNC 1.8.0 up to 1.8.1-rc1 allows authenticated users to trigger an application crash (with a NULL pointer dereference) if echo-message is not enabled and there is no network.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void ddl_ensure_index (const char *table, const char * index_name, const char *text) { client_connection_t *old_cli = sqlc_client(); sqlc_set_client (NULL); dbe_table_t * tb = sch_name_to_table (wi_inst.wi_schema, table); dbe_key_t * key = tb ? tb_find_key (tb, index_name, NULL) : NULL; if (!key) { caddr_t err = NULL; query_t *obj_create = eql_compile_2 (text, bootstrap_cli, &err, SQLC_DEFAULT); if (err) { log_error (""Error compiling a server init statement : %s: %s -- %s"", ((caddr_t *) err)[QC_ERRNO], ((caddr_t *) err)[QC_ERROR_STRING], err_first_line (text)); sqlc_set_client (old_cli); dk_free_tree (err); return; } sqlc_set_client (bootstrap_cli); first_id = DD_FIRST_PRIVATE_OID; err = qr_quick_exec (obj_create, bootstrap_cli, """", NULL, 0); if (err) { if (err == (caddr_t) SQL_NO_DATA_FOUND) log_error (""Error executing a server init statement : NO DATA FOUND -- %s"", err_first_line (text)); else log_error (""Error executing a server init statement : %s: %s -- %s"", ((caddr_t *) err)[QC_ERRNO], ((caddr_t *) err)[QC_ERROR_STRING], err_first_line (text)); dk_free_tree (err); qr_free (obj_create); sqlc_set_client (old_cli); return; } qr_free (obj_create); first_id = DD_FIRST_FREE_OID; sqlc_set_client (old_cli); local_commit (bootstrap_cli); } else sqlc_set_client (old_cli); }
Description: An issue in the kc_var_col component of openlink virtuoso-opensource v7.2.9 allows attackers to cause a Denial of Service (DoS) via crafted SQL statements.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void uv__rwlock_fallback_wrunlock(uv_rwlock_t* rwlock) { uv_mutex_unlock(&rwlock->fallback_.write_mutex_); }
Description: The uv_rwlock_t fallback implementation for Windows XP and Server 2003 in libuv before 1.7.4 does not properly prevent threads from releasing the locks of other threads, which allows attackers to cause a denial of service (deadlock) or possibly have unspecified other impact by leveraging a race condition.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: TEE_Result tee_pobj_get(TEE_UUID *uuid, void *obj_id, uint32_t obj_id_len, uint32_t flags, bool temporary, const struct tee_file_operations *fops, struct tee_pobj **obj) { struct tee_pobj *o; TEE_Result res; *obj = NULL; TAILQ_FOREACH(o, &tee_pobjs, link) { if ((obj_id_len == o->obj_id_len) && (memcmp(obj_id, o->obj_id, obj_id_len) == 0) && (memcmp(uuid, &o->uuid, sizeof(TEE_UUID)) == 0) && (fops == o->fops)) { *obj = o; } } if (*obj) { if (temporary != (*obj)->temporary) { res = TEE_ERROR_ACCESS_CONFLICT; goto out; } res = tee_pobj_check_access((*obj)->flags, flags); if (res == TEE_SUCCESS) (*obj)->refcnt++; goto out; } o = calloc(1, sizeof(struct tee_pobj)); if (!o) { res = TEE_ERROR_OUT_OF_MEMORY; goto out; } o->refcnt = 1; memcpy(&o->uuid, uuid, sizeof(TEE_UUID)); o->flags = flags; o->fops = fops; o->temporary = temporary; o->obj_id = malloc(obj_id_len); if (o->obj_id == NULL) { free(o); res = TEE_ERROR_OUT_OF_MEMORY; goto out; } memcpy(o->obj_id, obj_id, obj_id_len); o->obj_id_len = obj_id_len; TAILQ_INSERT_TAIL(&tee_pobjs, o, link); *obj = o; res = TEE_SUCCESS; out: if (res != TEE_SUCCESS) *obj = NULL; return res; }
Description: The function tee_obj_free in Samsung mTower through 0.3.0 allows a trusted application to trigger a Denial of Service (DoS) by invoking the function TEE_AllocateOperation with a disturbed heap layout, related to utee_cryp_obj_alloc.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void dissect_sdp(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree) { proto_tree *sdp_tree; proto_item *ti, *sub_ti; gint        offset = 0, next_offset, n, i; int         linelen; gboolean    in_media_description; guchar      type, delim; int         datalen, tokenoffset, hf = -1; char       *string; transport_info_t  local_transport_info; transport_info_t* transport_info = NULL; disposable_media_info_t media_info; sdp_packet_info  *sdp_pi; struct srtp_info *srtp_info = NULL; DPRINT2((""----------------------- dissect_sdp ------------------------"")); sdp_pi = wmem_new(wmem_packet_scope(), sdp_packet_info); sdp_pi->summary_str[0] = '\0'; if (!pinfo->fd->flags.visited) { transport_info = (transport_info_t*)wmem_tree_lookup32( sdp_transport_reqs, pinfo->fd->num ); if (transport_info == NULL) { transport_info = (transport_info_t*)wmem_tree_lookup32( sdp_transport_rsps, pinfo->fd->num ); } } if (transport_info == NULL) { transport_info = &local_transport_info; } #ifdef DEBUG_CONVERSATION else { DPRINT((""found previous transport_info:"")); sdp_dump_transport_info(transport_info); } #endif memset(&local_transport_info, 0, sizeof(local_transport_info)); local_transport_info.media_count = -1; for (n = 0; n < SDP_NO_OF_PT; n++) { local_transport_info.encoding_name[n] = (char*)UNKNOWN_ENCODING; } for (n = 0; n < SDP_MAX_RTP_CHANNELS; n++) { local_transport_info.media[n].rtp_dyn_payload = rtp_dyn_payload_new(); local_transport_info.media[n].set_rtp = FALSE; } memset(&media_info, 0, sizeof(media_info)); col_append_str(pinfo->cinfo, COL_PROTOCOL, ""/SDP""); ti = proto_tree_add_item(tree, proto_sdp, tvb, offset, -1, ENC_NA); sdp_tree = proto_item_add_subtree(ti, ett_sdp); in_media_description = FALSE; while (tvb_offset_exists(tvb, offset)) { linelen = tvb_find_line_end_unquoted(tvb, offset, -1, &next_offset); if (linelen < 2) break; type  = tvb_get_guint8(tvb, offset); delim = tvb_get_guint8(tvb, offset + 1); if (delim != '=') { proto_item *ti2 = proto_tree_add_item(sdp_tree, hf_invalid, tvb, offset, linelen, ENC_UTF_8|ENC_NA); expert_add_info(pinfo, ti2, &ei_sdp_invalid_line_equal); offset = next_offset; continue; } switch (type) { case 'v': hf = hf_protocol_version; break; case 'o': hf = hf_owner; break; case 's': hf = hf_session_name; break; case 'i': if (in_media_description) { hf = hf_media_title; } else { hf = hf_session_info; } break; case 'u': hf = hf_uri; break; case 'e': hf = hf_email; break; case 'p': hf = hf_phone; break; case 'c': hf = hf_connection_info; break; case 'b': hf = hf_bandwidth; break; case 't': hf = hf_time; break; case 'r': hf = hf_repeat_time; break; case 'm': hf = hf_media; if (local_transport_info.media_count < (SDP_MAX_RTP_CHANNELS-1)) local_transport_info.media_count++; if (in_media_description && (media_info.media_count < (SDP_MAX_RTP_CHANNELS-1))) media_info.media_count++; in_media_description = TRUE; break; case 'k': hf = hf_encryption_key; break; case 'a': if (in_media_description) { hf = hf_media_attribute; } else { hf = hf_session_attribute; } break; case 'z': hf = hf_timezone; break; default: hf = hf_unknown; break; } tokenoffset = 2; if (hf == hf_unknown) tokenoffset = 0; string = (char*)tvb_get_string_enc(wmem_packet_scope(), tvb, offset + tokenoffset, linelen - tokenoffset, ENC_ASCII); sub_ti = proto_tree_add_string(sdp_tree, hf, tvb, offset, linelen, string); call_sdp_subdissector(tvb_new_subset_length(tvb, offset + tokenoffset, linelen - tokenoffset), pinfo, hf, sub_ti, linelen-tokenoffset, &local_transport_info, &media_info); offset = next_offset; } if (in_media_description) { if (local_transport_info.media_count < (SDP_MAX_RTP_CHANNELS-1)) local_transport_info.media_count++; if (media_info.media_count < (SDP_MAX_RTP_CHANNELS-1)) media_info.media_count++; } if (transport_info == &local_transport_info) { DPRINT((""no previous transport_info saved, calling convert_disposable_media()"")); DINDENT(); convert_disposable_media(transport_info, &media_info, 0); DENDENT(); #ifdef DEBUG_CONVERSATION sdp_dump_transport_info(transport_info); #endif } #ifdef DEBUG_CONVERSATION else { DPRINT((""not overwriting previous transport_info, local_transport_info contents:"")); sdp_dump_transport_info(&local_transport_info); } #endif for (n = 0; n < local_transport_info.media_count; n++) { guint32 current_rtp_port = 0; if ((!pinfo->fd->flags.visited) && (transport_info == &local_transport_info) && (transport_info->media_port[n] != 0) && (transport_info->proto_bitmask[n] & (SDP_RTP_PROTO|SDP_SRTP_PROTO)) && (transport_info->proto_bitmask[n] & (SDP_IPv4|SDP_IPv6))) { if (transport_info->proto_bitmask[n] & SDP_SRTP_PROTO) { srtp_info = wmem_new0(wmem_file_scope(), struct srtp_info); if (transport_info->encryption_algorithm != SRTP_ENC_ALG_NOT_SET) { srtp_info->encryption_algorithm = transport_info->encryption_algorithm; srtp_info->auth_algorithm       = transport_info->auth_algorithm; srtp_info->mki_len              = transport_info->mki_len; srtp_info->auth_tag_len         = transport_info->auth_tag_len; } DPRINT((""calling srtp_add_address for media_port=%d, for channel=%d"", transport_info->media_port[n],n)); DINDENT(); srtp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, ""SDP"", pinfo->fd->num, (transport_info->proto_bitmask[n] & SDP_VIDEO) ? TRUE : FALSE, transport_info->media[n].rtp_dyn_payload, srtp_info); DENDENT(); } else { DPRINT((""calling rtp_add_address for media_port=%d, for channel=%d"", transport_info->media_port[n],n)); DINDENT(); rtp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, ""SDP"", pinfo->fd->num, (transport_info->proto_bitmask[n] & SDP_VIDEO) ? TRUE : FALSE, transport_info->media[n].rtp_dyn_payload); DENDENT(); } transport_info->media[n].set_rtp = TRUE; current_rtp_port = transport_info->media_port[n]; if (rtcp_handle) { if (transport_info->proto_bitmask[n] & SDP_SRTP_PROTO) { DPRINT((""calling srtcp_add_address for media_port=%d, for channel=%d"", transport_info->media_port[n],n)); DINDENT(); srtcp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n]+1, 0, ""SDP"", pinfo->fd->num, srtp_info); DENDENT(); } else { DPRINT((""calling rtcp_add_address for media_port=%d, for channel=%d"", transport_info->media_port[n],n)); DINDENT(); rtcp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n]+1, 0, ""SDP"", pinfo->fd->num); DENDENT(); } } } if ((!pinfo->fd->flags.visited) && (transport_info == &local_transport_info) && (transport_info->proto_bitmask[n] & SDP_SPRT_PROTO) && (transport_info->proto_bitmask[n] & (SDP_IPv4|SDP_IPv6)) && (sprt_handle)) { if (transport_info->media_port[n] == 0 && current_rtp_port) { sprt_add_address(pinfo, &transport_info->src_addr[n], current_rtp_port, 0, ""SDP"", pinfo->fd->num);  } else { sprt_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, ""SDP"", pinfo->fd->num); } } if ((!pinfo->fd->flags.visited) && (transport_info == &local_transport_info) && (transport_info->media_port[n] != 0) && !transport_info->media[n].set_rtp && (transport_info->proto_bitmask[n] & SDP_T38_PROTO) && (transport_info->proto_bitmask[n] & SDP_IPv4)) { t38_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], 0, ""SDP"", pinfo->fd->num); } if ((!pinfo->fd->flags.visited) && (transport_info == &local_transport_info) && (transport_info->proto_bitmask[n] & SDP_MSRP_PROTO) && (transport_info->proto_bitmask[n] & SDP_MSRP_IPv4) && msrp_handle) { msrp_add_address(pinfo, &transport_info->src_addr[n], transport_info->media_port[n], ""SDP"", pinfo->fd->num); } if (local_transport_info.media_port[n] != 0) { for (i = 0; i < local_transport_info.media[n].pt_count; i++) { DPRINT((""in for-loop for voip call analysis setting for media #%d, pt=%d"", i, local_transport_info.media[n].pt[i])); if ((local_transport_info.media[n].pt[i] >= 96) && (local_transport_info.media[n].pt[i] <= 127)) { const gchar *payload_type_str = rtp_dyn_payload_get_name( local_transport_info.media[n].rtp_dyn_payload, local_transport_info.media[n].pt[i]); if (payload_type_str) { if (strlen(sdp_pi->summary_str)) g_strlcat(sdp_pi->summary_str, "" "", 50); g_strlcat(sdp_pi->summary_str, payload_type_str, 50); } else { char num_pt[10]; g_snprintf(num_pt, 10, ""%u"", local_transport_info.media[n].pt[i]); if (strlen(sdp_pi->summary_str)) g_strlcat(sdp_pi->summary_str, "" "", 50); g_strlcat(sdp_pi->summary_str, num_pt, 50); } } else { if (strlen(sdp_pi->summary_str)) g_strlcat(sdp_pi->summary_str, "" "", 50); g_strlcat(sdp_pi->summary_str, val_to_str_ext(local_transport_info.media[n].pt[i], &rtp_payload_type_short_vals_ext, ""%u""), 50); } } } if ((transport_info == &local_transport_info) && !transport_info->media[n].set_rtp) { rtp_dyn_payload_free(transport_info->media[n].rtp_dyn_payload); transport_info->media[n].rtp_dyn_payload = NULL; } if ((local_transport_info.media_port[n] != 0) && (local_transport_info.proto_bitmask[n] & SDP_T38_PROTO)) { if (strlen(sdp_pi->summary_str)) g_strlcat(sdp_pi->summary_str, "" "", 50); g_strlcat(sdp_pi->summary_str, ""t38"", 50); } } if (transport_info == &local_transport_info) { for (n = transport_info->media_count; n < SDP_MAX_RTP_CHANNELS; n++) { if (!transport_info->media[n].set_rtp) { rtp_dyn_payload_free(transport_info->media[n].rtp_dyn_payload); transport_info->media[n].rtp_dyn_payload = NULL; } } } datalen = tvb_captured_length_remaining(tvb, offset); if (datalen > 0) { proto_tree_add_item(sdp_tree, hf_sdp_data, tvb, offset, datalen, ENC_NA); } tap_queue_packet(sdp_tap, pinfo, sdp_pi); }
Description: The dissect_sdp function in epan/dissectors/packet-sdp.c in the SDP dissector in Wireshark 1.12.x before 1.12.9 does not prevent use of a negative media count, which allows remote attackers to cause a denial of service (application crash) via a crafted packet.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: void continuous_agg_update_materialization(SchemaAndName partial_view, SchemaAndName materialization_table, const NameData *time_column_name, InternalTimeRange new_materialization_range, InternalTimeRange invalidation_range, int32 chunk_id) { InternalTimeRange combined_materialization_range = new_materialization_range; bool materialize_invalidations_separately = range_length(invalidation_range) > 0; int res = SPI_connect(); if (res != SPI_OK_CONNECT) elog(ERROR, ""could not connect to SPI in materializer""); if (new_materialization_range.start > new_materialization_range.end) new_materialization_range.start = new_materialization_range.end; if (range_length(invalidation_range) > 0) { Assert(invalidation_range.start <= invalidation_range.end); if (invalidation_range.start >= new_materialization_range.end || invalidation_range.end > new_materialization_range.end) elog(ERROR, ""internal error: invalidation range ahead of new materialization range""); materialize_invalidations_separately = !ranges_overlap(invalidation_range, new_materialization_range); combined_materialization_range.start = int64_min(invalidation_range.start, new_materialization_range.start); } if (range_length(invalidation_range) == 0 || !materialize_invalidations_separately) { spi_update_materializations(partial_view, materialization_table, time_column_name, internal_time_range_to_time_range( combined_materialization_range), chunk_id); } else { spi_update_materializations(partial_view, materialization_table, time_column_name, internal_time_range_to_time_range(invalidation_range), chunk_id); spi_update_materializations(partial_view, materialization_table, time_column_name, internal_time_range_to_time_range(new_materialization_range), chunk_id); } if ((res = SPI_finish()) != SPI_OK_FINISH) elog(ERROR, ""SPI_finish failed: %s"", SPI_result_code_string(res)); }
Description: TimescaleDB, an open-source time-series SQL database, has a privilege escalation vulnerability in versions 2.8.0 through 2.9.2. During installation, TimescaleDB creates a telemetry job that is runs as the installation user. The queries run as part of the telemetry data collection were not run with a locked down `search_path`, allowing malicious users to create functions that would be executed by the telemetry job, leading to privilege escalation. In order to be able to take advantage of this vulnerability, a user would need to be able to create objects in a database and then get a superuser to install TimescaleDB into their database. When TimescaleDB is installed as trusted extension, non-superusers can install the extension without help from a superuser.

Version 2.9.3 fixes this issue. As a mitigation, the `search_path` of the user running the telemetry job can be locked down to not include schemas writable by other users. The vulnerability is not exploitable on instances in Timescale Cloud and Managed Service for TimescaleDB due to additional security provisions in place on those platforms.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: static void parser_parse_function_statement (parser_context_t *context_p)  { JERRY_ASSERT (context_p->token.type == LEXER_KEYW_FUNCTION); #if ENABLED (JERRY_ES2015) if (JERRY_UNLIKELY (parser_statement_flags[context_p->stack_top_uint8] & PARSER_STATM_SINGLE_STATM)) { if (context_p->status_flags & PARSER_IS_STRICT) { parser_raise_error (context_p, PARSER_ERR_LEXICAL_SINGLE_STATEMENT); } if (context_p->stack_top_uint8 == PARSER_STATEMENT_IF || context_p->stack_top_uint8 == PARSER_STATEMENT_ELSE) { if (context_p->next_scanner_info_p->source_p == context_p->source_p) { parser_push_block_context (context_p, true); } } else if (context_p->stack_top_uint8 == PARSER_STATEMENT_LABEL) { parser_stack_iterator_t iterator; parser_stack_iterator_init (context_p, &iterator); parser_stack_iterator_skip (&iterator, sizeof (parser_label_statement_t) + 1); while (true) { uint8_t type = parser_stack_iterator_read_uint8 (&iterator); if (type == PARSER_STATEMENT_LABEL) { parser_stack_iterator_skip (&iterator, sizeof (parser_label_statement_t) + 1); continue; } if (parser_statement_flags[type] & PARSER_STATM_HAS_BLOCK) { break; } parser_raise_error (context_p, PARSER_ERR_LABELLED_FUNC_NOT_IN_BLOCK); } } else { parser_raise_error (context_p, PARSER_ERR_LEXICAL_SINGLE_STATEMENT); } } #endif  #if ENABLED (JERRY_DEBUGGER) parser_line_counter_t debugger_line = context_p->token.line; parser_line_counter_t debugger_column = context_p->token.column; #endif  #if ENABLED (JERRY_ES2015) bool is_generator_function = false; if (lexer_consume_generator (context_p)) { is_generator_function = true; } #endif  lexer_expect_identifier (context_p, LEXER_NEW_IDENT_LITERAL); JERRY_ASSERT (context_p->token.type == LEXER_LITERAL && context_p->token.lit_location.type == LEXER_IDENT_LITERAL); #if ENABLED (JERRY_ES2015) if (context_p->next_scanner_info_p->source_p == context_p->source_p) { JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_ERR_REDECLARED); parser_raise_error (context_p, PARSER_ERR_VARIABLE_REDECLARED); } #endif  #if ENABLED (JERRY_ES2015_MODULE_SYSTEM) uint16_t function_name_index = context_p->lit_object.index; parser_module_append_export_name (context_p); context_p->status_flags &= (uint32_t) ~(PARSER_MODULE_STORE_IDENT); #endif  uint32_t status_flags = PARSER_FUNCTION_CLOSURE; if (context_p->token.keyword_type >= LEXER_FIRST_NON_STRICT_ARGUMENTS) { status_flags |= PARSER_HAS_NON_STRICT_ARG; } JERRY_ASSERT (context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION); #if ENABLED (JERRY_ES2015) if (is_generator_function) { status_flags |= PARSER_IS_GENERATOR_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD; } if (context_p->next_scanner_info_p->u8_arg & SCANNER_FUNCTION_ASYNC) { status_flags |= PARSER_IS_ASYNC_FUNCTION | PARSER_DISALLOW_AWAIT_YIELD; } #endif  #if ENABLED (JERRY_DEBUGGER) if (JERRY_CONTEXT (debugger_flags) & JERRY_DEBUGGER_CONNECTED) { lexer_literal_t *name_p = context_p->lit_object.literal_p; jerry_debugger_send_string (JERRY_DEBUGGER_FUNCTION_NAME, JERRY_DEBUGGER_NO_SUBTYPE, name_p->u.char_p, name_p->prop.length); context_p->token.line = debugger_line; context_p->token.column = debugger_column; } #endif  JERRY_ASSERT (context_p->scope_stack_top >= 2); parser_scope_stack_t *scope_stack_p = context_p->scope_stack_p + context_p->scope_stack_top - 2; uint16_t literal_index = context_p->lit_object.index; while (literal_index != scope_stack_p->map_from) { scope_stack_p--; JERRY_ASSERT (scope_stack_p >= context_p->scope_stack_p); } JERRY_ASSERT (scope_stack_p[1].map_from == PARSER_SCOPE_STACK_FUNC); #if ENABLED (JERRY_ES2015) if (!(context_p->status_flags & PARSER_IS_STRICT) && (scope_stack_p >= context_p->scope_stack_p + context_p->scope_stack_global_end)) { bool copy_value = true; parser_scope_stack_t *stack_p = context_p->scope_stack_p; while (stack_p < scope_stack_p) { if (literal_index == stack_p->map_from && (stack_p->map_to & PARSER_SCOPE_STACK_NO_FUNCTION_COPY)) { copy_value = false; break; } stack_p++; } if (copy_value) { stack_p = context_p->scope_stack_p; while (stack_p < scope_stack_p) { if (literal_index == stack_p->map_from) { JERRY_ASSERT (!(stack_p->map_to & PARSER_SCOPE_STACK_NO_FUNCTION_COPY)); uint16_t map_to = scanner_decode_map_to (stack_p); uint16_t opcode = ((map_to >= PARSER_REGISTER_START) ? CBC_ASSIGN_LITERAL_SET_IDENT : CBC_COPY_TO_GLOBAL); parser_emit_cbc_literal_value (context_p, opcode, scanner_decode_map_to (scope_stack_p), map_to); break; } stack_p++; } parser_flush_cbc (context_p); } if (JERRY_UNLIKELY (context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_SCOPE || context_p->stack_top_uint8 == PARSER_STATEMENT_PRIVATE_CONTEXT)) { parser_pop_block_context (context_p); } } #endif  lexer_literal_t *literal_p = PARSER_GET_LITERAL ((size_t) scope_stack_p[1].map_to); JERRY_ASSERT ((literal_p->type == LEXER_UNUSED_LITERAL || literal_p->type == LEXER_FUNCTION_LITERAL) && literal_p->status_flags == 0); ecma_compiled_code_t *compiled_code_p = parser_parse_function (context_p, status_flags); if (literal_p->type == LEXER_FUNCTION_LITERAL) { ecma_bytecode_deref (literal_p->u.bytecode_p); } literal_p->u.bytecode_p = compiled_code_p; literal_p->type = LEXER_FUNCTION_LITERAL; #if ENABLED (JERRY_ES2015) parser_compiled_code_set_function_name (context_p, compiled_code_p, function_name_index, 0); #endif  lexer_next_token (context_p); }
Description: There is an Assertion 'context_p->next_scanner_info_p->type == SCANNER_TYPE_FUNCTION' failed at js-parser-statm.c:733 in parser_parse_function_statement in JerryScript 2.2.0.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int nfc_llcp_send_connect(struct nfc_llcp_sock *sock) { struct nfc_llcp_local *local; struct sk_buff *skb; u8 *service_name_tlv = NULL, service_name_tlv_length; u8 *miux_tlv = NULL, miux_tlv_length; u8 *rw_tlv = NULL, rw_tlv_length, rw; int err; u16 size = 0; __be16 miux; pr_debug(""Sending CONNECT\n""); local = sock->local; if (local == NULL) return -ENODEV; if (sock->service_name != NULL) { service_name_tlv = nfc_llcp_build_tlv(LLCP_TLV_SN, sock->service_name, sock->service_name_len, &service_name_tlv_length); size += service_name_tlv_length; } miux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ? local->miux : sock->miux; rw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw; miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0, &miux_tlv_length); size += miux_tlv_length; rw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length); size += rw_tlv_length; pr_debug(""SKB size %d SN length %zu\n"", size, sock->service_name_len); skb = llcp_allocate_pdu(sock, LLCP_PDU_CONNECT, size); if (skb == NULL) { err = -ENOMEM; goto error_tlv; } llcp_add_tlv(skb, service_name_tlv, service_name_tlv_length); llcp_add_tlv(skb, miux_tlv, miux_tlv_length); llcp_add_tlv(skb, rw_tlv, rw_tlv_length); skb_queue_tail(&local->tx_queue, skb); err = 0; error_tlv: if (err) pr_err(""error %d\n"", err); kfree(service_name_tlv); kfree(miux_tlv); kfree(rw_tlv); return err; }
Description: An issue was discovered in the Linux kernel before 4.20.15. The nfc_llcp_build_tlv function in net/nfc/llcp_commands.c may return NULL. If the caller does not check for this, it will trigger a NULL pointer dereference. This will cause denial of service. This affects nfc_llcp_build_gb in net/nfc/llcp_core.c.
 [output] "
"I will give you a test example that includes the vulnerability code and a description of the vulnerability. You only need to output the severity level of the vulnerability of the test example code and description, without outputting the corresponding explanation.
Test 1:
Determine Base Severity of the vulnerability code based on the following vulnerable code (a function) and the textual description of the vulnerability.
 [input] Code: int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2], unsigned char multicast_spec, u8 protocol_version) { struct hsr_priv *hsr; struct hsr_port *port; int res; hsr = netdev_priv(hsr_dev); INIT_LIST_HEAD(&hsr->ports); INIT_LIST_HEAD(&hsr->node_db); INIT_LIST_HEAD(&hsr->self_node_db); ether_addr_copy(hsr_dev->dev_addr, slave[0]->dev_addr); res = hsr_create_self_node(&hsr->self_node_db, hsr_dev->dev_addr, slave[1]->dev_addr); if (res < 0) return res; spin_lock_init(&hsr->seqnr_lock); hsr->sequence_nr = HSR_SEQNR_START; hsr->sup_sequence_nr = HSR_SUP_SEQNR_START; timer_setup(&hsr->announce_timer, hsr_announce, 0); timer_setup(&hsr->prune_timer, hsr_prune_nodes, 0); ether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr); hsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec; hsr->protVersion = protocol_version; netif_carrier_off(hsr_dev); res = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER); if (res) return res; res = register_netdevice(hsr_dev); if (res) goto fail; res = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A); if (res) goto fail; res = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B); if (res) goto fail; mod_timer(&hsr->prune_timer, jiffies + msecs_to_jiffies(PRUNE_PERIOD)); return 0; fail: hsr_for_each_port(hsr, port) hsr_del_port(port); return res; }
Description: In the Linux kernel before 5.0.3, a memory leak exits in hsr_dev_finalize() in net/hsr/hsr_device.c if hsr_add_port fails to add a port, which may cause denial of service, aka CID-6caabe7f197d.
 [output] "
